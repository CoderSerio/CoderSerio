<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="操作系统, 前端 JavaScript 碳苯 Serio Web 计算机 Carbon 框架 微前端 大厂 furry 福瑞 程序员 IT">
    <meta name="description" content="知道吗，栅格化线程是很辛苦的">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>操作系统 | 碳苯</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">碳苯</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">碳苯</div>
        <div class="logo-desc">
            
            碳苯是一只毛茸茸的程序员
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/CoderSerio" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/CoderSerio" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('该文章设置了密码，如需查阅请联系碳苯桑')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">操作系统</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">操作系统</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" class="post-category">
                                专业基础
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-02-20
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-02-04
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    30.5k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>操作系统因为翘课太多只能自学啊~~<br>而且计算机基础知识是很重要的，必须要认真对待才是（那为啥翘课？翘课学前端去了…）<br>不管怎么说，还是做个笔记方便日后复习</p>
<h2 id="计组和操作系统杂谈"><a href="#计组和操作系统杂谈" class="headerlink" title="计组和操作系统杂谈"></a>计组和操作系统杂谈</h2><p>随便写点（这个部分可以跳过）</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p><strong>计算机系统</strong>：处理机+外围设备</p>
<p><strong>处理机</strong>：包括CPU，主存储器、输入输出设备</p>
<p><strong>CPU</strong>：中央处理器+控制核心<br>(<strong>下文有时会把处理机称为CPU，见谅</strong>)<br>(<strong>后面网上一查才发现，好多人都把处理机和处理器混淆了</strong>)</p>
<p><strong>中央处理器</strong>：运算单元+控制单元<br><strong>主存储器</strong><br><strong>外围设备</strong>：输出设备 输入设备 存储设备 网络通信设备（比如鼠标键盘等）<br><strong>总线</strong>：Bus,是CPU，内存，输入输出设备传输信息的共用通道；外围设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统</p>
<p>存储器的层次：<br><img src="https://img-blog.csdnimg.cn/cf49c35e358f4d20a82d616b4466ae36.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>外围设备及其控制：<br><img src="https://img-blog.csdnimg.cn/a0c3bf94ddf941af87fec900e3433fd7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>总线的类型：<br><img src="https://img-blog.csdnimg.cn/2471b066836144e8b159b58b9001887c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>上述内容是<strong>冯诺依曼提出的存储程序计算机模型</strong><br><img src="https://img-blog.csdnimg.cn/1ac6e9d9460e48b8aa877a0817fc23d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="指令执行的过程"><a href="#指令执行的过程" class="headerlink" title="指令执行的过程"></a>指令执行的过程</h3><p><strong>前置概念</strong><br>（引用自<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34801169/article/details/102782643">CSDN博主「快乐的一只小喵喵」的原创文章</a>）</p>
<blockquote>
<p><strong>程序计数器（PC，Program counter）</strong><br>用于存放指令的地址。为了保证程序(在操作系统中理解为进程)能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，此过程称，为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。<br><strong>指令寄存器（IR，Instruction Register）</strong><br>用来保存当前正在执行的一条指令。是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一条指令。当执行一条指令时，先把它从内存取到数据寄存器（DR，Data<br>Register）中，然后再传送至IR。指令划分为操作码和地址码字段，由二进制数字组成。为了执行任何给定的指令，必须对操作码进行测试，以便识别所要求的操作。指令译码器就是做这项工作的。指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号。<br><strong>&gt; 通用寄存器（GR，General register）</strong><br>通用寄存器可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。除此之外，它们还各自具有一些特殊功能。通用寄存器的长度取决于机器字长，汇编语言程序员必须熟悉每个寄存器的一般用途和特殊用途，只有这样，才能在程序中做到正确、合理地使用它们。</p>
</blockquote>
<p>————————————————</p>
<p>一种较为简单的指令执行步骤:<br><strong>1.取指</strong>：根据PC从存储器或高速缓冲存储器中取指令到IR<br><strong>2.解码</strong>：解译IR中的指令来决定其执行行为<br><strong>3.执行</strong>：连接到CPU部件，执行运算，产生结果并写回，同时在CC里设置运算结论标志；跳转指令操作PC，其他指令递增PC值</p>
<p><strong>指令执行的流水线</strong><br><img src="https://img-blog.csdnimg.cn/9352d87c2e9246558b6d9ddce89c5de5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>其中流水线的过程有点<strong>并发</strong>的意思</p>
<h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><p>用户的程序并不能够使用全部的计算机指令（比如app总是要你授权就是这个道理），<strong>计算机核心资源的特殊指令会被保护起来</strong>，它们只能被操作系统程序使用<br>至于特权指令是怎么被实现的，就要提到<strong>处理器模式</strong>：<br>计算机一般设置0 1 2 3四种模式<br>0是操作系统内核<br>1是系统调用<br>2是共享库程序<br>3是用户程序</p>
<p>数值越大权限越低<br>tip：现代操作系统很多都只是用了0和3两个模式，<strong>内核模式</strong>和<strong>用户模式</strong>（下图以红色的括号为准）<br><img src="https://img-blog.csdnimg.cn/b5fedf610b114ce3b33a21bc84b51d55.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>嘛。。。其实就是字面意思嘛。。。<br>就是程序执行过程中，遇到突发状况，就暂时终止处理机上当前程序的运行，转去处理突发事件，<strong>处理完成之后再回到刚才暂停的地方继续执行</strong> 这个过程，就是中断</p>
<p><strong>中断是并发的基础</strong></p>
<hr>
<p><strong>中断源</strong><br>那引起中断的事件就称为中断源<br>它可能是处理器执行机器指令引起的，比如除数为0，操作数溢出等算数异常或者其他异常</p>
<hr>
<p>对于简单的问题，处理器会简单处理然后报告用户；也可以由用户编写的中断续元程序处理</p>
<p>但是复杂的问题（比如I/O中断，来源于外围设备报告I/O状态的中断事件)（比如打印机打印一般了发现缺纸了）<br>就需要人工干预了</p>
<hr>
<h2 id="初步认识操作系统"><a href="#初步认识操作系统" class="headerlink" title="初步认识操作系统"></a>初步认识操作系统</h2><p>终于进入主题。由于学校的视频资源给的好像不是很系统，所以我决定自己找视频再结合教材作书摘一样地写<br><img src="https://img-blog.csdnimg.cn/00a410ed4e5940efaad2e96334c6f6b7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>定义</strong></p>
<p>Operating system，即OS，是配置在计算机硬件上的第一层<strong>软件</strong>,也就是说，<strong>操作系统是计算机硬件的第一次扩充</strong></p>
<hr>
<p><strong>目的</strong></p>
<p><strong>管理硬件，提高利用率和系统吞吐量</strong>，具体实现了以下四个方面</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>方便性</td>
<td>没有操作系统的话用户只能用机器语言操作了</td>
</tr>
<tr>
<td>有效性</td>
<td>合理组织计算机工作流程，提高效率</td>
</tr>
<tr>
<td>可扩充性</td>
<td>方便地增加新的功能和模块</td>
</tr>
<tr>
<td>开放性</td>
<td>很好地应用于网络环境</td>
</tr>
</tbody></table>
<p><strong>功能</strong></p>
<p>不同的场合下身份不同，一共可以充当三个角色</p>
<table>
<thead>
<tr>
<th>身份</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>资源的管理者</td>
<td>管理 处理机、 存储器、 文件、 设备</td>
</tr>
<tr>
<td>用户的服务者</td>
<td>向用户提供接口（定义见后续内容）</td>
</tr>
<tr>
<td>硬件的扩充者</td>
<td>扩充机器</td>
</tr>
</tbody></table>
<p>管理处理机、存储器、文件和设备</p>
<hr>
<p><strong>接口</strong></p>
<p>学过开发的大家应该清楚什么意思。<br>这里指的是用户和计算机硬件之间的接口，即用户操控计算机硬件资源的途径<br>以下是三种主要的接口</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>命令接口</td>
<td>允许用户直接使用</td>
</tr>
<tr>
<td>程序接口</td>
<td>允许用户通过程序间接使用</td>
</tr>
<tr>
<td>GUI</td>
<td>现代操作中最流行的图形用户接口（比如windows，这里我们不讨论GUI）</td>
</tr>
</tbody></table>
<p>其中，<strong>命令接口</strong>又可以分为：<br>| 类型                       | 内容                   |<br>| ————————– | ———————- |<br>| 联机命令接口               | 用户说一句，系统做一句 |<br>| 脱机命令接口               | 用户说一堆，系统做一堆 |<br>| 然后，<strong>程序接口</strong>具体是： |                        |</p>
<blockquote>
<p>由一组系统调用组成（系统调用 就是 程序接口，有的地方也叫广义指令）</p>
</blockquote>
<h3 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h3><p>一共有四个特征：<strong>并发 共享 虚拟 异步</strong><br>其中 <strong>并发 和 共享 是最基本的特征</strong>， 二者互为存在条件</p>
<hr>
<p><strong>并发</strong></p>
<blockquote>
<p>并发是两个或多个事件在同一时间间隔内发生<br>这些事件在宏观上是同时发生，但是微观上是交替发生的</p>
</blockquote>
<p>这是书上的话，其实就是说<br><strong>并发是一个时间段里面多个事件先后发生</strong><br>（并且不是一贯到底的）<br>（如果时间段比较短的话，就像是同时完成了多个事件）</p>
<p><strong>另外，并发的基础是中断</strong></p>
<hr>
<p>这里有一个容易混淆的概念：<strong>并行</strong></p>
<blockquote>
<p>两个或多个事件在同一时刻同时发生</p>
</blockquote>
<p>这个才是真正的同时进行<br>如下图所示：<br><img src="https://img-blog.csdnimg.cn/dc310655319c4db7bacf383c78715bc9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<hr>
<p><strong>那么问题来了——为什么是并发而不是并行</strong><br>对于计算机来说，并行不是明显更高效吗，为什么操作系统的特征是并发呢？<br>主要是硬件限制，以前单核的CPU，同一时刻只能执行一个程序，所以就需要并发；<br>现在呢，保底都是四核了，也就是同一时刻四个程序，但是现在用电脑同一时刻才几个程序？所以还是会有并发…</p>
<hr>
<p> <strong>共享</strong></p>
<blockquote>
<p>共享指的是资源共享，是指系统中的资源可供内存中多个并发执行的进程使用</p>
</blockquote>
<hr>
<p><strong>资源共享的方式</strong><br>| 方式     | 内容                           |<br>| ——– | —————————— |<br>| 互斥共享 | 一个时间段内只能给一个进程访问 |<br>| 同时共享 | 一个时间段内由多个进程轮流访问 |</p>
<p>同时共享 和 并发 类似，也只是宏观上的同时，微观上是几个程序轮流占用</p>
<p>（当然有些时候也真的是同时，比如一边打游戏一边听歌，扬声器可以同时播放两者的音乐）</p>
<hr>
<p><strong>并发和共享的关系</strong><br>单核CPU下，没有并行这种操作，那要是并发都没有，计算机隔很久才执行一个程序，那共享从何而来？<br>另外，要是没有共享性质，极短的事件内，一个资源不能被两个或者多个程序访问，那么并发也无法继续进行</p>
<p>所以二者是相互依存</p>
<hr>
<p> <strong>虚拟</strong></p>
<blockquote>
<p>把一个物理上的实体变为若干个逻辑上的对应物；实体是实际存在的，对应物是用户感受到的</p>
</blockquote>
<p><strong>举例1：空间的虚拟</strong><br><strong>一个程序需要放入内存并且给它分配cpu才能执行</strong><br>那么比如运行一个游戏要10G内存，但是我们的电脑只有4G的内存，但是我们就是可以让它运行，好像我们电脑的内存不止10G的样子</p>
<p>这个例子中，4G内存就是实体，10G是用户感受到的，也就是逻辑上的对应物体<br>这里涉及到的技术叫做 <strong>空分复用术</strong></p>
<p><strong>举例2：时间的虚拟</strong><br>单核CPU的计算机 看上去 似乎可以“同时”执行多个程序（体现为 并发），可是它的原理是什么呢？<br>这里涉及到的技术叫做<strong>时分复用术</strong><br>（这里也看出，如果没有并发，就不需要（时间上的）虚拟；如果没有虚拟，就难以并发）</p>
<hr>
<p><strong>异步</strong></p>
<blockquote>
<p>在多道程序环境下，允许多个程序并发执行，但是资源有限，每个进程的执行不是一贯到底（进程是并发的），而是走走停停（轮流使用一段时间资源），以不可预知的速度向前推进</p>
</blockquote>
<p>说到异步啊….最开始学前端学到async和ajax的时候接触到了异步，当时我以为的异步实际上是并行（因为当时学的时候，有人说异步是生活中的同步，同步才是生活中的异步）….所以我之前一直理解错了….</p>
<hr>
<p><strong>图示举例</strong><br><img src="https://img-blog.csdnimg.cn/d75d734e01634f84ad34e566cb267da7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<hr>
<h3 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h3><p>我们学习的范围包括：</p>
<blockquote>
<p>1.手工操作系统<br>2.批处理操作系统（包括单道和多道）<br>3.分时操作系统<br>4.实时操作系统<br>5.网络操作系统<br>6.分布式操作系统<br>7.个人计算机操作系统</p>
</blockquote>
<p>发展顺序自上而下，每一个阶段都是为了解决上一代的主要缺点</p>
<p>其中重点掌握2 3 4，1 5 6 7了解即可</p>
<hr>
<p><strong>1.手工操作系统</strong><br>其实这个都算不上操作系统<br>当时的程序员用<strong>纸带打孔</strong>的方式 表示0和1 进行编程</p>
<p>流程大概是：</p>
<blockquote>
<p>纸带A（代码）–&gt;纸带机–&gt;计算机（计算）–&gt;纸带机–&gt;纸带B（运行结果）</p>
</blockquote>
<p><strong>计算机速度很快</strong>，但是啊<strong>纸带机很慢</strong>，整个流程中大部分时间都在等待纸带机读取数据</p>
<p>这种流程有两个主要缺点：</p>
<blockquote>
<p>计算机有很多时间在等待 ，<br>一次只能有一个用户占用资源（机器）<br>上述两点概括为 <strong>人机速度矛盾</strong></p>
</blockquote>
<hr>
<p><strong>2.1批处理操作系统：单道</strong></p>
<p>这个阶段引入了<strong>脱机输入/输出技术</strong>，并且引入<strong>监督程序</strong>（操作系统的雏形）负责控制作业的输入输出</p>
<p>流程大概是（对称的，看一半就行）</p>
<blockquote>
<p>纸带-&gt;纸带机-&gt;外围设备-&gt;磁带-&gt;计算机-&gt;磁带-&gt;外围设备-&gt;纸带机-&gt;纸袋</p>
</blockquote>
<p>其实就是<strong>引入了外围设备和磁带</strong>，外围设备可以把数据快速存到磁带里面，然后磁带内的数据可以被计算机快速处理，输出同理</p>
<p>这个过程中，<strong>监督程序负责调控 计算机读取磁带内数据</strong></p>
<p>图示<br><img src="https://img-blog.csdnimg.cn/0a3218f01fe94443b05c235a1bf2b629.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>缺点是</p>
<blockquote>
<p>只有一个程序能运行，CPU依旧有很多时间在等待I/O，资源利用率还是不高</p>
</blockquote>
<hr>
<p><strong>2.2批处理操作系统：多道</strong><br>流程同上，但是每次可以使用多个磁带向计算机输入数据了<br><strong>引入了中断技术，并发由此出现，操作系统正式诞生</strong><br>（再次强调，中断是并发的基础）</p>
<p>图示<br><img src="https://img-blog.csdnimg.cn/136015b304454cc7929165d0ce62b2cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>缺点</strong></p>
<blockquote>
<p>响应时间长，没有人机交互能力（用户提交之后就只能等，不能手动控制调度）</p>
</blockquote>
<hr>
<p><strong>3.分时操作系统</strong><br>引入了<strong>时间片</strong>的概念(就是一个较小的时间段，大概是一个定值)</p>
<blockquote>
<p>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可以通过终端与计算机进行交互</p>
</blockquote>
<p><strong>举例</strong><br>比如时间片是0.01s，那么每个任务轮流执行0.01s，在1s内可能会完成多个任务，给用户的感受就是多个“同时”完成</p>
<p><strong>缺点</strong></p>
<blockquote>
<p>没有优先级，完全公平地处理任务，不能分轻重缓急</p>
</blockquote>
<hr>
<p><strong>4.实时操作系统</strong><br>引入了优先级</p>
<blockquote>
<p>在分时操作系统的基础上，能够优先响应一些紧急任务（它们不需要时间片排队）</p>
</blockquote>
<p><strong>分类（了解即可）</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>硬实时系统</td>
<td>必须在绝对严格的固定时间内完成处理</td>
</tr>
<tr>
<td>软实时系统</td>
<td>能够接受偶尔违反时间规定</td>
</tr>
</tbody></table>
<hr>
<p><strong>5-7其他几种操作系统（了解即可）</strong><br><strong>网络操作系统</strong></p>
<blockquote>
<p>实现网络中各种资源的共享和各台计算机之间的通信</p>
</blockquote>
<p><strong>分布式操作系统</strong></p>
<blockquote>
<p>有分布性和并行性，由多台计算机分工，工作可以分布在这些计算机上并行、协同完成</p>
</blockquote>
<p><strong>个人计算机操作系统</strong></p>
<blockquote>
<p>比如windows，方便个人使用</p>
</blockquote>
<hr>
<h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p> <strong>两种指令</strong><br>这里的指令是指机器语言指令（高级语言翻译过来的）</p>
<p>两种指令主要是：<strong>特权指令</strong>和<strong>非特权指令</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>特权指令</td>
<td>不允许用户随意使用</td>
</tr>
<tr>
<td>非特权指令</td>
<td>允许用户随意使用</td>
</tr>
</tbody></table>
<p>出现这种分类的原因正如其名——有的指令可能造成的影响较大（比如删库？），不允许用户随便使用，即“特权”</p>
<p>但是，计算机怎么识别当前是否可以执行特权指令呢？<br>这就是接下来将要提到的处理器状态了</p>
<hr>
<p> <strong>两种处理器状态</strong><br>处理器状态分为 <strong>用户态（目态）</strong> 和 <strong>核心态（管态）</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>用户态（目态）</td>
<td>此时处理器不可执行特权指令</td>
</tr>
<tr>
<td>核心态（管态）</td>
<td>此时处理器可以执行特权指令</td>
</tr>
</tbody></table>
<p>这是利用<strong>程序状态字寄存器PSW</strong>中的某标志位来标识当前处理器处于什么状态。（比如可以让用户态为0，核心态为1）</p>
<p>上述内容体现在处于不同状态的程序上</p>
<hr>
<p><strong>两种程序</strong><br>也就是<strong>内核程序</strong>和<strong>应用程序</strong>，正如其名，不再多言<br>(当然，如果提到“管态程序”、“核心态程序”这些等价的概念时，也要反应得过来才是)</p>
<h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><blockquote>
<p>是计算结配置上的底层软件，是操作系统最基本、最核心的部分</p>
</blockquote>
<p>就是常常听到的什么四核八核十六核CPU那个核<br>大概是这么一个地位：<br><img src="https://img-blog.csdnimg.cn/7c5250cd7e24460887cd5f091490a10c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<hr>
<p> <strong>时钟管理</strong></p>
<blockquote>
<p>实现计时的功能</p>
</blockquote>
<hr>
<p> <strong>中断</strong><br>前面说并发的时候提到过</p>
<blockquote>
<p>负责实现中断机制（并发的前提）</p>
</blockquote>
<p><strong>分类</strong><br>广义的中断的分类标准主要根据信号的来源——CPU的内部还是外部</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>内中断（异常、例外、陷入/陷阱）</td>
<td>指令中断的则为<strong>自愿中断</strong>；硬件故障或者软件中断的则为<strong>强迫中断</strong></td>
</tr>
<tr>
<td>外中断(中断)</td>
<td>一般是人工干预或外围设备请求导致的</td>
</tr>
</tbody></table>
<p><strong>运作过程</strong><br>配合时钟管理的计时器，发出中断信号</p>
<p>中断处理是内核的一部分，<strong>所以中断发生时，CPU进入核心态</strong><br>（<strong>中断是 用户态 转为 核心态 的唯一途径</strong>）</p>
<p>（<strong>而核心态 转为 用户态 的途径是执行一个特权指令，将PSW设置为“用户态”</strong>）</p>
<p>中断发生后，当前运行的进程暂停，接下来操作系统内核将对其进行处理</p>
<p>那么具体一点就是：</p>
<blockquote>
<p>执行每个指令后，CPU都会检测是否有外部中断信号： 如果没有，那么执行下一个指令；<br>如果有，那么保存即将被中断的CPU环境（相当于游戏存档，方便下次继续），然后进行中断处理。</p>
</blockquote>
<hr>
<p><strong>原语</strong></p>
<blockquote>
<p>一种特殊的程序<br>处于操作系统最底层，最接近硬件<br>运行时间短、调用频繁<br>具有原子性（就是数据库事务提到的那个）</p>
</blockquote>
<hr>
<p> <strong>系统资源管理</strong></p>
<blockquote>
<p>包括进程管理、存储器管理和设备管理等</p>
</blockquote>
<hr>
<p> <strong>内核分类</strong><br>有不同的分类标准，比如：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>单内核</td>
<td>内核中各个部件混杂的形态</td>
</tr>
<tr>
<td>大内核</td>
<td>在微内核基础上，还包括进程、存储器、设备管理等</td>
</tr>
<tr>
<td>微内核</td>
<td>结构性部件与功能部件分离</td>
</tr>
<tr>
<td>混合内核</td>
<td>微内核和单内核的折中，较多组件再核心态中运行</td>
</tr>
<tr>
<td>外内核</td>
<td>尽可能减少内核的软件抽象化和传统微内核的消息传递机制</td>
</tr>
</tbody></table>
<hr>
<p>这里主要讨论 <strong>大内核 和 微内核</strong><br><strong>大内核</strong><br>把操作系统主要模块都作为系统内核，运行在核心态（管态）<br>优点：高性能（一直是核心态不用切换）<br>缺点：代码庞大，结构乱，难维护<br>（这个缺点是很多早期计算机技术的通病）</p>
<p><strong>微内核</strong><br>内核只保留基本功能<br>优点：内核功能少，结构清晰，方便维护<br>缺点：需要频繁地在核心态和用户态之间切换，低性能</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>就是程序接口（严格意义上说操作系统是由一组系统调用组成的），上面有提到过</p>
<blockquote>
<p>操作系统提供给应用程序（编程人员）使用的接口。可以理解为一种可供应用程序调用的特殊函数，应用程序可以请求系统调用来获得操作系统的服务。</p>
</blockquote>
<p><strong>系统调用背后的过程</strong><br><img src="https://img-blog.csdnimg.cn/d007fb671aff4eceba98feecac3295a5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="定义和组成"><a href="#定义和组成" class="headerlink" title="定义和组成"></a>定义和组成</h3><p>进程就是一个程序地执行过程<br>当一个程序被放到内存中，才能够被CPU处理，才能执行<br>(我们双击exe文件，就是把程序放入内存的操作)</p>
<p>其中，程序的定义是<strong>一个指令序列</strong><br>而进程可以从不同角度进行定义，比如这些：</p>
<blockquote>
<p>程序段，数据段，PCB（进程控制块）三部分组成了进程实体（也叫进程映像，简称为进程）</p>
</blockquote>
<blockquote>
<p>进程是程序的一次执行过程</p>
</blockquote>
<blockquote>
<p>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</p>
</blockquote>
<blockquote>
<p>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</p>
</blockquote>
<blockquote>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p>
</blockquote>
<p>程序段，数据段，PCB三者都在内存中：<br>程序段、数据段分别是CPU中存放程序代码和所需数据的地方，<br>PCB则存储了程序段和数据段在CPU中的地址等信息</p>
<p>严格地说，<strong>进程实体是静态的，进程是动态的</strong></p>
<p><strong>PCB的存在时进程存在的唯一标志</strong></p>
<hr>
<h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><p>一个系统中，会存在众多PCB。必须用适当的形式来组织管理他们。<br>主要有两种组织方式：<br>| 方式     | 内容                                                         |<br>| ——– | ———————————————————— |<br>| 链接方式 | 按照进程状态将PCB分为多个队列；操作系统持有指向各个队列的指针 |<br>| 索引方式 | 根据进程状态的不同，建立几张索引表；操作系统持有各个索引表的指针 |</p>
<p><strong>链接方式</strong><br>拥有<strong>执行指针</strong>，指向当前处于运行态（执行态）的进程的控制器PCB；<br>拥有<strong>就绪队列指针</strong>，指向当前处于就绪态的进程；<br>拥有<strong>阻塞队列指针</strong>，指向当前处于阻塞太的进程，很多操作系统会因为阻塞原因不同而划分多个阻塞队列；</p>
<p><strong>索引方式</strong><br>和链接方式类似，拥有<strong>执行指针</strong>和<strong>阻塞队列指针</strong><br>并且拥有<strong>就绪表指针</strong>，指向一张就绪索引表的地址</p>
<hr>
<h3 id="进程的五大特征与三大状态"><a href="#进程的五大特征与三大状态" class="headerlink" title="进程的五大特征与三大状态"></a>进程的五大特征与三大状态</h3><p><strong>五大特征</strong><br>| 特征   | 内容                                                         |<br>| —— | ———————————————————— |<br>| 动态性 | 进程是程序的一次执行过程，是动态地产生、变化和消亡           |<br>| 并发性 | 内存中存在多个进程实体，可以并发执行                         |<br>| 独立性 | 进程是<strong>能够独立地运行、获取资源、接受调度的基本单位</strong>       |<br>| 异步性 | 各个进程以独立的、不可预知的速度向前推进。操作系统需要提供“进程同步机制”来解决问题 |<br>| 结构性 | 每个进程都由PCB、结构段、数据段组成                          |</p>
<p>其中，<strong>动态性</strong>是进程的最基本特征</p>
<p><strong>三大状态</strong><br>| 状态                            | 内容                                                         |<br>| ——————————- | ———————————————————— |<br>| 运行态                          | 占有CPU并且在CPU上运行                                       |<br>| 就绪态                          | 已经具备运行条件，但是由于没有闲置CPU，暂时不能运行          |<br>| 阻塞态(等待态)                  | 因为等待某一件事暂时不能运行                                 |<br>| 以上是基本的状态                |                                                              |<br>| 进程还能被细分为更多的状态,比如 |                                                              |<br>| 其他状态                        | 内容                                                         |<br>| –                              | –                                                           |<br>| 创建态                          | 进程正在被创建，操作系统为进程分配资源、初始化PCB            |<br>| 终止态                          | 进程正在从系统中被撤销，操作系统将会回收资源、撤销PCB        |<br>| 挂起态                          | 还可以细分为<strong>就绪挂起态</strong>和<strong>阻塞挂起态</strong>，是在内存不够的时候，被<strong>调度</strong>（后面会说）到<strong>外存</strong>（硬盘;这是和阻塞的最大区别）暂时保存的状态 |</p>
<hr>
<p><strong>状态转换</strong><br>还是比较好懂，大概内容如图所示<br><strong>三态四转换模型</strong><br><img src="https://img-blog.csdnimg.cn/f124ce79f2cc4245a91b912267b4d629.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>五态六转换模型</strong></p>
<p><img src="https://img-blog.csdnimg.cn/f7eba01b479b4f3eb3dc7b9af053809a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>七态十二转换模型</strong><br><img src="https://img-blog.csdnimg.cn/2edc211422384c1aa41561d59ac76c4b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>内存不够可以理解为内存中的就绪/阻塞队列满了，只能先放到外存</p>
<hr>
<p>五态转换详细过程的如下<br><img src="https://img-blog.csdnimg.cn/c70fe6f5db5c4ae98a410f717bfd5bb7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>但是上图也看出了一个问题：<br>就绪态的任务在CPU修改PCB状态为执行之后，进入执行态，执行态开始请求，进入阻塞态，请求完成，阻塞态回归到就绪态——问题就出现了，这个时候，PCB的状态依旧是执行！<br>为了解决这个问题，利用了<strong>原语</strong></p>
<hr>
<h3 id="原语控制进程"><a href="#原语控制进程" class="headerlink" title="原语控制进程"></a>原语控制进程</h3><p><strong>原语的实现</strong><br>具有原子性的操作，不允许中断<br>原语是通过<strong>关中断指令</strong>和<strong>开中断指令</strong>实现的:</p>
<blockquote>
<p>在原语代码执行前，先执行关中断指令，之后代码执行不会引起中断；</p>
</blockquote>
<blockquote>
<p> 在原语代码执行后，再执行开中断指令，此后都将执行中断处理；</p>
</blockquote>
<hr>
<p><strong>进程的创建</strong></p>
<p>有两种常见的进程创建方式：</p>
<p><strong>发生引起创建进程的事件</strong></p>
<blockquote>
<p>用户登录、应用请求、作业调度和提供服务等</p>
</blockquote>
<p><strong>执行创建原语</strong></p>
<blockquote>
<p>1.申请空白PCB<br>2.为新进程分配所需资源<br>3.初始化PCB<br>4.将PCB插入就绪队列</p>
</blockquote>
<hr>
<p><strong>进程的终止</strong></p>
<p>也有两种常见的进程终止方式：</p>
<p><strong>发生引起进程终止的事件</strong></p>
<blockquote>
<p>任务正常结束、异常结束或被外界干预</p>
</blockquote>
<p><strong>执行撤销原语</strong></p>
<blockquote>
<p>1.从PCB集合中找到终止进程的PCB<br>2.如果进程正在执行，则将其占有的CPU剥夺然后分配给其他进程<br>3.终止其所有子进程<br>4.将该进程拥有的所有资源归还给父进程或操作系统<br>5.删除其PCB</p>
</blockquote>
<p><strong>注意，撤销原语可以直接让进程变为终止态——无论该进程正处于何种状态</strong></p>
<hr>
<p><strong>进程的阻塞</strong></p>
<p>还是两种方式：</p>
<p><strong>发生引起阻塞进程的事件</strong></p>
<blockquote>
<p>需要等待 系统分配资源 或 其他与之合作的进程完成工作</p>
</blockquote>
<p><strong>执行阻塞原语</strong></p>
<blockquote>
<p>1.找到阻塞进程对应的PCB<br>2.保护进程运行环境，将PCB信息修改为阻塞态，暂停该进程<br>3.将PCB插入相应事件的等待队列</p>
</blockquote>
<hr>
<p><strong>进程的唤醒</strong></p>
<p>依旧是两种方式：</p>
<p><strong>发生引起唤醒进程的事件</strong></p>
<blockquote>
<p>等待结束</p>
</blockquote>
<p><strong>执行唤醒原语</strong></p>
<blockquote>
<p>1.在事件等待队列中找到PCB<br>2.将PCB从等待队列中移除<br>3.将PCB插入就绪队列，等待被调度</p>
</blockquote>
<p>阻塞和唤醒其实就是等待和等待结束的意思<br>另外，阻塞和唤醒一定成双成对出现</p>
<hr>
<p><strong>进程的切换</strong><br>还是两种：<br><strong>发生引起切换进程的事件</strong></p>
<blockquote>
<p>1.当前时间片用完<br>2.有更高优先级的进程到达<br>3.当前进程主动阻塞<br>4.当前进程终止</p>
</blockquote>
<p><strong>执行切换原语</strong></p>
<blockquote>
<p>1.将运行环境存入当前进程的PCB<br>2.该PCB移入相应的队列<br>3.选择另一个进程执行，并更新其PCB<br>4.根据PCB中信息恢复进程需要的运行环境</p>
</blockquote>
<hr>
<p>其实无论哪种原语，其作用无非以下三点：<br><strong>1.更新PCB信息</strong><br>    1.1所有进程控制原语一定会修改进程状态标志<br>    1.2剥夺当前进程的CPU使用权必然要保存其运行环境<br>    1.3某进程回复运行前必然要恢复其运行环境<br><strong>2.将PCB插入合适的队列</strong><br><strong>3.分配/回收资源</strong></p>
<hr>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>由于进程是分配系统资源的基本单位，所以各个进程的内存地址相互独立<br>进程通信即进程之间的信息交换，但是为了保证安全性，一个进程不能直接访问其他进程的地址空间，所以进程通信会通过以下方式实现</p>
<p><strong>方式1：共享存储</strong></p>
<p>开辟一个共享空间，用来进程间传递信息<br><img src="https://img-blog.csdnimg.cn/37558959115b4394bae6ceaaa630f66b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>进程对这个空间的访问必须是互斥的，这由操作系统提供的工具实现（同步互斥工具，如P/V操作）</p>
<p><strong>实现原理</strong><br>两种…..<br>| 类型         | 内容                                                         |<br>| ———— | ———————————————————— |<br>| 基于数据结构 | 低级通信方式，速度慢，限制多，每次只能传格式固定的某种数据结构，如长度为10的串 |<br>| 基于存储区   | 高级通信方式，速度快，在内存中开辟共享存储区，<strong>存放的位置由进程决定</strong> |</p>
<p><strong>方式2：管道通信</strong></p>
<p><strong>实现原理</strong></p>
<blockquote>
<p>“管道”指的是用于连接读写进程的一个共享文件，又叫pipe文件，其实就是在内存中开辟的一个大小固定的缓冲区</p>
</blockquote>
<p>tips：<br>1.管道只能采用<strong>半双工通信</strong>（可以正向传输也可以逆向传输，但是同一时间只能朝一个方向传输；双向同时通信则需要两个管道）</p>
<p>2.各个进程对管道的访问是互斥的（哪怕是同向也一样）</p>
<p>3.其中，数据以字符流的形式传输，读写操作是用write()和read()程序接口（系统调用）实现的。</p>
<p>4.管道没写满，就不允许读；如果没读空，就不允许写（会被阻塞）</p>
<p>5.数据一旦被读出，就从管道中清除，无法再次使用（这意味着最多一个读进程，否则可能出现读取错误）</p>
<hr>
<p><strong>方式3：消息传递</strong></p>
<blockquote>
<p>进程之间的数据交互以格式化的信息为单位<br>通过操作系统提供的<strong>发送消息/接受消息</strong>两个原语进行数据交换</p>
</blockquote>
<p>上述的<strong>“格式化的信息”</strong>指的是消息头+消息体<br>（类似于请求/响应的头/体）<br>| 名称   | 内容                                                   |<br>| —— | —————————————————— |<br>| 消息头 | 发送进程ID，接受进程ID，消息类型，消息长度等格式化信息 |<br>| 消息体 | 消息的内容等等                                         |</p>
<p><strong>实现原理</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>直接通信</td>
<td>消息会被直接挂到接受进程的缓冲队列上</td>
</tr>
<tr>
<td>间接通信</td>
<td>消息先发送到中间实体“信箱”，所以间接通信也称“信箱通信”（可以通过消息头的信息确定收发对象）</td>
</tr>
</tbody></table>
<hr>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>背景</strong><br>上古之世，未有进程之说，企鹅和企鹅音乐竟然无法同时运作!<br>先贤鬼斧神工以创进程，自此以后，企鹅和企鹅音乐才得以“同时”运作…<br>再后来，随着科技发展，企鹅作为一个进程却可以同时进行文字传输，视频播放，文件传输等等操作<br>单个进程是如何做到同时进行多项任务的？</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>众所周知，传统的进程只能串行（顺序）执行一系列程序（传统进程是程序执行流的最小单位），无法达到“同时”的效果</p>
<p>所以引入了线程的概念：</p>
<blockquote>
<p>一个进程会包含多个线程，各个线程独立的、并发的运行，CPU轮流为每个线程服务。<br>这样一来，<strong>线程是程序执行流的基本单位</strong>，可以看做<strong>轻量级的进程</strong><br>和进程类似，拥有TCB（线程控制块）等</p>
</blockquote>
<p><strong>和子进程的区别</strong><br>1.线程是进程的一部分，一个没有线程的进程可以看做单线程<br>2.引入线程的概念后，<strong>进程是（除了CPU以外的）资源分配的基本单位，而线程是程序执行（调度）的基本单位。线程几乎没有系统资源。</strong><br>3.进程有独立的地址空间，而多个线程总是共享地址空间和公共变量</p>
<hr>
<p><strong>影响和意义</strong><br>1.同一个进程内的线程切换不需要切换进程环境，系统开销减小<br>2.线程可以并发，提高了并发度</p>
<h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><p><strong>方式1:用户级线程</strong><br>User-Level Thread(ULT)<br><img src="https://img-blog.csdnimg.cn/4d789aab865e4a928ac9d43f3b56a2b1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<blockquote>
<p>用户可以感知到多个线程，但是操作系统内核只能感知到进程</p>
</blockquote>
<p>tips：<br>用户级线程是由 应用程序 通过 线程库 实现的<br>所有的<strong>线程管理都由应用程序负责</strong><br>用户级线程中，线程切换可以在用户态下完成，无需操作系统干预</p>
<hr>
<p><strong>方式2：内核级线程（内核支持线程）</strong><br>Kernel-Level Thread，KLT<br><img src="https://img-blog.csdnimg.cn/33f7f9aaa9a54209b3b975f04b42fd73.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<blockquote>
<p>即操作系统内核可以感知到的线程，线程切换需要在核心态下进行</p>
</blockquote>
<hr>
<p><strong>方式3：组合线程</strong><br><img src="https://img-blog.csdnimg.cn/072a015c0c2d45d682e77558479d4638.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>将ULT和KLT混合使用（当然并不是每个操作系统都支持这么做)</p>
<blockquote>
<p>将n个用户级线程映射到m个内核级线程上（n &gt;= m)</p>
</blockquote>
<p>这里，分配CPU资源的单位是内核级线程（毕竟内核只看得见它们啊..）<br>如上图所示的情况，哪怕是4核CPU，也只能并行两个用户级线程</p>
<p><strong>混合线程的思路，引出了多线程模型</strong></p>
<hr>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p><strong>模型1：多对一模型</strong><br><img src="https://img-blog.csdnimg.cn/e64a39c14c03415483c0f89251f08117.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>概述</strong><br>多个用户级线程映射到一个内核级线程</p>
<p><strong>优点</strong><br>用户级线程的切换可以在用户态完成，无需切换核心态，开销小，效率高</p>
<p><strong>缺点</strong><br>当一个（内核级）线程被阻塞后，整个进程都会被阻塞，并发度低；<br>并且，多个线程不可以在多核CPU上并行。</p>
<hr>
<p><strong>模型2：一对一模型</strong><br><img src="https://img-blog.csdnimg.cn/fdeb388e1fd0482b91c05f1afb94ddf0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>概述</strong><br>一个用户级线程映射到一个内核级线程</p>
<p><strong>优点</strong><br>一个（内核级）线程阻塞，不影响线程，并发性强；<br>可以在多核CPU上并行。</p>
<p><strong>缺点</strong><br>一个用户进程会占用多个内核级线程，并且切换操作需要在核心态完成，<br>线程的管理成本高，开销大。</p>
<hr>
<p><strong>模型3：多对多模型</strong><br><img src="https://img-blog.csdnimg.cn/2de20aad87014cd29637bf096230edb4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>正是之前提到的组合模式的图示</p>
<p><strong>概述</strong><br>n个用户级线程映射到m个内核级线程（n&gt;=m)</p>
<p><strong>优/缺点</strong><br>是模型1和模型2的中和，并发度居中，开销和管理成本也居中</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><blockquote>
<p>在多道程序系统中，进程的数量总是多于CPU个数，不可能并行所有进程。<br>所以需要CPU调度，从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行</p>
</blockquote>
<h3 id="三层调度"><a href="#三层调度" class="headerlink" title="三层调度"></a>三层调度</h3><p> <strong>高级调度（作业调度）</strong></p>
<blockquote>
<p>按照一定原则，从后备队列中的作业中筛选一个或多个作业，为之分配资源、建立PCB，使它们获得竞争处理机的权力</p>
</blockquote>
<p>后备队列是因为有时候用户提交的作业过大，无法一次性全部放入内存，所以先放到处于外存的后备队列，等操作系统调度安排</p>
<blockquote>
<p>高级调度是外存（辅存，硬盘）与内存之间的调度，每个作业只调入一次（此时为之建立PCB），调出一次（作业结束菜调出）<br>主要是解决调入的问题，由操作系统决定何时调入</p>
</blockquote>
<p>tips:<br><strong>作业</strong></p>
<blockquote>
<p>是一个比程序/进程更加宽泛的概念，不仅包含通常的程序和数据，还配有一份程序说明书，系统根据说明书对进程进行控制</p>
</blockquote>
<hr>
<p><strong>中级调度（内存调度）</strong></p>
<blockquote>
<p>把暂时不能运行的进程调度到外存等待，直到其重新具备了运行条件才再次调入内存</p>
</blockquote>
<p>与高级调度的区别是这个可以多次调入调出，把进程放到外存等待（此时状态变为<strong>挂起</strong>，PCB放到内存中的挂起队列），给其他进程空间</p>
<p>这样做<strong>提高了内存的利用率和系统吞吐量</strong></p>
<hr>
<p><strong>低级调度（进程调度）</strong></p>
<blockquote>
<p>按照某种方法和策略，从就绪队列中选取一个进程，将处理机分配给它<br><strong>进程调度是操作系统中最基本的一种调度</strong>，频率较高，几十毫秒便会执行一次</p>
</blockquote>
<hr>
<p><strong>总结：</strong><br><img src="https://img-blog.csdnimg.cn/973a2560c87c461e8a582b2b01e045ae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="进程调度时机、方式、切换与过程"><a href="#进程调度时机、方式、切换与过程" class="headerlink" title="进程调度时机、方式、切换与过程"></a>进程调度时机、方式、切换与过程</h3><p><strong>时机</strong></p>
<p>进程调度即低级调度<br><strong>什么时候需要进程调度</strong><br>1.当前运行的进程<strong>主动</strong>放弃处理机</p>
<blockquote>
<p>进程正常终止、运行过程中发生异常而终止、进程主动请求（阻塞）</p>
</blockquote>
<p>2.当前运行的进程被<strong>动放</strong>弃处理机</p>
<blockquote>
<p>该进程的时间片用完、由优先级更高的进程进入就绪队列、有更紧急事件需要处理</p>
</blockquote>
<hr>
<p><strong>什么时候不能进程进程调度</strong></p>
<p>（对于大部分操作系统而言）</p>
<blockquote>
<p>1.处理中断的过程中（据说是因为中断处理很复杂，与硬件关联大…阿巴阿巴）<br>2.进程处于操作<strong>系统内核程序临界区</strong>（但是在普通临界区是可以进行的）<br>3.在原子操作中（比如原语），不可中断</p>
</blockquote>
<hr>
<p><strong>方式</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>非剥夺调度方式（非抢占方式）</td>
<td><strong>只允许进程主动放弃处理机</strong>。就算有优先级更高的任务到达，当前任务依旧会继续执行，知道该进程终止或者主动发出申请进入阻塞态</td>
</tr>
<tr>
<td>剥夺调度方式（抢占方式）</td>
<td>当一个进程在处理机上执行时，有优先级更高的进程到达，当前进程立刻暂停，处理机将被分配给更优先级更高的进程</td>
</tr>
</tbody></table>
<p><strong>优劣</strong><br><strong>非剥夺调度方式（非抢占方式）</strong>：<br>实现简单，系统开销小<br>但是无法实现紧急任务<br>适合早期的批处理系统</p>
<p><strong>剥夺调度方式（抢占方式）</strong>：<br>能优先处理紧急任务，也可以以时间片轮流执行<br>适合分时操作系统、实时操作系统</p>
<hr>
<p><strong>切换与过程</strong></p>
<p><strong>狭义的进程调度 与 进程切换 的区别</strong></p>
<blockquote>
<p>狭义的进程调度指的是，从就绪队列中选中一个要运行的进程这一行为。</p>
</blockquote>
<blockquote>
<p>进程切换是指，一个进程让出处理机，由另一个进程占用处理机的过程。</p>
<p>进程切换主要完成了<br>1.保存原来运行的进程中数据（保存到PCB）<br>2.恢复新的进程的数据（从PCB读取）</p>
</blockquote>
<p>而<strong>广义的进程调度</strong>包含 选择一个进程 和 进程切换 两个步骤（这也是我们通常所说的进程调度）</p>
<p>tips:<br>进程切换是有代价的，需要消耗时间，过于频繁必将拉低效率</p>
<h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><p><strong>CPU利用率</strong></p>
<blockquote>
<p>即 忙碌时间/总时间</p>
</blockquote>
<p>如某个作业需要在CPU上运行5s，再用打印机输出5s，之后再执行5s，那么利用率就是10/15<br>（这里打印机的利用率是5/15）</p>
<hr>
<p><strong>系统吞吐量</strong></p>
<blockquote>
<p>即 完成的作业量/总时间</p>
</blockquote>
<p>比如完成10道作业，花费100秒，则系统吞吐量为<br>10/100 = 0.1 </p>
<hr>
<p><strong>周转时间</strong></p>
<blockquote>
<p>即 作业提交到作业完成的用时<br>（站在用户的视角看待）</p>
</blockquote>
<p>tip：<br>实际运行时间是指<strong>占用处理机的时间</strong>（<strong>不包括输入输出的时间</strong>）</p>
<p> <strong>带权周转时间</strong></p>
<blockquote>
<p>（作业完成时间  -  作业提交时间）/  作业实际运行时间<br>即 <strong>周转时间 / 作业实际运行时间</strong></p>
</blockquote>
<p>对于周转事假相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，<strong>带权周转时间更小，用户满意度更高</strong></p>
<p>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高</p>
<hr>
<p><strong>等待时间</strong></p>
<blockquote>
<p>进程/作业处于等待处理机状态时间之和。</p>
</blockquote>
<p>对于进程来说，等待时间是指进程建立之后等待被服务的时间之和，但是等待I/O的期间也算是被服务，所以不计入等待时间</p>
<p>对于作业来说，还要加上作业在外存后备队列的等待时间</p>
<hr>
<p><strong>响应时间</strong></p>
<blockquote>
<p>指从用户提交请求到<strong>首次</strong>产生响应所用的时间</p>
</blockquote>
<hr>
<p><strong>响应比</strong></p>
<blockquote>
<p>（等待时间+要求服务时间） /  要求服务时间</p>
</blockquote>
<p><strong>举个例子</strong></p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>运行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>7</td>
</tr>
<tr>
<td>P2</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>0时刻：只有P1在就绪队列，P1占用处理机</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7时刻：P1主动放弃处理机，就绪队列中有P2，其响应比是(5 + 4)/4=2.25</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="几种调度算法"><a href="#几种调度算法" class="headerlink" title="几种调度算法"></a>几种调度算法</h3><p>前置概念：<strong>饥饿</strong></p>
<blockquote>
<p>作业/进程长期得不到服务（意思是可能一直被插队而无法得到处理，不是说需要等待的时间较长）</p>
</blockquote>
<p><strong>先来先服务FCFS</strong></p>
<blockquote>
<p>First Come First Serve，先来先服务</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>思想</td>
<td>公平（分先来后到）</td>
</tr>
<tr>
<td>规则</td>
<td>按照作业/进程的先后顺序进行服务</td>
</tr>
<tr>
<td>用于作业/进程调度</td>
<td>用于作业调度：考虑哪个作业先到达后备队列；用于进程调度：考虑哪个进程先到达就绪队列</td>
</tr>
<tr>
<td>是否为抢占</td>
<td>非抢占</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：公平、简单；缺点：不利于排在长作业/进程后的短作业/进程用户体验 和 长作业/进程的运行</td>
</tr>
<tr>
<td>是否会产生饥饿现象</td>
<td><strong>不会</strong></td>
</tr>
</tbody></table>
<hr>
<p><strong>短作业优先SJF</strong></p>
<blockquote>
<p>Shortest Job First，最先服务（服务时间）最短的<br>用于进程就是Shortest Process First</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>思想</td>
<td>追求最少的平均等待时间、平均周转时间、平均带权周转时间</td>
</tr>
<tr>
<td>规则</td>
<td><strong>从已经到达的作业/进程中，选择服务时间最短的优先服务</strong></td>
</tr>
<tr>
<td>用于作业/进程调度</td>
<td>用于作业调度：考虑哪个作业先到达后备队列；用于进程调度：考虑哪个进程先到达就绪队列</td>
</tr>
<tr>
<td>是否为抢占</td>
<td><strong>非抢占</strong></td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：“最短的”（不严谨地说）平均等待/周转时间；缺点：不利于厂作业，可能导致饥饿，难以做到真正的短作业优先</td>
</tr>
<tr>
<td>是否会产生饥饿现象</td>
<td><strong>会</strong></td>
</tr>
</tbody></table>
<hr>
<p><strong>最短剩余时间优先SRTN</strong></p>
<blockquote>
<p>Shortest Remaining Time Next，是短作业优先算法SJF的抢占版本</p>
</blockquote>
<hr>
<p><strong>高响应比优先HRRN</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>思想</td>
<td>综合考量作业进程的等待时间和要求服务的时间</td>
</tr>
<tr>
<td>规则</td>
<td>每次调度优先考虑响应比最高的</td>
</tr>
<tr>
<td>用于作业/进程调度</td>
<td>同上</td>
</tr>
<tr>
<td>是否为抢占</td>
<td>非抢占</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：综合考量了….；缺点：（不明显）</td>
</tr>
<tr>
<td>是否会产生饥饿现象</td>
<td><strong>不会（随着等待时间变长，响应比也会越来越大，被调用的几率就越来越大）</strong></td>
</tr>
</tbody></table>
<hr>
<p><strong>时间片轮转RR</strong></p>
<blockquote>
<p>Round-Robin<br>需要注意，如果一个任务剩余的时间小于一个时间片，那么它会在完成时主动放弃处理机，然后发生调度，其他就绪态的任务开始执行<br>这种调度方式常用于分时系统</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>思想</td>
<td>公平</td>
</tr>
<tr>
<td>规则</td>
<td>轮流执行一个时间片</td>
</tr>
<tr>
<td>用于作业/进程调度</td>
<td>用于进程调度（只有作业放入内存建立相应的进程后才能被分配处理机时间片）</td>
</tr>
<tr>
<td>是否为抢占</td>
<td>抢占（原理是中断）</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：响应快、公平；缺点：高频的进程切换开销太大、公平</td>
</tr>
<tr>
<td>是否会产生饥饿现象</td>
<td><strong>不会</strong></td>
</tr>
</tbody></table>
<hr>
<p><strong>优先级调度</strong></p>
<blockquote>
<p>优先级越高越先执行（注意优先级和优先数不一样，优先数还得看题目的定义）</p>
</blockquote>
<p>tips:</p>
<blockquote>
<p>1.优先级也有静态和动态两种，顾名思义<br>2.系统进程&gt;用户进程，前台进程&gt;后台进程<br>3.操作系统更偏好（优先处理）I/O型进程（也叫I/O繁忙型进程，与I/O相对的是计算型进程，也叫CPU繁忙型进程)。这样设计是因为I/O操作可以和CPU并行工作，如果让I/O繁忙的进程优先运行的话，那么就能让I/O设备尽早投入工作，资源利用率，系统吞吐量都会得到提升<br>| 属性               | 内容                                                     |<br>| —————— | ——————————————————– |<br>| 思想               | 轻重缓急                                                 |<br>| 规则               | 先执行优先级高的                                         |<br>| 用于作业/进程调度  | 用于进程和作业调度，甚至还会用于之后会提到的I/O调度      |<br>| 是否为抢占         | 两种都有                                                 |<br>| 优缺点             | 优点：能分清轻重缓急；缺点：可能会有高频的切换和饥饿现象 |<br>| 是否会产生饥饿现象 | 会                                                       |</p>
</blockquote>
<hr>
<p><strong>那么问题来了</strong><br>这么多算法，各有千秋但是也各有缺点，所以，能不能有一个集大成者出现呢？<br><strong>多级反馈队列调度算法</strong><br>| 属性               | 内容                                                         |<br>| —————— | ———————————————————— |<br>| 思想               | 其他算法的综合                                               |<br>| 规则               | 1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大 <br>2.新进程到达时进入第一级队列，按照FCFS等待分配时间片；若时间片用完进程还未结束，那么进程进入下一级队列队尾（如果此时已经是最低一级的队列，那么重新放到本队列末尾)<br>3.只有第K级队列为空时，才会为K+1级队列的进程分配时间片 |<br>| 用于作业/进程调度  | 用于进程                                                     |<br>| 是否为抢占         | 抢占                                                         |<br>| 优缺点             | 优点：综合性强，适应多种情况 缺点：可能导致饥饿              |<br>| 是否会产生饥饿现象 | 会（短进程不断，并且在一个时间片内可以被处理完，那么已经被降级的进程就得不到处理） |</p>
<hr>
<h2 id="进程同步-与-进程互斥"><a href="#进程同步-与-进程互斥" class="headerlink" title="进程同步 与 进程互斥"></a>进程同步 与 进程互斥</h2><p><strong>进程同步</strong><br>众所周知，进程具有异步性。异步性是指，各并发执行的进程以自己独立的、不可预知的速度向前推进。</p>
<p>但是在读写进程的时候，写 一定要发生在 读 的前面，这种情况就需要<strong>解决异步性带来的问题</strong>——这便是<strong>进程同步</strong>要讨论的</p>
<blockquote>
<p>进程同步 也叫 <strong>直接制约关系</strong>，它是为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
</blockquote>
<p><strong>进程互斥</strong><br>一个资源在同一时间内只能被一个进程使用<br>对临界区的互斥访问，从逻辑上可以分为以下四个部分：</p>
<blockquote>
<p>do{<br>    entry section;            //进入区:负责检测<br>critical section;        //临界区<br>exit section;                //退出区<br>    remainder section;  //剩余区<br>}</p>
</blockquote>
<table>
<thead>
<tr>
<th>区域</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>entry section进入区</td>
<td>负责检查是否可以进入临界区，若可进入，则应设置正在访问临界资源的标指（可以看作<strong>上锁</strong>），阻止其他进程进入临界区</td>
</tr>
<tr>
<td>critical section临界区</td>
<td>也叫临界段。就是访问临界资源的那段代码</td>
</tr>
<tr>
<td>exit section退出区</td>
<td>“解锁”</td>
</tr>
<tr>
<td>remainder section剩余区</td>
<td>做一些其他处理</td>
</tr>
</tbody></table>
<p>tips:<br><strong>进入区</strong>和<strong>退出区</strong>是 <strong>负责实现互斥</strong> 的代码段</p>
<p>遵循了四个原则：<br>| 原则     | 内容                                                         |<br>| ——– | ———————————————————— |<br>| 空闲让进 | 临界区空闲时，允许 一个请求进入临界区的进程 立刻 进入临界区  |<br>| 忙则等待 | 当已经有进程进入临界区的时候，其他试图进入这里的进程必须等待 |<br>| 有限等待 | 等待时间不能是无限的（不能饥饿）                             |<br>| 让权等待 | 当进程不能进入临界区时，应该立即释放处理机，防止进程忙等待   |</p>
<hr>
<h3 id="软件实现方法"><a href="#软件实现方法" class="headerlink" title="软件实现方法"></a>软件实现方法</h3><p><strong>1.单标志法</strong></p>
<blockquote>
<p>两个进程在访问完临界区之后，把临界区的权限交给另一个进程。也就是<strong>每个进程进入临界区的权限只能被另一个进程授予</strong><br><strong>违背了空闲让进原则</strong><br><img src="https://img-blog.csdnimg.cn/e74855743ed94d5888de6c1a54b69c94.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</blockquote>
<hr>
<p><strong>2.双标志先检查法</strong></p>
<blockquote>
<p>设置一个布尔型数组（习惯性叫flag)，数组中每个元素用来标记进程想进入临界区的意愿。比如flag[0] = true表示0号元素想要进入，每个进程进入临界区之前都要检查当前有没有别的进程想要进入临界区。<br>如果没有，那么就把自身对应的表示设为true</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/08b8df5ca4a349d68037e0071d5908e4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>上图的问题是，两者同时进入了临界区</p>
<hr>
<p><strong>3.双标志后检查法</strong></p>
<blockquote>
<p>双标志先检查法的改版。前一个算法（先检查）的问题是，先“检查”后“上锁”，但是这两个操作无法一气呵成，因此导致了两个进程同时进入临界区。<br>所以机智的人类就提出了先上锁后检查的操作<br><img src="https://img-blog.csdnimg.cn/c86ea433dd7049619ab0e84fe5571cae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</blockquote>
<p>然后又发现，这不是会导致两个都进不去吗（注意<strong>这是饥饿，不是死锁</strong>）</p>
<hr>
<p><strong>4.peterson算法</strong></p>
<blockquote>
<p>在双标志检查法的基础上，如果出现了几个进程争着进入临界区的情况，那么让进程变得“谦让”<br>方法是，依旧设置一个flag数组表示自身的意愿，但是额外地增加一个turn值表示愿意谦让哪个进程(比如turn=1，就是在发生冲突时，愿意把机会让给1号进程)</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/75720710fb4d48998fcb1688e65970fc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果按①⑥②⑦⑧的顺序执行<br>P0谦让，然后P1不甘落后又谦让，并且执行⑧循环等待，所以最终P0先使用</p>
<hr>
<h3 id="硬件实现方法"><a href="#硬件实现方法" class="headerlink" title="硬件实现方法"></a>硬件实现方法</h3><p><strong>1.中断屏蔽法</strong></p>
<blockquote>
<p>利用 开/关中断指令 实现（和原语一样，在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个进程同时访问临界区的情况）</p>
</blockquote>
<p>优点：简单高效<br>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令，只能运行在内核态，这组指令如果能让用户随意使用会很危险)</p>
<hr>
<p><strong>2.TestAndSet指令</strong></p>
<blockquote>
<p>简称TS指令，也有叫做TestAndSetLock指令的，简称TSL指令<br>他们是通过硬件控制做到的，暂不细究</p>
</blockquote>
<p>优点：实现简单；适用于多处理机环境；<br>缺点：不满足“让权等待”</p>
<hr>
<p><strong>Swap指令</strong></p>
<blockquote>
<p>也叫Exchange简称XCHG指令，同上，暂不细究</p>
</blockquote>
<p>优点：实现简单；适用于多处理机环境；<br>缺点：不满足“让权等待”</p>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><blockquote>
<p>分为两大类，整型信号量 和 记录型信号量<br>主要思想是，设置一个变量（即信号量），可以用这个量表示系统中某种资源的数量<br>常用到一对原语：wait(S)和signal(S)，分别简称为P、V（来自荷兰语），操作其中S是信号量</p>
</blockquote>
<p><strong>整形信号量</strong></p>
<blockquote>
<p>只支持三种操作：初始化、p、v</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/0c897e1d1a5b44529e10e61d1c55f455.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>注意这里的while只是为了方便理解，实际上当资源不够的时候，进程会被挂起而中断</strong></p>
<p>优点：检查和上锁一气呵成，避免了并发异步导致的问题<br>缺点：不满足让权等待原则，会发生忙等</p>
<hr>
<p><strong>记录型信号量</strong></p>
<blockquote>
<p>即在整型信号量的基础上，用记录型数据结构表示的信号量</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/1d5c5b1a820744778b95e5020311eb1b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>至于signal那里，<br>由于wait保证了，在没资源的情况下，进程会进入阻塞队列（block），<br>所以<br><strong>value为正数的时候表示空闲资源数量，<br>为负数的时候其绝对值表示阻塞队列中进程的数量</strong></p>
<hr>
<p><strong>使用信号量实现进程互斥</strong><br><img src="https://img-blog.csdnimg.cn/c222b06ad5564f0e8bd3d00b39f363f2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<hr>
<p><strong>使用信号量实现进程同步</strong><br><img src="https://img-blog.csdnimg.cn/b7331da4c8ca4aaf868323600600d35c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<hr>
<p><strong>信号量机制实现前驱关系</strong><br><img src="https://img-blog.csdnimg.cn/458be36075aa454c82418fa33726841f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<hr>
<h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><p>tip:缓冲区等临界资源为互斥访问，不为临界资源可以不用互斥</p>
<p><strong>生产者消费者问题</strong></p>
<blockquote>
<p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一组数据放入缓冲区，消费者每次从缓冲区拿出一组数据使用。<br>生产者消费者共用一个初始为空、大小为n的缓冲区。</p>
</blockquote>
<p>只有当缓冲区不满的时候，生产者才能生产，否则进入阻塞直到收到缓冲区不满的信号才被唤醒，重新进入就绪队列；<br>消费者只有当缓冲区不为空的时候，才能拿出使用，否则阻塞知道收到缓冲区不为空的信号才被唤醒，重新进入就绪队列；</p>
<p>规则很简单，但是存在问题：<br>如果并发（或者并行）环境下，有多个生产者，它们几乎同时检测了缓冲区，都发现还没满，结果两个都试图写入，结果其中一个生产者写入之后就已经满了，其他的生产者就写入失败发生写入错误</p>
<p>解决这个问题之前，我们先要<strong>分析</strong></p>
<blockquote>
<p>1.缓冲区是临界资源，需要<strong>互斥</strong>访问<br>2.缓冲区满的时候，消费者先取，生产者后放，是一种<strong>同步</strong>关系；缓冲区为空的情况同理</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/8c64f235e3314b61b9c1cde460d920d3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>但是如果我们这么执行呢？<br><img src="https://img-blog.csdnimg.cn/08e99cca3c4a48db85b7312af2b94de3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这就会引发死锁</p>
<hr>
<p><strong>多生产者-多消费者问题</strong><br>是对上一个问题的拓展<br><img src="https://img-blog.csdnimg.cn/7b88b9a3118a452287d8810fe06be3d5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>我们再来分析一手：</p>
<blockquote>
<p>互斥（其实就是先V后P）：<br>1.盘子相当于缓冲区，是临界资源，需要互斥访问<br>同步：<br>2.父亲放苹果后，女儿才能取苹果，是同步关系。母亲和儿子同理。<br>3.只有盘子为空，父母才能放，也是同步关系。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/3166525c3a064162bfeedab2f3ace993.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果不设互斥信号量mutex会怎么样？</p>
<blockquote>
<p>不会怎么样。因为缓冲区大小为1，并且存在三个同步信号量，这三个同步信号量中同一时刻最多有一个为1。因此在任何时刻，最多只有一个进程的P操作<strong>不会</strong>被阻塞，从而顺利进入临界区<br>(但是还是设置一个吧，保险</p>
</blockquote>
<p><strong>分析技巧</strong><br><img src="https://img-blog.csdnimg.cn/f6a6915aa72842638bb172680c562eb1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>其实是站在缓冲区的角度看问题，而不是站在进程上看问题</p>
<hr>
<p><strong>吸烟者（单生产者-多消费者）问题</strong><br><img src="https://img-blog.csdnimg.cn/f132573e2d6149d3babb6bf3af8de72d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>再来分析一手：</p>
<blockquote>
<p>这里桌子是缓冲区，但是注意容量应该是1！桌上摆了两个东西但是不能看作是2，应该 把两个东西看做捆绑出现的一种组合！<br>所以有三种组合：纸+胶水、烟草+胶水、烟草+纸<br>互斥：<br>1.桌上只能摆放一种组合，需要互斥访问<br>同步：<br>1.桌上有组合一，那么第一个抽烟者取走<br>2.桌上有组合二，那么第二个抽烟者取走<br>3.桌上有组合三，那么第三个抽烟者取走<br>4.抽烟完毕，供应者提供下一组材料<br>另外，还需要设置一个变量来使得三个抽烟者轮流抽烟（如果是随机给材料的情况那么就不用了）<br><img src="https://img-blog.csdnimg.cn/419f972cd19f4e458d3ee9cae0f72562.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>伪代码如下（建议把P（finish）放到前面去，这样更符合表达）<br><img src="https://img-blog.csdnimg.cn/1567e0f45e6545f7a9758437d3b1ad86.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</blockquote>
<hr>
<p><strong>读写（带计数器的互斥）问题</strong><br><img src="https://img-blog.csdnimg.cn/37fb365530be4d979330926870c37547.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>这个问题我也深有体会，在CSDN写博客的时候，如果对同一个文字打开多个编辑窗口，分别写入不同的内容发布，最后以后者的内容为最终内容。</p>
<p>分析一手：</p>
<blockquote>
<p>由于这里出现了两种类型的进程，所以不能够再从缓冲区出发了<br>互斥：<br>1.写进程和写进程互斥<br>2.写进程和读进程互斥</p>
</blockquote>
<p><strong>初步设想</strong><br><img src="https://img-blog.csdnimg.cn/f0c564bdb77e4ac29c6db3407829c7c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"> 由于会出现无法<strong>一气呵成</strong>的情况，count还没自增就一起进去了，所以我们发现读进程之间还是得互斥的来</p>
<blockquote>
<p>（3.读进程也得先后读取，主要是先后上锁）</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/c61c864004444faaad7d02e12ecc0772.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p> 但是我们还忽略了一个问题就是，写进程优先级比读进程高，那么从实际角度来说，应该是内容更新更为重要，而这种可能导致写进程<strong>饥饿（因为最后一个读进程负责解锁，所以读进程可以一直插队到写进程前)的算法</strong>不太好，所以我们进一步优化为：</p>
<hr>
<p><strong>哲学家进餐问题</strong><br><img src="https://img-blog.csdnimg.cn/f7de3e41beae4dd79345311ce27ba10f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>上述伪代码的问题是，由于异步和并发，可能出现，每个人依次拿起自己左边的筷子，然后就出现<strong>死锁</strong>，所有人都没法进行下一步于是全体尬住乐<br>所以我们还得先分析一手：</p>
<p><img src="https://img-blog.csdnimg.cn/ef20f104f1b2433dae0d89b50be4f980.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<blockquote>
<p>互斥：<br>1.每只筷子都是临界资源，要互斥访问<br>同步：<br>1.需要组织一定的先后顺序，比如设置一个初值为4的同步信号量 或者 让每个人互斥地取筷子</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/4bc9cb9c203b4e5e8581d5603d85d8d9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<hr>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><blockquote>
<p>在管程出现之前，使用信号量机制较为普遍，但是这样很容易出错<br>管程是一种特殊的软件模块，属于一种高级的同步机制，由<br>1.共享数据结构<br>2.初始化数据结构的语句<br>3.一组用来访问数据结构的过程（函数）</p>
</blockquote>
<p>如果感觉不容易理解，那么可以把管程看做是PV操作的封装，这样一来直接调用就不容易出错</p>
<p><strong>管程的基本特征</strong></p>
<blockquote>
<p>1.外部进程/线程只能通过管程提供的特定入口才能访问共享数据<br>2.每次仅允许一个进程在管程内执行某个内部过程</p>
</blockquote>
<p><strong>补充</strong></p>
<blockquote>
<p>各个进程必须互斥访问管程的特性，是由编译器实现的<br>可以在管程设计条件变量及等待/环形操作来解决同步问题</p>
</blockquote>
<hr>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><blockquote>
<p>并发环境下，各进程竞争资源而造成的一种互相等待其他进程占有的资源，导致各个进程都阻塞、都无法进一步推进的现象</p>
<p><strong>死锁、饥饿、死循环的区别</strong><br>先来看看各个名词的定义<br>| 名称   | 定义                                                         |<br>| —— | ———————————————————— |<br>| 死锁   | 各个进程互相等待对方手里的资源，导致各个进程阻塞、都无法推进 |<br>| 饥饿   | 由于长期得不到想要的资源，某个进程无法向前推进               |<br>| 死循环 | 某个进程一直执行，没有跳出某个循环（有时是bug，有时是有意为之） |</p>
</blockquote>
<p>再来分析一下区别<br>| 名称   | 区别（特点）                                                 |<br>| —— | ———————————————————— |<br>| 死锁   | 1.两个或者两个以上的进程<br>2.一定处于阻塞态                 |<br>| 饥饿   | 1.不限数目<br>2.可能是 阻塞态 或 就绪态                      |<br>| 死循环 | 1.不限数目<br>2.前两个是管理者（OS）的问题，死循环是被管理者的逻辑问题引发的（除非有意为之）<br>3.是运行态 |</p>
<hr>
<h3 id="死锁的发生"><a href="#死锁的发生" class="headerlink" title="死锁的发生"></a>死锁的发生</h3><p><strong>死锁的四个必要条件</strong><br>死锁发生必须<strong>同时满足</strong>四个条件：<br>| 条件       | 内容                                               |<br>| ———- | ————————————————– |<br>| 互斥条件   | 对必须互斥使用的资源的争抢会导致死锁               |<br>| 不剥夺条件 | 进程保持的资源只能主动释放，不能由其他进程强行夺走 |<br>| 请求和保持 | 保持某些资源不放的同时，请求别的资源               |<br>| 循环等待   | 存在进程资源的循环等待链                           |</p>
<p>这里需要注意</p>
<blockquote>
<p>死锁一定有循环等待，但是循环等待未必是死锁</p>
</blockquote>
<p>即 <strong>循环等待是死锁的必要不充分条件</strong><br>如果同类资源数大于1，即使循环等待，也未必死锁；<br>但是<strong>如果系统中每类资源都只有一个，那么循环等待就是死锁的充分必要条件了</strong></p>
<hr>
<p><strong>死锁发生的时候</strong></p>
<blockquote>
<p>概括就是<strong>资源分配不合理时就可能导致死锁</strong>，主要是以下三种情况：<br>1.对系统资源的竞争<br>2.进程推进顺序非法<br>3.信号量使用不当</p>
</blockquote>
<hr>
<h3 id="静态策略：死锁的预防"><a href="#静态策略：死锁的预防" class="headerlink" title="静态策略：死锁的预防"></a>静态策略：死锁的预防</h3><blockquote>
<p>核心思想是<strong>破坏</strong>死锁产生的四个必要<strong>条件</strong>中的一个或者几个</p>
</blockquote>
<p><strong>破坏互斥条件</strong></p>
<blockquote>
<p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：<strong>SPOOLing技术</strong>。</p>
<p>SPOOLing技术可以把独占设备<strong>在逻辑上改造为共享设备</strong><br>这里由于涉及的硬件知识过多，所以我们不用深究该技术原理，只需要明白其过程：<br>比如进程1和进程2同时访问打印机，在使用SPOOLing之前会发生阻塞；使用该技术之后，宏观上看就不会阻塞，两个请求被“同时”接受了（或许是类似并发的技术吧）</p>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<p>1.并不是所有资源都能被改造为共享资源。<br>2.并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</p>
</blockquote>
<hr>
<p><strong>破坏不剥夺条件</strong></p>
<blockquote>
<p>我们有几种方案可供选择<br><strong>方案一</strong><br>当某个进程请求新的资源得不到满足，那<strong>使它立即释放保持的资源</strong>，待以后需要时再重新申请。<br><strong>方案二</strong><br>大概某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般要考虑各个进程的优先级。（比如剥夺调度方式，就是将处理及资源强行剥夺给优先级更高的进程使用）</p>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<p>1.实现起来比较复杂<br>2.释放已经获得的资源可能导致前一阶段的工作失效。因此这种方法一般只适用于容易保存和恢复的资源，比如CPU<br>3.反复地申请和释放资源会增加系统开销，降低系统吞吐量。<br>4.如果采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就需要放弃，以后再重新申请。如果一直发生这种情况，就会发生进程饥饿。</p>
</blockquote>
<p>嘶。看完第4点才意识到，原来饥饿中提到的“得不到处理”是指处理完毕！</p>
<hr>
<p><strong>破坏请求和保持</strong></p>
<blockquote>
<p>采用<strong>静态分配法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它资源未满足之前不开始运行。一旦请求完毕，这些资源一直归它所有，那么它就不会再请求资源，也就不会发生死锁。</p>
</blockquote>
<p>如果需要的资源都有，那它不争不抢（感觉也破坏了互斥条件），当然不会死锁呀~</p>
<p><strong>缺点</strong></p>
<blockquote>
<p>虽然简单，但是也有很明显的缺点呀：<br>1.如果整个运行期间都一直保持所有资源，就会造成严重的资源浪费而且利用率可能很低<br>2.可能导致其他进程饥饿<br>（比如有A类进程需要资源1，B类进程需要资源2，C类进程需要资源1和资源2。如果由源源不断的A或B进程，那么C就会饥饿）</p>
</blockquote>
<hr>
<p><strong>破坏循环等待</strong><br>说实话这个看上去很简单，但是我还是看得有点懵…</p>
<blockquote>
<p>采用<strong>顺序资源分配法</strong>，首先给系统资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完毕</p>
<p><strong>原理</strong><br>一个进程只有已经占有小编号的资源时，才有资格申请更大编号的资源。<br>按照这种规则，已经持有大编号的进程不可能逆向地申请小编号的资源，从而就不会产生循环等待现象。（懵逼，这说的啥看不懂啊(＃°Д°)）</p>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<p>1.不方便增加新的设备，因为可能需要重新分配所有编号<br>2.一个进程实际使用资源的顺序可能和编号递增顺序不一致，这样会导致资源浪费<br>3.必须按照规定次序申请资源，用户编程麻烦（(＠_＠;)这又是为啥啊）</p>
</blockquote>
<hr>
<h3 id="动态策略：死锁的避免"><a href="#动态策略：死锁的避免" class="headerlink" title="动态策略：死锁的避免"></a>动态策略：死锁的避免</h3><blockquote>
<p>用某种方法防止系统进入不安全的状态，比如<strong>银行家算法</strong></p>
</blockquote>
<p><strong>安全序列</strong><br>先看图<br><img src="https://img-blog.csdnimg.cn/38afac5b2919437f8e19e0caa96e9d75.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/21ad05f964e14c249e307ac02c5c1eab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>提炼一下：</p>
<blockquote>
<p><strong>安全序列</strong><br>如果按照这种序列分配资源，那么每个进程都能顺利完成。安全序列可能有多个<br><strong>不安全状态</strong><br>如果没有任何安全序列，那么就进入不安全状态。不安全状态可能会因为进程资源的提前归还，而重新进入安全状态<br>(死锁一定发生在不安全状态，但是不安全状态不一定死锁)<br><strong>安全状态</strong><br>在安全状态下<strong>一定不会发生死锁</strong></p>
</blockquote>
<p>上述内容可以得出<br><strong>银行家算法</strong><br>没错，这个算法又是DJ老哥提出的，一开始真的是为了解决银行贷款时避免资金不够的情况。</p>
<blockquote>
<p>在资源分配之前，预先判断这次分配是否会导致系统进入不安全状态，以此来决定是否分执行这次分配</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/d9858bc47b264ffca6e50bde12942367.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/6e712da2bdb24746bbd555e174ca98ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>此后继续检测（不检测已经加入安全序列的进程）<br>通俗地说就是，如果它我分配了之后它能够顺利完成，它就会归还——那就分配，然后把它加入安全序列，之后继续。<br>（类似贪心？)<br>考试中用笔算，注意技巧：如果现有资源可以分别满足几个进程，那么直接把它们全部扔进安全序列（反正可以先后完成）</p>
<p>至于计算机怎么实现…这个对于数学不好的人（比如我）简直劝退<br>这一部分有兴趣了解一下就行…<br><img src="https://img-blog.csdnimg.cn/cfd1bf0d37864a0f8df0133530918641.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<hr>
<h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><blockquote>
<p>允许死锁发生，不过操作系统会检测出死锁，然后采取某种措施解除死锁</p>
</blockquote>
<p>当然，这是 死锁预防措施 或 死锁避免措施 没有被系统启用（或者失效了)的情况下的处理方式</p>
<p><strong>两个算法</strong></p>
<p> <strong>1.死锁检测算法</strong></p>
<blockquote>
<p>用于检测系统状态，以确定系统中是否发生了死锁<br><strong>方式</strong><br>1.用某种数据结构(<strong>资源分配图</strong>)来保存资源的请求和分配信息<br>2.提供一种算法，利用上述信息来检测系统是否进入了死锁</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/6cc1da3f54714a16977d0674a5eda755.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>（注意，分配边表示<strong>已经</strong>分配了多少）<br>对于上图中P1 P2 R1 R2构成的资源分配图<br>首先看P1，因为P1的请求可以满足，那么和P1相连的边可以全部移除<br>然后看P2，也是同理，与之相连的边可以全部移除<br>这样一来所有的边都被移除了，这种资源分配图就是<strong>可完全简化的</strong>，这说明这是安全的，没有发生死锁；否则就是<strong>已经发生了死锁</strong>，而最终还有相连边的进程就是<strong>发生死锁的进程</strong></p>
<p>其实上述内容就是<br><strong>死锁定理</strong></p>
<blockquote>
<p>如果某时刻资源分配图是不可完全简化的，那么此时系统处于死锁</p>
</blockquote>
<p>(比如来看一个死锁的情况)<br><img src="https://img-blog.csdnimg.cn/e2ff05e67b6849d4a33baa8b3d3cc3c1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p> <strong>2.死锁解除算法</strong></p>
<blockquote>
<p>发生死锁时，解除死锁。有几种方法：<br><strong>1.资源剥夺法</strong><br>挂起某些死锁进程，抢占其资源，并且将其资源分配给其他资源。但是要防止被挂起的进程发生饥饿。<br><strong>2.撤销进程法</strong><br>也叫<strong>终止进程法</strong>。强制撤销部分甚至全部死锁进程，并剥夺这些进程的资源。（这种方式简单粗暴，但是代价可能巨大，比如一个进程运行很久已经快结束了结构又被撤销直接白干了）<br><strong>3.进程回退法</strong><br>让一个或多个死锁进程回退到足以避免死锁的地步<br>（这需要系统记录进程的历史信息，设置还原点）</p>
</blockquote>
<p>有了方法，现在还要讨论对哪个进程出手<br>我们一般从一下几个方面进行考虑：</p>
<blockquote>
<p>1.进程优先级（干掉优先级低的）<br>2.已经执行时间（干掉执行时间少的）<br>3.剩余执行时间（干掉剩余时间多的）（和上面那个有点矛盾）<br>4.已经使用多少资源（先干掉资源用的多的）<br>5.交互式进程还是批处理式进程（先干掉批处理进程，让用户感受好些）<br>…..</p>
</blockquote>
<h2 id="存储与查询"><a href="#存储与查询" class="headerlink" title="存储与查询"></a>存储与查询</h2><h3 id="内存基础知识"><a href="#内存基础知识" class="headerlink" title="内存基础知识"></a>内存基础知识</h3><blockquote>
<p>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</p>
</blockquote>
<p><strong>内存单元</strong><br>即每一个内存地址对应的存储空间，至于存储空间的大小，分两种情况：<br><strong>1.按字节编址</strong></p>
<blockquote>
<p>每个内存单元大小为1字节（byte，b）</p>
</blockquote>
<p><strong>2.按字长编址</strong></p>
<blockquote>
<p>每个内存单元大小为1字（每个字大小是2字节)</p>
</blockquote>
<p><strong>冷知识</strong><br>1K  = 2^10<br>1M = 2^20,<br>1G = 2^30 </p>
<p>所以4G内存表示，内存中可以存储4<em>2^30字节——如果是按字节编址，也就有4</em>20^30个地址，即2^32个地址</p>
<hr>
<p> <strong>逻辑地址 与 物理地址</strong><br>其实就相当于直接路径和相对路径这样的，很好理解<br>比如实际的地址（物理地址）是666，把666当成0，那么667就是1</p>
<hr>
<p><strong>编辑、编译、链接 和 装入</strong></p>
<blockquote>
<p>编辑：高级语言写代码<br>编译：高级语言编译为(机器语言)多个目标模块，分散在多个逻辑地址段中<br>链接：多个模块组装成一个<strong>装入模块</strong>，有一个完整的<strong>逻辑地址</strong>段<br>装入：把装入模块装入内存中，有完整的物理地址</p>
</blockquote>
<hr>
<h3 id="三种装入-与-三种链接"><a href="#三种装入-与-三种链接" class="headerlink" title="三种装入 与 三种链接"></a>三种装入 与 三种链接</h3><p>首先是三种装入：<br><strong>绝对装入</strong></p>
<blockquote>
<p><strong>在编译时</strong>，如果知道程序放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。<br><strong>概述为：编译时产生绝对地址</strong></p>
</blockquote>
<p>比如你知道大小为装入模块要从物理地址为100的地方开始存放，那就直接装入100</p>
<p>只适用于<strong>单道程序环境</strong>，且通常是编译或汇编环节给出绝对地址(其实也可以由程序给)</p>
<hr>
<p><strong>静态重定位</strong></p>
<blockquote>
<p>又称<strong>可重定位装入</strong>，装入模块中的地址是逻辑地址，直至真正装入时逻辑地址换为物理地址。程序运行期间无法移动。<br><strong>概述为：装入时将逻辑地址转为物理地址。</strong></p>
</blockquote>
<p><strong>这是早期多道批处理操作系统采用的</strong></p>
<hr>
<p><strong>动态重定位</strong></p>
<blockquote>
<p>又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的逻辑地址都是从0开始的。装入程序（负责把装入模块装入的程序)把装入模块装入内存之后，并不会把逻辑地址转为物理地址，而是把地址转换推迟到<strong>程序真正要执行时</strong>才进行。因此，装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持（进行的操作是物理地址+目标逻辑地址）。<br><strong>概述为：运行时将逻辑地址转为物理地址</strong></p>
</blockquote>
<p>通过重定位寄存器，可以将程序分配到不连续的内存中（意思是每段只有部分的程序代码，这也是<strong>虚拟</strong>的体现，这样使用户能够使用一个比存储空间大得多的地址空间）<br><strong>这也是现代操作系统普遍采用的</strong></p>
<hr>
<p>再来看看三种链接：</p>
<p><strong>静态链接</strong></p>
<blockquote>
<p>在程序运行之前，将各目标模块及它们所需要的库函数连接成一个完整的可执行文件(也就是装入模块)，之后不再拆分。</p>
</blockquote>
<hr>
<p><strong>装入时动态链接</strong></p>
<blockquote>
<p>将各目标模块装入内存时，边装入边链接。</p>
</blockquote>
<hr>
<p><strong>运行时动态链接</strong></p>
<blockquote>
<p>在程序执行中需要该目标模块时，才对他进行链接。其优点时便于修改和更新，便于实现对目标模块的共享。</p>
</blockquote>
<hr>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><blockquote>
<p>管理内容大概分为以下3个方面：<br>1.内存空间的分配与回收<br>2.从逻辑上对内存空间进行扩充<br>3.地址转换（逻辑地址和物理地址的转换)<br>4.内存保护</p>
</blockquote>
<hr>
<p>专门说一下</p>
<p><strong>内存保护</strong></p>
<blockquote>
<p>只允许各个进程访问自己拥有的内存，保证各个进程互不干扰</p>
</blockquote>
<p><strong>方式一</strong></p>
<blockquote>
<p>cpu中有上下限寄存器，存放进程的上下限地址，进程访问地址时，cpu据此检测是否越界</p>
</blockquote>
<p><strong>方式二</strong></p>
<blockquote>
<p>采用<strong>重定位寄存器（也叫基址寄存器）</strong> 和  <strong>界地址寄存器（也叫限长寄存器）</strong>，分别存放<strong>起始物理地址</strong>和<strong>最大逻辑地址</strong>，同样检测是否越界</p>
</blockquote>
<h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><blockquote>
<p>早期计算机额内存很小，比如IBM的第一台PC机器，最大就1MB内存。所以得想办法解决一下内存过小从而导致程序无法顺利运行的情况——<strong>覆盖技术</strong>因此诞生</p>
</blockquote>
<p><strong>覆盖</strong></p>
<blockquote>
<p>思想是<strong>将程序分为多个段（多个模块)</strong><br>常用的段常驻内存，不常用的段在需要时调入内存</p>
</blockquote>
<p>这样就使得1mb的内存可以运行2mb甚至更大程序！</p>
<p>这其中，内存被划分为两个区域<br>| 区域名称 | 数量   | 简介                                             |<br>| ——– | —— | ———————————————— |<br>| 固定区   | 1个    | 常驻内存的段就被放入这里，在运行结束之前不会调出 |<br>| 覆盖区   | 若干个 | 选取可能放入这个区域中最大的段的内存             |</p>
<p><img src="https://img-blog.csdnimg.cn/b4ec013df1844f488b5a7cdc4e8293e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>橙色是常驻区，BC是不会被同时调用的两个段，分别是D、EF的前驱</p>
<p>这种技术</p>
<blockquote>
<p>优点：由程序员声明覆盖结构，操作系统自动完成覆盖<br>缺点：对用户不透明，增加了编程负担</p>
</blockquote>
<hr>
<p><strong>交换技术</strong></p>
<blockquote>
<p>思想是内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某系已经具备运行条件的进程换入内存（进程在内存与外存间动态调度)</p>
</blockquote>
<p>没错，就是<strong>挂起与就绪之间的转换</strong>的<strong>中级调度（内存调度）</strong></p>
<p><strong>1.至于如何交换呢？</strong></p>
<blockquote>
<p>一般来说，具有交换功能的操作系统中，通常把磁盘空间分为 <strong>文件区</strong> 和 <strong>对换区</strong>两个部分。<br>文件区主要用于存放文件，追求存储空间的利用率，因此对文件区的空间管理采用<strong>离散匹配方式</strong>；<br>对换区只占很小的空间，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此通常对换区采用<strong>连续分配方式</strong>。<br>（总之，对换区的I/O速度比文件区要快）</p>
</blockquote>
<p><strong>2.那么什么时候发生交换？</strong></p>
<blockquote>
<p>交换通常在内存紧张时进行，在内存充裕时暂停。比如在许多进程运行时发生缺页，就说明内存紧张，此时可以换出一些进程。</p>
</blockquote>
<p><strong>3.换出哪些进程？</strong></p>
<blockquote>
<p>优先换出阻塞进程。可以换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。（注意PCB常驻内存）</p>
</blockquote>
<hr>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>由于时间紧迫，这里开始先水一点了，后面再细细地补上</p>
<p><strong>连续分配</strong></p>
<blockquote>
<p>指为用户进程分配一个连续的内存空间</p>
</blockquote>
<hr>
<p><strong>固定分区分配</strong></p>
<blockquote>
<p>把整个内存的用户区域（对换区）分为n个大小固定的分区</p>
</blockquote>
<hr>
<p><strong>动态分区分配</strong></p>
<blockquote>
<p>动态分区分配又称为可变分区分配，在进程装入内存时，根据进程动态地建立分区</p>
</blockquote>
<p><strong>动态分区分配算法</strong><br>这个算法是为了解决一个问题：在动态分配过程中，当很多歌空闲分区都能满足需求时，应该选择哪个分区进行分配？</p>
<p>这里举例四种动态分区分配算法：<br><strong>1.首次适应算法</strong></p>
<blockquote>
<p>每次从低地址开始查找，找到第一个满足的空闲分区<br>查找方式是通过空闲分区链或者空闲分区表来查找的(其实就是空闲的内存的首地址和大小等信息会以顺序或者链式存储，可以据此遍历）</p>
</blockquote>
<p><strong>2.最佳适应算法</strong></p>
<blockquote>
<p>和首次适应算法类似，不过存储空闲分区地址的数据结构将以<strong>递增</strong>的形式存储，所以空间越大的分区排在越后面</p>
</blockquote>
<p>这样一来每次都能找到大小最接近的，使得内存利用率很高<br>可是问题也很明显，每次使用，都可能会留下非常小的空间（比如10mb的程序占用了11mb内存，空闲的1mb难以利用），这种空间叫做<strong>内部碎片</strong><br>内部碎片多了之后，利用率又下来了</p>
<p><strong>3.最坏适应算法</strong></p>
<blockquote>
<p>和最佳适应算法相反，最坏适应算法存储是<strong>递减</strong>的</p>
</blockquote>
<p>主要是想着防止小碎片产生，那我就每次用最大的空间不就好了？（10mb程序占用100mb内存，还有90mb这不是很容易用出去吗）</p>
<p>但是问题是，可能导致后面来的大进程没有空间<br><strong>4.邻近适应算法</strong></p>
<blockquote>
<p>递增存储并且是环形结构，每次查找从上一次查找结束的位置开始继续查找</p>
</blockquote>
<h3 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h3><blockquote>
<p>上一节中提到的算法，虽然各有千秋，但是无一例外地都可能产生碎片<br>（虽然可以使用<strong>紧凑技术</strong>来解决碎片问题，但是其时间开销太大）</p>
</blockquote>
<p>所以出现了<strong>基本分页存储管理</strong></p>
<blockquote>
<p>就是把内存分为一个个大小相等的小分区，再按照分区大小把进程拆分为一个个小部分<br><strong>每一个分区就是一个“页框”</strong>，或者叫“页帧”、“内存块”、“物理块”，每个页框都有一个编号，即“页框号”（或者叫“内存块号”之类的），从0开始</p>
</blockquote>
<p>tips：内存可能不能整除页框大小，所以最后一个页面可能没有一个页框那么大，因此页框不能太大，否则可能产生较大的内部碎片</p>
<p><strong>装入</strong><br>类似于一个程序的链接装入过程<br><img src="https://img-blog.csdnimg.cn/3ffe3e28e17c4ceb91cdbc873529da8f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>其中涉及到一些关于 <strong>页号</strong> 和 <strong>页内偏移量</strong>的计算</p>
<blockquote>
<p>页号 = 逻辑地址 / 页面长度<br>页内偏移量 = 逻辑地址 % 页面长度</p>
</blockquote>
<p>另外，为了方便计算页号、页内偏移量，页面大小一般用2的整数幂</p>
<hr>
<p><strong>页表</strong><br>为了能够知道进程中每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表<br><img src="https://img-blog.csdnimg.cn/9017ebfe3cf34f45a928e5e96e46093b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>（完了卧槽啊，吃个饭回来发现电脑重启了，一下午的笔记就没了，7k字一个字一个字码上去的啊，淦哦，缺失的内容先简单写一下了，心态有点炸）</p>
<p><strong>基本概念</strong></p>
<blockquote>
<p>核心思想是把进程分成很多大小相等的段，内存也分为与进程等大的段，然后前者叫做页面，后者叫页框，它们之间的对应关系用页表来存，页表也放在页框中</p>
<p>1.页面：简称页，也就是进程的分段<br>2.页框：大小和页面相同，也叫内存块的（有一堆名字），是内存的分段<br>3.页表：记录了页面和页框的对应关系，其中每一项叫做页表项<br>4.页号：页表中某个页面的编号，其值为 <strong>逻辑地址 / 页面大小</strong><br>5.页面偏移量：即 <strong>逻辑地址位数 % 页面大小</strong>（页面长度）的值<br>6.<strong>逻辑地址构成 = 页号 + 页内偏移量</strong><br>（比如30位的逻辑地址 = 10位页号 + 20位页内偏移量;<br>如果有m位页号，那么说明一个进程中最多有m个页面；<br>如果有k位页内偏移量，那么一个页面的大小是2^k^个内存单元）<br>7.页面大小：就是一个页面的大小，是2的整数幂</p>
</blockquote>
<hr>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p><strong>基本地址变换机构</strong></p>
<blockquote>
<p>基本地址变换机构通过页表将逻辑地址转为物理地址<br>通常会在系统中设置一个<strong>页表寄存器（PTR）</strong>，存放在内存中的<strong>起始地址F</strong>和<strong>页表长度M</strong>。地址变换的过程如下：<br>1.进程未执行时，页表的  起始地址F 和  页表长度M 放在进程控制块PCB中，当进程被调度时候，操作系统内核将F和M放到寄存器中<br>2.根据页表中记录的逻辑地址计算出 <strong>页号</strong> 和 <strong>页内偏移量</strong><br>3.与PTR里面的数据进行比较，如果页号<strong>大于等于</strong>页表长度，那么发生越界，内中断；如果小于，那么判定合法，进入下一步。<br>4.根据页号查询页表，找到对应的页框号<br>5.用页框号和页内偏移量得到物理地址<br>6.访问目标单元</p>
</blockquote>
<p>这个过程中，<strong>访问了两次内存</strong><br>（访问内存开销比较大，所以减少访问内存的次数可能会得到优化）</p>
<hr>
<p><strong>带有快表的地址变换机构</strong></p>
<p><strong>局部性原理</strong><br>先看如下代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	arr<span class="token punctuation">[</span>i <span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><strong>时间局部性</strong><br>如果执行了程序中某条指令，那么不久后这条指令可能被再次执行；<br>如果某个数据被访问过，那么不久后该数据可能再次被访问；<br><strong>空间局部性</strong><br>如果某个存储单元被访问，那么不久之后其附近的存储单元也可能被访问。（比如很多具有连续存储这一性质的数据）<br><strong>至于为什么叫局部</strong><br>我个人的理解是，限制在某一个时间段，限制在某一个空间内，这就是局部。<br><strong>有什么意义</strong><br>其实上述内容暗示我们，一个较短的时间段内，进程只有一部分被访问了。这就说明我们每次只需要访问一部分就能运行一个进程，那么就没有必要一次性存储全部的内容。</p>
</blockquote>
<p>我们上面提到过，访问内存开销大，那么我们尽量减少访问内存的次数。<br>这样重复的访问内存，却只是找同样的东西，那么我们能不能把这个东西保存到内存外面，下次访问就不需要从内存里面找了？</p>
<p><strong>快表</strong></p>
<blockquote>
<p>又称<strong>联想寄存器（TLB） 或者 地址变换高速缓存</strong>，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问过（当前指的是当前运行的进程）的若干页表。<br>与之对应的<strong>慢表</strong>通常指的是内存中的页表</p>
</blockquote>
<p>在加入快表后，地址变换过程变为：<br><strong>（黑色斜体字表示新加入的步骤）</strong></p>
<blockquote>
<p>1.进程未执行时，页表的  起始地址F 和  页表长度M 放在进程控制块PCB中，当进程被调度时候，操作系统内核将F和M放到寄存器中<br>2.根据页表中记录的逻辑地址计算出 <strong>页号</strong> 和 <strong>页内偏移量</strong><br>3.与PTR里面的数据进行比较，如果页号<strong>大于等于</strong>页表长度，那么发生越界，内中断；如果小于，那么判定合法，进入下一步。<br><em><strong>3.查询快表，如果查询成功（命中），就进入第5步；失败则进入第4步</strong></em><br>4.根据页号查询页表，找到对应的页框号，<em><strong>并把该页表项中的页号和页框号放入快表中</strong></em><br>5.用页框号和页内偏移量得到物理地址<br>6.访问目标单元</p>
</blockquote>
<p>上述过程中，如果第3步命中，那么地址变换就只需要访问一次内存<br>可以根据以下例题感受效率的变化<br><img src="https://img-blog.csdnimg.cn/dbec1330a0bc457b860dd742beb9241e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>tips：<br>至于第3步为什么会有<strong>查询失败</strong>的情况，有两种可能：</p>
<blockquote>
<p>1.第一次访问某个页号，快表中没有存储（快表一开始是空的）<br>2.快表满了，装不下全部数据，所以就出现访问过也查找失败的情况（因为快表造价要贵点，空间比较小。不）（然要主存干啥，干脆全用快表了）</p>
</blockquote>
<hr>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>其实主要还是二级页表….多级同理…</p>
<p><strong>单级页表存在的问题</strong><br>首先看一个计算<br><img src="https://img-blog.csdnimg.cn/2532254450104700b1a82f52e115f05b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<blockquote>
<p>首先是告诉我们这个系统支持32位逻辑地址，然后页面大小是4KB = 2^12^位，结合前面的知识（逻辑地址位数 = 页面大小位数 +<br>页号位数）,我们知道<strong>页号位数 = 32 - 12 = 20位</strong>，<br>然后页号就是页面的编号嘛，所以有2^20^个页面，一个页面在页表中都有一个对应的页表项，那么就有2^20^个页表项，题目告知一个页表项大小为4B，那么整个页表的大小就是2^22^B。<br>这时候，不要忘了页框和页面等大，所以一个页框也是4KB = 2^12^B，于是乎，页框个数就是 <strong>2^22^/ 2^12^ =<br>2^10^个</strong> ，也就意味着，要分配1024个连续的页框来存储页表，这将是不小的开销</p>
</blockquote>
<p>所以存在两个问题：<br>1.页表必须连续存放，当页表很大时，存放起来比较困难（最起码开销很大吧）<br>2.由于存在局部性原理，所以让整个页表常驻内存并不明智</p>
<p>为了解决问题1，大佬们提出<br><strong>二级页表</strong></p>
<blockquote>
<p>将页表分组，使得每一个内存块正好可以放入一个分组（比如页面大小4KB，页表项4B，每个页框可以存放1K个页表项，所以每1K个页表项分为一组，然后离散地存入各个页框）<br>此后，为了记录这些离散存储的页表组，我们再建一张页表，称为<strong>页目录表，或者外层页表、顶层页表</strong>等等</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2939689873d1496ea6f392f42572d470.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>需要注意的几个细节：<br><img src="https://img-blog.csdnimg.cn/a009ca69fdd146d193e6d5b65a6b7c6d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>让我鹦鹉学舌来一手（主要是为了巩固，加深印象）</p>
<blockquote>
<p>40位逻辑地址就是2^40^B，而一个页面是4KB = 2^12^B，那么可以容纳2^28^个页面，也就是有2^28^个页号，因为按字节编制，所以页号有28位。<br>页面和页框等大，都是2^12^B，一个页表项是4B，那么一个页面可以容纳2^10^个页表项，因此一个页表项对应的页号是10位。<br>由于<strong>各级页表的大小不能超过一个页面的容量</strong>，所以一级最大就是10位，那么对于28位的页号来说就是10 + 10 + 8三级页表才能完成存储</p>
</blockquote>
<p>但是n级页表的缺陷也很明显：<br>（不考虑快表）需要访问n+1次内存</p>
<hr>
<p>至于问题2，后面细说，这里先大概了解</p>
<blockquote>
<p>大佬们提出了虚拟存储技术，就是在内存只放一部分，然后访问的时候如果内存中没有那么就产生缺页中断（内中断），从外存中调进来就可以了</p>
</blockquote>
<h3 id="分段存储"><a href="#分段存储" class="headerlink" title="分段存储"></a>分段存储</h3><blockquote>
<p>与分页存储的最大区别就是离散分配时，所分配的地址空间的基本单位不同：<br>进程的地址空间指的是，按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址。<br><strong>段成为内存分配的单位</strong>，每个段在内存中占据连续的空间，但是<strong>各段之间可以不相邻</strong>。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/336dcb1cdd7346cdbad992866805e425.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>段名会在编译过程中被处理为段号</p>
<h3 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h3><p><strong>分页分段的优缺点</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>分页管理</td>
<td>内存利用率高，没有外部碎片，几乎没有页内碎片（很少）</td>
<td>不方便按照逻辑模块实现信息的共享和保护</td>
</tr>
<tr>
<td>分段管理</td>
<td>很方便按照逻辑模块实现信息的共享和保护</td>
<td>如果段长过大，为其分配连续的内存空间不方便，另外也可能产生较多外部碎片</td>
</tr>
</tbody></table>
<p><strong>段页式的具体过程</strong></p>
<blockquote>
<p>段页式便是段和页的结合<br>是先分段，分成大大小小不同的段，然后再装进一样大小的页框中</p>
<p><img src="https://img-blog.csdnimg.cn/0db198d7e86c4c3fa5f286ac9c16823b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统段页式管理中分段分块"></p>
</blockquote>
<p>（仔细一想，这不应该是产生了更多没有利用的内存空间吗，不过考试迫在眉睫，暂时先背着吧）</p>
<p>之后的对应关系大概是<br><img src="https://img-blog.csdnimg.cn/be8a44faa43e40908d76887ff54a13c3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统段页式管理离散匹配"></p>
<blockquote>
<p>段页式管理中，一个进程可以对应<strong>一个段表</strong>，这个段表又对应了<strong>多个页表</strong>（即一个段表项对应了一个页表）<br>注意这里的段表，其每个段表项是等长的，短号是隐含的（不记录，默认从0开始升序），<br>记录了页表长度和页表存放的块号</p>
</blockquote>
<blockquote>
<p>至于进程分段后是怎么确定在内存中的位置这件事情：<br>0.先把<strong>段表始址F</strong>和<strong>段表长度M</strong>存放到段表寄存器中<br>1.根据逻辑地址得到<strong>段号S</strong>、<strong>页号P</strong>、页内<strong>偏移量W</strong><br>2.判断是否越界：如果段号S&gt;=偏移量M那么产生越界，中断；否则进行下一步<br>3.查询页表，找到对应的段表项，段表项的存放地址为F+S*段表项长度<br>4.判断是否越界，若页号&gt;=页表长度，中断；否则进行下一步<br>5.根据页表存放块号、页号查询页表，找到对应页表项<br>6.根据内存块号页内偏移量得到最终物理地址<br>7.访问目标内存单元</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/784b552e912e4e34885c43f2869ee095.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统段页式访问内存的过程"></p>
<p>上述过程会访问三次内存（访问段表、页表、最终目标内存）</p>
<p>当然如果引入<strong>快表</strong>，那么可能只需要一次访问</p>
<h2 id="虚拟内存及相关存储管理方式"><a href="#虚拟内存及相关存储管理方式" class="headerlink" title="虚拟内存及相关存储管理方式"></a>虚拟内存及相关存储管理方式</h2><h3 id="虚拟内存概述"><a href="#虚拟内存概述" class="headerlink" title="虚拟内存概述"></a>虚拟内存概述</h3><p><strong>传统内存</strong></p>
<blockquote>
<p>即之前提到的连续分配和非连续分配内存的方式。<br>很多暂时用不到的数据也会长期占用内存，导致内存利用率不高。<br>其特征如下：<br><strong>一次性</strong>：作业必须一次性全部装入内存后才能开始运行<br>这就造成了两个问题：<br>（<br>1.作业很大时，不能全部装入内存，大量作业无法运行；<br>2.大量作业运行时，由于内存无法容纳所有作业，只有少量作业能运行，导致多道程序并发度下降<br>）<br><strong>驻留性</strong>：一旦作业被装入内存，就会一直驻留在内存中，直到作业运行结束。<br>（事实上，在一个时间段内，只要访问作业的一小部分数据即可正常运行，导致了大量内存空间浪费）</p>
</blockquote>
<p><strong>虚拟内存的原理</strong></p>
<p>上一篇提到过<strong>局部性原理</strong>，还有<strong>时空局部性</strong><br>虚拟内存就是利用了（理论上的原理）空间的局部性原理实现的<strong>空分复用术</strong>，其技术上的原理是<strong>高速缓冲技术</strong></p>
<blockquote>
<p>高速缓冲技术的思想是将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放到更低速的存储器中<br>（存储器速度：寄存器&gt;cache(高速缓存)&gt;内存&gt;外存）</p>
</blockquote>
<p><strong>虚拟内存的具体体现</strong></p>
<blockquote>
<p>比如，程序执行过程中，访问的信息不在内存中时，由操作系统负责将所需要的信息从外存调入内存，然后继续执行程序<br>如果内存空间不够，那么就把暂时用不到的信息调到外存<br>在操作系统的管理下，在用户看来似乎有一个比实际内存大的多的内存，这就是<strong>虚拟内存</strong></p>
</blockquote>
<p><strong>虚拟内存三大特性</strong><br>（就是单纯想总结一下，不要求掌握）<br>| 名称   | 内容                                                         |<br>| —— | ———————————————————— |<br>| 多次性 | 无需作业运行时一次性全部装入内存，而是允许被分为多次调入内存 |<br>| 对换性 | 在作业运行时，无需一直常驻，而是在作业运行的过程中，将作业换入换出（请求调页 + 页面置换） |<br>| 虚拟性 | 从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量 |</p>
<h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><p> <strong>与 基本分页管理 的主要区别：</strong></p>
<blockquote>
<p>在程序执行过程中，当所<strong>访问的信息不在内存时</strong>，由操作系统负责将<strong>所需要的信息从外存调入内存</strong>，然后继续执行程序<br>若内存空间不够，由操作系统将<strong>内存中暂时用不到的信息换出外存</strong></p>
</blockquote>
<p>为了更好的实现调入调出，请求分页存储管理的页表增加了四个字段：<br><img src="https://img-blog.csdnimg.cn/5f3b5dd82d1748eca44ca2cde6997bc7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_请求分页存储管理的页表"></p>
<table>
<thead>
<tr>
<th>新增字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>状态位</td>
<td>是否已经调入内存</td>
</tr>
<tr>
<td>访问字段</td>
<td>可记录最近被访问过几次，或者记录上次访问的时间，供置换算法选择换出页面时参考</td>
</tr>
<tr>
<td>修改位</td>
<td>页面调入内存后是否被修改过</td>
</tr>
<tr>
<td>外存地址</td>
<td>页面在外存中的存放位置</td>
</tr>
</tbody></table>
<p>和基本分页存储管理<strong>不同之处</strong><br><strong>请求调页</strong><br>如果访问页面不在内存中，那么就产生一个<strong>缺页中断</strong>（属于内中断），然后由操作系统的缺页中断处理程序处理中断，此时缺页的进程阻塞，被放入阻塞队列末尾，调页完成后再被唤醒加入就绪队列。</p>
<p><strong>页面置换</strong><br>如果内存不够，则会根据<strong>页面置换算法</strong>淘汰页面，若该页面在内存时期被修改过，那么还得将其在外存中的内容同步修改（写回外存）；未修改则不用写回；<br>具体过程是：<br>请求调页、页面置换、需要请求页表中新增的表项</p>
<p><strong>引入快表</strong><br>同样地，又是需要多次访问内存，所以我们就容易想到快表</p>
<p><img src="https://img-blog.csdnimg.cn/2ec9fb40089646ca9091459b2b41e08b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_具有快表的请求分页管理"></p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>这里时间有些紧迫，所以长话短说，暂时先不举出例子了<br><strong>OPT最佳置换算法</strong></p>
<blockquote>
<p>每次选择淘汰<strong>不再使用 或 以后最长时间不使用</strong>的页面</p>
</blockquote>
<p>这是最优的算法，但是<strong>无法实现</strong>，因为无法预知未来</p>
<hr>
<p><strong>FIFO先进先出置换算法</strong></p>
<blockquote>
<p>淘汰最先到达的页面</p>
</blockquote>
<hr>
<p><strong>LRU最近最久未使用置换算法</strong></p>
<blockquote>
<p>利用访问字段记录上次自上次使用后经历的时间，据此淘汰目前最长时间未使用的页面。需要硬件支持才能实现。<br>该算法是最性能最接近OPT的</p>
</blockquote>
<p>乍一想好像和FIFO一样，我对此只能说，<br><em>想的好，下次不许想了</em><br>验证过了，有些时候结果不一样，所以别想了，先背着要考了<br><strong>手写做题的时候，可以倒过来找，当前的几个页面里最后出现的就是淘汰的</strong></p>
<hr>
<p><strong>CLOCK时钟置换算法</strong></p>
<blockquote>
<p>也叫<strong>NRU最近未使用算法</strong>，或者<strong>第二次机会算法</strong><br>页面访问字段为1表示最近访问过，0反之；<br>循环扫描当前几个页面，修改访问字段，如果是1就改为0，如果是0那就淘汰当前页面，循环结束</p>
</blockquote>
<p>也就是最多循环两次</p>
<p>这个算法性能是很好的，虽然次于OPT和LRU，但是实现难度相对小，均衡</p>
<hr>
<p><strong>改进的CLOCK时钟置换算法</strong></p>
<blockquote>
<p>简单的CLOCK时钟置换只考虑页面最近是否被访问，但是没考虑最近是否被修改（因为只有被修改过的页面才有必要调出内存、写回外存）<br>改进就是，其他条件相同的时候，优先淘汰没有被修改的页面（利用修改位判断是否被修改过）</p>
</blockquote>
<p>这个至多访问四轮：</p>
<blockquote>
<p>第一轮是找<strong>最近没使用的、且 没有 修改过的</strong>，这一轮不会修改访问位，如果没找到：<br>第二轮就查找<strong>最近没使用的、且修改过的</strong>，这一轮要是再失败，就把所有扫描到的访问位置为0——表示没使用过<br>第三轮就重复第一轮的过程，如果还失败，（就再来一轮） 第四轮就重复第二轮的过程，由于第二轮的修改，那这次一定会找到</p>
</blockquote>
<hr>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><p><strong>驻留集</strong></p>
<blockquote>
<p>指请求分页存储管理中给进程分配的物理块（内存块）的集合，在虚拟存储技术中，驻留集一般小于进程的总大小</p>
</blockquote>
<p>驻留集大小过大，并发度下降，资源利用率低下<br>驻留集过小，系统大量时间用于处理缺页，进程推进的实际时间太小</p>
<hr>
<p><strong>页面分配、置换策略</strong><br>分配</p>
<blockquote>
<p><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不在改变。即，驻留集大小不变。<br><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可以根据情况做适当的增加或减少。即，驻留集大小改变。</p>
<p>置换</p>
</blockquote>
<blockquote>
<p><strong>局部置换</strong>：发生缺页时，只能选进程自己的物理块进行置换<br><strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存</p>
</blockquote>
<p>组合起来：</p>
<p><strong>可变分配全局置换</strong>：刚开始会为每个进程分配一定数量的物理块，当某天进程发生缺页的时候<br><strong>可变分配局部置换</strong>：根据发生缺页的频率来动态地增加或减少进程的物理块</p>
<hr>
<p><strong>调入页面的时机 及 从何处调入</strong></p>
<p><strong>调入时机</strong></p>
<blockquote>
<p>1.<strong>预调页策略</strong>：根据局部性原理，一次性调入若干个相邻的页面比一次性调入一个页面更高效，但是如果提前调入的页面中有大多数都不被访问，则又是低效的。<br>这种策略需要程序员指出应该先调入哪些部分。<br>2.<strong>请求调页策略</strong>：进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都因I/O操作而有较大的开销</p>
</blockquote>
<p><strong>从外存的何处调入内存</strong><br><strong>外存</strong>有对换区和文件区，<br>对换区I/O操作速度快，采用连续分配方式；<br>文件区I/O操作速度慢，采用离散分配方式；</p>
<blockquote>
<p>1.系统对换存空间足够： 页面调入调出都是在<strong>内存和对换区</strong>之间进行的（进程运行前，将进程相关数据复制到对换区）</p>
</blockquote>
<blockquote>
<p>2.系统对换区空间不足： 凡是不会被修改的数据都会直接从文件区调入内存，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。</p>
</blockquote>
<hr>
<p><strong>抖动现象</strong></p>
<blockquote>
<p>页面在内外间过于频繁的切换。（一般是发生在进程频繁访问的<strong>页面数目高于可用的内存块数</strong>）</p>
</blockquote>
<p><strong>工作集</strong></p>
<blockquote>
<p>指在某段时间间隔里，<strong>进程实际访问页面</strong>的集合</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/656565ffeaca46b19c568871db11bebd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统工作集示例"></p>
<p>一般来说，驻留集大小不能小于工作集大小，否则容易<strong>抖动</strong></p>
<h2 id="文件管理（待补充）"><a href="#文件管理（待补充）" class="headerlink" title="文件管理（待补充）"></a>文件管理（待补充）</h2><p>这部分咱学校考试考得稍微少点，所以这部分先水过，后面有空再回来补上</p>
<h3 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h3><blockquote>
<p>类似数据结构，逻辑结构指的从用户的视角看的结果<br>分为两大类：无结构文件 和 有结构文件</p>
</blockquote>
<hr>
<p><strong>无结构文件</strong><br>文件内部的数据就是一系列二进制流或字符流组成。又称“<strong>流式文件</strong>”。如：windows操作系统中的txt文件。</p>
<hr>
<p><strong>有结构文件</strong><br>由一组相似的记录组成，又称“<strong>记录式文件</strong>”。每条记录又由若干个数据项组成，又可以分为“<strong>可变长记录</strong>”和“<strong>定长记录</strong>”。如：数据库表文件。一般来说，每条记录有一个数据项可作为关键字（主码/主键）</p>
<p>我们重点讨论的就是有结构文件，它又有三种：<br><strong>顺序文件</strong>、<strong>索引文件</strong>、<strong>索引顺序文件</strong></p>
<p><strong>顺序文件</strong></p>
<blockquote>
<p>（逻辑上的顺序）类似线性表，（物理上的存储结构）即链表和数组；(考试通常是数组)</p>
</blockquote>
<p>其结构可以分为<br>串结构：记录之间的顺序与关键字无关；<br>顺序结构：记录之间的顺序按关键字顺序排列；</p>
<hr>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><strong>文件控制块</strong></p>
<blockquote>
<p>FCB，类似进程控制块，这是实现文件目录的关键数据结构<br>FCB中包含了文件的<br>基本信息（文件名、物理地址、逻辑结构、物理结构）<br>存取控制信息（是否可读/可写、禁止访问的用户名单）<br>使用信息（如文件的建立时间、修改时间）</p>
</blockquote>
<p>由于目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该目录下的文件，这些记录项也正是FCB。<br><strong>FCB实现了文件名和文件之间的映射，使用户可以实现“按名存取”</strong><br>以及以下四种操作：<br>| 操作     | 具体内容                                                   |<br>| ——– | ———————————————————- |<br>| 搜索     | 当用户使用一个文件时，系统要根据文件名搜索目录             |<br>| 创建文件 | 创建一个文件时，需要在其所属的目录中增加一个目录项         |<br>| 删除文件 | 当删除一个文件时，需要在目录中删除相应的目录项             |<br>| 显示目录 | 用户可以请求显示目录的内容，如显示该目录中的所有文件及属性 |</p>
<hr>
<p><strong>单级目录结构</strong></p>
<blockquote>
<p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项</p>
</blockquote>
<p>单级目录实现了“按名存取”，但是不允许文件重名<br>所以建立一个新的文件时，要先优先查看有无重名文件。</p>
<hr>
<p><strong>两级目录结构</strong></p>
<blockquote>
<p>早期的多用户操作系统，采用两级目录结构。分为<strong>主文件目录</strong>（MFD）和<strong>用户文件目录</strong>（UFD）</p>
</blockquote>
<p>其实就是允许建文件夹了（但是不能在文件夹建文件夹）</p>
<hr>
<p><strong>多级目录结构</strong></p>
<blockquote>
<p>也叫<strong>树型目录结构</strong></p>
</blockquote>
<p>也就是现在大家常见的这种，文件夹可以进行套娃<br>每访问一层，都要进行一次读磁盘的I/O操作</p>
<p>从这里开始引入<strong>绝对路径</strong>和<strong>相对路劲</strong>的概念，这个大家dddd，不再赘述</p>
<hr>
<p><strong>无环图目录结构</strong></p>
<blockquote>
<p>在树形目录结构的基础上，增加了一些指向同一节点的有向边，方便多个文件夹之间共享文件</p>
</blockquote>
<p>其实就是，文件夹A里面的文件，在文件夹B里面创建了个快捷方式，所以B可以访问到A的文件</p>
<hr>
<h3 id="非空闲磁盘块管理（文件的物理结构）"><a href="#非空闲磁盘块管理（文件的物理结构）" class="headerlink" title="非空闲磁盘块管理（文件的物理结构）"></a>非空闲磁盘块管理（文件的物理结构）</h3><p>讨论这点的目的是为了更好地对磁盘块进行管理，具体内容和内存分页很像</p>
<p>这里有一个前置概念是<strong>磁盘块</strong>，也就是类似内存分页，即<strong>外存的内存分配单元，其大小与一个页面等大</strong></p>
<p><strong>文件的物理结构 ，也叫文件的分配方式，即文件数据应该怎样存放在外存中</strong>，这里讨论三种方式：<br>1.连续分配<br>2.链接分配：又有隐式链接和显式链接两种形式<br>3.索引分配</p>
<hr>
<p><strong>1.连续分配</strong></p>
<blockquote>
<p>连续分配方式要求每个文件在磁盘上占有一组连续的块</p>
</blockquote>
<p>这里提前介绍一下，读取磁盘块的时候，要移动磁头。<strong>访问的两个磁盘块相隔越远，移动磁头所需时间就越长</strong></p>
<table>
<thead>
<tr>
<th>优缺点</th>
<th>具体内容</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>连续分配的文件在<strong>顺序读写</strong>时速度是最快的</td>
</tr>
<tr>
<td>缺点</td>
<td>1.在对文件进行拓展时，可能因为当前位置连续的空间不足而发生整体的迁移，最坏的情况是没有足够的连续空间从而无法进行拓展<br> 2.容易产生难以利用的磁盘碎片</td>
</tr>
</tbody></table>
<hr>
<p><strong>链接分配</strong></p>
<blockquote>
<p>采用离散匹配的方式，可以为文件分配离散的磁盘块（FCB增加两个字段：起始块号和结束块号，然后串起来）<br>分为<strong>隐式链接</strong>和<strong>显示链接</strong>两种形式<br>隐式指的是（静态链表），使用指针链接<br>显示指的是（邻接表），建立一张文件分配表（FAT）记录所有前驱后继关系</p>
</blockquote>
<p>隐式链接<br>| 优缺点 | 具体内容                                 |<br>| —— | —————————————- |<br>| 优点   | 空间利用率高                             |<br>| 缺点   | 1.只能顺序访问<br>2.指针会占用一定的空间 |</p>
<p>显式链接<br>| 优缺点 | 具体内容                                                     |<br>| —— | ———————————————————— |<br>| 优点   | 1.空间利用率高<br>2.文件拓展方便<br>3.支持随机访问，并且.地址转换时不需要访问磁盘，速度会快很多<br> |<br>| 缺点   | 1.文件分配表需要占用一定的空间                               |</p>
<hr>
<p><strong>3.索引分配</strong></p>
<blockquote>
<p>类似页表地，文件离散分配在各个磁盘块中，系统会为每个文件建立一张索引表，其中记录了文件的各个逻辑块对应的物理块。<br>索引表存放的磁盘块称为索引块，文件数据存放的磁盘块称为数据块。</p>
</blockquote>
<p><strong>和显示链接的区别在哪？</strong><br>显示链接是把所有链接关系都放到了一起集中存储（只有一张FAT）<br>索引分配中，每个文件的索引表也是离散存储在各个磁盘块中的（有多张表）<br>这样带来的优势就是，更灵活，也就引申出了以下三种索引分配方案：<br>1.链接方案<br>2.多层索引<br>3.混合索引<br>（暂不细究）</p>
<hr>
<h3 id="空闲磁盘块管理（文件存储空间）"><a href="#空闲磁盘块管理（文件存储空间）" class="headerlink" title="空闲磁盘块管理（文件存储空间）"></a>空闲磁盘块管理（文件存储空间）</h3><p><strong>文件卷、存储空间的划分与初始化</strong></p>
<blockquote>
<p>安装windows操作系统的时候，一定经历过磁盘分区（C、D、E盘等等），这些盘就是文件卷<br>（有的系统支持超大型文件，可以由多个物理磁盘合并为一个文件卷）<br><strong>初始化</strong>是将各个文件卷划分为<strong>目录区</strong>和<strong>文件区</strong></p>
</blockquote>
<blockquote>
<p>目录区主要存放文件目录信息（FCB）和用于磁盘管理的信息<br>文件区用于存储各种普通文件</p>
</blockquote>
<hr>
<p><strong>空闲空间分配方式</strong><br><strong>1.空闲表法</strong></p>
<blockquote>
<p>建议一张表，包含首个空闲盘块号 和 空闲盘块数 两个信息<br>同样可以采用首次适应、最佳适应、最坏适应等算法来解决这个问题</p>
</blockquote>
<p><strong>2.空闲链表法</strong></p>
<blockquote>
<p>分为两种：<br>1.空闲盘块链<br><img src="https://img-blog.csdnimg.cn/046c1b20f42d4ec0907cfb429c2c50bc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_文件_空闲盘块链"><br>2.空闲盘区链<br><img src="https://img-blog.csdnimg.cn/5906fd2cf9904e589ef5c7716cf37f9c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_文件_空闲盘区链"></p>
</blockquote>
<p><strong>3.成组链接法</strong></p>
<blockquote>
<p>空闲表法和空闲链表法可能不适用于大型文件系统，因为空闲表和空闲链表可能过大<br>而成组链接法实在目录区中专门用一个磁盘块作为“<strong>超级块</strong>”，系统启动时，将超级块读入内存并保证内外存中超级块数据一致<br><img src="https://img-blog.csdnimg.cn/453d304e67474a6c840a5de424308206.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_文件_成组链接法"></p>
</blockquote>
<h3 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>系统调用（接口）</th>
</tr>
</thead>
<tbody><tr>
<td>创建文件</td>
<td>create</td>
</tr>
<tr>
<td>删除文件</td>
<td>delete</td>
</tr>
<tr>
<td>读文件</td>
<td>read</td>
</tr>
<tr>
<td>写文件</td>
<td>write</td>
</tr>
<tr>
<td>打开文件</td>
<td>open</td>
</tr>
<tr>
<td>关闭文件</td>
<td>close</td>
</tr>
</tbody></table>
<h3 id="文件共享和保护（暂不细究）"><a href="#文件共享和保护（暂不细究）" class="headerlink" title="文件共享和保护（暂不细究）"></a>文件共享和保护（暂不细究）</h3><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h3><p><img src="https://img-blog.csdnimg.cn/a4ca03a865444899ae941c48eaf1b85b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_磁盘结构"><br><img src="https://img-blog.csdnimg.cn/9bf7417d2f2049e1973d8518336a0c57.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_磁盘的磁道"><br><img src="https://img-blog.csdnimg.cn/2848f22bf8f847138125958d9bfebf1f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_磁盘的扇区"><br><img src="https://img-blog.csdnimg.cn/1f83c409f0f64834aaca3e908e477924.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_磁盘_磁臂_盘面_柱面"></p>
<table>
<thead>
<tr>
<th>结构名称</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>磁盘</td>
<td>磁盘表面由一些磁性物质组成，可以记录二进制数据</td>
</tr>
<tr>
<td>磁道</td>
<td>磁盘的盘面被划分为多圈，每一个圈都是一个磁道</td>
</tr>
<tr>
<td>扇区</td>
<td>磁盘被划分为多个扇形区域，这些区域就是扇区，<strong>每个扇区都是一个磁盘块</strong>，<strong>各个扇区存放的数据量相同</strong>，所以每个扇区最内的磁道数据密度最大</td>
</tr>
<tr>
<td>盘面</td>
<td>盘片<strong>记录了数据的表面</strong>，有的可能是两面都能记录</td>
</tr>
<tr>
<td>柱面</td>
<td>所有盘面中相对位置相同的磁道组成柱面</td>
</tr>
<tr>
<td>磁头</td>
<td>用于读取数据的结构，磁头可以移动的磁盘是<strong>活动头磁盘</strong>，不可移动的是<strong>固定头磁盘</strong>（固定头磁盘是为每个磁道设置一个磁头，贵）</td>
</tr>
<tr>
<td>磁臂</td>
<td>固定磁头的结构，一般有多个磁头</td>
</tr>
</tbody></table>
<p><strong>磁盘中读写数据</strong><br>读写数据首先要把<strong>磁头移动</strong>到指定扇区的指定磁道，之后磁盘转动起来，让目标扇区从磁头下面划过，才能进行数据的读写</p>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>由于固定头磁盘很贵，通常还是采用活动头磁盘，所以如何高效地移动、读写数据就成了问题，这就需要我们使用算法去解决这个问题</p>
<p>先分析问题所在：</p>
<blockquote>
<p>消耗时间 = 寻找时间 + 延迟时间 + 传输时间<br><strong>寻找时间（寻道时间）</strong><br>启动磁臂 和 移动磁头到指定磁道的时间<br><strong>延迟时间</strong><br>由硬件决定，无法通过算法优化<br>旋转磁盘，使磁头进入目标扇区所要的时间<br><strong>传输时间</strong><br>由硬件决定，无法通过算法优化<br>读写数据所用的时间</p>
</blockquote>
<p>所以我们通过算法能够优化的就是<strong>寻道时间</strong></p>
<p><strong>调度算法</strong><br><strong>1.先来先服务算法FCFS</strong></p>
<blockquote>
<p>按照请求的顺序先后执行</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/1f5a736d9ee9470c8358831a8eaed6f3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="先来先服务算法"></p>
<p><strong>2.最短寻找时间优先算法SSTF</strong></p>
<blockquote>
<p>相当于是优先找最近的<br><img src="https://img-blog.csdnimg.cn/b576d35133f44f59bf3029a911cba694.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="最短寻找时间优先算法"><br><strong>可能产生饥饿</strong></p>
</blockquote>
<p><strong>3.扫描算法SCAN</strong></p>
<blockquote>
<p>也叫<strong>电梯算法</strong>,只有磁头移动到最外侧磁道的时候才能往内侧移动，反之同理<br><img src="https://img-blog.csdnimg.cn/7a0ef86e0252452a86b316aa4abe94ed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这就<strong>避免了死锁</strong>，<br>但是每次都要移动到头，这是没有必要的，<br>而且它对各个位置磁道的响应频率不平均</p>
</blockquote>
<p>所以对于SCAN算法来说，还存在以下几种改进版本</p>
<p><strong>4.LOOK调度算法</strong></p>
<blockquote>
<p>是改进的扫描算法，<br>即如果在磁头移动的方向上已经没有新的请求了，那么就允许立刻改变方向<br><img src="https://img-blog.csdnimg.cn/90a0ed9e464741fda7364ffca065334f.png" alt="LOOK调度算法"></p>
</blockquote>
<p><strong>5.循环扫描算法C-SCAN</strong></p>
<blockquote>
<p>再次改进，规定磁头移动到头之后立刻返回初始位置而不处理之间的任何任务<br><img src="https://img-blog.csdnimg.cn/8a8ef6cdcdce4654a3b8afb476e30bb7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="循环扫描算法"><br><strong>6.C-LOOK调度算法</strong><br>再次改进，就是C-SCAN依旧没有必要移动到头，如果移动方向上已经没有任务要处理，那么就立刻返回初始位置<br><img src="https://img-blog.csdnimg.cn/1e73acb19e684e83a064cc03029985cb.png" alt="C-LOOK调度算法"></p>
</blockquote>
<p>需要注意一个事情，大部分时候，题目如果没有特别说明，那么其所指的SCAN就是LOOK，C-SCAN就是C-LOOK</p>
<h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h3><p><strong>磁盘初始化</strong></p>
<blockquote>
<p>磁盘刚被制造出来的时候，只有磁道：<br>1.需要进行<strong>低级格式化（物理格式化）</strong>，即划分扇区，而一个扇区又可以分为头、数据区域、尾三个部分（计组阿巴阿巴）<br>2.<strong>磁盘分区</strong>，每个分区由若干柱面组成（即C、D、E盘）<br>3.进行<strong>逻辑格式化</strong>，创建文件系统的根目录、初始化存储空间管理所用的数据结构</p>
</blockquote>
<p><strong>引导块</strong></p>
<blockquote>
<p>计算机刚开机的时候，需要初始化一系列东西，而这初始化是通过执行<strong>初始化程序（自举程序）</strong> 完成的<br>ROM中存在一个自举装入程序，完整的自举程序会放在磁盘的引导块（启动块）内，引导块又位于磁盘的固定位置<br>拥有引导块的磁盘被称为<strong>系统磁盘（引导磁盘）</strong> （比如C盘）</p>
</blockquote>
<p><strong>坏块及其管理</strong></p>
<blockquote>
<p>坏块就是坏掉的部分，可以在逻辑格式化的时候检查出来，<br>并且会通过一系列操作来<strong>忽略或者启用备用扇区来替换</strong>它，这些操作对于操作系统是透明的</p>
</blockquote>
<h2 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h2><p><del>这部分算是计组的内容，暂时不写了，很多科目要考试了，得预习了~~~<br> （几天后）<br> ~~做了套真题回来发现考的还不少，回来补上…..</del> </p>
<p>其实这部分内容相对于前面的内容来说已经算是简单的了<br> <strong>基本概念</strong></p>
<blockquote>
<p><strong>什么是I/O设备</strong><br>input/output设备，输入输出设备，能讲数据输入计算机的设备，比如鼠标键盘等是输入设备，显示屏等是输出设备，而U盘、触摸屏等则是可以是输入设备也可以是输出设备<br><strong>系统管理I/O设备</strong><br>一些系统会将接入计算机的输入输出设备抽象为一种特殊的文件，用户可以通过相关的文件操作来对实现对输入输出设备进行操作<br> 比如我们这个数位板，就可以通过其相关的软件来管理<br> （为了避免打广告嫌疑，这里图只放一半）<img src="https://img-blog.csdnimg.cn/72a4dc3a19ef41baa8e078f47e7a61f4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统管理输入设备的体现"></p>
</blockquote>
<h3 id="I-O设备的几种分类"><a href="#I-O设备的几种分类" class="headerlink" title="I/O设备的几种分类"></a>I/O设备的几种分类</h3><p><strong>按使用特性分类</strong><br>虽然都是输入输出设备，但是也会有不同的特性<br>| 分类           | 特点                           | 举例                 |<br>| ————– | —————————— | ——————– |<br>| 人机交互类外设 | 数据传输速度慢，用于人机交互   | 鼠标、键盘、数位板等 |<br>| 存储设备       | 数据传输速度快，用于存储数据   | 移动硬盘、光盘等     |<br>| 网络通信设备   | 数据传输速度介中，用于网络通信 | “猫”，路由器等       |</p>
<p><strong>按传输设备分类</strong><br>| 分类     | 大致速度范围         | 举例         |<br>| ——– | ——————– | ———— |<br>| 低速设备 | 每秒几个到几百个字节 | 鼠标、键盘等 |<br>| 中速设备 | 每秒几千上万个字节   | 激光打印机等 |<br>| 高速设备 | 每秒几千只几千兆字节 | 磁盘等       |</p>
<p><strong>按信息交换的单位分类</strong><br>| 分类     | 单位                                                         | 举例       |<br>| ——– | ———————————————————— | ———- |<br>| 块设备   | “块”，即之前的学习中常常提到的那个概念，传输速率高。可以寻址，即可以对块设备进行随机读写 | 磁盘等     |<br>| 字符设备 | “字符”，较慢。不可寻址，输入输出时常采用<strong>中断驱动</strong>的方式   | 鼠标键盘等 |</p>
<h3 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I/O控制器"></a>I/O控制器</h3><p><strong>概念</strong></p>
<blockquote>
<p>I/O设备由机械部件和<strong>电子部件</strong>（I/O控制器，也称设备控制器）组成，<br>机械部件是鼠标、键盘、硬盘、显示器等我们看见的结构<br>电子部件一般是一块<strong>电路板</strong>，它的存在相当于操作系统 和 机械部件 间建立联系的桥梁</p>
</blockquote>
<p><strong>结构组成</strong><br>涉及部分计组知识，此处大概了解即可<br><img src="https://img-blog.csdnimg.cn/7155bf1b276c4588b93d6b7415fd1c3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="I/O控制器组成结构"></p>
<p><strong>功能</strong></p>
<blockquote>
<p>四个主要功能：<br><strong>1.接受和识别CPU发出的命令</strong><br>I/O控制器内包含<strong>控制寄存器</strong>，存放CPU发来的命令和参数<br>2.<strong>向CPU报告设备的状态</strong><br>I/O控制器内包含<strong>状态寄存器</strong>，记录I/O设备的状态，比如1代表空闲，0代表忙碌<br>3.<strong>数据交换</strong><br>I/O控制器内包含<strong>数据寄存器</strong>，用于暂存CPU发来的数据<br>4.<strong>地址识别</strong><br>类似于内存地址，为了区分各个寄存器，I/O控制器也给各个寄存器设置了一个“地址”<br>tips：地址编码方式有两种，一种是<strong>内存映射I/O</strong>，另一种是<strong>寄存器独立编址</strong>：<br>前者是，寄存器地址是接着内存地址递增；<br>后者是，各个寄存器采用独立的地址。<br><img src="https://img-blog.csdnimg.cn/b2f8274bb7154ab0b00d569a9aa81159.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="I/O控制器的两种编址方式"></p>
</blockquote>
<h3 id="四种I-O控制方式"><a href="#四种I-O控制方式" class="headerlink" title="四种I/O控制方式"></a>四种I/O控制方式</h3><p>究竟用什么样的方式来控制I/O设备的数据读写</p>
<p> <strong>1程序直接控制方式</strong><img src="https://img-blog.csdnimg.cn/f553e513a899475a90facefc2b76a2b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="程序直接控制方式"></p>
<table>
<thead>
<tr>
<th>行为</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>完成一次读写操作的流程</td>
<td>轮询</td>
</tr>
<tr>
<td>CPU干预频率</td>
<td>I/O操作之前、之后需要CPU介入，并且等待I/O完成的过程中CPU会不断轮询状态寄存器</td>
</tr>
<tr>
<td>数据传输</td>
<td>低速，每次传输一个字符，读操作是从I/O设备-&gt;CPU-&gt;内存；写操作是则是读操作反过来</td>
</tr>
<tr>
<td>优点</td>
<td>实现简单，在读写指令之后加上一些循环检测指令即可（因此才叫程序直接控制）</td>
</tr>
<tr>
<td>缺点</td>
<td>CPU和I/O只能串行工作，CPU一直轮询长期忙等，利用率低</td>
</tr>
</tbody></table>
<p> <strong>2.中断驱动方式</strong><br> <img src="https://img-blog.csdnimg.cn/f2ee849ac24445e5ac3d9037bd20091b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_15,color_FFFFFF,t_70,g_se,x_16" alt="中断驱动方式"><br>| 行为                   | 内容                                                         |<br>| ———————- | ———————————————————— |<br>| 完成一次读写操作的流程 | 中断                                                         |<br>| CPU干预频率            | I/O操作之前、之后需要CPU介入，但是且等待I/O完成的过程中<strong>CPU可以处理别的进程</strong> |<br>| 数据传输               | 低速，每次传输一个字符，读操作是从I/O设备-&gt;CPU-&gt;内存；写操作是则是读操作反过来 |<br>| 优点                   | 通过<strong>中断信号</strong>主动报告进程完成，而不用CPU不停轮询，此时CPU则可以和I/O设备并行工作，CPU利用率明显提升 |<br>| 缺点                   | 每个字在设备与内存之间的传输，都要经过CPU，频繁的中断会消耗CPU较多时间 |</p>
<p> <strong>3.DMA方式</strong></p>
<blockquote>
<p>即直接存储器存储，主要用于块设备<br>主要做了以下几个改进：<br>1.用“块”作为数据传送的单位，而不再是字，可以读写连续的多个块<br>2.数据的流向是从设备直接放入内存，或者从内存直接到设备。而不再需要CPU作为中介。<br>3.仅在传送一个或多个数据块的开始和结束时，才需要CPU干预 </p>
</blockquote>
<p>硬件结构大概如下，了解即可</p>
<p><img src="https://img-blog.csdnimg.cn/7de7e500971146dc99a6f37f78736ecb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="DMA方式"><br><img src="https://img-blog.csdnimg.cn/33ebc6915c6f4499ab803a190aa95c43.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="DMA方式"></p>
<table>
<thead>
<tr>
<th>行为</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>CPU干预频率</td>
<td>I/O操作之前、之后需要CPU介入</td>
</tr>
<tr>
<td>数据传输</td>
<td>高速，每次传输<strong>一个或连续的多个块</strong>，读操作是从I/O设备-&gt;内存；写操作是则是读操作反过来</td>
</tr>
<tr>
<td>优点</td>
<td>CPU介入频率降低，数据传输不再需要先经过CPU</td>
</tr>
<tr>
<td>缺点</td>
<td>读取离散的数据时，开销较大</td>
</tr>
</tbody></table>
<p> <strong>4.通道控制方式</strong></p>
<blockquote>
<p>通道是一种硬件，可以理解为低配版CPU<br><img src="https://img-blog.csdnimg.cn/8a113ddd950344fa834f54ad490e25c9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="通道控制方式"></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/b53e7cbeae9d47bf9578654d65519c5f.png" alt="通道控制方式的执行过程"></p>
<table>
<thead>
<tr>
<th>行为</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>CPU干预频率</td>
<td>极低，通道根据CPU的指令执行响应的通道程序，只有完成一组数据块的读写后才需要发出中断信号，请求CPU干预</td>
</tr>
<tr>
<td>数据传输</td>
<td>高速，每次传输<strong>一个或连续的多个块</strong>，读操作是从I/O设备-&gt;内存；写操作是则是读操作反过来</td>
</tr>
<tr>
<td>优点</td>
<td>CPU介入频率相当低，CPU、通道、I/O设备可以并行工作</td>
</tr>
<tr>
<td>缺点</td>
<td>实现复杂，需要专门的硬件设备支持</td>
</tr>
</tbody></table>
<p><strong>总结</strong><br><img src="https://img-blog.csdnimg.cn/3e134741fb1e4a8e97cfbe107329d08e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="四种控制方式的比较"></p>
<h3 id="I-O软件的结构层次"><a href="#I-O软件的结构层次" class="headerlink" title="I/O软件的结构层次"></a>I/O软件的结构层次</h3><p>如图所示<br><img src="https://img-blog.csdnimg.cn/7a6cc78b61104a8eb4c953ee356e7e50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="I/O软件的结构层次"></p>
<p><img src="https://img-blog.csdnimg.cn/ad2d8a3a2ad249bd8b939763ccb6cd6b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="库函数与系统调用"></p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p><strong>什么是缓冲区</strong><br>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可用内存作为缓冲区<br>其中，硬件成本较高，容量也较小，适用于对速度要求较高的场合（比如快表作为缓冲区）<br><strong>有什么作用</strong><br><strong>1.减少了CPU的中断频率</strong><br>CPU可以把要输出的数据快速放入缓冲区，之后就可以去做别的事情，慢速的I/O设备就可以从缓冲区里拿数据。<br>就比如两个人交换物品，没有缓冲区的话，就得一个人等另一个人来了之后才完成交接。<br>有缓冲区的话，先到的人把东西放到缓冲区里面就可以走了，后到的人自己拿就行<br>（如下图就是一个单缓冲）<img src="https://img-blog.csdnimg.cn/7a72283e0dd5472197dd7092659b96bf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="缓冲区"><br><strong>2.解决数据粒度不匹配（人机速度不匹配）</strong><br>输出进程每次只能生成一块数据，但是I/O设备每次只能输出一个字符<br><strong>3.提高了CPU和I/O设备之间的并行度</strong></p>
</blockquote>
<h3 id="几种类型的缓冲区"><a href="#几种类型的缓冲区" class="headerlink" title="几种类型的缓冲区"></a>几种类型的缓冲区</h3><p>其实在上篇的进程同步互斥章节的内容中我们已经提到过一些了<br><strong>1.单缓冲</strong></p>
<blockquote>
<p>只有一个缓冲区，如果没有特殊说明，默认其是一个内存块。</p>
</blockquote>
<table>
<thead>
<tr>
<th>状态</th>
<th>写（冲入数据）</th>
<th>读（传出数据）</th>
</tr>
</thead>
<tbody><tr>
<td>空</td>
<td>可</td>
<td>不可</td>
</tr>
<tr>
<td>非空</td>
<td>不可</td>
<td>可</td>
</tr>
</tbody></table>
<p><strong>2.双缓冲</strong></p>
<blockquote>
<p>也就是两个缓冲区，这里我们将其称为A和B<br>设置两个缓冲区的目的是，在遇到如A非空B空的情况时，读写操作可以并行执行<br>另外，在遇道两机通信时：<br><img src="https://img-blog.csdnimg.cn/7aa3106d85b3468295df4a393d8ae658.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="缓冲区在两机通信中的应用"><br>上图中的两台机器都只有单缓冲区，这意味着它们同一时间只能单向通信<br>而双缓冲就是：<br><img src="https://img-blog.csdnimg.cn/e9520ba9ad9244bb9620f32831134e0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="双缓冲区在两机通信时的优势"><br>其实，上篇提到过的<strong>管道通信</strong>中的<strong>管道就是缓冲区</strong><br>而上述两机通信的情形，就是管道通信</p>
</blockquote>
<p><strong>循环缓冲</strong></p>
<blockquote>
<p>将多个大小相等的缓冲区链接成一个循环队列<br><img src="https://img-blog.csdnimg.cn/f236aaf7b4804a5e8d8ece7b0411d26d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="循环缓冲"></p>
</blockquote>
<p><strong>缓冲池</strong><br><img src="https://img-blog.csdnimg.cn/4d35c1577c334b75972dca8484e95296.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="缓冲池"></p>
<hr>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Serio</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://coderserio.github.io/2023/02/20/os/">https://coderserio.github.io/2023/02/20/os/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Serio</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">操作系统</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC81NDg1OC8zMTMyNw==">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/02/20/pug/">
                    <div class="card-image">
                        
                        <img src="/medias/postimages/46.png" class="responsive-img" alt="Pug">
                        
                        <span class="card-title">Pug</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            以前叫做Jade啦~
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-02-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/web/" class="post-category">
                                    web
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF/">
                        <span class="chip bg-color">前端</span>
                    </a>
                    
                    <a href="/tags/%E5%90%8E%E7%AB%AF/">
                        <span class="chip bg-color">后端</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/02/20/node.js-be/">
                    <div class="card-image">
                        
                        <img src="/medias/postimages/20.webp" class="responsive-img" alt="Node.JS后端开发">
                        
                        <span class="card-title">Node.JS后端开发</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            JavaScript后端！！
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-02-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/web/" class="post-category">
                                    web
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">
                        <span class="chip bg-color">数据库</span>
                    </a>
                    
                    <a href="/tags/%E5%90%8E%E7%AB%AF/">
                        <span class="chip bg-color">后端</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>





    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('1'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="song"
                   id="1322877419"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">Serio</a>
            |&nbsp;Powered by&nbsp;<a href="#" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="#" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/CoderSerio" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2779066456@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>





    <a href="https://twitter.com/Eg4HTb5i41JUERI" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/Eg4HTb5i41JUERI" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2779066456" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2779066456" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/serio-41" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/serio-41" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/"><\/script>');
            }
        </script>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    
        <script src="//code.tidio.co/8rh2fkswsxbq8ekykk2ieakrakfltfah.js"></script>
        <script>
            $(document).ready(function () {
                setInterval(change_Tidio, 50);
                function change_Tidio() {
                    var tidio=$("#tidio-chat iframe");
                    if(tidio.css("display")=="block"&& $(window).width()>977 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"85px":"20px";
                        document.getElementById("tidio-chat-iframe").style.right="-15px";
                        document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;
                        document.getElementById("tidio-chat-iframe").style.right="-15px";
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                        document.getElementById("tidio-chat-iframe").style.zIndex="998";
                    }
                }
            });
        </script>
    

    

    <!--腾讯兔小巢-->
    
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
