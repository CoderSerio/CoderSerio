<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>KMP算法</title>
      <link href="/2022/02/22/algorithm-kmp/"/>
      <url>/2022/02/22/algorithm-kmp/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>KMP也是困扰我许久的算法了，道理感觉能懂，但是一到代码就难以理解</p><p>但是所幸我现在终于是搞懂了</p><p>记一些笔记，希望帮到未来的自己和更多学习的人</p><h2 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h2><p><strong>主串</strong><br>也叫匹配串、模式串，相当于是要进行搜索的范围</p><p><strong>子串</strong><br>主串中包含的连续的字符</p><p><strong>模板串</strong><br>需要搜索的目标，如果能够在主串中找到与自身相同的子串即为匹配成功</p><p><strong>朴素匹配算法</strong><br>也叫幼稚匹配、简单匹配算法，就是暴力</p><h2 id="KMP思路"><a href="#KMP思路" class="headerlink" title="KMP思路"></a>KMP思路</h2><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168427385788add0a9e4dfd35857cd02bd295f1049f2f2f877d4e/0.png" alt="主串和模板串"></p><p>比如我们要在如图所示的主串中找到该模板串，</p><p>请先不要以计算机的思维去想如何实现，我们<strong>先以人类的思维入手</strong>——</p><p>我们总是会先找以g开头的部分，而不是一个一个去比对：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168427385788add0a9e4da98fea21485ec81d455393c4335f5823/0.png" alt="人类思维匹配示意"></p><p>如图，我们大概能在进行第三次匹配时成功</p><p>总结一下就是：</p><blockquote><p>顺序遍历主串，不回溯</p><p>移动模板串并<strong>跳过</strong>不必要的回溯</p><p>（这里的移动实际上就是遍历，移动只是一个利于结合图文进一步理解的说法——毕竟一个字符串能怎么动，还能在内存里面运动起来不成？）</p></blockquote><h2 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h2><p>既然要跳过不必要的回溯，那么该往哪里跳就成了我们要考虑的问题，先来看下面这个例子</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168427385788add0a9e4d0b7cc71b88049c02ddceb9c91806c67c/0.png" alt="KMP思路说明"></p><p>next数组是要记录“平移的距离”，其实也就是记录出现不匹配时，p指针应该回溯到的位置</p><p>那么该如何去求这个数组呢？</p><p>其实就是要记录（结合图片把下面这句话好好捋一捋）</p><blockquote><p> 出现不匹配的元素<strong>前面</strong>的 字符串中的 相同的<strong>最长</strong>的 <strong>前缀</strong> 和 <strong>后缀</strong> </p></blockquote><p>如果理解了这句话，那么也不难发现求next数组<strong>只需要观察模板串</strong></p><p><strong>举个例子</strong></p><p>这里我们习惯是下标从1开始，这样会有很多好处——我们后面再提</p><p>而且此处next[i]代表，<strong>当第i+1个元素不匹配时指针p应该回溯的位置</strong>——所以下标为0是有意义的</p><table><thead><tr><th>元素</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th></tr></thead><tbody><tr><td><strong>下标 i</strong></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td><strong>next[i]</strong></td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><p>手动求取的过程如下：</p><p>注意前缀和后缀是串的真子集</p><table><thead><tr><th>下标i</th><th>讨论的串</th><th>最长相同前后缀</th><th>结果</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>不讨论</td><td>i=1时，若回溯，则一定是到0</td></tr><tr><td>2</td><td>ab</td><td>无</td><td>不匹配则只能重新开始，回溯到0</td></tr><tr><td>3</td><td>abc</td><td>无</td><td>同上</td></tr><tr><td>4</td><td>abca</td><td>a</td><td>回溯到第一个a，也就是i = 1这里</td></tr><tr><td>5</td><td>abcab</td><td>ab</td><td>回溯到第第一个b，也就是i = 2这里</td></tr></tbody></table><p>其实对于i=5的情况来说已经不用讨论了，因为到了这一步已经是完全匹配上了，但是我们还是把它记录下来</p><p><strong>代码实现</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int N = 1e5 + 10;int next[N];char t[N];// 模板串// 数组下标均从1开始，但根据上文可知next[1]是默认为0的不用求，所以i从2开始// 而且从2开始相较于从1开始会省去不少麻烦// 而j从0开始是为了一种试探性的比较for (int i = 2, j = 0; i &lt;= n; i ++) {    // j + 1是试探性地比较，不匹配则递归回溯直到 匹配或者j为0while (j &amp;&amp; t[i] != t[j + 1])     {        j = next[j];    }    // 跳出while的原因有两种，如果是因为匹配而跳出    // 那么就让试探性的j + 1真正地进一步    if(t[i] == t[j + 1])     {        j ++;    }    // 可以自己推导一下，在经历上述步骤后，    // j已经代表了此时讨论的串中最长相同前后缀的长度    next[i] = j;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="开始匹配"><a href="#开始匹配" class="headerlink" title="开始匹配"></a>开始匹配</h2><p>在求完next数组后</p><p>就要开始进行匹配了，匹配的思路 和 求next异曲同工</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// i是主串的下标，j+1是模板串下标，j仍可以用来试探next数组for (int i = 1, j = 0; i &lt;= m; i ++) {    // S是主串，P是模板串    while (j &amp;&amp; S[i] != P[j + 1]) {        j = next[j];    }    if (S[i] == P[j + 1]) {        j ++;    }    if (j == n) {        cout &lt;&lt; i - n &lt;&lt; " ";        // 我们如果要找出主串中所有的模板串，那么就进行下一步，回溯        j = next[j];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;const int M = 1e6 + 10;int n, m;char P[N], S[M];int ne[N];int main() {    cin &gt;&gt; n &gt;&gt; P + 1 &gt;&gt; m &gt;&gt; S + 1;    for (int i = 2, j = 0; i &lt;= n; i ++) {        while (j &amp;&amp; P[i] != P[j + 1]) {            j = next[j];        }        if (P[i] == P[j + 1]) {            j ++;        }        next[i] = j;    }    for (int i = 1, j = 0; i &lt;= m; i ++) {        while (j &amp;&amp; S[i] != P[j + 1]) {            j = next[j];        }        if (S[i] == P[j + 1]) {            j ++;        }        if (j == n) {            cout &lt;&lt; i - n &lt;&lt; " ";            j = next[j];        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022/02/04/git/"/>
      <url>/2022/02/04/git/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><p>今天是2021/9/12，计划和同学一起开发微信小程序了，看了下语法大概就是html和css以及Vue的魔改，这个问题应该不大。重点是我们觉得这也是第一个正正经经的可以算得上项目的东西了，所以还是决定好好打磨它，于是乎这个时候就想到了版本管理的问题，自然而然就得开始学习Git了</p><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/02/04</strong><br>现在是1:09 AM，计划在今天下午和逸飞大佬研究git技术，忽然想起自己写过一篇git的笔记，就打算放到自己的个人博客上了</p></blockquote><h2 id="关于版本控制的一些话"><a href="#关于版本控制的一些话" class="headerlink" title="关于版本控制的一些话"></a>关于版本控制的一些话</h2><h3 id="为什么要有版本控制"><a href="#为什么要有版本控制" class="headerlink" title="为什么要有版本控制"></a>为什么要有版本控制</h3><p>比如今天觉得第一版不好，就出了第二版，但是第一版怎么办呢，总不能删了吧——万一哪天又觉得第一版好怎么办？<br>存在本地又不好大家合作开发，所以我们需要一个中间的平台来储存众多版本</p><h3 id="版本控制的发展史"><a href="#版本控制的发展史" class="headerlink" title="版本控制的发展史"></a>版本控制的发展史</h3><p><strong>1.本地版本控制</strong><br>在本地记录保存每次更新，适合个人开发用</p><p>很方便，但是也很明显，很low</p><p><strong>2.集中版本控制——SVN</strong><br>所有版本都放到一个服务器，这样一来就方便协同开发了<br>（缺点是不联网就很难办，另外，要是服务器炸了就可以重开了）</p><p><strong>3.分布式版本控制——Git</strong><br>每个人都拥有完整的代码，所有的版本信息都会同步到每一个开发者，<br>断网的时候可以本地提交，有网络时会自动同步，这样一来只要有一个还保留着代码，就能很快恢复数据<br>（缺点是，安全隐患大，容易出内鬼；另外这同一份文件多次存储，加大了空间消耗）<br>（欸，等等，这难道是区块链？？w(ﾟДﾟ)w，算了，先学会用再说</p><h2 id="Git下载与安装"><a href="#Git下载与安装" class="headerlink" title="Git下载与安装"></a>Git下载与安装</h2><p>官网下载比较慢的话，<br>那么就试试镜像下载吧，相信用过npm的应该很熟悉了：<a href="https://npm.taobao.org/mirrors/git-for-windows/">git镜像下载</a><br>进去之后选一个稍微旧一点的版本下载<br><img src="https://img-blog.csdnimg.cn/ea98c417dc774e0aa0182ec04213e8b8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>64位就找64位咯<br><img src="https://img-blog.csdnimg.cn/9780be46e52142e190331cd947851598.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/3a98d56150a848e08e21911e608c13d5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/88dde751837f46fe8d8ad82485a5155d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里要注意，选择默认的文本编辑器<br><img src="https://img-blog.csdnimg.cn/0b625bbfb5714d0590bf1fe12903519b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>我选的visual studio code（虽然喜欢idea<br><img src="https://img-blog.csdnimg.cn/5a841580fe2a48f3866f3472a7860a73.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>然后管他三七二十一地，直接莽Next就完事，最后finish，安装完毕<br>此时鼠标右键可以看到Git的相关内容，<br>这里也可以看到<br><img src="https://img-blog.csdnimg.cn/3fc1663611d546cd8f147abcfc561c18.png" alt="在这里插入图片描述"><br>它们分别是：<br>Git Bash:Unix与Linux风格的命令行<br>Git CMD:Windows风格<br>Git GUI :图形界面版本Git，但是初学者嘛还是先学会用命令行比价好，所以暂时不推荐使用</p><p>为了以后更好地学习Linux，我们这里采用Git Bash</p><h2 id="基本Linux命令"><a href="#基本Linux命令" class="headerlink" title="基本Linux命令"></a>基本Linux命令</h2><p><img src="https://img-blog.csdnimg.cn/2546d8c8986943e68619b6b1c97d5d47.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>点开就能看到类似这样地画面<br><img src="https://img-blog.csdnimg.cn/21b4fcd991ca462881441e0e58871e63.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>好了，这下得开始学Linux命令才能继续玩下去了<br>大概就是这样，这里看看就像<br><img src="https://img-blog.csdnimg.cn/f5b8be004d014757a92b46d336a86841.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里就提一句：<br><strong>(不要尝试，不要尝试，不要尝试！</strong><br><strong>这是删库，难以跑路，后果自负)</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> -rf/<span class="token comment"># 要是你计算机文件全没了别怪我没提醒你别用这个指令</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>只是想说一下啊，rm是remove的简写，-r是递归，f是强制，/是根目录</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p> <strong>git config -l</strong><br>就是查看配置列表啦<br><img src="https://img-blog.csdnimg.cn/1975bd2990a6482682d7f09528ad9503.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>还可以细一点，使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --system --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看系统配置<br><img src="https://img-blog.csdnimg.cn/07ba27c335aa43c69f9b41ee7d497037.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>同样的可以查看用户配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config --global --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/4e9d54d0d6f1458d9dd0bb4b78959a99.png" alt="在这里插入图片描述"><br>现在我们来更改一下配置<br>其实如果不执行这一步配置操作的话，那么是不能提交项目的</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"Serio"</span>$ <span class="token function">git</span> config --global user.email <span class="token string">"2779066456@qq.com"</span>$ <span class="token comment">#第一个是配置名称，第二个是配置邮箱</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后再使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config --global --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看一下配置是否成功<br><img src="https://img-blog.csdnimg.cn/0e227ed71eaf40e3852e6b431cc99d4e.png" alt="在这里插入图片描述">系统配置会保存在Git安装目录下的etc文件中的config文件里面<br>用户配置会保存在C盘用户文件下的gitconfig中</p><p>在说下一个命令以前，先得提一下</p><h3 id="Git工作原理"><a href="#Git工作原理" class="headerlink" title="Git工作原理"></a>Git工作原理</h3><p>Git有三个工作区域：</p><blockquote><p>1.工作目录<br>2.暂存区<br>3.资源库<br>4.远程it仓库</p></blockquote><p> <img src="https://img-blog.csdnimg.cn/e9625b566e2d47a7a9ec01bb05947f44.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="git的三个工作区域"></p><blockquote><p>1.<strong>workspace/working directory</strong><br>工作区，就是平时存放代码的地方<br>2.<strong>index/stage</strong><br>暂存区，用于临时存储，是一个文件，存储将要提交到文件列表的信息<br>3.<strong>repository/history</strong><br>仓库区（本地仓库)，能安全存储数据的位置，存储了所有版本的数据。其中的HEAD指向最新版本<br>4.<strong>remote</strong><br>远程仓库，托管代码的服务器</p></blockquote><p><strong>git的工作流程是</strong><br>1.在工作目录中添加修改文件<br>2.将需要进行版本管理的文件放入暂存区域<br>3.将暂存区域的文件提交到git仓库</p><h3 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h3><p>有两种方式：<br>1.本地新建仓库<br>2.克隆远程仓库<br>大概涉及到以下六个命令<br>（没错，图片依旧来自狂神说）<br><img src="https://img-blog.csdnimg.cn/e1d0fa7b46294284b4ae1adc70be557a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>本地搭建</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/0f4a1719dfb74740ba38a589744a6e6f.png" alt="初始化"><br>注意这是个隐藏文件，所以要勾选显示隐藏文件才看得见<br><img src="https://img-blog.csdnimg.cn/8b0497c92e14465ea46b83dccdc108df.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>远程克隆</strong><br>首先我们先建立一个远程仓库<br>（由于hub比较卡顿，所以我们这里用ee）<br><img src="https://img-blog.csdnimg.cn/fff157437e3f4ecbbe756a81d992a253.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone <span class="token string">"https://gitee.com/Serio/test.git"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/7903edf67f654139a3e0f8a69e9220a1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后同样的我们就得到了这个库</p><p>这个时候可能就有人要问了，这都下载到c盘去了，要怎么下到指定路径呢？</p><p>这还是先得用cd等命令<br><img src="https://img-blog.csdnimg.cn/85d61f59e42d43f98fe089ea09969d34.png" alt="在这里插入图片描述"><br>比如这样就进入了e盘，然后建立仓库之类的就会在e盘下进行</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>文件有四种状态：<br>1.<strong>Untacked</strong>：未跟踪，这个文件在项目中，但是没有传到git库里面，不参与版本库，<br>在git add命令执行后改变为<strong>Staged</strong>暂存</p><hr><p>2.<strong>Unmondify</strong>：文件已经传入库，未修改，即版本库中文件快照内容与文件夹中内容完全一致，<br>此后如果执行git rm命令，那么就会被移除<br>如果被修改，那么状态变为<strong>Modified</strong></p><hr><p>3.<strong>Modified</strong>：修改过，<br>在执行git checkout命令后撤销修改内容，返回<strong>Unmodify</strong>状态<br>也可以在执行git add后变为<strong>Staged</strong></p><hr><p>4.<strong>Staged</strong>：暂存，<br>执行git commit后将提交到库中，此时库中文件又和本地文件一致了，文件又变为<strong>Unmodify</strong><br>执行git reset HEAD filename那么就会取消暂存，回退到<strong>Modified</strong>状态</p><p><strong>实际操作示例</strong><br>首先我们新建一个文本<br><img src="https://img-blog.csdnimg.cn/963090cbb7e849e29b3095a35274bf1e.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> status <span class="token string">"LEC牛逼"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/93fcbb191fce4d2394e964820b6b0a73.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="查看文件状态"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> <span class="token string">"LEC牛逼.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/a539a5679a8c4b2c95f13d6bb15d0027.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="添加"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"这是第一次提交测试"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/828adeb39f4b43cca0d38386fbd7396d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>当然，如果我们不想让每一个文件都上传，那么可以定义一个扩展名为gitignore的文件<br><img src="https://img-blog.csdnimg.cn/6d5232c581324790ae5154754ce2811e.png" alt="在这里插入图片描述"><br>配置内容依次解释为，忽略根目录下的TODO文件，忽略所有txt文件，但是”LEC牛逼.txt”除外</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>我们先得有一个ssh公钥</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-t表示采用加密，rsa是加密的方式<br>一路enter就好<br><img src="https://img-blog.csdnimg.cn/3bd51771f7e04261b167c8889519f49b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后去这里找找生成的公钥<br><img src="https://img-blog.csdnimg.cn/239106ea238f4cb49785249bcff2a4e4.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8370a33362d24046bae58663e56e673d.png" alt="在这里插入图片描述"><br>然后打开其中扩展名为pub的那个文件，复制里面的内容，粘贴到<br>（这里我们用国内的远程库吧）<br><img src="https://img-blog.csdnimg.cn/115cb00b73bc4c2ba779dcc634cd236c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>添加了ssh公钥之后<br>再新建一个库<br><img src="https://img-blog.csdnimg.cn/056e99704e7e4f01beb38976e430b5cf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果不太清楚开源协议的话，可以点框起来的部分<br><img src="https://img-blog.csdnimg.cn/dee06512bea842b6be3912dd4586809c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后一路我不在乎————下一步下一步（好吧这个根据个人需求来就行）<br><img src="https://img-blog.csdnimg.cn/3ecdb96f87cb45f886b1a68fc051dc8f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>得到远程仓库之后，我们就不同本地的了（原来那个可以删了）<br>来克隆一下</p><h3 id="使用IDEA集成开发"><a href="#使用IDEA集成开发" class="headerlink" title="使用IDEA集成开发"></a>使用IDEA集成开发</h3><p>idea创建一个普通项目<br><img src="https://img-blog.csdnimg.cn/2075b0171ce44a6ead2c5c4a1dc8920c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里我的IDEA帮我自动配置好了这两个东西<br>打开看看<br><img src="https://img-blog.csdnimg.cn/45bc4efd55be4ef1b8cd541a5742d356.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8d6259a29782475fbb5429bbda7065a6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后我们把下载到本地的git文件的内容移动到工程文件中<br><img src="https://img-blog.csdnimg.cn/427bb7592b2e4509a63c1e4d4f06d776.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里红色的就是代表选中状态,绿色代表已经提交<br>右上角也多了几个按钮<br><img src="https://img-blog.csdnimg.cn/8d7fa7209a9b4965b623b05196982841.png" alt="在这里插入图片描述"><br>底部也多了终端的几个选项<br><img src="https://img-blog.csdnimg.cn/8e03f6dc80b3454ab74c55182b4661ff.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>接下来我们在终端使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加所有文件到暂存区<br><img src="https://img-blog.csdnimg.cn/cfaa008c216141bd81113beb25132096.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>当然鼠标右键找到git选项中的add，也能实现同样的效果<br>添加到暂存区之后的文件都变绿了<br><img src="https://img-blog.csdnimg.cn/2858bea0e2bb42cf9468a4228126418e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后输入一下描述信息，直接提交就好了</p><p><img src="https://img-blog.csdnimg.cn/8739f86691834655a2af7fe7002d8b56.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>当然，使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"这是第一次提交阿巴阿巴阿巴.."</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也能达到同样的效果</p><p>当看到这个的时候<br><img src="https://img-blog.csdnimg.cn/a93be1af60414ec5829a4baaca24abe0.png" alt="在这里插入图片描述"><br>就已经提交到本地仓库了<br>如果要同步到远程，可以使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（终端不需要加$；push后面什么都不写）<br>或者点击IDEA的快捷按钮：推送，即可完成同步<br><img src="https://img-blog.csdnimg.cn/36dde07f366a4bc78e9aa5b00f8412cf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这就很棒了</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>主干叫master，一定要对应最优的稳定运行版本<br>查看本地库的分支</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/b6f43ba242494267a90fc36c755a8c62.png" alt="在这里插入图片描述"><br>查看远程库的分支</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/9820a853a2e345b2a9e71c1ef2906554.png" alt="在这里插入图片描述"><br>三个开发小组A B C<br>B会调用A的接口<br>C会调用A，B的接口<br>那么如果B在使用的过程中修改了A的代码<br>C要调用A原本的代码时，就产生了冲突</p><p>所以这就需要分支，使得各个版本不冲突<br>(C调用A1.0，B修改后产生的记为A2.0这样就可以了)</p><p>另外，最后ABC三组合并文件，如果发生冲突<br>那么可以修改冲突文件重新提交，选择保留其中一种可行的方案即可</p><p>相关操作见下图，当然下图依旧来自网络（好吧就是狂神说）<br><img src="https://img-blog.csdnimg.cn/0403f6b7c0c345799940b56bc310969c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="协同开发实操"><a href="#协同开发实操" class="headerlink" title="协同开发实操"></a>协同开发实操</h3><p>这个得等等队友了…<br>后面再更新<br><img src="https://img-blog.csdnimg.cn/002dee626d9041fdb3cbc2e3e6758cc8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web多媒体基础</title>
      <link href="/2022/02/03/webmedia/"/>
      <url>/2022/02/03/webmedia/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h2><blockquote><p>在这短短数十天的学习中，我的认知也有了长足的进步，不再把前端局限于web，因为我见识到了更为广大的前端，那是奇伟瑰丽的，也是人迹罕至的，当我见到这一幕时的心情，就像是远行者历经千辛万苦终于要翻过一个山头的时候怀揣的期待被山头那边高不可攀的<strong>“真正的顶峰”</strong>打破，随即而来的震撼</p><p>这次远足，没有终点</p><p>对于没有终点这种概念无需产生惶恐，心怀敬仰地用有限去博弈无穷，向世界献上赞歌，这何尝不是一种浪漫呢</p></blockquote><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><blockquote><p><strong>2022/02/03</strong><br>开始学习吧</p><p><strong>2022/02/04</strong><br>搜集各种资料，学习关于“信息熵”的知识并做好记录</p></blockquote><h1 id="浏览器原生多媒体和扩展"><a href="#浏览器原生多媒体和扩展" class="headerlink" title="浏览器原生多媒体和扩展"></a>浏览器原生多媒体和扩展</h1><h2 id="音频和视频"><a href="#音频和视频" class="headerlink" title="音频和视频"></a>音频和视频</h2><p>这里指的是audio标签和video标签<br>它们具有如下属性:</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab1d80a544e355be6571a20f66494aa68b/0.png" alt="两个标签的属性1"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab3bc48a6faf48e3507f87bcd5bf181da8/0.png" alt="两个标签的属性2"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab6540d6a86140386f8a3a29dd0517c936/0.png" alt="两个标签的属性3"></p><p>由于现在的浏览器很可能会避免随机噪声的出现，所以会禁用如autoplay这种属性，从而直接配置是无效的，所以我们需要使用JS来触发它们（我还没试过，可能也没效果）</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><blockquote><ol><li><p>不支持直接播放hls、flv等格式的视频</p></li><li><p>视频资源的请求和加载无法通过代码控制</p><p>(无法实现分段加载、清晰度无缝切换、精准预加载等功能)</p></li></ol></blockquote><h2 id="多媒体元素和扩展API"><a href="#多媒体元素和扩展API" class="headerlink" title="多媒体元素和扩展API"></a>多媒体元素和扩展API</h2><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168420129fe8edd9b5365abedda178b287ad511b808c5d4115c76/0.png" alt="MSE"></p><blockquote><p>MSE使用过程：</p><ol><li>创建mediaSource实例</li><li>创建指向mediaSource的URL</li><li>监听sourceopen事件</li><li>创建sourceBuffer</li><li>向sourceBuffer中加入数据</li><li>监听updateend事件</li></ol><p>而用MSE播放mp4的过程如下：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168420129fe8edd9b5365abf43c6184acf2aa006e3774b6af85e2/0.png" alt="MSE播放mp4过程"></p><p>对比一下播放器播放mp4：</p><ol><li>数据加载（ts flv mp4）</li><li>解封装（音频裸流、视频裸流）</li><li>重封装（fmp4）</li><li>appendBuffer（video、audio）</li><li>解码渲染（解码渲染）</li><li>音视频同步（时间戳）</li></ol></blockquote><h2 id="流媒体协议"><a href="#流媒体协议" class="headerlink" title="流媒体协议"></a>流媒体协议</h2><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168420129fe8edd9b536548804879f3a4982fe79604b406190403/0.png" alt="流媒体协议一览"></p><blockquote><p> 其中，HLS全称是<strong>HTTP Live Streaming</strong>，用于实时音视频流的传输，目前HLS协议被广泛应用于视频点播和直播领域</p></blockquote><p><strong>工作流程</strong></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168420129fe8edd9b53655ab2070bf4ff9db2eadf702d8f6958ca/0.png" alt="工作流程"></p><h1 id="Web多媒体基础知识"><a href="#Web多媒体基础知识" class="headerlink" title="Web多媒体基础知识"></a>Web多媒体基础知识</h1><h2 id="Web多媒体历史"><a href="#Web多媒体历史" class="headerlink" title="Web多媒体历史"></a>Web多媒体历史</h2><p>多媒体历史可以大致的分为三个阶段：</p><blockquote><ol><li><strong>Flash时代</strong><br>已经开摆了</li><li><strong>HTML5时代</strong><br>至今还在用，但是audio等标签完全不够用，亟待扩展</li><li><strong>Media Source Extension（MSE）时代</strong><br>媒体资源扩展，未来的发展趋势</li></ol></blockquote><h2 id="图像的基本概念"><a href="#图像的基本概念" class="headerlink" title="图像的基本概念"></a>图像的基本概念</h2><p><strong>图像分辨率</strong></p><blockquote><p>用于确定组成一副图像的像素数据<br>就是指在 水平和垂直方向上图像所具有的像素<strong>个数</strong></p></blockquote><p> <strong>图像深度</strong></p><blockquote><p>图像深度是指存储每个像素所需要的比特数<br>图像深度决定了图像的每个像素可能的颜色数，或可能的灰度级数<br>例如:<br>彩色图像每个像素用R,G,B三个分量表示,每个分量用8位，像素深度为24位，可以表示的颜色数目为2的24次方，既16777216个<br>单色图像存储每个像素需要8bit，则图像的象素深度为8位，最大灰度数目为2的8次方，既256个。</p></blockquote><h2 id="视频基本概念"><a href="#视频基本概念" class="headerlink" title="视频基本概念"></a>视频基本概念</h2><p><strong>分辨率</strong></p><blockquote><p>指的是构成视频的每一帧图像的分辨率</p></blockquote><p><strong>帧率</strong></p><blockquote><p>视频单位时间内包含的视频帧的数量</p></blockquote><p><strong>码率</strong></p><blockquote><p>视频单位时间内传输的数据量，一般用kbps表示——注意这里是bit不是Byte</p></blockquote><h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2><p><strong>I帧</strong></p><blockquote><p>又称<strong>帧内编码帧</strong>，是一种自带全部信息的独立帧，无需参考其他图像便可独立进行解码</p></blockquote><p><strong>P帧</strong></p><blockquote><p>又称<strong>帧间预测编码帧</strong>，需要参考前面的I帧或者P帧才能进行编码</p></blockquote><p><strong>B帧</strong></p><blockquote><p>又称<strong>双向预测编码帧</strong>，也就是B帧记录的是本帧与前后帧的差别</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fabc59002d34a0826d96fa797467f5b7d65/0.png" alt="I/P/B帧示意图"></p><p><strong>GOP</strong></p><blockquote><p>group of picture<br>指的是两个I帧之间的间隔</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fabc8d503f7eba1ac49cc861886ac6a3d26/0.png" alt="GOP示意图"></p><p>下面这些是常见的编码格式：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fabe9b50b94a16a56ec2be41c3a3b893891/0.png" alt="常见编码格式发展一览"></p><h2 id="为什么要进行编码"><a href="#为什么要进行编码" class="headerlink" title="为什么要进行编码"></a>为什么要进行编码</h2><blockquote><p>编码是将源对象内容按照一种标准转换为一种<strong>标准格式</strong>内容<br>解码是和编码对应的,它使用和编码相同的标准将编码内容还原<br><strong>最初是为了加密</strong>,经过加密的内容不知道编码标准的人很难识别<br>而<strong>现在主要是为了信息交换</strong></p></blockquote><p>编码可以做到压缩体积等效果，有效优化一些冗余问题</p><h2 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h2><blockquote><p>从信息论的角度来看，描述信息源的数据是信息和数据冗余之和，即：数据=信息+数据冗余。</p></blockquote><p><strong>空间冗余</strong></p><blockquote><p>又称<strong>几何冗余</strong></p><p>同一景物表面上采样点的颜色之间通常存在着空间关联性，相邻各点的取值往往近似或者相同，这就是空间冗余</p><p>例如图片中有<strong>一片连续的区域像素都是相同的颜色</strong>，那么空间冗余就产生了</p><p>图像数据中经常存在的一种数据冗余，是静态图像中存在的最主要的一种数据冗余</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab399bc15dbbe7ffba271eba1017a694a5/0.png" alt="空间冗余"></p><p>图中虚线划出的区域便是</p><p><strong>时间冗余</strong></p><blockquote><p>又称<strong>帧间冗余</strong></p><p>在视频、动画图像中，相邻帧之间往往存在着时间和空间的相关性</p><p>例如人们在会议室中开会，随着会议的进行，时间在改变，但是背景（房间、家具等）一直是相同的、而且没有移动，变化的只是人们的动作和位置</p><p>这里的背景就反映为时间冗余。同样，由于人在说话时产生的音频也是连续和渐变的，因此声音信息中也会存在时间冗余</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab5df4c67d50850706fb13e5edd03f90ea/0.png" alt="时间冗余"></p><p><strong>视觉冗余</strong></p><blockquote><p>又称<strong>心理视觉冗余</strong></p><p>在多媒体技术的应用领域中，人的眼睛是图像信息的接收端。视觉冗余是相对于<strong>人眼的视觉特性</strong>而言的，人类的视觉系统并不能对图像画面的任何变化都能感觉到，通常情况下具有以下特点：</p><ol><li>对亮度的变化敏感，对色度的变化相对不敏感</li><li>对静止图像敏感，对运动图像相对不敏感</li><li>对图像的水平线条和竖直线条敏感，对斜线相对不敏感</li><li>对整体结构敏感，对内部细节相对不敏感</li><li>对低频信号敏感，对高频信号相对不敏感（如：对边沿或者突变附近的细节不敏感）</li><li>…..</li></ol><p>因此，包含在色度信号、运动图像、图像高频信号中的一些数据，相对于人眼而言，并不能对增加图像的清晰度作出贡献，<strong>被人眼视为多余的</strong>，这就是视觉冗余。</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab3f9691179be372457bad67abeab8ece4/0.png" alt="视觉冗余"></p><p><strong>编码冗余</strong></p><blockquote><p>推测可能是指的<strong>信息熵冗余</strong></p><p>具体的例子可以参考哈夫曼编码解决的问题：如何用0 1两种字符代表26个字母——哈夫曼编码能在这个问题中得到最优解，解决的正是编码冗余问题（但是哈夫曼编码在特定的情况下无法得到最优解）</p><p>数据压缩的理论极限是信息熵原理:</p><p>信息论之父香农指出，任何信息都存在冗余，冗余大小与信息中每个符号（数字、字母或单词）的出现概率或者说不确定性有关。香农借鉴了热力学的概念，把信息中<strong>排除了冗余后的平均信息量</strong>称为“信息熵”，并给出了计算信息熵的数学表达式：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab7e1df10b1601636fc9eebf6bb1b61c0d/0.png" alt="信息熵计算公式"></p><p>其中，pi代表随机事件i出现概率,log通常是以2为底——这里对数的底数选择是任意的，因为信息熵其实是一个相对值，但是传统是以2为底，这样一来不仅可以使得数据有通用性，而且还能用bit作为单位</p><p>如果要求编码过程中不丢失信息量，即要求保存信息熵，这种信息保持编码叫<strong>熵编码</strong>，是<strong>无损压缩</strong>的</p><p>常用的熵编码：<br>香农编码、 哈夫曼编码、 算术编码、 BLE行程编码、CAVLC基于上下文的自适应变长编码、CABAC基于上下文的自适应二进制算术编码</p></blockquote><p><strong>更多的冗余</strong></p><blockquote><p>还有其他多种冗余形式，比如结构冗余、其他冗余等等..<br>此处不再一一例举</p></blockquote><h2 id="编码处理过程"><a href="#编码处理过程" class="headerlink" title="编码处理过程"></a>编码处理过程</h2><blockquote><p>基本顺序依次为：</p><ol><li><strong>预测</strong><br>减少空间冗余、时间冗余</li><li><strong>变换</strong><br>减少空间冗余</li><li><strong>量化</strong><br>减少视觉冗余</li><li><strong>熵编码</strong><br>去除编码冗余</li></ol></blockquote><h2 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a>封装格式</h2><blockquote><p>封装格式是存储音视频、图片或者字幕信息的一种容器</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab6b93341d2a767ea7f83854dcf8b27176/0.png" alt="常见封装格式发展一览"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fabea700ed355541bd0be62792b700aa7ff/0.png" alt="常见封装格式和文件映射关系表"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>又一次感受到数学对计算机的印象，多亏了本次学习探索，窥见图像处理这个领域的一隅。</p><p>同时也勾起了对WebGPU，WebVR，WebXR，Webassembly，WebCodecs的向往</p><p>期待这些技术成熟时为我们带来的惊艳！</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote><ol><li><p><strong>字节跳动青训营培训资料</strong></p></li><li><p><strong>百度百科</strong><br><a href="https://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%86%97%E4%BD%99">https://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%86%97%E4%BD%99</a><br><a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%86%97%E4%BD%99">https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%86%97%E4%BD%99</a><br><a href="https://baike.baidu.com/item/%E8%A7%86%E8%A7%89%E5%86%97%E4%BD%99">https://baike.baidu.com/item/%E8%A7%86%E8%A7%89%E5%86%97%E4%BD%99</a><br><a href="https://baike.baidu.com/item/%E7%86%B5%E7%BC%96%E7%A0%81">https://baike.baidu.com/item/%E7%86%B5%E7%BC%96%E7%A0%81</a></p></li><li><p><strong>《图像处理学习笔记》</strong><br><a href="https://blog.csdn.net/qq_33208851/article/details/95335809">https://blog.csdn.net/qq_33208851/article/details/95335809</a></p></li><li><p><strong>《走进Web多媒体技术》</strong><br><a href="https://juejin.cn/post/7000726903787094029">https://juejin.cn/post/7000726903787094029</a></p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端游戏开发理论基础</title>
      <link href="/2022/02/01/gamedev/"/>
      <url>/2022/02/01/gamedev/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>​    没想到啊，本来这几天在学linux的，结果现在又来学前端游戏开发了，我真的是被迫营业啊</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/30</strong><br>你说吧，都要过年了，我这还被迫学习容易吗<br>算了，开工开工</p><p><strong>2022/02/01</strong></p><p>发布发布</p></blockquote><h2 id="游戏的定义"><a href="#游戏的定义" class="headerlink" title="游戏的定义"></a>游戏的定义</h2><h3 id="广义定义"><a href="#广义定义" class="headerlink" title="广义定义"></a>广义定义</h3><blockquote><p>一种有组织的玩耍，一般以娱乐为目的，有时也有教育目的<br>在英语中，体育比赛（Game）也是游戏，只要其活动本质带有目的、规则、挑战和互动，我们都可以把其归为游戏</p></blockquote><h3 id="狭义定义"><a href="#狭义定义" class="headerlink" title="狭义定义"></a>狭义定义</h3><blockquote><p>通过游戏引擎制作的电子游戏</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168421427961456ee7bf7e45b9d73d13d35bf5bc19df37e1a1c96/0.png" alt="游戏分类"></p><p>那么问题来了，MOBA算是哪一类呢？</p><p>MOBA全称是多人在线战术竞技游戏，是即时战略游戏（RTS)的一个子类</p><h2 id="游戏开发流程"><a href="#游戏开发流程" class="headerlink" title="游戏开发流程"></a>游戏开发流程</h2><p>一个最小规模但是完整的游戏开发团队只需要三个角色：策划、程序、美术</p><p>当然，能力够强的话可以作为独立开发者</p><h3 id="策划"><a href="#策划" class="headerlink" title="策划"></a>策划</h3><blockquote><p>负责设计规划各种数值和游戏内容等</p></blockquote><h3 id="美术"><a href="#美术" class="headerlink" title="美术"></a>美术</h3><blockquote><p>负责设计和制作原画、2D/3D模型、音效/动效等</p></blockquote><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><blockquote><p>前端、后端</p></blockquote><h3 id="其他支持"><a href="#其他支持" class="headerlink" title="其他支持"></a>其他支持</h3><blockquote><p>包括QA、运营、运维、市场等</p></blockquote><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168421427961456ee7bf7f1e3573f499a5a0165e2d505f20d3297/0.png" alt="开发流程图"></p><p>Demo阶段是，能够有基础的图形界面（小方块代表人物这种），各项数值能够在对应的时刻触发</p><h3 id="游戏引擎"><a href="#游戏引擎" class="headerlink" title="游戏引擎"></a>游戏引擎</h3><p>游戏引擎最大的功效：<strong>渲染</strong></p><blockquote><p>引擎 的诞生就是因为一家公司做了一款游戏，做下一款游戏时复用了上一款游戏的代码，后来发现这些代码几乎每个游戏都会用到,抽离出来就成了一个引擎。<br>如果不使用引擎，你可以做复杂的动效渲染和交互吗?当然可以。方便吗?不一定。<br>所以游戏引擎更像是一套解决方案，让你在制作某一类型的产品的时候能够提高你的开发效率。<br>做多平台移植:  <strong>React Native、Weex、Cordova</strong>等方案也可以做到。<br>做物理效果: <strong>MatterJS、ammo.js</strong>等物理引擎可以用。</p></blockquote><p>为什么使用游戏引擎呢？</p><blockquote><p>因为你想要的它能够给你一套完整的实现方案，不需要你再自己去拼凑、封装,让你花更少的时间做出更好的效果，特别是关于渲染效率和性能优化。<br>它提供游戏开发时需要的常见功能:引擎会提供许多组件，使用这些组件能缩短开发时间，让游戏开发变得更简单;专业引擎通常会能比自制引擎表现出更好的性能。<br>游戏引擎通常会包含渲染器，2D/3D图形元素，碰撞检测，物理引擎，声音，控制器支持，动画等部分。</p></blockquote><h3 id="市面上常见的游戏引擎"><a href="#市面上常见的游戏引擎" class="headerlink" title="市面上常见的游戏引擎"></a>市面上常见的游戏引擎</h3><blockquote><p><strong>Unreal</strong>(虚幻引擎，代表作《PUBG》、《GTA5》)<br><strong>Source</strong> (起源引擎，代表作《CS》、《Dota2》)<br><strong>Frostbite Engine</strong>(寒霜引擎，代表作《战地》、《极品飞车18》) <strong>Unity3D</strong>(代表作《炉石传说》、《王者荣耀》)</p></blockquote><p>但是这种是专业级游戏开发引擎，我们从前端过渡的话先从入门级引擎入手</p><h2 id="前端到游戏开发的过渡"><a href="#前端到游戏开发的过渡" class="headerlink" title="前端到游戏开发的过渡"></a>前端到游戏开发的过渡</h2><p>需要先有一个明确的认知:前端开发和游戏开发<strong>不是相斥的</strong></p><p>以web前端开发的视角看2d游戏引擎、无非是一套框架、一套解决方案，但游戏开发理念上更注重内容而已</p><blockquote><p>现在市场上很多H5游戏、小游戏都是Web前端开发制作的，而不是专门的游戏开发团队、专业的游戏研发同学开发。<br>其原 因可能在于:<br>1.接触前端开发的研发数量远大于接触游戏开发的数量(招聘成本高)2.2d游戏引擎的上手门槛已经足够低(易上手)<br>3.活动H5中的游戏玩法的实现方式比较模糊(开发界限模糊)<br>现在很多<strong>主流的2d游戏引擎都支持使用Javascript</strong>进行开发同时使用相关的工程化能力，也是游戏开发向web前端开发靠拢的一种表现。</p></blockquote><h3 id="The-NVL-Maker"><a href="#The-NVL-Maker" class="headerlink" title="The NVL Maker"></a>The NVL Maker</h3><blockquote><p>No Code无代码形式的开发，只需要写文字脚本加上一点配置就可以生成一个文字冒险游戏</p><p>虽然有一种年代感，但是还是能用的</p><p>代表作《Fate/stay night》和steam上一大把GAL Game</p></blockquote><p>其内有一个适用于前端的库AVG.js Project（以pixiJS为渲染引擎）</p><h3 id="RPG-Maker"><a href="#RPG-Maker" class="headerlink" title="RPG Maker"></a>RPG Maker</h3><blockquote><p>No Code低代码形式开发，需要微量代码能力</p><p>可以图形化编辑制作地图，并使用少量代码的RPG游戏</p><p>代表作《To the Moon》</p></blockquote><h3 id="Web游戏引擎"><a href="#Web游戏引擎" class="headerlink" title="Web游戏引擎"></a>Web游戏引擎</h3><blockquote><p>利用<strong>Canvas和 WebGL</strong>为底层技术抽象的图像绘制库（往往还附带一些其他的功能)Web游戏引擎的通用能力:</p><ol><li><p><strong>预加载</strong>:</p><p>游戏中往往存在大量的静态素材，包括场景、元素、声音、动画、模型、贴图等，如果以原生JS进行请求，并统筹请求时间和加载的时机，将会非常麻烦。游戏引擎中的预加载引擎将加载时机、加载过程加以抽象，解决加载编码中的效率问题。</p></li><li><p><strong>展示与图层、组合系统</strong>:</p><p>对于Web游戏编程而言，往往选择Canvas或 WebGL作为渲染方式(大家可以想想为什么不用DOM作为渲染方式?）。而 Canvas和 WebGL作为底层的API，接口非常基础，需要用大量的编码来编写简单的展示。而且图形之间没有组合和图层，很难处理元素组合和图层问题。渲染引擎和图层、组合系统应运而生。</p></li><li><p><strong>动画系统</strong>:</p><p>动画往往被分为缓动动画和逐帧动画，这里讨论缓动动画系统。缓动动画系统在原生JS中需要搭配帧渲染进行考量而进行书写，代码量和思考量巨大，抽象程度低，所以需要游戏引擎动画系统。</p></li><li><p><strong>音效和声音系统</strong>︰</p><p>游戏相较于普通的 Web前端而言需要更加立体、及时的反馈，声音和音效是反馈的重要组成部分。所以声音和音效系统往往包含了声音的播放、音量、截止、暂停等功能的集成.</p></li></ol></blockquote><p>Web游戏引擎中值得推荐的有</p><blockquote><p><strong>Cocos</strong>:<br>生态较好，功能支持完整，但是3D能力还有待提高（版本高速迭代ing）</p><p><strong>Laya</strong>:<br>3D能力成熟，据说市场占有率90%，支持JS、TS、AS，相对轻量，但是界面据说不友好，生态一般</p><p><strong>Egret</strong><br>工具链完善，第三方支持好，企业定制能力强，但是版本更新屡遭瓶颈，生态薄弱</p><p><strong>CreateJS和 Phaser</strong></p><p>是多个库的集合，比如CreateJS包括了EASEJS，TWEENJS，SOUNDJS, PRELOADJS，通过预加载后的素材展示、动画、声音构成游戏</p><p>Phaser则是除了CreateJS已有的内容以外，还设计了摄像机、物理引擎、内置浏览器、插件系统等高级功能</p></blockquote><p><strong>功能引擎</strong></p><blockquote><p>大型游戏引擎往往是由小的功能引擎组装成的，一个大型游戏引擎往往包含渲染引擎、物理引擎、Ul系统、声音系统、动画系统、粒子系统、骨骼系统、网络系统等组合而成。其中最重要的便是渲染引擎和物理引擎。<br>功能引擎是专注某个方向能力的引擎，其特点是体积小、功能完善。特别是Pixil.js和Three.js这两个渲染引擎，通常被误以为是一个完整的游戏引擎，但它们是专注渲染能力的渲染引擎。<br>下面介绍几种可能会经常接触的功能引擎:</p></blockquote><p>比如 </p><blockquote><p> <strong>Pixi.js</strong> </p><p> 2d渲染引擎，轻量化，在需要复杂动画、复杂图片渲染、用Canvas不想自己手写、自己制作2d游戏引擎的时候可以考虑它</p><p>AVG.js和Phaser.js的渲染引擎就是Pixi.js</p><p><strong>Three.js</strong></p><p>3d渲染引擎，API简明，支持WebGL和CSS3D两种渲染模式，在做3D或者WevVR的时候可以考虑</p><p><strong>Box2D.js</strong></p><p>2d物理引擎，接口简单，物理效果强大，在做物理效果的时候可以考虑</p></blockquote><p>以Pixi.js为例了解其渲染流程：</p><blockquote><p>以Pixi的渲染流程为例子大致流程如下<br>1.创建一个Renderer渲染器，获取它的view (一个canvas对象)，添加到Dom Tree中。(或者指定Dom Tree中已经存在的canvas对象作为view)</p><p>2.在MainLoop(主循环)中调用Renderer.render()并传入一个DisplayObject作为根节点开发渲染。</p><p>3.从场景树的根节点开始，以zlIndex为序从小到大进行深度优先遍历，对每个节点进行渲染操作，由后往前把整个场景绘制一次。(CanvasRenderer)</p><ol start="4"><li>WebGL的render方法执行</li></ol></blockquote><h3 id="游戏开发技能树"><a href="#游戏开发技能树" class="headerlink" title="游戏开发技能树"></a>游戏开发技能树</h3><p>最大的差别在于不深入学习CSS，而是学习游戏相关的样式概念</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253ecd37dbe503202f5544b3a011e712a72a370b01a738975/0.png"></p><p>入门建议学习CoCos</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253ecd37dbe5032026c0135077b7920449691116ad7ab7936/0.png"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253ecd37dbe503202c9e3cadb4fe43125661b373c769edbd0/0.png"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253ecd37dbe503202ecf38946994e5f56c5a828505cc5681b/0.png"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253ecd37dbe5032028f6fc8c1947de5e234274bbfec4f11f0/0.png"></p><p>这些据说和React类似</p><p>具体内容这里暂时不提了，有兴趣就学，（现在我web都还没摸透呢…）</p><h3 id="游戏平台"><a href="#游戏平台" class="headerlink" title="游戏平台"></a>游戏平台</h3><p>众所周知国内游戏发布变得困难起来了，所以发布平台要选好啊，不然限流下架免不了啊，x399这个就不考虑了，入门可以考虑一下Web Mobile这些平台（小程序游戏的话可以考虑去对应的平台），以后有资金了能开注册公司的话就可以考虑一下Steam之类的平台了</p><p>另外，说一下H5和小程序游戏</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253ecd37dbe503202d0eff5770fe98186958d786948ea19fd/0.png"></p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全基础攻防技术</title>
      <link href="/2022/01/26/websafety/"/>
      <url>/2022/01/26/websafety/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>二进制的计算机世界中黑白之中的灰色地带，一场剑与盾的战争悄然上演！<br>没有战火，没有硝烟，只有无数暗流涌动，这就是Web安全</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/25</strong><br>开始学习</p><p><strong>2002/01/26</strong><br>初步记录完毕</p></blockquote><h2 id="跨站脚本攻击XSS"><a href="#跨站脚本攻击XSS" class="headerlink" title="跨站脚本攻击XSS"></a>跨站脚本攻击XSS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Cross-Site Script，本该简称CSS，但为了避免歧义，所以就叫XSS<br>(X就是Cross嘛)<br>是最常见的一种攻击手段</p></blockquote><p>有如下几种常见的类型:</p><blockquote><ol><li><strong>Stored XSS</strong><br>存储型XSS，恶意脚本存到数据库中，在访问页面并进行数据读取时发动攻击，伤害最大，对全部用户可见</li><li><strong>Reflected XSS</strong><br>反射型XSS，从URL上攻击，将恶意脚本填入URL参数的值中，在执行GET请求时发动</li><li><strong>DOM-Based XSS</strong><br>基于DOM的XSS，不需要服务器参与，全程在浏览器完成。注入原理同反射型XSS，但是执行条件是JS利用URL参数创建DOM</li><li><strong>Mutation-based XSS</strong><br>基于变化的XSS，利用浏览器渲染DOM的特性，比如在标签的title属性中注入XSS，在渲染时进行攻击，作用于不同浏览器时可能会有差异<br>这种注入方式最为复杂，需要攻击者非常了解浏览器的渲染规则——同时也是最难防御的XSS攻击</li></ol></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">'XSS'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这段代码放到 数据库 或者 URL参数的值中则可以造成XSS攻击</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>用户提交的string转为DOM的过程中，可能使用到了下述代码片段</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write()</span><br><span class="line">element.innerHTML = <span class="string">''</span></span><br><span class="line"><span class="comment">// 或者使用了 SSR类的操作</span></span><br></pre></td></tr></tbody></table></figure><p>而XSS攻击具有以下特点:</p><blockquote><ol><li>通常难以从UI上感知</li><li>能窃取cookie/token等信息</li><li>绘制UI（如植入弹窗），欺骗用户填写、点击</li></ol></blockquote><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p><strong>核心思想</strong></p><blockquote><p><strong>永远不要相信用户提交的内容</strong>：<br>不要直接把用户提交内容转为DOM，尽可能转为字符串等相对安全的类型<br>小心类似于 “需要动态生成DOM” 这种客户需求</p></blockquote><p><strong>防御工具</strong></p><blockquote><p><strong>前端</strong></p><ol><li>主流框架默认防御XSS</li><li>google-closure-library</li></ol><p><strong>服务端（指Node）</strong></p><ol><li>DOMPurify</li></ol></blockquote><p><strong>注意事项</strong></p><blockquote><ol><li>string类型注意转义内容</li><li>如果允许用户上传SVG文件等，需要先预处理</li><li>小心自定义跳转连接，因为这样是可以传递JS代码的</li><li>小心自定义样式，因为CSS的URL也可能包含GET请求</li></ol></blockquote><h2 id="跨站请求伪造CSRF"><a href="#跨站请求伪造CSRF" class="headerlink" title="跨站请求伪造CSRF"></a>跨站请求伪造CSRF</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Cross-Site Request Forgery<br>（翻译是跨站请求伪造，但是口头上也常称为跨站伪造请求..总感觉一个是名词一个是动宾短语…）</p><p>这里举出一些较为特殊的CSRF：</p><ol><li><p><strong>iframe攻击</strong><br>由于iframe中发起请求是同源请求，所以检测是否来自安全源的防御机制对此近乎无效，而且攻击者可能更加高明，会利用事件冒泡\事件捕获等JS特性在看似安全的按钮等事件对象的背后隐藏恶意的事件对象</p></li><li><p><strong>anti-pattern攻击</strong></p><p>这是由于程序员本身因为疏忽（更大概率是因为懒），设置GET请求也可以作为POST请求使用，导致攻击者可以直接利用GET请求篡改数据</p></li></ol></blockquote><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><blockquote><ol><li>用户访问到了恶意页面，并输入、提交了个人信息</li><li>恶意页面利用这些信息设置cookie，请求另一个域名下的银行转账接口，由于cookie信息是有效的，转账的请求也被认为是有效的</li><li>请求执行成功，转账完毕，用户权益受到侵害</li></ol></blockquote><p>这些恶意的脚本可能隐藏在a、img等标签的属性中，或者直接不隐藏而是构建一个表单。<br>它们会在被点击时触发GET请求发动攻击</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>跨站请求伪造有如下几个特点:</p><blockquote><pre><code> 1. 用户不知情为前提 2. 利用用户的权限（cookie） 3. 构造指定的HTTP请求，窃取/修改信息</code></pre></blockquote><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><p><strong>核心思想</strong></p><blockquote><p><strong>（大部分情况下）尽可能判断请求的来源，如果来源异常，那么对其进行限制</strong></p></blockquote><p><strong>注意事项</strong></p><blockquote><p><strong>前端</strong></p><ol><li><p>同源请求中，GET、HEAD不会发送Origin字段，这种情况<br>判断来源的话就比较麻烦，所以同源请求尽量避免GET、HEAD</p></li><li><p>也可以结合Referer字段来进行判断</p></li><li><p>使用token和用户进行绑定，并设置过期时间，这样避免了token被他人利用，也避免了持续时间较长的攻击</p></li><li><p>对于iframe攻击，需要在服务器响应头部设置X-Frame-Options的值为DENY，意味着当前页面的值不能作为iframe进行加载；或者设置为SAMEORIGIN，意味着这个页面本身必须和当前页面同源，才能作为iframe加载</p></li><li><p>CSRF是因为Cookie被携带导致的，那么设置SameSite Cookie使得特定页面的Cookie只能在该页面生效，也就能从根源上解决CSRF<br>(这里要注意区分SameSite和CORS的区别，前者是和第三方域与页面域的Cookie相关；后者是和资源域与页面域间资源读写的白名单相关)</p><p><strong>后端（偏指Node）</strong></p><p>构建中间件（Middlewares）专门做CSRF防御</p></li></ol></blockquote><h2 id="注入攻击Injection"><a href="#注入攻击Injection" class="headerlink" title="注入攻击Injection"></a>注入攻击Injection</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><blockquote><p>通过发送注入 SQL语句的<strong>参数</strong> 的请求，使后端获取这些恶意的参数而执行恶意的SQL操作，导致数据库信息被修改<br>常见的注入攻击有以下几类：</p><ol><li>SQL</li><li>CLI</li><li>OS command</li><li>SSRF(Server-Side Request Forgery) 服务端伪造请求，严格意义上<strong>不算注入</strong>，但是原理类似</li></ol></blockquote><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p><strong>SQL注入示例</strong></p><p>假设现在后端有如下SQL语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> users;</span><br></pre></td></tr></tbody></table></figure><p>SQL注入:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'/api'</span>,{</span><br><span class="line">    <span class="attr">method</span>: <span class="string">"POST"</span>,</span><br><span class="line">    <span class="attr">headers</span>: {</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify({</span><br><span class="line">        <span class="attr">users</span>: <span class="string">'table1;DROP TABLE users;'</span></span><br><span class="line">    <span class="comment">// SQL注入关键语句</span></span><br><span class="line">    })</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>后端收到请求后，SQL会被解析为:</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> table1;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> users;</span><br></pre></td></tr></tbody></table></figure><p>结果就是数据库信息被删除</p><p><strong>OS command注入示例</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> command = <span class="string">'convert-cli video -o &amp;&amp; rm -rf xxx'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>SSRF示例</strong></p><blockquote><ol><li>请求用户自定义的callback URL</li><li>利用内网访问权限（前提是要有），此时访问acllback即可能暴露内网信息</li></ol></blockquote><p>（说实话这个没看太懂，不过还是先记下来吧）</p><p><strong>不知道是哪一类的注入示例</strong></p><blockquote><ol><li>篡改nginx.conf文件中的代理服务器</li><li>把该网站流量转发到第三方服务器</li><li>第三方服务器流量突增，可能无法继续支撑，从而崩溃</li></ol></blockquote><h3 id="防御-2"><a href="#防御-2" class="headerlink" title="防御"></a>防御</h3><blockquote><ol><li>使用prepared statement</li><li>遵循<strong>最小权限原则</strong>，所有命令都不要通过sudo执行</li><li>建立允许名单，并进行过滤，避免rm这种高危操作</li><li>（针对SSR注入）对URL类型参数进行协议、域名、ip等限制</li></ol></blockquote><h2 id="拒绝服务攻击DoS"><a href="#拒绝服务攻击DoS" class="headerlink" title="拒绝服务攻击DoS"></a>拒绝服务攻击DoS</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Denial of Server </p><p>通过某种方式（构造特定请求），导致服务器资源被显著消耗，来不及响应更多请求，导致请求挤压，进而雪崩，<br>大概有如下几种常见类型：</p><ol><li><strong>ReDoS</strong><br>正则表达式拒绝服务攻击，利用贪婪模式的正则表达式的回溯操作</li><li><strong>DDoS</strong><br>分布式拒绝服务攻击，直接发送大量请求</li></ol></blockquote><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p><strong>正则表达式拒绝服务攻击</strong></p><p>类似的情况可以在正则匹配的过程中遇到</p><p>在贪婪模式下，正则表达式的运作规律如下：</p><blockquote><p>正则表达式： /^((ab)*)+$/<br>试图匹配字符: ‘ababaa’</p><p>先尝试用3个ab去匹配，发现不匹配；<br>再尝试用2个ab去匹配，发现不匹配；<br>再尝试用1个ab去匹配，发现不匹配；<br>最终判断为不匹配</p><p>当这样的串长度非常大、并且数量非常多时，会使得响应时间极大地变长，吞吐量极大地下降，，那么服务器可能就有崩溃的风险</p></blockquote><p><strong>分布式拒绝服务攻击</strong></p><p>没什么技巧，就靠数量打人海战术</p><blockquote><p>可以访问任意IP、任意API，不区分接口，消耗大量的带宽</p><p>洪水攻击（SYN Flood）就属于DDoS的一种：<br>利用三次握手，发送大量SYN，服务器来不及确认响应进而崩溃</p></blockquote><h3 id="防御-3"><a href="#防御-3" class="headerlink" title="防御"></a>防御</h3><blockquote><p><strong>流量治理</strong></p><ol><li>负载均衡 —— 过滤</li><li>API网关 —— 过滤</li><li>CDN —— 抗量</li></ol><p><strong>快速自动扩容</strong> —— 抗量</p><p><strong>非核心服务降级</strong> —— 抗量</p></blockquote><h2 id="中间人攻击MITM"><a href="#中间人攻击MITM" class="headerlink" title="中间人攻击MITM"></a>中间人攻击MITM</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Man-in-the-Middle Attack,简称MITM</p><p>基于传输层，在浏览器和服务器之间进行伪装：</p><p>浏览器&lt;–交互–&gt;中间人&lt;–交互–&gt;服务器</p><p>中间人的身份可以有很多种，包括伪劣路由器、恶意网络服务提供商等，但浏览器和服务器却都没有察觉到中间人的存在</p></blockquote><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这种攻击有三个特点</p><blockquote><ol><li>明文传输：未加密的信息可以被直接获取</li><li>信息篡改不可知：浏览器和服务器没有有效地验证信息</li><li>身份未验证：没有验证交互对象的身份</li></ol></blockquote><h3 id="防御-4"><a href="#防御-4" class="headerlink" title="防御"></a>防御</h3><blockquote><p><strong>HTTPS</strong></p><p>（HTTP3(QUIC)内置了TLS1.3，所以非常安全，但是这里不提这个，太超前了，这里依旧介绍HTTPS）</p><p>HTTPS具有如下特性：</p><ol><li><p>可靠性（加密）</p></li><li><p>完整性 （MAC验证）</p></li><li><p>不可抵赖性 （私钥和内容可以加密生成数字签名，公钥可以解密；证书校验也是前面这个原理）</p></li></ol><p>  <strong>HSTS</strong><br>  HTTP Strict-Transport-Security，强制安全传输<br>  前提是一定要有一次HTTPS请求</p><p>  <img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684262bdd1851090ac95c9fcb976c5e4eb93ffc912a60efe43d1/0.png" alt="HSTS示意图"></p><p><strong>SRI</strong><br>Subresource Integrity，静态资源完整性</p><p>能够有效针对静态资源劫持，校验原理是原始内容hash对比实际内容hash</p><p><strong>Featrue Policy/Permission Policy</strong><br>能够限制一个源（页面），可以使用那些功能，比如camera、microphone、autoplay</p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote><p>web安全，不论攻防都振奋人心<br>安全没有小事可言，以上例举的内容只是九牛之一毛，web还存在太多潜在的风险，甚至使用的依赖（npm package）或者说作为中间服务器的Node，都可能成为出现问题的一环</p><p>web安全的学习到此就要告一段落了，但是学习的步伐不会就此停滞</p><p>前方是星辰大海</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP(持续更新)</title>
      <link href="/2022/01/23/http/"/>
      <url>/2022/01/23/http/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>电脑坏掉了，现在使用的是备用机，性能不太好，用着也有点不太习惯，但是还是得学啊！<br>毕竟字节的课程还是很难得的，能学一点是一点吧！</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/22</strong><br>开始动工–HTTP其实应该补充到计算机网络一部分的，所以这里只是做一些补充和扩展</p><p><strong>2022/01/23</strong><br>骑着我心爱的小电驴去把修好的尕玛吉（我的电脑）背回了家，然后第一时间把这篇博文发布到我的个人博客上！<br>博文内容上没有做太大的改动，但是后面我知道后面我还会找时间做补充的！<br>之后一段时间，我可能会继续学习小程序开发、Linux、Web安全中的一个，至于究竟会做什么，我也不知道~</p><p><strong>2022/01/26</strong><br>更新了HTTPS部分</p></blockquote><h2 id="HTTP发展史"><a href="#HTTP发展史" class="headerlink" title="HTTP发展史"></a>HTTP发展史</h2><blockquote><p><strong>HTTP/0.9</strong><br>单行协议，请求html文件则至响应html文件<br><strong>HTTP/1.0</strong><br>构建扩展性，增加了请求头（Header）、状态码（status），支持多种文档类型<br><strong>HTTP/1.1</strong><br>标准化，增添了链接复用、缓存、内容协商等功能<br>截止至目前（2022年），是最常用的HTTP版本<br><strong>HTTP/2</strong><br>更优异的表现（更快、更稳定、更简单），支持二进制协议、压缩请求头、服务器推送等功能，数据传输使用的是帧而不是报文<br>目前国内大厂陆续开始采用该版本<br><strong>HTTP/3</strong><br>正在起草各种相关规则</p></blockquote><h2 id="协议分析-报文"><a href="#协议分析-报文" class="headerlink" title="协议分析-报文"></a>协议分析-报文</h2><h3 id="请求方法Method"><a href="#请求方法Method" class="headerlink" title="请求方法Method"></a>请求方法Method</h3><p>众所周知请求方法有GET、PUT、FETCH、POST等等，这些方法我们可以根据其安全性对其进行分类<br>这里就涉及到以下几个概念：</p><blockquote><p><strong>安全请求safe</strong><br>不会修改服务器数据的方法：<br>GET HEAD OPTIONS<br><strong>幂等请求idempotent</strong><br>同样的请求被执行一次与执行多次的的效果是一样的方法：<br>GET HEAD OPTIONS PUT DELETE<br>所有安全请求都是幂等请求</p></blockquote><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>这里总结一下常见状态码</p><blockquote><p><strong>1xx</strong><br>指示信息，表示请求已经接收，继续处理<br><strong>2xx</strong><br>成功，表示请求已经被成功接收、理解、接受，如：<br>200 — 客户端请求成功<br><strong>3xx</strong><br>重定向，要完成请求必须进行更进一步的操作，如：<br>301 — 资源被永久转移到别处<br>302 — 临时跳转<br><strong>4xx</strong><br>客户端错误，请求有语法错误或请求无法实现， 如：<br>401 — Unauthorized 未经授权的请求<br>404 — 访问资源不存在<br><strong>5xx</strong><br>服务器错误，服务器未能实现合法请求<br>500 — 服务器内部发生了不可预期的错误<br>504 — Gateway Timeout 网关或代理等待响应超时</p></blockquote><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>REST是Representational State Transfer，表现层状态转化<br>而RESTful API就是具有REST风格的API啦</p><p>具体规则是</p><blockquote><p>1.每一个URL代表一种资源<br>2.客户端和服务端之间，传递这种资源的某种表现层<br>3.客户端通过HTTP method，对服务器端资源进行操作，实现“表现层状态转化”</p></blockquote><p>那到底是什么样的API呢？在我看来，可以粗略地理解为——响应的状态码带有语义化的关键词<br>比如 200 OK， 201 CREATED， 400 INVALID REQUEST等等</p><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>这里也例举一些常用的请求头</p><blockquote><p><strong>Accept</strong><br>接收类型，表示浏览器支持的MIME类型<br>（MIME: Multipurpose Internet Mail Extensions,多用途互联网邮件扩展类型，是HTTP协议中迎来定义文档性质及格式的标准）<br>（对标服务端返回的Content-Type）<br><strong>Content-Type</strong><br>客户端发送出去实体内容的类型<br><strong>Cache-Control</strong><br>指定请求和响应遵循的缓存机制，比如no-cache<br><strong>if-Modified-Since</strong><br>对应服务端的Last-Modified，用来匹配看文件是否发生变动，只能精确到1s内<br><strong>Expires</strong><br>缓存控制，在这个时间内不会请求，直接使用缓存<br><strong>Max-age</strong><br>设置缓存有效时间（有效时间内不会请求而是使用缓存）<br><strong>if-None-Match</strong><br>对应服务器的ETag，用来匹配文件内容是否变动<br><strong>Cookie</strong><br>有cookie并且同域访问会自动带上<br><strong>Referer</strong><br>该页面的来源URL（适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用这个字段）<br><strong>Origin</strong><br>最初的请求是从哪里发起的（精确到端口）<br>Origin比Referer更保护隐私<br><strong>User-Agent</strong><br>用户客户端的一些必要信息，如UA头部<br>(UA:User Agent，用户代理)</p></blockquote><p>嗯，只有少数没印象</p><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>说了请求头，自然还得来响应头,说一说常见的几个</p><blockquote><p><strong>Content-Type</strong><br>服务端返回的实体内容的类型<br><strong>Cache-Control</strong><br>指定请求和响应遵循的机制，比如no-cache<br><strong>Last-Modified</strong><br>请求资源最后修改的时间<br><strong>Expires</strong><br>应该在什么时候认为资源已经过期并且不再缓存它<br><strong>Max-age</strong><br>客户端的本地资源应该缓存多少秒<br>（只有开启了Cache-Control才有效）<br><strong>ETag</strong><br>资源的特定版本的标识符，Etags类似于指纹<br><strong>Set-Cookie</strong><br>设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端<br><strong>Server</strong><br>服务器的一些相关信息<br><strong>Access-Control-Allow-Origin</strong><br>服务器端允许的请求Origin头部</p></blockquote><p>很好，对其中三四个有印象</p><p>进一步地，我们还需要重点学习其中提到的缓存</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>可以分为两类：</p><blockquote><p><strong>强缓存</strong><br><em>本地有缓存，则直接使用，这就是强缓存</em><br>Expires — 时间戳<br>Cache-Control —</p><ol><li>可缓存性：<br>   no-cache — 协商缓存验证<br>   no-store — 不使用任何缓存</li><li>到期：<br>   max-age — 存储的最大周期（相对于请求时间，单位是秒）</li><li>重新验证/重新加载<br>   must-revalidate — 如果资源过期，在成功向原始服务器验证之前，不能再使用</li></ol></blockquote><blockquote><p><strong>协商缓存</strong><br><em>本地有缓存，但是还需要和服务端协商判断该缓存状态（比如是否为最新版本的）才决定是否使用</em><br>Etag/If-None-Match — 资源的特有标识符，类似于指纹<br>Last-Modified/If-Modified-Since — 最后修改时间</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842810b59a6468a4f084f4efc419c8e58a2be2c80b3fcd51176/0.png" alt="缓存机制"></p><p>我们还得再进一步聊聊Cookie</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>我们通常只是给饼干一个名字和值，但是实际上还可以给它更多<br>Cookie包括以下内容<br>（响应头可以写在set-cookie字段的值）</p><blockquote><p><strong>Name = value</strong><br>设置名称<br><strong>Expires = Date</strong><br>设置有效期，缺省则默认为有效至浏览器关闭<br><strong>Path = Path</strong><br>指定cookie发送范围，默认为当前范围<br><strong>Domain = domain</strong><br>限制cookie生效的域名，默认为创建cookie的服务域名<br><strong>secure</strong><br>仅对HTTPS生效<br><strong>HttpOnly</strong><br>JS无法获取Cookie<br><strong>SameSite = [None|Strict|Lax]</strong><br>None:同站、跨站请求都可以发<br>Strict:仅在同站发送<br>Lax:允许与顶级导航一起发送，并将第三方网站发起的GET请求一起发送</p></blockquote><p>这里给出一个非常优雅的Cookie获取方式，为了方便称呼，我个人将其称为<strong>我爱Cookie算法</strong></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842810b59a6468a4f0888cc3221cd23d25dce4e9f6b558c2de5/0.png" alt="&quot;我爱Cookie&quot;算法"></p><p>另外，建议是后端来配置cookie</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>我们都知道多出来的S代表安全，<br>那么从本质上来说，<br>HTTPS究竟做了什么样的改动才变得更安全呢？<br>（总不能是把默认端口从80改到了443把）</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Hypertext Transfer Protocol Secure<br>相比HTTP来说，HTTPS多了一个TSL/SSL加密的过程<br>这个过程是在<strong>应用层和传输层之间</strong>完成的<br>这里提到了加密，那么又得学习两个概念：<br><strong>对称加密</strong><br>加密和解密用的同一个密钥<br><strong>非对称加密</strong><br>加密和解密需要使用两个不同的密钥，比如 公钥&amp;&amp;私钥</p></blockquote><h3 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h3><p>访问某个HTTPS协议的URL的验证过程：</p><blockquote><p>需要进行TLS握手，分为两个过程：对称加密和非对称加密</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684262bdd1851090ac95c22e96166ecd6088105de91696f5ce32/0.png" alt="TLS握手"></p><p>其中所谓的证书涉及到的概念如下</p><h3 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h3><blockquote><p>每个浏览器都会内置大量 证书机构（CA）签发的证书，这些证书是和私钥生成的，里面有证书机构的信息以及公钥，利用这些公钥即可解密，通过证书的内容判断签发者是否合法</p><p>当然，如果数字签名不够健壮的话，那么也可能被伪造，进而产生<strong>MITM中间人攻击</strong>的风险</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842810b59a6468a4f08f302aff72b4f2a23aeb79545c6d86956/0.png" alt="验证流程"></p><h2 id="静态资源部署"><a href="#静态资源部署" class="headerlink" title="静态资源部署"></a>静态资源部署</h2><h3 id="常用方案"><a href="#常用方案" class="headerlink" title="常用方案"></a>常用方案</h3><blockquote><p>缓存 + CDN + 文件名hash<br>CDN： Content Delivery Network<br>通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户提供请求</p></blockquote><h3 id="更新资源"><a href="#更新资源" class="headerlink" title="更新资源"></a>更新资源</h3><p>由于cookie保存时间可能设置得很长，那么旧版本的信息可能就长时间得不到替换更新，这时候，常见的一种处理操作就是更改这个信息文件的文件名，比如该版本号等等</p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p><strong>cross-origin</strong><br>是由于浏览器的Same-origin Policy同源策略导致的，只要协议（scheme）、域名（这里指的是host name，包括了domain和subdomain）、端口（port）有一个不一样，那么就形成了跨域</p><p><strong>同源策略</strong><br>即上述内容中提到的Same-origin Policy，简称SoP<br>协议、域名、端口均一致则为同源</p><p><strong>内容安全策略</strong><br>Content Security Policy，简称CSP<br>允许用户自定义被认为是安全的源（域名），对于安全源的脚本可以执行，否则直接抛出错误<br>此外，还可以直接拒绝eval和内联的script标签</p></blockquote><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><blockquote><p>大部分情况（指请求为复杂请求而非简单请求），发送预请求，获知服务端是否允许该跨域请求，这个请求的方法通常是options，如果允许则一如平常进行请求。</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><blockquote><p><strong>1.CORS</strong><br>大概就是后端配置一下Access-Control-Allow-Origin之类的<br><strong>2.代理服务器</strong><br>同源策略是浏览器的安全策略而不是HTTP的，所以只要用服务器绕开浏览器的限制就可以解决跨域<br><strong>3.Iframe/JSONP</strong><br>发送Iframe或者scirpt</p></blockquote><h2 id="Cookie、Session、Token"><a href="#Cookie、Session、Token" class="headerlink" title="Cookie、Session、Token"></a>Cookie、Session、Token</h2><p>我们以用户登录为背景，分析两种常见的模式</p><blockquote><p><strong>1.Session + Cookie</strong><br>Browser发送用户信息到Server试图登录，Server检验数据，如果匹配成功那么生成一个Session,（Session中最主要的是一个SessionID字段）Server会存储这个Session，并且放到响应头的Set-Cookie字段里面给Browser，这样Browser就拥有了一个带有Session的Cookie<br>由于HTTP请求是会自动带上Cookie信息的，所以在下次（Cookie有效期内）Browser试图登录的时候，就会自动将这个带有Session的Cookie发送给Server，Server根据这个Session就能直接响应而不会判断用户信息是否正确（当然如果SessionID被修改，那么服务器就无法识别了，也就不会响应）<br>这样就实现了用户登录一次之后，短时间内保持登录状态的效果</p></blockquote><blockquote><p><strong>2.JWT: JSON Web Token</strong><br>Browser发送用户信息到Server试图登录，Server检验数据，如果匹配成功那么生成JWT，其中包含一个独一无二的字符串（Token令牌），Server只保存这个Token，接着把JWT放到响应头里发送给Browser，这时候Browser通常会把这个JWT存储（查阅相关资料做了些研究后，个人推荐是放到localStorage里面）<br>在下次（有效期内）试图登录时，Browser从localStorage里拿出这个JWT放到请求头里一并发送到Server，Server会解析JWT然后提取其中的Token迅速给出响应<br>这样就实现了和第一种方法一样的效果</p></blockquote><p><strong>为什么需要这些技术?</strong></p><blockquote><p>从根本上说还是因为HTTP协议是无状态的，一个用户访问一次之后，下一次在访问，浏览器也不会发觉这是同一个人浏览的</p></blockquote><h3 id="优劣分析"><a href="#优劣分析" class="headerlink" title="优劣分析"></a>优劣分析</h3><blockquote><p><strong>Cookie + Session的弊端</strong></p></blockquote><ol><li>Cookie不是很安全，他人可以通过揣测Cookie名称等操作来进行Cookie欺骗</li><li>Cookie容量小，一个站点在Browser最多存放3k数据</li><li>Session会保存在Server，所以会占用服务器性能</li><li>据说，在服务器集群或者跨域服务导向架构中，Session的数据就需要共享，意味着每个服务器都需要读取它，这可能会造成负责分享的这个服务器的超载；如果说为了让各个服务器共享而把Session放到数据库中，如果数据库崩溃了，那么又会有问题</li><li>最大的问题：如果浏览器设置了禁用Cookie，那么随之而来的就是Session也无法简单地被使用了，各种问题也可想而知。</li></ol><p>由于上述问题的存在，我们必须有一种新的技术思路，那就是以JWT<br>这个技术的核心思想就是</p><blockquote><p><strong>前后端分别开辟一个空间存储用户信息</strong><br>这个新的技术就是JWT，<br>其具体工作流程上面说过了，此处不再赘述</p></blockquote><blockquote><p><strong>JWT的好处</strong></p></blockquote><ol><li>无状态，可扩展<br>Browswer存储的Tokens是无状态的，且能被扩展。<br>基于这种无状态和不存储session信息，负载均衡器能将用户信息从一个服务器传到其他服务器，能够实现数据共享</li><li>安全<br>请求中发送token而不再是cookie，能够防止CSRF跨站请求伪造。即使在客户端用cookie存储token，cookie也仅仅用于存储而不是认证（个人建议还是存到localStorage或者redis里面），并且token默认是有时间限制的，一段时间后用户就需要重新认证</li><li>多平台跨域<br>每次都是携带绑定自己信息的Token访问Server，在服务器集群中，不是访问某一台指定的服务器，而是通过从缓存服务器中拿出数据，并根据负载均衡器来选择服务器</li></ol><p>对于第2点中提到的安全，可能还需要进一步解释<br>由于JWT是存储在Browser的，但是它又是比较安全的，所以我们就需要从其结构上分析推导其原理</p><h3 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h3><p>JWT由三部分组成</p><blockquote><p><strong>1.header</strong><br>声明了需要用什么算法来生成Token<br><strong>2.payload</strong><br>包含一些特定的数据，比如有效期等<br><strong>3.signature</strong><br>将header和payload中的内容进行Base64编码生成字符串,<br>再根据编码之后的两个字符串，以header中声明的算法进行加密，<br>最终得到Token，Token是一个格式为xxx.xxx.xxx的字符串<br>也就是signature这部分的内容</p></blockquote><p>这三个部分是相互关联的，只要有一个部分被修改，三个部分都会出错</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Session是被Server创建、保存，<br>而Cookie则是一种数据载体，将Session发给Browser，<br>至于Token，是被Server创建，却被Browser保存</p><h2 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h2><p>既然说了Cookie、Session、Token那么自然也得学学本地存储了<br>Cookie可以作为信息的载体，也可以存储内容，但是一般不把Cookie放在Web存储的范围内<br>（Cookie大概是94年提出的技术，而Web存储是H5更新的内容）<br>（我们还是会把它和Web存储作比较，所以这里还是写出来）</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><blockquote><p>大小：4kb<br>兼容：支持H4、H5<br>访问情况：任何同源的窗口都可以访问<br>有效期：手动设置，默认为直到结束</p></blockquote><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><blockquote><p>永久存储数据，直到手动删除，本身并不直接参与通信<br>但是是同步的，可能会影响渲染速度<br>大小：10Mb<br>兼容：H5<br>访问情况：任何同源的窗口都可以访问<br>有效期：永久，直到手动删除</p></blockquote><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><blockquote><p>会话期间存储数据，结束则删除<br>大小：5Mb<br>兼容：H5<br>访问情况：仅同一窗口可以访问（安全性高）<br>有效期：直到结束</p></blockquote><h3 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h3><blockquote><p>暂时还没研究</p></blockquote><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h3><p>其实可以直接看红宝书的，但是还是写一遍加深印象吧</p><blockquote><p>0: UNSET<br>代理已经被创建，但是尚未调用open()方法<br>1: OPENED<br>open()已经被调用<br>2: HEADERS_RECEIVED<br>send()方法已经被调用，且头部和状态已经可获取<br>3: LOADING<br>下载中，responseText属性已经包含部分数据<br>4: DONE<br>下载操作已经完成</p></blockquote><h2 id="其他通信方式"><a href="#其他通信方式" class="headerlink" title="其他通信方式"></a>其他通信方式</h2><p>没错说的就是WebSocket，它相较于HTTP的优点就是它是全双工的，适合对实时性要求比较高的场景，其URL是使用ws://或者wss://开头</p>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序开发</title>
      <link href="/2022/01/13/miniprogram/"/>
      <url>/2022/01/13/miniprogram/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>熟悉的也好，陌生的也好，方向要自己去寻找。</p><p>学做小程序，同时在学着用JS做算法，真的很想吐槽其堪称腌臜的输入方式，但是在做了一下青训的笔试题之后感到自己就像是膨胀的肥皂泡，来硬的一戳就破——还有太多路要走，还得加油！</p><p>每当我读文档、博客或者视频等各种学习资料，看到技术的发展和更迭，以及编写者、讲述人的故事和过往，我就仿佛在走近一段历史岁月，日新月异变迁中不仅是技术的进步，更有着人物的沧桑——大概真是如此，世上半数人都可谓传奇！</p><p>那么如果有一天，有人读到我这一篇博文，那么是否也会产生和我相仿的情感呢？</p><p>不论如何，计算机真是一个充满理想浪漫主义色彩的领域啊！就像是我曾看到一名物理学子高呼愿去宇宙的最深处追寻纯真的世界那般，我也希望通过二进制让世界成为我的画布——</p><p>现在，继续前行吧！</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/13</strong><br>读了些文档，看了点视频，写了点代码，先把提纲理好</p><p><strong>2022/01/14</strong><br>我敲，今天下午一点才醒，我是废物啊</p><p><strong>2022/01/15</strong><br>我…下午两点半醒的….不说的，今天的题晚上再做，先把技术学了尽快上线一个小程序</p><p><strong>2022/02/01</strong><br>更新自定义组件部分</p><p><strong>2022/02/02</strong><br>更新走近小程序、进阶开发技巧和分包</p></blockquote><h2 id="走近小程序"><a href="#走近小程序" class="headerlink" title="走近小程序"></a>走近小程序</h2><h3 id="小程序发展史"><a href="#小程序发展史" class="headerlink" title="小程序发展史"></a>小程序发展史</h3><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842ad1905841601332d64d6083a5c53612af48b74d47ac38b0a/0.png" alt="2017-2018"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842ad1905841601332d76f00e25d7460a9b56436270093eb966/0.png" alt="2018-2019"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842ad1905841601332d1664f87ee4a1f496095e2fafab3d893a/0.png" alt="2019-2020"></p><p>当然，2020-2022也有很多发展，不过这里就不一一例举了</p><h3 id="各种小程序"><a href="#各种小程序" class="headerlink" title="各种小程序"></a>各种小程序</h3><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842ad1905841601332dc4927b9e00c1352b8cdc93a072125c03/0.png" alt="各种小程序"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842ad1905841601332db1de88bebcfccd85707d59441b2c3bee/0.png"></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>众所周知，小程序开发语言的语法是参照了前端框架的，具体参照对照如下表</p><table><thead><tr><th>Vue</th><th>美团（mpvue）、网易（megalo）、京东（taro）、Hbuilder（uni-app）、腾讯（?）</th></tr></thead><tbody><tr><td><strong>React</strong></td><td><strong>蚂蚁金服（remax）、京东（taro）</strong></td></tr></tbody></table><h2 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h2><h3 id="常用基础标签"><a href="#常用基础标签" class="headerlink" title="常用基础标签"></a>常用基础标签</h3><p>标签太多了，这里只举出基础的、常见的标签的部分知识点，更多细致内容参考官方文档</p><p><strong>view</strong></p><blockquote><p>块级，可以看做div标签<br>其衍生的标签还有scroll-view，可以看做加上了滚动条的div标签</p></blockquote><p><strong>block</strong></p><blockquote><p>行内元素（就离谱，明明叫block）</p><p>相当于span标签</p></blockquote><p><strong>image</strong></p><blockquote><p>不用我说也知道是img</p><p>用法基本一致</p></blockquote><p><strong>swiper</strong></p><blockquote><p>轮播图，结合其衍生的swiper-item标签配套使用</p><p>具体使用方式和大部分组件库中的轮播图一致</p></blockquote><p><strong>text</strong></p><blockquote><p>行内元素</p><p>特点是能够长按选中复制</p><p>衍生的rich-text标签能够当做iframe使用</p></blockquote><p><strong>button</strong></p><blockquote><p>和原来一样，但是注意点击事件在这里变成了按下-抬起事件（bindtap）</p></blockquote><p><strong>全局配置</strong></p><p>在app.json中：</p><blockquote><p>pages选项里依葫芦画瓢地添加新的内容后，就添加了新页面的存放路径，并且将会自动创建其相关文件</p><p>window中可以全局设置小程序窗口的外观，包括navigationBar（指的是手机最上面显示电量的那一行），background（下拉时可见）和页面主体部分</p><p>tabBar就是设置tabBar，tabBar就是平时写的navigator那种东西，这里可以设置位置、路由等等</p><p>style中可以设置是否启用新版组件，其中v2是新版，注释这一段代码即可回到旧版</p></blockquote><p>具体配置细则可参见官方文档</p><h2 id="常用小程序API"><a href="#常用小程序API" class="headerlink" title="常用小程序API"></a>常用小程序API</h2><h3 id="事件监听API"><a href="#事件监听API" class="headerlink" title="事件监听API"></a>事件监听API</h3><h3 id="同步API"><a href="#同步API" class="headerlink" title="同步API"></a>同步API</h3><h3 id="异步API"><a href="#异步API" class="headerlink" title="异步API"></a>异步API</h3><h2 id="协同开发权限管理"><a href="#协同开发权限管理" class="headerlink" title="协同开发权限管理"></a>协同开发权限管理</h2><h2 id="全局、局部数据和方法"><a href="#全局、局部数据和方法" class="headerlink" title="全局、局部数据和方法"></a>全局、局部数据和方法</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>点进index.js一看，哎呀好家伙，这不是咱mustache吗！</p><blockquote><p>虽然知道mustache语法支持运算，但是一直没有意识到可以进行三目运算——如果可以进行三目运算的话，那么就可以配合逗号运算符做一些奇妙的操作了</p></blockquote><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>还记得事件的概念吗？不记得就倒立喝水同时大声朗读下述文字</p><blockquote><p>事件是渲染层到逻辑层的通讯方式，通过事件可以将用户在渲染层产生的行为，反馈到逻辑层进行业务的处理</p><p>可以说，事件是渲染层到逻辑层的通讯方式</p></blockquote><p><strong>独特的参数传递方式</strong></p><p>小程序的事件传参比较特殊，比如下述代码</p><p><strong>是错误的</strong><br><strong>是错误的</strong><br><strong>是错误的</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span> <span class="token attr-name">bindtap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Count(123)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>上述内容在微信小程序中是被理解为一个叫做”Count(123)”的方法，传递参数的正确形式应该是下面这样</p><p><strong>其中data-xxx=”<code>{{}}</code>“是传递参数的格式，xxx为参数的名称，而花括号内的则为参数的值</strong></p><p>（如果不使用mustache传参，那么传递的就是文本字符串）</p></blockquote><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span> <span class="token attr-name">bindtap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Count<span class="token punctuation">"</span></span> <span class="token attr-name">data-abc</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{{123}}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中的bindtap是绑定触屏事件，也可以写做bind:tap<br>类似的还有bindinput绑定输入事件，bindchange绑定状态改变事件等等（更多的事件自己查官方文档）</p><p>data-xxx=“yyy”，表示传递一个参数xxx，值为yyy，其中data-是固定写法</p><p>函数中则通过调用事件对象即可拿到参数:</p><blockquote><p>e.currentTarget.dataSet</p></blockquote><h2 id="条件渲染和列表渲染"><a href="#条件渲染和列表渲染" class="headerlink" title="条件渲染和列表渲染"></a>条件渲染和列表渲染</h2><p>其实说的就是wx:if=””和wx:for=””</p><p>同样地，要使用mustache语法，而且对于列表渲染来说，最好指定一个wx:key=””（没错就是因为diff算法）</p><h2 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h2><p>几乎完全移植了CSS的选择器和常用的样式属性（意思是也有相当一部分属性没有被移植），然后也进行了一些扩展加入了很多特有的内容（比如超强的自适应单位rpx，还有@import导入CSS）</p><h3 id="rpx"><a href="#rpx" class="headerlink" title="rpx"></a>rpx</h3><p>总是会把宽度750等分，然后根据实际尺寸做相应的适配</p><p>与px的换算就很简单了，直接750rpx == （实际尺寸大小）px就可以了</p><h3 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h3><p>在WXSS中使用，其后加上路径即可将其他文件中的WXSS导入进来</p><p>当然，如果有需要的话，可以考虑在app.wxss中写，这个就是直接对全局生效的</p><h2 id="网络数据请求"><a href="#网络数据请求" class="headerlink" title="网络数据请求"></a>网络数据请求</h2><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p><strong>和AJAX的区别</strong></p><p>微信小程序开发是基于客户端的，而AJAX的核心技术是依赖浏览器的XMLHttpRequest对象的，所以小程序中这种并不是AJAX请求，而是<strong>发起网络数据请求</strong>，而且<strong>不存在跨域问题</strong></p><p><strong>请求权限</strong></p><p>需要先登录微信开发后台，然后配置一下域名信息，只有设置了目标URL等相关信息才能进行相关URL下的网络数据请求</p><p><strong>相关使用</strong></p><p>通过配置wx.request({})发起网络数据请求，</p><p>其中的wx对象和window对象类似，可以看做是BOM的一种</p><h2 id="WXS"><a href="#WXS" class="headerlink" title="WXS"></a>WXS</h2><h3 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h3><blockquote><p>页面导航是指的页面之间的相互跳转</p></blockquote><p>在浏览器中我们一般采用两种形式实现上述功能，一种是a标签，另一种是location.href</p><p>而在小程序中，类似地，我们可以通过navigator标签，或者小程序的导航API来实现</p><p>这两个例子中，前者都可以认为是<strong>声明式导航</strong>，后者均可以认为是<strong>编程式导航</strong></p><p><strong>声明式导航</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>navigator</span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/pages/index/index<span class="token punctuation">"</span></span> <span class="token attr-name">open-type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>switchTab<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>导航1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>navigator</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>navigator</span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/pages/<span class="token punctuation">"</span></span> <span class="token attr-name">open-type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>navigate<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>导航2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>navigator</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://serio.gitee.io<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>跳转3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第一种形式是导航到tabBar页面，何为tabBar页面？即app.json中配置了路径的页面</p><p>第二种则是用于导航到非tabBar页面</p><p>第三种似乎在微信小程序中失效了？（但是标签有自动补全，具体情况有待考证）</p><p>另外，我们可以设置open-type为navigateBack使点击这个按钮的效果变为回退，并且可以设置delta为n从而实现指定回退n级页面</p><p><strong>编程式导航</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">wx<span class="token punctuation">.</span><span class="token function">switchTab</span><span class="token punctuation">(</span><span class="token punctuation">{</span>   url<span class="token operator">:</span> <span class="token string">'url'</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>wx<span class="token punctuation">.</span><span class="token function">navigateTo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>   url<span class="token operator">:</span> <span class="token string">'url'</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样，</p><p>第一种是导航到tabBar页面，</p><p>第二种是导航到非tabBar页面</p><p>并且也能设置后退，此处不再赘述，具体信息查看官方文档</p><p><strong>导航传参</strong></p><p>就是url?yyy=xxx&amp;yy=xx这样的</p><p>要知道左下角可以查看页面参数</p><p>而且，参数可以直接在生命周期函数onload的默认参数中找到</p><h3 id="下拉刷新-和-上拉触底"><a href="#下拉刷新-和-上拉触底" class="headerlink" title="下拉刷新 和 上拉触底"></a>下拉刷新 和 上拉触底</h3><blockquote><p>注意上拉和下拉，上拉是手指由下往上（下拉反之），说的是手指不是页面</p></blockquote><p><strong>下拉刷新</strong></p><p>分为全局和局部，但是都是将enablePullDownRefresh设置为true</p><p>另外，下拉刷新的loading效果不会主动消失，需要手动处理，这时候只需要调用wx.stopPullDownRefresh()就可以了</p><p>除了这种loading以外，还可以通过wx.showLoading来主动展示并且通过wx.hideLoading来隐藏 </p><p><strong>上拉触底</strong></p><blockquote><p>手指向上滑动，从而加载更多数据</p><p>大部分时候用于实现分页数据请求</p></blockquote><p>实现是在js文件中，通过onReachBottom()监听</p><p>所谓触底，也并非和底部距离为0，默认是50rpx，可以通过在配置文件中修改onReachBottomDistance属性来更改</p><p>另外，记得对上拉触底做一下节流处理，其中的一个技巧是，方法内存在生命周期函数complete，利用好这一点可以更方便地处理</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><blockquote><p>Life Cycle，和Vue差不多，具体有什么生命周期函数直接看文档，这里挑重点记一下概念</p></blockquote><p>这里的生命周期存在一个分类：</p><p><strong>应用生命周期</strong></p><p>启动-&gt;运行-&gt;销毁</p><p><strong>页面生命周期</strong></p><p>加载-&gt;渲染-&gt;销毁</p><p>其中，页面的生命周期范围较小，应用程序的生命周期范围较大，总的来看，整体的周期是：</p><p>启动-&gt;页面1的生命周期-&gt;页面2的生命周期-&gt;etc…-&gt;销毁</p><h3 id="WXS脚本"><a href="#WXS脚本" class="headerlink" title="WXS脚本"></a>WXS脚本</h3><blockquote><p>WeiXin Script，小程序独有的一套结构</p><p>和JS类似但是不一样，本质上还是两种语言，WXS有以下几个比较重要的特点：</p><p><strong>1.有自己的数据类型</strong></p><p><strong>2.不支持类似ES6及以上的语法形式</strong></p><p><strong>3.遵循CommonJS</strong></p><p>看到这些我就大胆猜测一手，一定就是你——NodeJS！</p><p><strong>4.有隔离性，一是wxs和JS不能相互使用，而是wxs不能调用小程序的API</strong></p><p><strong>5.性能更好，IOS设备上WXS会比JS快2-20倍，但是在Android上无差异</strong></p><p>我缓缓打出一个？</p></blockquote><p>wxml中无法调用页面级js文件中定义的函数，但是wxml可以调用wxs中的函数。所以小程序中的wxs应用的典型场景就是 <strong>过滤器</strong>（没错就是filter）</p><p><strong>使用</strong></p><p><strong>内嵌式</strong></p><p>在wxml文件中写一个wxs标签，并且每一个wxs标签都必须具有一个module属性用于指明当前wxs的模块名称，此后在wxml中可以将wxs当做一个对象来使用，可以通过module属性指明的名称来访问其中定义的方法和变量——没错嘛这不就是还没exports的模块的使用方法吗</p><blockquote><p>那么，这和过滤器有什么关系呢？</p><p>没错，我们这里可以处理数据，但是又不会修改js文件中的数据，这就是过滤的效果</p></blockquote><p><strong>外联式</strong></p><p>目录下创建一个文件，然后单独写，最后exports即可</p><p>但是导入不是用require，而是利用wxs中的src属性</p><h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p><strong>1.创建组件</strong><br>在项目的根目录中，鼠标右键，创建components -&gt; test文件夹<br>在新建的components -&gt; test文件夹上，鼠标右键，点击“新建Component”<br>键入组件的名称之后回车，会自动生成组件对应的4个文件，后缀名分别为.js，.json，.wxml和.wxss</p><blockquote><p>组件和页面的区别：</p><p>1.组件的配置文件中的component字段值为true</p><p>2.组件的.js中调用的是Component()函数(可能是构造函数)</p><p>3.组件的事件处理函数需要定义到methods节点中</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684297fd0d5e89c4cb6b57f9259d5e4e3809fb0e08dc7483be9c/0.png" alt="文件结构"></p><p>不同于Vue，组件的wxml文件中并不要求唯一一个标签包裹其余所有标签</p><p><strong>2.局部引入组件</strong></p><p>在配置文件中写：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token string">"usingComponents"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"a-good-component"</span><span class="token operator">:</span> <span class="token string">"/components/test/test1"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中test1是组件文件的名字</p><p>然后要使用这个组件的话，只需要在wxml中写：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a-good-component</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a-good-component</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3.全局引入组件</strong></p><p>在全局配置中新增字段</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token string">"usingComponents"</span><span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token string">"a-good-component"</span><span class="token operator">:</span> <span class="token string">"/components/test/test1"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其余一样</p><p><strong>4.区别于页面</strong></p><blockquote><ol><li>组件的.json文件中需要声明”component” : true属性</li><li>组件的.js 文件中调用的是Component()函数组件的事件</li><li>处理函数需要定义到 methods节点中，而页面则是直接放到page内</li><li>页面的自定义函数传参可以通过event.target.dataset获取，组件则有专门的properties负责接收数据</li></ol></blockquote><h3 id="样式隔离"><a href="#样式隔离" class="headerlink" title="样式隔离"></a>样式隔离</h3><p>组件之间的样式不会相互影响，也不会受到引用它的页面的样式的影响，包括全局样式也对组件无效</p><blockquote><p>一个中肯但是不知道为什么如此的建议是：<strong>在组件样式中不要使用除了class以外的选择器</strong></p></blockquote><p>如果希望破坏这种隔离性的话，可以修改其配置文件中的styleIsolation字段的值为isolated</p><p>或者在js文件中写如下代码也能达到同样的效果：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    options<span class="token operator">:</span> <span class="token punctuation">{</span>        styleIsolation<span class="token operator">:</span> <span class="token string">'isolated'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="父向子传参"><a href="#父向子传参" class="headerlink" title="父向子传参"></a>父向子传参</h3><p>是熟悉的属性绑定语法</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token comment">// 属性定义的完整方式</span>    properties<span class="token operator">:</span> <span class="token punctuation">{</span>         type<span class="token operator">:</span> Number<span class="token punctuation">,</span> <span class="token comment">// 指定类型</span>        value<span class="token operator">:</span> <span class="token number">10</span>  <span class="token comment">// 默认值</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token comment">// 属性定义的简化版</span>    name<span class="token operator">:</span> String      <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传参直接如下图所示，不需要有额外的关键字，直接写就行了</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a-good-component</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>沈俞佑<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a-good-component</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>properties中可以写一些键值对，和data类似</p><blockquote><p>1.properties和data都是可读可写的</p><p>2.data更倾向于存储私有组件的私有属性</p><p>3.properties更倾向于存储外界传递到组件中的值</p><p>4.this.data === this.properties 的结果是true，所以使用this.setData也是可以对this.properties起作用的</p></blockquote><h3 id="数据监听器"><a href="#数据监听器" class="headerlink" title="数据监听器"></a><strong>数据监听器</strong></h3><p>类似于Vue的watch，是监听数据而不是事件</p><p>在组件的methods方法列表内除了写方法之外还能写监听器等</p><p>添加以下字段对n1,n2进行监听</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">observers<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">'n1, n2'</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newN1<span class="token punctuation">,</span> newN2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842d7aa5377124ce70b8843e0e8f092ea5867dae5625a0e2058/0.png"></p><p>即使是在this.setData方法里面，后面的值也要用this.data.xxx访问</p><p>当然，也可以监听某个对象的属性——是个值都能监听</p><h3 id="纯数据字段"><a href="#纯数据字段" class="headerlink" title="纯数据字段"></a>纯数据字段</h3><p>只是一个概念性的东西，知道就行</p><blockquote><p>指不用于界面渲染的data字段，既不会展示在页面上，也不会传递给其他组件，<strong>仅在其所属组件的内部使用</strong></p></blockquote><h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p>不再赘述</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842d7aa5377124ce70be528a816990658073ed67ea9851b805d/0.png"></p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>单个slot没什么好说的，就当看一遍复习了</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrapper<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>小广告<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ad</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>image</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://p.qlogo.cn/hy_personal/3e28f14aa0516842d7aa5377124ce70be528a816990658073ed67ea9851b805d/0.png<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>image</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ad</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，如果有多个插槽，那么操作就有点不一样了</p><p>首先要在启用多slot的组件的js文件中 与 data等字段平级的位置添加一个options字段，并设置multipleSlots: true</p><p>然后又是一套基本操作了</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrapper<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>before<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>小广告<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>after<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ad</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>after<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>slot写上插槽名字就好了<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ad</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="子向父传参"><a href="#子向父传参" class="headerlink" title="子向父传参"></a>子向父传参</h3><p>是学过但是依旧不是很熟练的自定义事件</p><p>（以前每次都是去现查一遍再用…并且能不用就不用，就算用了也会因为搞不清到底有几个事件而把所有事件都命名相同）</p><p>使用步骤如下:</p><blockquote><ol><li>在父组件的js 中，定义一个函数</li><li>在父组件的wxml中，通过自定义事件的形式，将步骤1中定义的函数引用，传递给子组件</li><li>在子组件的js中，通过调用<code>this.triggerEvent('自定义事件名称'，{ /*参数对象*/ })</code>，将数据发送到父组件</li><li>在父组件的js中，通过e.detail获取到子组件传递过来的数据</li></ol></blockquote><p>简明扼要说一下就是：</p><blockquote><p>父级给个函数，子级用this.triggerEvent自定义一个事件，在父级用e.detail就能接收到数据</p></blockquote><p>绑定事件的时候需要用到<strong>关键字bind:xxx</strong>，注意这里似乎没有缩写为:xxx这样的语法糖，但是可以直接写作bindxxx(离谱吧，没错我也觉得离谱)</p><p>比如bindtap实际上也可以写作bind:tap</p><blockquote><p>知道真相的我大为震撼！</p></blockquote><h3 id="获取组件实例"><a href="#获取组件实例" class="headerlink" title="获取组件实例"></a>获取组件实例</h3><p>也可以用这种方式来进行父子间通信</p><p>在父组件中调用**this.selectComponent( id选择器/class选择器 )**来获取子组件的实例对象，这样就能够使用子组件内部的所有数据了</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ad</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ad-one<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>image</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://p.qlogo.cn/hy_personal/3e28f14aa0516842d7aa5377124ce70be528a816990658073ed67ea9851b805d/0.png<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>image</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ad</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">bindtap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getChild<span class="token punctuation">"</span></span> <span class="token attr-name">data-name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{{<span class="token punctuation">'</span>#ad-one<span class="token punctuation">'</span>}}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>获取#ad-one的信息<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">getChild</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">selectComponent</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>currentTarget<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="behaviors"><a href="#behaviors" class="headerlink" title="behaviors"></a>behaviors</h3><blockquote><p>behaviors是小程序中，用于实现<strong>组件间代码共享</strong>的一种特性，类似Vue中的mixins（mixins是啥啊）</p><p>每个behavior都可以包含一组属性、数据、生命周期函数和方法，<br>组件引用它时，属性、数据和方法等z会合并到组件中，<br>behavior也可以引用behavior</p><p><strong>总结一下</strong><br>wxml有模板可以用，那么这里就大胆地把JS也搞一个模板，这个模板就是behavior</p></blockquote><p><strong>创建一个behavior</strong></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684283b1d08f593bedd6879b1b14048319474c9836c37cc6cee9/0.png"></p><p><strong>导入一个behavior</strong></p><p>注意behavior字段的值是以数组的形式进行存储的</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684283b1d08f593bedd6d76ca82aac58e0b583467bceac458a40/0.png"></p><p><strong>使用behavior的数据</strong></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684283b1d08f593bedd6ba5f641b5df51ca7d237aa5bd6d379b8/0.png"></p><p>那么什么时候使用behavior呢？</p><p>还记得曾经苦恼过的——开发vue项目的过程中，总是感慨应该把复用多次的xxx函数先封装到一个JS文件里面的——这时候我们就该想到behavior了！</p><p>但是这时候又出现了新的问题，如果behavior中属性和调用组件已有的属性冲突，那么这些属性将会怎么被处理呢？这就是我们需要思考的新问题了</p><p><strong>同名字段的覆盖和组合规则</strong></p><blockquote><p>组件和它引用的behavior中可以包含同名的字段，此时可以参考如下3种同名时的处理规则</p><p><strong>1.同名数据字段（data)</strong></p><ol><li>如果都是对象类型，那么会发生对象合并（那么问题来了，这时候属性名有重复了咋办）</li><li>其余情况则和<strong>↓↓↓第2点↓↓↓</strong>中提到的一致</li></ol><p><strong>2.同名属性（properties和methods）</strong></p><ol><li>组件自身的优先</li><li>behavior内部出现重复属性则靠后的优先</li><li>behavior调用behavior时，父级优先</li></ol><p><strong>3.同名生命周期函数</strong></p><ol><li>不同生命周期则会依次执行</li><li>相同生命周期则和<strong>↑↑↑第2点↑↑↑</strong>中的一致</li></ol></blockquote><h2 id="进阶开发技巧"><a href="#进阶开发技巧" class="headerlink" title="进阶开发技巧"></a>进阶开发技巧</h2><h3 id="使用npm"><a href="#使用npm" class="headerlink" title="使用npm"></a>使用npm</h3><p>可以使用npm但是在小程序中多了如下三点限制：</p><blockquote><ol><li>不支持依赖于Node.js内置库的包</li><li>不支持依赖于浏览器内置对象的包</li><li>不支持依赖于C++插件的包</li></ol></blockquote><p>当时我就知道能用的没多少了</p><p>但是我们可以安装 <strong>Vant Weapp、uni-app</strong>等UI库帮助我们开发</p><p>当然，小程序里面使用npm安装也没那么方便就是了，还得手动配置一些东西…</p><blockquote><p>npm下载之后东西会放到node_module文件夹下，</p><p>但是小程序不争气啊没法直接用，还得先<strong>构建</strong>才能用</p></blockquote><p><strong>构建</strong></p><p>根目录下有个文件夹：miniprogram_npm</p><p>这之中的包可以被小程序直接使用，而要构建这个文件夹，首先需要正常npm操作一波，然后点击这里：</p><p><img src="E:/blog/blog/source/_posts/MiniProgram.assets/image-20220202145951115.png"></p><p>之后如果再添加新的包，那么再构建npm可能会不生效，这时候我们把miniprogram_npm文件夹删了重新构建就好了</p><p>当然，不同的包在安装的时候可能有不同的要求</p><p>具体安装和使用方式参考官方文档，此处不再赘述</p><h3 id="API的Promise化"><a href="#API的Promise化" class="headerlink" title="API的Promise化"></a>API的Promise化</h3><blockquote><p> Promise是为了解决回调地狱而出现的</p></blockquote><p>在小程序中要使用Promise的话需要先用npm安装一下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install --save miniprogram-api-promise<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此后构建一下miniprogram_npm，之后在app.js中书写如下代码进行全局promise化</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span>promisifyAll<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'miniprogram-api-promise'</span><span class="token keyword">const</span> wxp <span class="token operator">=</span> wx<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">promisifyAll</span><span class="token punctuation">(</span>wx<span class="token punctuation">,</span> wxp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这之后，wx对象中的所有API都会有一个pormise化的版本，而这些新版本会被放到wxp和wx.p对象上</p><p>页面的js文件中，定义对应</p><h3 id="全局数据共享"><a href="#全局数据共享" class="headerlink" title="全局数据共享"></a>全局数据共享</h3><p><strong>概念</strong></p><p>没错，可以类比Vuex、Redux、Mobx等等</p><blockquote><p>也称为状态管理</p><p>小程序的实现方式是通过<strong>mobx-miniprogram</strong>配合<strong>mobx-miniprogram-bindings</strong>实现全局数据共享</p><p>其中，<br>mobx-miniprogram用来<strong>创建</strong>Store实例对象<br>mobx-miniprogram-bindings用来把Store中的共享数据或方法<strong>绑定</strong>到组件或页面中使用</p></blockquote><p><strong>安装</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install --save mobx-miniprogram mobx-miniprogram-bindings<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后又是基本的构建操作</p><p><strong>创建store实例</strong></p><p>在根目录下创建Store文件夹，里面再新建一个store.js，我们将用这个js文件专门来创建store实例对象</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>observable<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'mobx-miniprogram'</span><span class="token keyword">export</span> <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">observable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token comment">// 数据字段</span>    num1<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    num2<span class="token operator">:</span> <span class="token number">2</span>    <span class="token comment">// get修饰符： 计算属性，类似于watch</span>    <span class="token keyword">get</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num1 <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num2<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">// actions 方法，用来修改 store 中的数据，</span>  <span class="token comment">// 外界调用updateNum即可触发内部函数</span>     updateNum1<span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">step</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>num1 <span class="token operator">+=</span> step     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     updateNum2<span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">step</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>num2 <span class="token operator">+=</span> step     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>页面绑定store</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> createStoreBindings <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'mobx-miniprogram-bindings'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> store <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../../store/store'</span><span class="token function">Page</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token comment">// 生命周期上挂一下</span>    <span class="token function-variable function">onLoad</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>storeBindings <span class="token operator">=</span> <span class="token function">createStoreBindings</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            store<span class="token punctuation">,</span><span class="token comment">// 数据源</span>            fields<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'num1'</span><span class="token punctuation">,</span> <span class="token string">'num2'</span><span class="token punctuation">,</span> <span class="token string">'sum'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 当前页面需要的数据字段</span>            actions<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'updateNum1'</span><span class="token punctuation">]</span><span class="token comment">// 当前页面需要的方法</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function-variable function">onUnLoad</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>storeBindings<span class="token punctuation">.</span><span class="token function">destoryStoreBindings</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>页面使用store</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 依旧是this访问就行了</span><span class="token function">xxxFun</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateNum1</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>step<span class="token punctuation">)</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>组件绑定store</strong></p><p>要额外给一个storeBindingsBehavior来过渡，</p><p>暂时不清楚为什么要这么设计</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> storeBindingsBehavior <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'mobx-miniprogram-bindings'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> store <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../../store/store'</span><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    behaviors<span class="token operator">:</span><span class="token punctuation">[</span>storeBindingsBehavior<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 通过storeBindingsBehavior自动绑定</span>    storeBindings<span class="token operator">:</span><span class="token punctuation">{</span>        store<span class="token punctuation">,</span>        fields<span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token function-variable function">num1</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> store<span class="token punctuation">.</span>num1<span class="token punctuation">,</span>   <span class="token comment">// 绑定字段的第1种方式</span>            <span class="token function-variable function">num2</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">store</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> store<span class="token punctuation">.</span>num2<span class="token punctuation">,</span>  <span class="token comment">// 绑定字段的第2中方式</span>            sum<span class="token operator">:</span> <span class="token string">'sum'</span><span class="token comment">// 绑定字段的第3种方式，前两者也可以这么写</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用还是那么使用</p><p>如果需要在wxml中使用，那么遵循mustache语法使用就好了</p><h2 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>把一个完整的小程序分为不同的子包，用户使用时可以按需进行加载</p></blockquote><p>好处就是优化了小程序首次启动的下载时间，在多团队合作的之后有更好的解耦协作</p><p><strong>分包前后对比</strong></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842f31e86df92f8a1ffe63e0933e4c70b74929a6d3fa3f9f0c6/0.png" alt="分包前"></p><p>分包之后，小程序变为由1个主包 + n个分包</p><blockquote><p><strong>主包</strong><br>一般只能包含项目的启动页面或TabBar页面、以及所有分包需要用到的一些公共资源</p><p><strong>分包</strong><br>只包含和当前分包有关的页面和私有资源</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842f31e86df92f8a1ff8cb3c4c5a6819c9942a6ce04a5d3e6db/0.png" alt="分包后"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842f31e86df92f8a1ff9b0c5d03f26d43df33acf8e712a86652/0.png" alt="分包目录结构"></p><p>可以在app.json文件中的subpackages字段里面以类似路由配置的形式进行管理</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842f31e86df92f8a1ff6162b5c95cc52e5582f9ed675cb7188b/0.png" alt="app.json内的subpackages字段"></p><p>如果编辑这一部分，那么保存后会自动创建响应的文件</p><p>subpackages之内是写的分包，之外的内容则是主包</p><p>注意分包之内不能相互嵌套</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>加载规则</strong></p><blockquote><ol><li>小程序启动时，默认会下载主包并启动主包内页面</li></ol><p>（所以tabBar放主包里面）</p><ol start="2"><li>用户访问某个分包页面的时候，客户端会把对应包下载下来</li></ol></blockquote><p>我寻思，这不就是个懒加载吗，说的这么高级….</p><p><strong>大小限制</strong></p><blockquote><p>一个包不能超过2M，所有包加起来不能超过20M</p><p>(当然这个具体数值是随着技术发展不断增加的，但是一定要知道每个包大小是需要控制的)</p></blockquote><p>我寻思着公共资源文件夹里面塞个图片那不是直接爆炸吗…</p><h3 id="独立分包"><a href="#独立分包" class="headerlink" title="独立分包"></a>独立分包</h3><blockquote><p>一种特殊的分包，可以不依赖主包独立运行</p><p>独立分包与其他分包之间<strong>相互隔绝</strong>，不能相互引用资源</p></blockquote><p>这种设计应该应用于什么样的场景呢？</p><p>有的功能不依赖主包即可运行，但是进入小程序时却需要默认下载主包——这时候就该独立分包了</p><p>而设置独立分包的操作也非常容易实现，只需要在app.json对每个包的设置中加上<strong>independent</strong>字段并设置为true</p><h3 id="预下载"><a href="#预下载" class="headerlink" title="预下载"></a>预下载</h3><blockquote><p>在进入某个页面时，由框架自动预先下载好之后可能需要的分包，从而优化进入后续分包页面的速度</p></blockquote><p>在app.json中使用preloadRule字段配置预下载：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842729a2b71db44bd900d2fcb03d310c45999cb144a0ec6e9fc/0.png"></p><p>一个分包的预下载大小限额：2M，超出的部分会下载失败</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>（这部分后面再更）</p>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/01/10/internet/"/>
      <url>/2022/01/10/internet/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>计算机网络可以说是我第二重视的专业基础课了，因为网络这个概念早已深入千家万户，在我没有正式进入计算机这个专业之前，就已经有了对网络的体会——网络为生活提供了不少便利，所以我对网络有一种亲切和敬仰的感觉</p></blockquote><blockquote><p>嗯？你问我为什么是第二重视的？因为第一是数据结构和算法啊——虽然我学的很烂就是了，不过我会努力补上的！</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/04</strong><br>1月10号考试，现在基本上还算是零基础（<del>对计网极其重视</del> ），教务处老师给个机会，我真的很热爱计网啊！<br><strong>2022/01/04</strong><br>真不错，明天下午考试，今天刚把视频粗略地刷了一遍，常考的大题看了一遍，笔记肯定是没时间写得非常细致了，这里先把重要的内容记下来吧！</p></blockquote><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p><strong>概念</strong></p><blockquote><p>计算机网络:是一个将<strong>分散</strong>的、具有<strong>独立功能</strong>的<strong>计算机系统</strong>，通过通信设备与线路连接起来，由功能完善的软件实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统。<br>分散是指地理位置分散<br>独立功能是指组成计算机网络的各个计算机功能不同</p></blockquote><p>上述内容可以简单总结为：</p><blockquote><p>计算机网络是互连的、自治的计算机集合<br>互连 即 互联互通<br>自治 即 无主次关系</p></blockquote><p><strong>功能</strong></p><blockquote><p>1.<strong>数据通信</strong><br>2.<strong>资源共享</strong><br>3.分布式处理<br>4.提高可靠性<br>5.负载均衡</p></blockquote><p><strong>结构组成</strong></p><blockquote><p>硬件 软件 协议 三个部分</p></blockquote><p><strong>工作方式组成</strong></p><blockquote><p><strong>1.边缘部分（用户直接使用）</strong><br>C/S方式<br>P2P方式<br><strong>2.核心部分（为边缘部分服务）</strong><br>相当于是边缘部分包裹的（用户与用户之间的）路由等等 </p></blockquote><p><strong>功能组成</strong></p><blockquote><p>1.通信组成——实现数据通信<br>2.资源子网——实现<strong>资源共享</strong>（数据处理）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/3217747256c245c08e181c31e2f645c8.png" alt="七层模型"><br><strong>分类</strong><br><img src="https://img-blog.csdnimg.cn/d0e8bbf02c464e5ebe159454ff798f85.png" alt="计算机网络分类"></p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>这里我用尽最大努力<strong>通俗易懂并且精简</strong>而非官方（至少自认为是这样）的语言进行解释</p><p><strong>速率</strong></p><blockquote><p>也称为数据率，数据传输率，比特率等<br>即<strong>比特位的传输快慢</strong><br>单位是kb/s, Mb/s, Gb/s等，需要注意，<strong>速率单位之间相差1000倍</strong>（存储空间单位之间才是1024倍）</p></blockquote><p><strong>带宽</strong></p><blockquote><p>比特位传输的<strong>最大速率</strong></p></blockquote><p><strong>吞吐量</strong></p><blockquote><p>单位时间通过某特定位置的比特数目<br>（注意在全双工信道上要取来往比特数目之和</p></blockquote><p><strong>时延</strong><br>注意，以下言论不区分信道和链路两个名词（虽然实际上有一定的区别）</p><blockquote><p>俗称延迟<br>包括四类：<br><strong>1.发送时延（传输时延）</strong><br>注意传输时延这个别称，千万别和传播时延搞混了！<br>就是从主机或者路由器内部离开，来到信道上的用时<br>（具体就是从第一位离开，到最后一位离开的用时）<br><strong>2.传播时延</strong><br>就是在信道上传播的用时<br><strong>3.排队时延</strong><br>到达目的后，可能目的主机已经在处理其他信息，需要等待一段时间才能轮到自己<br><strong>4.处理时延</strong><br>处理这段信息所需要的时间</p></blockquote><p><strong>时延带宽积</strong></p><blockquote><p><strong>这里的时延指的是传播时延</strong>，即传播时延 * 带宽<br>代表发送一条信息在信道上传播的时间，而带宽是单位时间内最大的比特传输速率<br>所以时延带宽积的意义就是<br><strong>信道中能够同时容纳的比特数目的最大值</strong><br>说白了就是和导线中电子和电流的关系一样，比特看做电子，时延带宽积就看做电流</p></blockquote><p><strong>往返时延</strong></p><blockquote><p>Round-Trip Time，简称RTT<br><strong>不包括发送时延（传输时延）</strong>，而是 传播时延 * 2 + 排队时延 + 处理时延<br>但是大部分时候，只考虑 传播时延 * 2</p></blockquote><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><strong>概念</strong></p><blockquote><p>一般是指网络协议（因为“协议”不仅是计算机的专业术语），业内交流一般简称为协议<br>是<strong>为了进行网络中数据交换而建立的规则标准</strong>，比如HTTP、DCHP、ICMP等</p></blockquote><p><strong>构成</strong></p><blockquote><p>由三个部分构成：<br><strong>1.语法</strong>：数据和控制信息的结构或者格式<br><strong>2.语义</strong>：具体的需要做的事情，比如发出某种信息<br><strong>3.同步（时序）</strong>：定义做事的先后顺序</p></blockquote><p><strong>协议和服务</strong></p><blockquote><p><strong>协议是水平的</strong><br>协议是作用于对等实体（即同一层）之间的，比如HTTP只能做用于两个应用层之间<br><strong>服务是垂直的</strong><br>服务是指下层向上层提供能够实现某种特定功能的接口<br>（上层调用下层的接口是通过服务原语实现的）</p></blockquote><p><strong>三种模型</strong><br>七层，四层，五层模型</p><p><strong>OSI七层模型</strong></p><blockquote><p>Open System Interconnect 开放式系统互联，是一种<strong>理想化</strong>的模型</p></blockquote><p><strong>TCP/IP四层模型</strong></p><blockquote><p>Transmission Control Protocal / Internet Protocal， 传输控制协议/网际协议，实用性强，是如今普遍使用的模型</p></blockquote><p><img src="https://img-blog.csdnimg.cn/00137d6804964767955e745a310934f4.png" alt="TCP/IP四层模型和OSI七层模型"><br>国内为了方便教学，结合了二者的特点，产生了一个五层协议：<br><img src="https://img-blog.csdnimg.cn/150a8e76ad3843f2a62b6569235576b8.png" alt="五层模型"></p><p>学校的考试一般是基于五层模型的，<strong>所以我接下来以五层模型为标准，且自底向上地进行讨论</strong></p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>可以理解为，包含了一大堆关于各种硬件方面标准的一层，比如规定了接口电缆上电压的范围</p><blockquote><p>由于学校期末考试不考这个，而且找工作面试也不怎么问这块，如果不打算深入研究计算机科学的话那这块相对次要，所以只挑出相对重要的概念说一说</p></blockquote><h3 id="重要的硬件"><a href="#重要的硬件" class="headerlink" title="重要的硬件"></a>重要的硬件</h3><p><strong>中继器、集线器</strong></p><p><strong>二者关系</strong></p><blockquote><p>中继器只有两端，一端进来一端出去，<strong>集线器则是有多个端口的中继器</strong></p></blockquote><p><strong>功能</strong></p><blockquote><p>放大衰减的信号，增加信号传输距离<br>放大信号后会将其<strong>广播（发送给其他所有端口）</strong>，不具备顶线传输</p></blockquote><p> <strong>特点</strong></p><blockquote><p>通过同一个集线器连接的主机属于同一个<strong>冲突域（这个区域内，同一时刻只能有一个主机收或者发信息，否则冲突）</strong>，冲突域内工作的主机会<strong>平分带宽</strong><br>当然，如果不连接的话，每个主机自身就是一个冲突域</p></blockquote><h3 id="重要的概念"><a href="#重要的概念" class="headerlink" title="重要的概念"></a>重要的概念</h3><p><strong>数据和信号</strong></p><blockquote><p><strong>数据</strong><br>要传送的内容，分为数字数据（离散的，方格）和模拟数据（连续的，平滑）<br><strong>信号</strong><br>数据的电气/电磁表现，一般是波，也分为数字信号和模拟信号</p></blockquote><h3 id="重要的单位"><a href="#重要的单位" class="headerlink" title="重要的单位"></a>重要的单位</h3><p><strong>带宽、速率</strong></p><blockquote><p>上面说过了</p></blockquote><p><strong>码元</strong></p><blockquote><p>比如有00 01 10 11四种状态，那码元有四个，每个包括2个比特<br>所以n进制马元包括log2n个比特</p></blockquote><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="三类服务"><a href="#三类服务" class="headerlink" title="三类服务"></a>三类服务</h3><blockquote><p>有三类：<br><strong>无确认无连接服务</strong><br>广播，收到数据不返回确认信息<br><strong>有确认无连接服务</strong><br>广播，收到数据返回确认信息<br><strong>有确认面向连接服务</strong><br>建立连接定向传输，收到数据返回确认信息</p></blockquote><h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><blockquote><p>在收到上层，即网络层来的IP数据报后，数据链路层为其添加<strong>帧首部</strong>和<strong>帧尾部</strong>，构成一个<strong>帧</strong>，而构成帧的这个过程，就叫<strong>组帧</strong><br>其中，来自网络层的<strong>IP数据报</strong>的最大长度即为<strong>MTU</strong>（Max Transmission Unit 最大传输单元）</p></blockquote><p>其中，添加帧首部和帧尾部（即组帧）的方式有四种</p><p><strong>1.字符计数法</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/81b6508debd34fb09bb7e5ec870426cb.png" alt="字符计数法组帧"><br>在<strong>帧首部</strong>添加一个计数的字段，表示包括这个字段在内这个帧的长度</p></blockquote><p><strong>2.字符填充法</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/ffca1aecbb464097bc706f39c175a37e.png" alt="字符填充法组帧"><br>SOH即帧的开始，EOT是帧结束，一对SOH和EOT则确定一帧<br>但是为了防止与帧内部数据内容出现二义性，可以在特殊的内容前加上ESC作为转义标识</p></blockquote><p><strong>3.零比特填充法</strong></p><blockquote><p>如果规定帧首部尾部的特殊标志是01111110（中间是6个1）<br>那么我们组帧的时候，在IP数据报，即帧的数据部分中，扫描到5个连续的1时，就在其后插入一个0，这样就避免出现6个1，也就避免数据部分和内容部分出现二义性<br><img src="https://img-blog.csdnimg.cn/fa7bc13c5d024ac09d3ebdb898f1cedb.png" alt="零比特填充法组帧"><br>可以看做<strong>更好地解决了二义性的优化版字符填充法</strong>，因为为了避免出现二义性，字符填充法每次填充一个转义字符是8位，而零比特填充法每次只需要填充1位</p></blockquote><p><strong>4.违规编码法</strong></p><blockquote><p>从物理层入手，对信号进行处理，不在话下</p></blockquote><h3 id="差错和差错控制"><a href="#差错和差错控制" class="headerlink" title="差错和差错控制"></a>差错和差错控制</h3><p><strong>类型</strong><br>一共四种，和高中生物学的那个碱基对出错很像<br><img src="https://img-blog.csdnimg.cn/363dfb29f3c74b9d9d797098c5819896.png" alt="帧的错误类型"></p><p><strong>差错控制</strong></p><blockquote><p>差错控制两种方式是<br><strong>1.检错编码</strong><br>常见的方式是通过<strong>奇/偶校验码 或 CRC循环冗余码</strong>检错<br><strong>2.纠错编码</strong><br>常见的方式是通过<strong>海明码</strong>纠错</p><p>共同之处都是通过添加<strong>冗余编码</strong>来检验，冗余编码可以理解为一些附加的信息</p></blockquote><p><strong>检错编码——奇/偶校验码</strong></p><blockquote><p><strong>添加冗余编码</strong><br><img src="https://img-blog.csdnimg.cn/beeafa33e66d4362aa64ddfce2c43a9c.png" alt="奇偶校验码"><br>比如，对101和001采用分别奇校验，就是要在首部添加一位，使得1的个数为奇数<br>所以，处理结果分别是0101, 1001<br>偶校验同理，不再赘述<br><br><br><strong>检验</strong><br>（以奇校验为例）接收方拿到数据后开始检测1的个数，如果为1的个数变成偶数了，那么即可判定数据发送变化<br>（没错，这个方法<strong>并不能100%地检测错误</strong>，只能筛掉一部分错误数据）</p></blockquote><p><strong>检错编码——CRC循环冗余码</strong></p><blockquote><p>题目至少会给发送的数据，比如11010 11011， 还有生成多项式，比如10011（即x^4^+x + 1）<br><strong>添加冗余编码</strong><br>那么我们取发送数据的前5位（11010）与生成多项式<strong>异或</strong>，结果为01001，放回原位删去前驱零得到新的数据1001 11011，然后再取前5位与生成多项式异或…重复上述过程直到最终结果不足5位（即不能再进行异或）<br>由于生成多项式最高阶是4，若不足4位通过补前驱零补满4位，即得到<strong>CRC循环冗余</strong><br>将FCS放到接收端尾部，即得到最终要发送的数据<br><br><br><strong>检验</strong><br>和上面进行一样的异或操作，如果最终结果为0，则帧没出错，否则出错</p></blockquote><p><strong>纠错编码——海明码</strong></p><blockquote><p><strong>添加冗余编码</strong><br><img src="https://img-blog.csdnimg.cn/a037b3c6dce34ebeb753f5b8dbc12699.png" alt="确定海明码校验位位数r"></p><p><img src="https://img-blog.csdnimg.cn/178dd5dba68441e998d6c3b4a1c5ad61.png" alt="确定海明码中校验码和数据的位置"><br><img src="https://img-blog.csdnimg.cn/aa903abe2aad4d1097e8fe4e863dfc28.png" alt="求海明码中校验码的值"><br>对于P1则看二进制的倒数第一位，看看Dx（x为1,2,3….）对应的二进制的倒数一位是否也是1，如果是，那么这个Dx将参与接下来的一次异或运算，该次异或运算是P1与所有满足条件的Dx异或且结果为0，这样就能求得P1的值<br>（这些满足条件的Dx即在P1纠错能力范围内）<br>同理，<strong>对于Pi则看二进制的倒数第i位，看看Dx对应的二进制的倒数第i位是否为1</strong>…..<br>这样我们就求得了所有Pi的值，最终合在一起就是<strong>海明码</strong><br><br><br><strong>纠错</strong><br><img src="https://img-blog.csdnimg.cn/636b50cd87bf448196ef0e9e1c94852a.png" alt="海明码纠错原理"><br>这里我们进行和刚才类似的异或操作，Pi和自己纠错能力范围内的Dx异或，<br>如图，结果依次是1010，但是要注意，我们之前总是提到Pi的二进制倒数第i位，所以这里是反着的，最终结果需要颠倒一下，即0101，也就是5<br>这表示第五位出错了，即D2出错，我们直接取反，D2由1变0，完成纠错</p></blockquote><h3 id="停止-等待协议-和-滑动窗口协议"><a href="#停止-等待协议-和-滑动窗口协议" class="headerlink" title="停止-等待协议 和 滑动窗口协议"></a>停止-等待协议 和 滑动窗口协议</h3><p><img src="https://img-blog.csdnimg.cn/a22812bdafca402b81aa55ef5c4bfaea.png" alt="停止-等待协议和滑动窗口协议GBN和SR"></p><p><strong>停止-等待协议</strong><br>如图，每传一帧之后都要等到收到确认帧（ACK）后才传下一帧<br>如果确认帧丢失或者出错，那么发送方可能就会一直等待——为了避免这种情况，<br>引入了</p><blockquote><p><strong>超时重传方法</strong><br>每当发送一个帧，就启动一个计时器，如果在一定时间内没有收到正确的确认帧，那么就会重新发送<br>另外，如果确认帧迟到了，那么它将会作废处理直接被抛弃</p></blockquote><p><strong>滑动窗口协议</strong><br>联想到同名的一个算法<br><img src="https://img-blog.csdnimg.cn/d0d8853d64dd49d48297aa0fe6aa83b6.png" alt="后退N帧协议GBN和选择重传协议SR"></p><blockquote><p>相当于是停止-等待协议的改进，由一次发一个帧变为<strong>可以连续发多个帧</strong><br>无论是GBN还是SR，滑动窗口都有<br>发送窗口和接受窗口<br><img src="https://img-blog.csdnimg.cn/005adf3e01fa41c8a463907ca5519dc0.png" alt="发送窗口接收窗口"><br>其中的<strong>数字是编号</strong>而非数据，<br>接收窗口收到0后，往后移动一位，并返回一个确认帧——发送窗口收到确认帧后，也往后移动一位<br>注意，只有第一位完成了上述过程窗口才发生移动</p></blockquote><blockquote><p>停止-等待协议可以看做发送窗口和接受窗口大小都是1<br>而GBN和SR的区别主要是在于<strong>处理确认帧和错误的方式</strong></p></blockquote><p><strong>GBN后退N帧协议</strong></p><blockquote><p>Go Back N-Frames，也叫回退N步协议</p></blockquote><blockquote><p><strong>接收窗口处理确认帧ACK</strong><br>这里ACK采用<strong>累积确认</strong>，即ACK的值(此处记为x)代表<strong>已经收到 x及其前面的所有帧</strong><br><br><br><strong>发送帧丢失或出错</strong><br>比如发送窗口连发了0 1 2 3 4，2在过程中丢失了，接收方就会回传一个ACK 1 代表已经收到了0 1号（当然，也可能会回传ACK 0），虽然3 4成功到达，但是接收窗口不接收…<br>在超时后，发送方只接收到了ACK 1，所以它知道从2开始就有帧丢失了，于是<strong>将 2 3 4全部重新发送</strong>——可以看做是后退了3帧这里，所以叫才后退N帧吧..</p></blockquote><p>来看看一个例题<br><img src="https://img-blog.csdnimg.cn/38613d89108443fb96cc0cc518861c85.png" alt="滑动窗口例题"></p><p><strong>SR选择重传协议</strong></p><blockquote><p>没查到英文缩写是什么<br>SR可以看做<strong>改进版的GBN</strong>，因为上面GBN的例子中，有些帧明明就成功的到达了，却还要重传，这样就造成了资源浪费<br>具体改进就是，接收窗口会<strong>存下所有正确到达的帧</strong>，然后返回响应的确认帧，发送窗口收到确认帧后也会<strong>标记所有被确认帧</strong><br>这样，当某个帧没有正确到达时，就能通过这些标记来确定该重发哪个（对，超时时，SR每次只重传一个）</p></blockquote><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p><strong>以太网</strong></p><blockquote><p>以太网（Etherner）是局域网的一种<br>10BASE-T以太网指的是，10Mb/s的传送基带（BASE）的双铰链（T）以太网<br>提供<strong>无连接不可靠</strong>服务，<strong>速率范围是10Mb/s~10Gb/s，高于100Mb/s则为高速以太网</strong>——没错这个竟然考过选择题<br>以太网拓扑：逻辑上总线型，物理上星型</p></blockquote><h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><p><img src="https://img-blog.csdnimg.cn/c9847f7d967f487ba2b0b02db51b067b.png" alt="介质访问控制的分类"><br>其中静态划分信道只需要记住名字和缩写对应关系就好了<br>而动态分配信道只需要知道<strong>CSMA/CD协议</strong>即可</p><h3 id="CSMA载波监听多点接入协议"><a href="#CSMA载波监听多点接入协议" class="headerlink" title="CSMA载波监听多点接入协议"></a>CSMA载波监听多点接入协议</h3><blockquote><pre><code>    Carrier Sense Multiple Access多点接入是指接入一根总线</code></pre></blockquote><p><strong>CSMA/CD协议</strong></p><blockquote><p>其中CD是指 Collision Detection 碰撞检测<br>检测方式是<br>发送帧之前，监听信道（半双工的）——空闲则立刻发送，忙着推迟发送</p><p>但是这并不意味着不会发生碰撞，因为监听的时候信道似乎是空闲的——但是这也可能是因为距离过程，占用信道的电磁波没进入监听范围，随后发送信号即产生碰撞</p><p><strong>争用期</strong><br>如果发生碰撞，要经过2τ-σ的时间发送方才能得知此次碰撞的发生，这个时间即<strong>争用期（也叫 冲突窗口/碰撞窗口）</strong><br>σ趋向零时，争用期趋向最大值<br><img src="https://img-blog.csdnimg.cn/485ccb9fa3ac4e49a200cdf76e835892.png" alt="载波监听和碰撞"></p></blockquote><p><strong>重传时机：截断二进制指数规避算法</strong></p><blockquote><p>如果碰撞后立即重传，那么可能又会碰撞，并且无休无止，所以需要一个算法求一个适当的时机重传信号，这个算法即<strong>截断二进制指数规避算法</strong><br><img src="https://img-blog.csdnimg.cn/d301e71f48014ea88a9ce415d819ffab.png" alt="截断二进制指数规避算法"></p></blockquote><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="电路交换、报文交换、分组交换"><a href="#电路交换、报文交换、分组交换" class="headerlink" title="电路交换、报文交换、分组交换"></a>电路交换、报文交换、分组交换</h3><p><strong>电路交换</strong><br><img src="https://img-blog.csdnimg.cn/a8a5d451c1eb4757b79f89730bb43c86.png" alt="电路交换"><br>唯一要提一下就是，一条链路中一个设备崩溃那么整个链路崩溃，即缺点3.不灵活</p><p><strong>报文交换</strong><br>报文：源应用发送的信息整体<br><img src="https://img-blog.csdnimg.cn/dc29ea69820a41eda742baaad5de7358.png" alt="报文交换"><br><strong>分组交换</strong><br>就是把报文切片了再发<br><img src="https://img-blog.csdnimg.cn/fdee67f60d714ddd9232b9f231d6da84.png" alt="分组交换"><br>分组交换其实还可以细分为</p><blockquote><p><strong>数据报方式（无连接）</strong><br>无连接，不会事先确定传输路径，每个分组路径独立，彼此之间可能不通过<br><strong>虚电路方式（连接）</strong><br>实现会确定传输路径</p></blockquote><p>发送同样的数据，分组交换一般比报文交换快</p><blockquote><p>已知，链路传输速率为1000bps（bits per second，看到这个单位要知道就是b/s）<br>要发送的报文大小是10000bits，要经过的链路如上图所示，求报文交换和分组交换（假设分为1000片）的最短用时</p><p><strong>报文交换</strong><br>10000bits / 1000bps = 10s  ，即在每段链路上传播要10s<br>很容易看出是30s<br><strong>分组交换</strong><br>10000bits/1000 = 10 bits，每一片10bits<br>10bits / 1000 bps = 0.01 s,  每小片在每段链路上传播要0.01 s<br>第一片走完全程要0.03s, 第一片和最后一片相差 999 片，也就是 9.99 s, 所以，最后一片到达重点需要10.02s<br>即10.02s</p></blockquote><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><blockquote><p>Internet Protocal 网际协议</p></blockquote><p><strong>IP数据报</strong></p><blockquote><p>注意数据部分包括了TCP段和UDP段<br>IP数据报的最大长度即MTU，最大传送单元，以太网中MTU为1500Bytes<br><img src="https://img-blog.csdnimg.cn/2ae85e270df9444d89b4d7cf3ffaf343.png" alt="IP数据报格式"><br><strong>注意，片便宜的单位是8Bytes</strong>，所以记得除8<br>字段MF是More Fragments, DF是Don‘t Fragment，其值是布尔值<img src="https://img-blog.csdnimg.cn/aaeb19a9f22c4600aeca7cc058232987.png" alt="IP数据报分片"><br>注意，通常我们认为不能出现全0或全1的网络号或者主机号，所以这里还得减去那么一两个(虽然有的可以用了，但是做题的时候我们依旧认为其不可用）<img src="https://img-blog.csdnimg.cn/7d9f3f63555647879048bfcef72adec2.png" alt="最大可用主机数"></p></blockquote><h3 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h3><blockquote><p>全世界唯一的 32位/4字节 标识符，标识路由器主机的接口<br>形如01110000 11001100 11110000 11111111，一共32位<br>也可以写作形如112.204.240.255，则称为<strong>点分十进制记法</strong><br>分为 <strong>网络号 和 主机号</strong>两部分</p></blockquote><p> <strong>分类及区别</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/6ed9bc257ab44788bb5e76ad9b483c93.png" alt="IPv4地址分类"></p></blockquote><h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p> <strong>私有IP地址</strong></p><blockquote><p>对于私有IP地址，路由器是不会转发的<br><img src="https://img-blog.csdnimg.cn/ee8b7b61096e4237847c4affbecc95b3.png" alt="IPv4的私有IP地址"></p></blockquote><p>如果想要用私有IP地址和外部网络通信的话，就需要用到NAT了·<br><strong>NAT网络地址转换器</strong></p><blockquote><p>Network Address Translation<br>在专用网连接因特网的<strong>路由器上安装NAT软件</strong>，这个路由器就变成了NAT路由器，它至少拥有一个外部全球IP地址<br>能把LAN局域网IP转换为WAN广域网IP：<br><img src="https://img-blog.csdnimg.cn/d74834af11124292bbd3a6ad30e43721.png" alt="NAT网络地址转换"></p></blockquote><h3 id="子网划分-和-子网掩码"><a href="#子网划分-和-子网掩码" class="headerlink" title="子网划分 和 子网掩码"></a>子网划分 和 子网掩码</h3><p><strong>子网划分</strong></p><blockquote><p>在主机号里抽一部分作为子网<br><img src="https://img-blog.csdnimg.cn/445a24f6df0c44b58bd4349ad89df324.png" alt="子网划分"><br><img src="https://img-blog.csdnimg.cn/aad62d4830df4217885c7dbbc74b784b.png" alt="子网划分"><br><img src="https://img-blog.csdnimg.cn/c76357d59c2c4dffbc8bb03ffe2481a4.png" alt="子网划分"></p></blockquote><h3 id="CIDR无分类编址"><a href="#CIDR无分类编址" class="headerlink" title="CIDR无分类编址"></a>CIDR无分类编址</h3><blockquote><p>CIDR，读作sider<br>能够延缓IPv4用尽的危机，作用机制如下：<br><strong>以128.233.233.233/16的形式表示IP</strong><br>其中末尾的**/16代表前16位是网络号**，这样一来就拜托了ABCDE类的束缚，更加灵活，更便于按需供给减少浪费<br><strong>需要注意，在CIDR中，网络号也称前缀号</strong></p></blockquote><p><strong>构成超网</strong></p><blockquote><p>也叫路由聚合<br>即多个子网聚合为一个大的子网，方法是缩短网络前缀</p></blockquote><p>来个例题<br><img src="https://img-blog.csdnimg.cn/2ee2c5bb25c84078aadbf31918119595.png" alt="CIDER路由转发"></p><h2 id="运输层-待更新"><a href="#运输层-待更新" class="headerlink" title="运输层(待更新)"></a>运输层(待更新)</h2><h2 id="应用层-待更新"><a href="#应用层-待更新" class="headerlink" title="应用层(待更新)"></a>应用层(待更新)</h2>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE</title>
      <link href="/2022/01/08/vue/"/>
      <url>/2022/01/08/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>这是个人的学习笔记，用于自己复习的同时也希望能帮助到有需要的人<br>由于是初学，加上Vue的知识也不少，难免有错误和不足，希望大家谅解，也欢迎批评指正</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/08</strong></p><p>本博客最初于2021/08/20发布在我的C站博客，现在做了微小的调整后搬运到此处</p></blockquote><h2 id="完善的准备"><a href="#完善的准备" class="headerlink" title="完善的准备"></a>完善的准备</h2><h3 id="认识Vue框架"><a href="#认识Vue框架" class="headerlink" title="认识Vue框架"></a>认识Vue框架</h3><p>为了便于理解，我将Vue概括为：<br>1.Vue是一个<strong>主要关注视图层</strong>的渐进式框架，即Vue可以只运用到局部代码。</p><p>2.并且Vue实现了<strong>MVVM双向绑定</strong>模式<br>M：模型层，指js对象<br>V：视图层，指DOM<br>VM：链接视图和数据的中间件</p><p>3.而且兼顾了React的<strong>虚拟DOM</strong>和Angular的<strong>模块化开发</strong></p><p>至于什么是框架，我的理解是：<br><strong>自动生成</strong>各种文件配置及相关代码的，并且提供了许多更<strong>简洁高效</strong>的开发方式的东西</p><p>另外，Vue读作view，而不是   微优易<br>================================================</p><p>需要安装下载的东西都写在这里了，根据需要自行节选阅读</p><h3 id="Vue-引入"><a href="#Vue-引入" class="headerlink" title="Vue 引入"></a>Vue 引入</h3><p>两种引入方式：<br>本地引入：去官网复制一份代码到本地然后js引入即可<br>CDN引入：加上以下代码</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><em><strong>接下来的内容是暂时不会用到的，不过提前准备好呢也没有坏处（要是觉得麻烦就先跳过）</strong></em></p><h3 id="npm-安装"><a href="#npm-安装" class="headerlink" title="npm 安装"></a>npm 安装</h3><p>Node.js的包管理工具,经常用到</p><p>1.搜索Node.js去它的官网下载，然后安装即可（自动配置环境变量）</p><p>2.win+r输入cmd打开命令提示符(或者打开编译器终端）输入：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></tbody></table></figure><p>检测版本号<br>如果出现版本号则说明安装成功</p><h3 id="cnpm镜像加速器-安装"><a href="#cnpm镜像加速器-安装" class="headerlink" title="cnpm镜像加速器 安装"></a>cnpm镜像加速器 安装</h3><p>由于npm下载国外资源的时候可能会比较慢，所以我们还得专门弄一个“中国版”（<strong>镜像加速器</strong>）的：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cnpm -g</span><br></pre></td></tr></tbody></table></figure><p>以后每当遇到npm下载卡顿的时候，就可以用<strong>ctrl+c</strong>终止下载，然后用<strong>cnpm替代npm</strong>即可体验极速下载</p><h3 id="Vue-Cli脚手架-安装"><a href="#Vue-Cli脚手架-安装" class="headerlink" title="Vue-Cli脚手架 安装"></a>Vue-Cli脚手架 安装</h3><p>Vue-Cli才是真正开始Vue，新建项目自动配置上万个文件让萌新感受一下什么才叫大前端</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install vue-cli -g</span><br></pre></td></tr></tbody></table></figure><h3 id="webpack-安装"><a href="#webpack-安装" class="headerlink" title="webpack 安装"></a>webpack 安装</h3><p>代码打包工具，自动将工程代码转为ES5并且压成一行代码</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install webpack -g</span><br></pre></td></tr></tbody></table></figure><h3 id="webpack-cli-安装"><a href="#webpack-cli-安装" class="headerlink" title="webpack-cli 安装"></a>webpack-cli 安装</h3><p>webpack都装了，那webpack顺便一起吧</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-cli -g</span><br></pre></td></tr></tbody></table></figure><h3 id="axios-安装"><a href="#axios-安装" class="headerlink" title="axios 安装"></a>axios 安装</h3><p>其实也就是Vue版的ajax</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></tbody></table></figure><h3 id="vue-router-安装"><a href="#vue-router-安装" class="headerlink" title="vue-router 安装"></a>vue-router 安装</h3><p>路由<br>这个要在<strong>项目目录下</strong>安装<br>进入项目目录下，输入</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save-dev</span><br></pre></td></tr></tbody></table></figure><h3 id="devtools-安装"><a href="#devtools-安装" class="headerlink" title="devtools 安装"></a>devtools 安装</h3><p>这是一个浏览器插件，用于vue代码的调试，只需要在浏览器上安装就行了</p><h2 id="开始使用Vue"><a href="#开始使用Vue" class="headerlink" title="开始使用Vue"></a>开始使用Vue</h2><h3 id="创建Vue对象-以及-mustache语法"><a href="#创建Vue对象-以及-mustache语法" class="headerlink" title="创建Vue对象 以及 mustache语法"></a>创建Vue对象 以及 mustache语法</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"> <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="comment">//绑定id为app的DOM元素,这也确定了Vue对象的作用范围</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">"#app"</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">//以键值对的形式存放数据</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="attr">mes</span>:<span class="string">"HelloWorld!"</span></span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="comment">//类似的，存放方法</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">     <span class="attr">helloWorld</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">     <span class="comment">//访问对象的属性</span></span></span><br><span class="line"><span class="javascript">                alert(<span class="built_in">this</span>.mes);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>相应的html部分为：<br>其中嵌套的大括号就是mustache语法,括号里面可以写多个变量，也可以填表达式(不推荐这么做)<br>mustache语法不能用于标签的内部！<br><strong>(不能出现&lt;div <code>{{name}}</code>&gt;&lt;/div&gt;这种或者其他类似的形式)</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- {{}}会动态的去接收值</span></span><br><span class="line"><span class="comment">这就是mustache语法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>{{mes}}<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用v-on:绑定事件，也可以简写为@ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">"helloWorld"</span>&gt;</span>点击我试试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></tbody></table></figure><p>运行效果：</p><p><img src="https://img-blog.csdnimg.cn/62d58f8e5fe344829912e8ee7422b55b.png" alt="在这里插入图片描述"><br>另外，vue3.0之后，建议将Vue对象中的data写为函数的形式：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">return</span>{</span><br><span class="line">    <span class="attr">mes</span>:<span class="string">"HelloWorld!"</span></span><br><span class="line">}</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>这样写的话，多个与之关联的html元素都会有自己独立的作用域，避免了污染</p><h3 id="循环v-for"><a href="#循环v-for" class="headerlink" title="循环v-for"></a>循环v-for</h3><p><strong>记得每次都要引入Vue的js文件<br>为了方便阅读，后面就不再提醒了</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm2 = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">"#app2"</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">items</span>: [<span class="string">"牛逼"</span>,<span class="string">"天秀"</span>,<span class="string">"妙绝"</span>]</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"app2"</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"i in items"</span>&gt;</span>{{i}}<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></tbody></table></figure><p>运行结果，可以看到动态的创建了三个<br><img src="https://img-blog.csdnimg.cn/7d275a5d45fc42698dd64fa38ae65e88.png" alt="在这里插入图片描述"><br>v-for还可以支持多个参数</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(i, index) in arr"</span>&gt;</span>{{index}}----{{i}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(i, index, key) in arr"</span>&gt;</span>{{index}}----{{i}}----{{key}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(i, index, key) in obj"</span>&gt;</span>{{index}}----{{i}}----{{key}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/b3d133b02d3b4eceb2a7f9d6af58e76d.png" alt="在这里插入图片描述"><br><strong>从结果上看，第一个参数是值，第二个参数是键，在对象中还会有第三个参数是下标</strong></p><h3 id="分支v-if"><a href="#分支v-if" class="headerlink" title="分支v-if"></a>分支v-if</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm1 = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">"#app1"</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="attr">num</span>: <span class="number">3</span></span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"num == 1"</span>&gt;</span>num是1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"num === 2"</span>&gt;</span>num是2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>num为其他值{{num}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>运行结果<br><img src="https://img-blog.csdnimg.cn/d2bfdca36e524429872374decee4d3b7.png" alt="在这里插入图片描述"></p><h3 id="单次变化v-once"><a href="#单次变化v-once" class="headerlink" title="单次变化v-once"></a>单次变化v-once</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">msg</span>: <span class="string">"hhhh"</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {}</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>变化：{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span>不会变化：{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>什么叫做单次变化呢？<br>首先来看看结果<br><img src="https://img-blog.csdnimg.cn/514089cec1e744ac8f40b9665ead23c9.png" alt="在这里插入图片描述"><br>我们在浏览器的控制台上对值进行一个修改，此时我们就发现：<br><img src="https://img-blog.csdnimg.cn/7c9a55b5acf44193a42c7b6d50386531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="v-text和v-html"><a href="#v-text和v-html" class="headerlink" title="v-text和v-html"></a>v-text和v-html</h3><p>v-text其实还没有mustache语法<code>{{}}`好用...但是还是要了解相比之下，v-html就显得有用多了</code></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">msg</span>:<span class="string">"&lt;div style=\"color: red;\"&gt;123&lt;/div&gt;"</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><code><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>运行结果也可想而知![在这里插入图片描述](https://img-blog.csdnimg.cn/ffcc95d216da40198a47ec82ab3dde81.png)### 预设v-pre这个说实话应该猜都能猜到作用了，其实就是\<pre>\</pre>的vue版本这里我也不给vue对象的代码了（因为给了也没用）<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-pre</span>&gt;</span>预设不处理：{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>![在这里插入图片描述](https://img-blog.csdnimg.cn/4b025bb7343b47fe9ac67190ae2df55c.png)有什么用呢？大概就是...基本上没什么用....### 解析判定v-cloakvue对象的data数据可能会来自服务器，那么网络不畅的时候就可能导致数据没有及时渲染到页面，就会出现满屏的`{{}}</code>这种mustache语法，让用户看了觉得十分诡异，为了<strong>判定Vue对象到底有没有解析完毕</strong>，就出现了v-cloak<p></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span><br><span class="line">        <span class="attr">el</span>: <span class="string">'app'</span>,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span><br><span class="line">            <span class="keyword">return</span>{</span><br><span class="line">                <span class="attr">msg</span>:<span class="string">"hhhh"</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span>啊哈！{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>请求成功和请求失败的状态:<br><img src="https://img-blog.csdnimg.cn/8aa3458d0255449fbc57451cff090d9d.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/9c3d3e32b7184e0ba04ef23c084ca8ab.png" alt="在这里插入图片描述"><br>没错，v-cloak就是在成功时消失，失败时保留<br>那么我们就可以利用css的属性选择器搞一手操作了</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-attr">[v-cloak]</span>{</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="css">    }</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样一来，失败时就不会显示mustache语法了</p><h3 id="动态绑定v-bind"><a href="#动态绑定v-bind" class="headerlink" title="动态绑定v-bind"></a>动态绑定v-bind</h3><p>之前说过了，mustache不能用在标签的内部，也就是不能用在左右箭头的里面，那么问题来了：<br>对于这样的vue对象</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">myColor</span>: <span class="string">"color:red;"</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">someOnesColor</span>: <span class="string">"blue"</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>我却偏要这么写html（甚至还报错了）：<br><img src="https://img-blog.csdnimg.cn/c40060eac0254d60a6e250b739d4d45c.png" alt="在这里插入图片描述"><br>很明显这个mycolor是没有解析成color：red；的（被当作了css)<br>此时我们就需要用到v-bind了（第二种写法是个语法糖)</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"myColor"</span>&gt;</span>啊哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"myColor"</span>&gt;</span>啊哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"{color: someOnesColor,}"</span>&gt;</span>啊哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/748291b1825e436ab21e6ec651e2658f.png" alt="在这里插入图片描述"></p><p>这里提一句，<strong>如果返回多个值，也可以考虑用数组或者对象的形式发送/接受</strong>,</p><p>中间可以利用函数进行处理（当然不用也行)</p><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p>另外，vue或react中，一个dom对象默认有一个key值，需要用v-bind绑定一个唯一标志（不要用下标，因为下标会在排序等变化值发生改变），<br>这样一来在基于<strong>diff算法</strong>的动态变化（增删改排序）时，能够做到正确匹配每个元素</p><h3 id="事件绑定v-on"><a href="#事件绑定v-on" class="headerlink" title="事件绑定v-on"></a>事件绑定v-on</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">sayhi</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">"好啊你真敢点我"</span>);</span></span><br><span class="line"><span class="javascript">            },</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">saywow</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">"这么说你很勇哦"</span>);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>其中@是一个语法糖</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">"sayhi"</span>&gt;</span>点我一下你试试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"saywow"</span>&gt;</span>这个彬彬就是逊啦<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>运行结果<br><img src="https://img-blog.csdnimg.cn/94654a883bda47ca908f401f65fdcaa5.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/27d40b49e67f4bad86fa7303092e9977.png" alt="在这里插入图片描述"></p><h3 id="事件对象参数"><a href="#事件对象参数" class="headerlink" title="事件对象参数"></a>事件对象参数</h3><p>另外，涉及到参数的一种情况</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">clickEvent1</span>(<span class="params">args</span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(args);</span></span><br><span class="line"><span class="javascript">            },</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">clickEvent2</span>(<span class="params">args</span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(args);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>注意绑定的事件，都不传参数，但是一个加了括号一个没加括号</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickEvent1()"</span>&gt;</span>按钮1号<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickEvent2"</span>&gt;</span>按钮2号<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>可见分别输出<strong>undefined</strong>和<strong>事件对象</strong><br>所以如果<strong>不加括号时会自动传一个事件对象</strong><br><img src="https://img-blog.csdnimg.cn/37f33bb47e284b2b80d5203dcf7f592f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么问题来了，如果需要传参数的同时有需要事件对象该如何操作呢?</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">clickEvent3</span>(<span class="params">num1, num2, event</span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(num1);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(num2);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(event);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>注意，第三个参数前面加了一个$符号，表示传递事件对象，这样一来我们就可以在传递其他参数的通时传递事件对象了</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickEvent3(123, 456, $event)"</span>&gt;</span>按钮3号<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>当然，事件对象参数的位置可以随意，但是约定俗成还是放末尾比较好</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>还记得<strong>事件冒泡</strong>和<strong>事件捕获</strong>吧</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">fatherClick</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"我是父元素"</span>);</span></span><br><span class="line"><span class="javascript">            },</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">sonClick</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"我是子元素"</span>);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>写了点style方便观察（懒得写class）</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"fatherClick"</span> <span class="attr">style</span>=<span class="string">"background-color: red;height: 300px;text-align: center;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"sonClick"</span> <span class="attr">style</span>=<span class="string">"margin-top:150px;"</span>&gt;</span>冒泡：OoOoOooOOOo<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>当我们点击子元素时，<strong>触发子元素事件之后会触发父元素事件</strong><br>这是因为子元素时父元素的一部分，所以点击子元素也相当于点击了父元素的一部分，也就触发了事件冒泡（<strong>事件触发自底向上</strong>）<br><img src="https://img-blog.csdnimg.cn/787c14666cb74214a9985edcd968f0a5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在以前我们会采用在子元素的函数中利用事件对象的内置函数<strong>stopPropagation</strong>来阻止冒泡</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sonClick</span>(<span class="params">event</span>)</span>{</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是子元素"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是现在我们有了修饰符,允许我们在标签中写：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"sonClick"</span> <span class="attr">style</span>=<span class="string">"margin-top:150px;"</span>&gt;</span>冒泡：OoOoOooOOOo<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>另外，不只有事件绑定v-on才有修饰符，其他vue关键词也有</p><p>懂了概念和作用，那么使用修饰符也是得心应手，下面是一些常用的事件修饰符，这里不再赘述：</p><table><thead><tr><th>修饰符</th><th>作用</th></tr></thead><tbody><tr><td>.trim</td><td>清除首尾空格</td></tr><tr><td>.stop</td><td>阻止事件冒泡</td></tr><tr><td>.prevent</td><td>阻止默认行为</td></tr><tr><td>.self</td><td>只有元素本身能触发自己的事件</td></tr><tr><td>.once</td><td>只能触发一次</td></tr><tr><td>.capture</td><td>将事件冒泡调整为事件捕获（自顶向下触发）</td></tr><tr><td>.keycode:</td><td>监听键盘</td></tr><tr><td>.enter</td><td>监听键盘是否按下enter键</td></tr><tr><td>.up(上下左右空格之类依葫芦画瓢)</td><td>监听键盘是否按下↑</td></tr></tbody></table><h3 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h3><p>虽然说mustache语法中的<code>{{}}</code>内可以进行一些如同字符串拼接的简单操作，但是遇到更多的计算时，不仅是视觉上会显得不美观，而且还存在无法正确运算的可能。<br>我们可以通过methods来解决这些问题，不过methods内的方法是动态的从而很容易被修改，存在被意外地污染的风险<br>这时候，为了防止这种事情发生，就出现了computed计算属性</p><p>最简单的使用大概就像以下这样</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">msg1</span>: <span class="string">"hello"</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">msg2</span>: <span class="string">"world"</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">computed</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">msgStrcat</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">this</span>.msg1 + <span class="string">" "</span> + <span class="built_in">this</span>.msg2</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }  </span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    {{msgStrcat}}</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>和函数有什么区别？<br>在mustache语法调用的时候<strong>不加（）</strong>,因为这是一个属性而不是函数——这是形式上的区别，<br>那还有更多本质上的区别吗？<br>各位看官莫急，且看以下分析：<br><strong>1.computed内的实际形式：</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed:{</span><br><span class="line">    <span class="attr">msgStrcat</span>:{</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params"></span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"这是computed的set函数"</span>);</span><br><span class="line">        },</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"这是computed的get函数"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure><p>其中get和set也就是ES6中增加的内容，可以参考我的ES6学习笔记<br><strong>2.被调用的时候：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">strcat</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"这是methods的方法"</span>);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">computed</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="attr">msgStrcat</span>:{</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"这是computed的set"</span>);</span></span><br><span class="line"><span class="javascript">                },</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"这是computed的get函数"</span>);</span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }  </span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后是三次同时调用computed和methods</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{msgStrcat}}{{strcat()}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{msgStrcat}}{{strcat()}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{msgStrcat}}{{strcat()}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>可以看见的是，<strong>computed只被触发了一次</strong>，这源于set的性质<br><img src="https://img-blog.csdnimg.cn/1faafaacff364b36982d82c0659f6cc0.png" alt="在这里插入图片描述"><br>没错！<strong>computed计算后的结果是放在缓存里面的</strong>，这样一来不仅避免了大量重复计算从而大大地提高了页面响应式加载的效率！<br>所以以后遇到那种几乎不变的值时，就可以考虑computed了（由于几乎不变，set也没什么用了…）<br>当然也别管那么多，以后遇到属性直接先莽computed！</p><h3 id="显示v-show"><a href="#显示v-show" class="headerlink" title="显示v-show"></a>显示v-show</h3><p>本质是修改css中display的值</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">isShowed</span>:<span class="literal">true</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"isShowed"</span>&gt;</span>显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"!isShowed"</span>&gt;</span>没有显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/a3231fcea02c4c51ac10833fee9f17fd.png" alt="在这里插入图片描述"><br><strong>和v-if的区别</strong><br><strong>v-show纵使不显示，那么标签也还在，只不过隐藏了</strong><br><img src="https://img-blog.csdnimg.cn/8826972873194b70b653b1dff58212f8.png" alt="在这里插入图片描述"><br><strong>但是v-if是 移除或创建 标签</strong><br>想一下vue为什么出现，不就是为了响应式动态加载避免频繁操作DOM吗，所以这里也是一个道理——在涉及到频繁切换的时候，我们就优先考虑v-show而不是v-if</p><h3 id="双向绑定v-model"><a href="#双向绑定v-model" class="headerlink" title="双向绑定v-model"></a>双向绑定v-model</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">inputStr</span>:<span class="string">""</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"inputStr"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>您输入的是:{{inputStr}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>双向绑定之后，两边就可以同步变化了<br><img src="https://img-blog.csdnimg.cn/0a8d0fe6575148ddb4edbc177f097d4e.png" alt="在这里插入图片描述"></p><p> <strong>v-model的底层实现</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">msg</span>: <span class="number">666</span>,</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">valueChanged</span>(<span class="params">event</span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.msg = event.target.value;</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"msg"</span> @<span class="attr">input</span>=<span class="string">"valueChanged"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>您输入的是：{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>通过<strong>v-bind动态绑定</strong>和<strong>methods方法</strong>完成双向绑定<br>懂了这个原理，你就可以这么写：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"msg"</span> @<span class="attr">input</span>=<span class="string">"msg = $event.target.value"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>您输入的是：{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="组件化component"><a href="#组件化component" class="headerlink" title="组件化component"></a>组件化component</h2><h3 id="开始组件化开发"><a href="#开始组件化开发" class="headerlink" title="开始组件化开发"></a>开始组件化开发</h3><p>低耦合高内聚嘛<br>先来看看最简单的使用方式</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义全局组件</span></span></span><br><span class="line"><span class="javascript">    vm.component(<span class="string">'button-count'</span>,{</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                <span class="attr">count</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;button @click="count ++;"&gt;你点击了这个按钮{{count}}次&lt;/button&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 绑定</span></span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这里我们不再采用Vue2中使用new来创建Vue对象的形式，而是采用了Vue3中的createApp方法。<br><strong>这里需要注意的是，引入的文件需要更改为：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue@next"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>接下来我们就可以这样写了<br>(组件化中标签的写法有一定的讲究)<br>组件命名要么像buttonCount，要么像button-count</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button-count</span>&gt;</span><span class="tag">&lt;/<span class="name">button-count</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button-count</span>&gt;</span><span class="tag">&lt;/<span class="name">button-count</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button-count</span>&gt;</span><span class="tag">&lt;/<span class="name">button-count</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/3d5e4eae6c6143729703ab02611e13ed.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于data部分我们使用的函数形式，所以能够返回独立的函数作用域，因此每个点击按钮的数值可以<strong>相互独立</strong>；<br>反之，如果不采用函数形式的data，那么所有值都会同步。</p><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p>我们之前使用的都是全局组件<br>在介绍它有什么特点之前，先来看看以下代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义全局组件</span></span></span><br><span class="line"><span class="javascript">    vm.component(<span class="string">'cool-title'</span>,{</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;h1 style="color:red;background-color:pink;"&gt;炫酷的标题&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript">    vm.component(<span class="string">'button-count'</span>,{</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;cool-title&gt;&lt;/cool-title&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;button&gt;嘿，兄贵快来点我&lt;/button&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 绑定</span></span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>在一个Vue对象内定义多个组件的时候，它们之间可以相互调用</strong><br>上述代码中，第二个组件内就调用了第一个组件<br>效果如下：<br><img src="https://img-blog.csdnimg.cn/8c974d88cbd34b768e122ecf58d05a61.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><p>先看代码</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义局部组件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> title = {</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                <span class="attr">title</span>: <span class="string">"炫酷的标题"</span> </span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;h1 style="color:red;background-color:pink;"&gt;{{title}}&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> button = {</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;cool-title&gt;&lt;/cool-title&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;button&gt;嘿，兄贵快来点我&lt;/button&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="string">"cool-title"</span>:title,</span></span><br><span class="line"><span class="javascript">            <span class="string">"button-count"</span>:button</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>没错，是声明一个类似于对象的东西，最后在创建Vue对象实例的时候才塞到components内，<br>这个时候我们还要给他们自定义一个名字构成键值对</p><p>效果如下<br><img src="https://img-blog.csdnimg.cn/b634ea4481f1448e82d24dee3ef40f98.png" alt="在这里插入图片描述"><br>没错，如果你仔细看了代码，你会发现第<strong>二个组件内调用了第一个组件，但是从效果上来看并没有起到作用。</strong></p><p>这就是局部组件，<strong>只能在components中引入后才能使用</strong></p><p>所以如果硬要使用，就得像这样写：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = {</span><br><span class="line">    <span class="attr">components</span>:{</span><br><span class="line">        <span class="string">"niubi-title"</span>:title</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;niubi-title&gt;&lt;/niubi-title&gt;</span></span><br><span class="line"><span class="string">        &lt;button&gt;嘿，兄贵快来点我&lt;/button&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> <strong>其他形式</strong>：<br>这两种形式都是可以的，引入方式都一样</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/template"</span> <span class="attr">id</span>=<span class="string">"coolTitle"</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color:red;background-color:pink;"</span>&gt;</span>酷炫的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>嘿，兄贵快来点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"goodTitle"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color:red;background-color:pink;"</span>&gt;</span>酷炫的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>嘿，兄贵快来点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>使用：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = {</span><br><span class="line">    <span class="attr">components</span>: {</span><br><span class="line">    },</span><br><span class="line"></span><br><span class="line">    <span class="attr">template</span>:<span class="string">`#coolTitle</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意这时候对象中的template中就不能再书写其他东西了（包括前置空格）,不然总是会出一些稀奇古怪的问题</p><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="父组件向子组件传递props"><a href="#父组件向子组件传递props" class="headerlink" title="父组件向子组件传递props"></a>父组件向子组件传递props</h3><p>props其实就是参数</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> box = {</span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>: [<span class="string">'p'</span>],</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;h1 style="color:red;"&gt;{{p}}&lt;/h1&gt; `</span></span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="string">"great-box"</span>:box,</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">great-box</span> <span class="attr">:p</span>=<span class="string">"6666"</span>&gt;</span><span class="tag">&lt;/<span class="name">great-box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果如下<br><img src="https://img-blog.csdnimg.cn/890f5ac691f04f1fbbb87864d6228c29.png" alt="在这里插入图片描述"><br><strong>约束</strong><br>可以通过如下形式对参数传递的内容进行约束，<br>当内容不符合约束时，控制台会给出相应的警告</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box = {</span><br><span class="line">    <span class="attr">props</span>: {</span><br><span class="line">        <span class="attr">p</span>: <span class="built_in">String</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1 style="color:red;"&gt;{{p}}&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当然，也有更完善的约束形式：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box = {</span><br><span class="line">    <span class="attr">props</span>: {</span><br><span class="line">        <span class="attr">p</span>: {<span class="attr">type</span>:<span class="built_in">String</span>, <span class="attr">required</span>:<span class="literal">true</span>, <span class="attr">default</span>:<span class="string">'哈哈哈哈'</span>}</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1 style="color:red;"&gt;{{p}}&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>props命名规范</strong><br>props中比如写一个</p><p><strong>coolBrand，那么在html部分进行绑定时就要写成cool-brand，原因是html不区分大小写</strong></p><h3 id="no-props"><a href="#no-props" class="headerlink" title="no-props"></a>no-props</h3><p>不使用props传递内容</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="attr">price</span>: <span class="number">5</span></span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            },</span></span><br><span class="line"><span class="javascript">            <span class="attr">components</span>: {</span></span><br><span class="line"><span class="javascript">                <span class="string">"box"</span>: {</span></span><br><span class="line"><span class="javascript">                    <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">                    &lt;h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                        &lt;div&gt;吴彦祖？哦，是镜子啊&lt;/div&gt;    </span></span></span><br><span class="line"><span class="string"><span class="javascript">                    &lt;/h1&gt;`</span></span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }).mount(<span class="string">"#app"</span>);     </span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>当前的价格是{{price}}<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span> <span class="attr">ababa</span>=<span class="string">"阿巴阿巴"</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 200px;background-color: #faa;"</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/529ddf638633455687e0add94926579c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>课件，最外层的h1继承了模板标签的各项属性</p><p><strong>需要注意的是，在以下两种情况中，继承无法完成：</strong><br><strong>第一种：inheritAttrs:false</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">components: {</span><br><span class="line">    <span class="string">"box"</span>: {</span><br><span class="line">        <span class="attr">inheritAttrs</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;吴彦祖？哦，是镜子啊&lt;/div&gt;    </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;`</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>第二种：模板内最大父级元素不唯一 （并且不做处理时）</strong><br>此处指的两个h1标签，都是最大的父级元素</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">components: {</span><br><span class="line">    <span class="string">"box"</span>: {</span><br><span class="line">        <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;吴彦祖？哦，是镜子啊&lt;/div&gt;   </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;古尔丹？哦，是镜子啊&lt;/div&gt;   </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>在第二种情况中，如果还是想要继承</strong>，<br>可以使用用 <strong>v-bind:=”$attrs”</strong> ：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">components: {</span><br><span class="line">    <span class="string">"box"</span>: {</span><br><span class="line">        <span class="comment">// inheritAttrs:false,</span></span><br><span class="line">        <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1 :="$attrs"&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;吴彦祖？哦，是镜子啊&lt;/div&gt;   </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;h1 :="$attrs"&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;古尔丹？哦，是镜子啊&lt;/div&gt;   </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另外，我们还可以选择其中一部分属性继承</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">components: {</span><br><span class="line">    <span class="string">"box"</span>: {</span><br><span class="line">        <span class="comment">// inheritAttrs:false,</span></span><br><span class="line">        <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1 :a="$attrs.ababa"&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;吴彦祖？哦，是镜子啊&lt;/div&gt;   </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;h1 :style="$attrs.style"&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;古尔丹？哦，是镜子啊&lt;/div&gt;   </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是，这样具体到某一个属性的时候，v-bind需要加上一个名字（<strong>盲猜之前没加的时候都是自动把$attrs解构了</strong>）</p><h3 id="子组件向父组件传递"><a href="#子组件向父组件传递" class="headerlink" title="子组件向父组件传递"></a>子组件向父组件传递</h3><p>子组件向父组件传递的方式是通过自定义事件</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> box = {</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;button style="color:red;" @click="boxClick"&gt;我是子组件，快来点我&lt;/button&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">boxClick</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"子组件发出了信息"</span>);</span></span><br><span class="line"><span class="javascript">                <span class="comment">//1.this.$emit使得boxClick方法可以作为事件触发</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//（注意当做事件使用时，命名规则形如box-click）</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$emit(<span class="string">'boxClick'</span>);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="string">"great-box"</span>:box,</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">response</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"父组件表示收到"</span>);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 200px;background-color: #faa;"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2.把方法当事件用，绑定父组件中的一个方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">great-box</span> @<span class="attr">box-click</span>=<span class="string">"response"</span>&gt;</span><span class="tag">&lt;/<span class="name">great-box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>来一步一步分析：<br>1.子组件自定义一个方法，这个方法内部有一个this.$emit()是用于触发自定义事件的，<strong>它的存在使得这个函数可以作为一个事件来使用</strong>。<strong>其中值是作为事件时的名称</strong>，可以随意。<br>2.在模板标签上用1中所构成的自定义事件来绑定一个父组件的方法<br>3.触发子组件的自定义事件，则父组件的函数也会触发</p><p>效果：<br><img src="https://img-blog.csdnimg.cn/3655a43a56a14988a27cf2c61816a542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="refs-parent和-root"><a href="#refs-parent和-root" class="headerlink" title="$refs,$parent和$root"></a>$refs,$parent和$root</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//这个box就是子组件对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> box = {</span></span><br><span class="line"><span class="javascript">            <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div style="background-color: #faa;width:200px;height:200px"&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">            `</span></span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">            <span class="attr">components</span>:{</span></span><br><span class="line"><span class="javascript">                <span class="string">"box"</span>:box</span></span><br><span class="line"><span class="javascript">            },</span></span><br><span class="line"><span class="javascript">            <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">getChildComponent</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="comment">//this.$refs访问到所有具有ref属性的子组件对象</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'啊哈'</span>,<span class="built_in">this</span>.$refs);</span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        })</span></span><br><span class="line"><span class="javascript">        vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>给父组件下的元素添加一个ref属性，就是给个名字<br>点击button调用方法，通过this.$refs访问到父组件下的具有ref属性的子组件对象</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span> <span class="attr">ref</span>=<span class="string">"牛蛙牛蛙"</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span> <span class="attr">ref</span>=<span class="string">"牛蛙牛蛙2"</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getChildComponent"</span>&gt;</span>别来点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果：<br><img src="https://img-blog.csdnimg.cn/188f686bf7b74679b53bfc397823efcc.png" alt="在这里插入图片描述"><br>由于是对象，所以也可以通过这样的语句去进一步地访问:</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.牛蛙牛蛙);</span><br></pre></td></tr></tbody></table></figure><p><strong>至于$parent和$root，前者是访问最近的父级，后者是访问最远的父级，用法同上，不再赘述</strong></p><h2 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>一个组件在一个项目中可能会被反复用。但是问题是，我们可能会根据使用该组件的环境来对其进行一个调整，可是组件无法更改，我们也不想重新再写一个组件。就这样，插槽出现了。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    let box = {</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        template: `</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color: #faa;width: 250px;height: 250px;float:left"</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>好消息好消息!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>机会有限<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">           <span class="tag">&lt;<span class="name">p</span>&gt;</span>先到先得<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        `</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    }</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    let vm = Vue.createApp({</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        data(){</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            return{}</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        },</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        methods: {},</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        components: {</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            'box': box</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        }</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    });</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">vm.mount('#app');</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/db1d0d337f6d49cf9c93ee6c89d7b9fd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果我们要对其进行修改，那么就在组件标签中填入相应的内容，这些内容会依次匹配slot</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 50px;background-color: #fff;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hhhhh<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span></span><br><span class="line">        牛逼</span><br><span class="line">    <span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 32px;color: #fff;"</span>&gt;</span>6666<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>插入之后就是这样了<br><img src="https://img-blog.csdnimg.cn/a4ad142f6c824cffac7ef386b9044256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果需要默认内容的话，只要在slot标签里面写好就行了</p><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>也就是具有名字的插槽的意思。前面提到的都是匿名插槽，内容会自动匹配模板中的slot标签，这也意味着可能出现匹配错误的情况。为了准确的引导匹配，我们可以在slot标签中加上一个name属性，然后在插入的标签上加上v-slot。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box = {</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div style="background-color: #faa;width: 250px;height: 250px;float:left"&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;好消息好消息!&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name="dalao"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;机会有限&lt;/p&gt;</span></span><br><span class="line"><span class="string">       &lt;p&gt;先到先得&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意v-slot只能运用在template标签或者components中</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:dalao</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">box</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 32px;color: #fff;"</span>&gt;</span>6666<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意v-slot的值不加引号。另外，和v-on一样，v-slot可以简写为#</strong></p><h3 id="渲染作用域"><a href="#渲染作用域" class="headerlink" title="渲染作用域"></a>渲染作用域</h3><p>什么是渲染作用域？看看下面的代码就知道了：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">     <span class="keyword">let</span> box = {</span></span><br><span class="line"><span class="javascript">         <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">             <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                 <span class="attr">flag</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">             }</span></span><br><span class="line"><span class="javascript">         },</span></span><br><span class="line"><span class="javascript">         <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">             &lt;div style="background-color:green;width:200px;height:200px"&gt;&lt;/div&gt; </span></span></span><br><span class="line"><span class="string"><span class="javascript">         `</span></span></span><br><span class="line"><span class="javascript">     }</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">     <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">         <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">             <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                 <span class="attr">flag</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">             }</span></span><br><span class="line"><span class="javascript">         },</span></span><br><span class="line"><span class="javascript">         <span class="attr">components</span>: {</span></span><br><span class="line"><span class="javascript">             <span class="string">'box'</span>: box</span></span><br><span class="line"><span class="javascript">         }</span></span><br><span class="line"><span class="javascript">     })</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">     vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>上图中，子组件和父组件都有一个值为flag，但是分别为false和true。<br>那么假如像下图这样访问flag值，究竟会不会显示呢？</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span> <span class="attr">v-show</span>=<span class="string">"flag"</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>竟然是会显示的，解释是，在<strong>模板外访问flag值时</strong>，优先使用父级组件的值。<br><img src="https://img-blog.csdnimg.cn/3da22cd8a89c4322914f1b0e16c04c72.png" alt="在这里插入图片描述"><br>那么，什么又是在<strong>模板内访问flag值</strong>呢？</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box = {</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">            <span class="attr">flag</span>: <span class="literal">false</span></span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">//template里面使用就是模板内使用</span></span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div v-show="flag" style="background-color:green;width:200px;height:200px"&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就会<strong>只访问组件自身的值</strong><br>（如果自身没有，并不会向上访问父组件，反而会给出警告）<br><img src="https://img-blog.csdnimg.cn/557475ff8e804b5c8ae8c6f39670288e.png" alt="在这里插入图片描述"><br>总结起来就是，在模板外使用访问父组件的值，内部访问子组件自身的值</p><p><strong>那问题来了，如果要在模板外使用，却依旧需要子组件的值呢？</strong></p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽就是为了解决上述问题而诞生的<br>实际上就是一个v-bind与slot结合使用的产物，如果想通了v-bind的作用的话可以不用刻意去学作用域插槽</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> box = {</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                <span class="attr">datas</span>: [<span class="string">'123'</span>,<span class="string">'456'</span>,<span class="string">'789'</span>]</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="comment">//slot标签通过v-bind绑定data属性,并把datas赋值给data</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//后面通过v-slot:dalao1=""来接收</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div style="background-color:green;width:300px;height:300px"&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;h1&gt;广告位招商啦~&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                </span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;slot name="dalao1" :data="datas"&gt;&lt;/slot&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                </span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;h1&gt;买得早的都抱富(婆)了&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;/div&gt; </span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="string">'box'</span>: box,</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这里dataReceiver类似于一个参数，可以自由命名，其data属性(<strong>就是在模板里面绑定那个data</strong>)保存了传递的值<br>(#dalao1是v-slot:的简写)</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> #<span class="attr">dalao1</span>=<span class="string">"dataReceiver"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 32px;color: #fff;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"i in dataReceiver.data"</span>&gt;</span>{{i}}<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果如下<br><img src="https://img-blog.csdnimg.cn/787ebbfdeac24e498aa60f86af3e823b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>另外，如果不给slot一个name值，那么在使用v-slot时，写成v-slot:default=””就好了，这样就会自动匹配</p><h2 id="组件进阶"><a href="#组件进阶" class="headerlink" title="组件进阶"></a>组件进阶</h2><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>嘛…也没啥好说的，还是类似于一个模板</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">     <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">         <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">             <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                 <span class="attr">boxOne</span>: <span class="string">'cool-box'</span>,</span></span><br><span class="line"><span class="javascript">                 <span class="attr">boxTwo</span>: <span class="string">'handsome-box'</span></span></span><br><span class="line"><span class="javascript">             }</span></span><br><span class="line"><span class="javascript">         },</span></span><br><span class="line"><span class="javascript">         <span class="comment">//就是一个组件，名字都写明白了，然后替换掉is属性绑定的那个组件</span></span></span><br><span class="line"><span class="javascript">         <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript"> </span></span></span><br><span class="line"><span class="string"><span class="javascript">             &lt;component :is="boxOne"&gt;&lt;/component&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">         `</span></span></span><br><span class="line"><span class="javascript">     })</span></span><br><span class="line"><span class="javascript">     vm.component(<span class="string">'cool-box'</span>,{</span></span><br><span class="line"><span class="javascript">         <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">             &lt;h1&gt;很炫酷的box&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">         `</span></span></span><br><span class="line"><span class="javascript">     })</span></span><br><span class="line"><span class="javascript">     vm.component(<span class="string">'handsome-box'</span>,{</span></span><br><span class="line"><span class="javascript">         <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">             &lt;h1&gt;十分帅气的box&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">         `</span></span></span><br><span class="line"><span class="javascript">     })</span></span><br><span class="line"><span class="javascript">     vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>异步组件实际上也就是大家所想的那样<br>只是语法上要注意一下就是了</p><p>实现方式很多，只要保证结果是“在需要的时候才加载”就行了</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {}</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript">    vm.component(<span class="string">'box'</span>,Vue.defineAsyncComponent(<span class="function">()=&gt;</span>{</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>{</span></span><br><span class="line"><span class="javascript">            resolve({</span></span><br><span class="line"><span class="javascript">                <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">                    &lt;div&gt;hhhh&lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                `</span></span></span><br><span class="line"><span class="javascript">            })</span></span><br><span class="line"><span class="javascript">        })</span></span><br><span class="line"><span class="javascript">    }));</span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/cd217f0e0d66440289d5d6eae62f26f4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当然还有其他实现的形式:</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.component(<span class="string">'box2'</span>,</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">''</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>这种方法简洁一些，但实际上还是一个意思</p><h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p> <strong>钩子函数</strong><br>为什么叫钩子函数？大概就是说，钩在某个组件上的函数，这个函数会在组件创建到销毁过程中的<strong>某个阶段触发</strong><br>使用方式类似于下面这样：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'beforeCreate!!!!'</span>);</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>beforeCreate顾名思义就是创建之前执行的函数。<br>其他常用的生命周期钩子函数还有：<br>| 阶段   | 名称          | 作用                                   |<br>| —— | ————- | ————————————– |<br>| 初始化 | beforeCreate  | 创建之前执行                           |<br>| 初始化 | created       | 创建之后执行                           |<br>| 初始化 | beforeMount   | 渲染（挂载）之前执行                   |<br>| 初始化 | mounted       | 渲染（挂载）之后执行                   |<br>| 更新   | beforeUpdate  | 数据更新之前执行                       |<br>| 更新   | updated       | 数据更新之后执行                       |<br>| 销毁   | beforeUnMount | app.unmount(‘#app’)（DOM销毁）之前执行 |<br>| 销毁   | unMounted     | app.unmount(‘#app’)（DOM销毁）之前执行 |</p><p>(unmount方法可以手动结束组件的生命周期，但是不建议操作组建的生命周期)</p><h3 id="侦听器watch"><a href="#侦听器watch" class="headerlink" title="侦听器watch"></a>侦听器watch</h3><p><strong>侦听数据，当其发生变化时，触发相应的操作</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="attr">price</span>: <span class="number">5</span></span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            },</span></span><br><span class="line"><span class="javascript">            <span class="attr">watch</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="comment">//第一个参数是当前的值，第二个参数是之前的值</span></span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">price</span>(<span class="params">cur, pre</span>)</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"price变化了"</span>)</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"现在的值是"</span>,cur)</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"以前的值是"</span>,pre)</span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }).mount(<span class="string">"#app"</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">//注意，这里的挂载！</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//之前都是单独写一个vm.mount("#app")</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//只有这样写才能用vm.price访问</span></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/ab57a0a72504417b9d8fbbe6676eb63d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么问题来了，这个和computed有什么区别呢?<br>通俗地说，区别在于：<br><strong>watch支持异步，不缓存，并且可以接受两个参数；<br>computed不支持异步，默认缓存；</strong><br>更多的区别在于：<br>watch默认为浅度观测（对多层嵌套，只观测其最外层）….<br>computed在调用时需要在模板中渲染，且默认为深度依赖（对多层嵌套，观测所有）….<br><strong>分别什么时候用？</strong><br>计算属性就用computed；<br>异步、复杂的操作 或者 一个值得变化会引起一堆值变化的情况 就用 watch</p><h2 id="特效动画"><a href="#特效动画" class="headerlink" title="特效动画"></a>特效动画</h2><p>（略）<br>两种使用特效动画的方式，<br>一种是通过动态修改class等来添加动画，这个就是css3的内容，不在话下；<br>另一种就是Vue封装的特效动画。<br>不过这个东西个人感觉相对次要，这里先不做笔记，以后再说</p><h2 id="Vue高阶API"><a href="#Vue高阶API" class="headerlink" title="Vue高阶API"></a>Vue高阶API</h2><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>前面我们用到了v-if等指令，现在我们来自定义指令<br>比如我们来自定义一个叫做v-tianxiu的指令</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">              <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">          },</span></span><br><span class="line"><span class="javascript">          <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">          },</span></span><br><span class="line"><span class="javascript">          <span class="attr">directives</span>:{</span></span><br><span class="line"><span class="javascript">              <span class="attr">tianxiu</span>: {</span></span><br><span class="line"><span class="javascript">                  <span class="comment">// 里面写生命周期钩子</span></span></span><br><span class="line"><span class="javascript">                  <span class="function"><span class="title">mounted</span>(<span class="params">el</span>)</span>{</span></span><br><span class="line"><span class="javascript">                      el.focus();</span></span><br><span class="line"><span class="javascript">                      <span class="built_in">console</span>.log(<span class="string">'执行成功了'</span>);</span></span><br><span class="line"><span class="javascript">                  }</span></span><br><span class="line"><span class="javascript">              }</span></span><br><span class="line"><span class="javascript">          }</span></span><br><span class="line"><span class="javascript">      })</span></span><br><span class="line"><span class="javascript"><span class="comment">//这样写也可以</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//也可以写个局部的然后挂载到组件上</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// vm.directive('tianxiu',{</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//     mounted(el){</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//         el.focus()</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//         console.log('执行成功')</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//     }</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// }</span></span></span><br><span class="line"><span class="javascript">      vm.mount(<span class="string">"#app"</span>)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样一来，在组件挂载后就会执行这个v-tianxiu<br>也就是 自动聚焦+输出“执行成功了”</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入一点东西"</span> <span class="attr">v-tianxiu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>自定义事件最多可以有四个参数<br><img src="https://img-blog.csdnimg.cn/746670b5723846ea80aea9977c194572.png" alt="在这里插入图片描述"></p><h3 id="传送门teleport"><a href="#传送门teleport" class="headerlink" title="传送门teleport"></a>传送门teleport</h3><p>就和c/c++的goto差不多一个意思</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">components: {</span><br><span class="line">    <span class="string">'box'</span>: {</span><br><span class="line">        <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;div class="box"&gt;这是box&lt;/div&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    },</span><br><span class="line">    <span class="string">'container'</span>: {</span><br><span class="line">        <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;teleport to=".box"&gt;</span></span><br><span class="line"><span class="string">                &lt;div class="mask"&gt;是container组件的部分&lt;/div&gt;    </span></span><br><span class="line"><span class="string">            &lt;/teleport&gt;</span></span><br><span class="line"><span class="string">            &lt;div class="container"&gt;这是container&lt;/div&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里box和container是两个不相干的标签</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container</span>&gt;</span><span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>但是通过teleport传送，让container的部分传送到了box内<br>并且是放到box内<strong>原有的DOM元素之后</strong><br><img src="https://img-blog.csdnimg.cn/ff8bd21695c34f658f5531386ec2be41.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="组件式API"><a href="#组件式API" class="headerlink" title="组件式API"></a>组件式API</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>本来应该放到Vue高阶API中的，但是由于过于重要，所以单独提出来<br>之前我们在Vue2.x中的写法:</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{},</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {},</span></span><br><span class="line"><span class="javascript">        <span class="attr">computed</span>: {},</span></span><br><span class="line"><span class="javascript">        <span class="attr">watch</span>: {},</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: {},</span></span><br><span class="line"><span class="javascript">        <span class="attr">directives</span>: {}</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript">vm.mount()</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样把，不同的内容分类放到不同的选项里面就是<strong>选项式API</strong><br>但是如果后期业务量庞大起来，一个功能的相关内容会分布到各个位置，维护起来就十分麻烦。<br>所以Vue3.x推出了组件化API，把一个业务的内容放到一个地方</p><p>（以下图片来自网络）<br>这是选项式API<br><img src="https://img-blog.csdnimg.cn/8c951f4fca6d4e1ba2f080f170ec8cbf.png" alt="请添加图片描述"><br>这是组件式API<br><img src="https://img-blog.csdnimg.cn/c26eedba3dc943928a81ff6432523cb0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>接下来我们开始使用组件式API<br>其中，改动了不少生命周期函数（删了一些又增了一些）</p><h3 id="新的生命周期钩子"><a href="#新的生命周期钩子" class="headerlink" title="新的生命周期钩子"></a>新的生命周期钩子</h3><p> setup()<br>取代了beforeCreate()和created()，<br>并且不建议再使用data()等（虽然可以并存）</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                <span class="attr">msg</span>: <span class="string">'hello compositionAPI'</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">sayHi</span>: <span class="function">()=&gt;</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="built_in">this</span>,<span class="string">'hhh'</span>);</span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;h1&gt;{{msg}}&lt;/h1&gt;  </span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;button @click="sayHi"&gt;点击一下&lt;/button&gt;  </span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }).mount(<span class="string">"#app"</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/e8f67afc3f9849228c875f9a83781374.png" alt="在这里插入图片描述"><br>这里注意setup是创建之前触发，此时this指向的是window<br>更多生命周期钩子变化如下：<br>| 选项式API                                                    | 组件式API         |<br>| ———————————————————— | —————– |<br>| beforeCreate                                                 | setup             |<br>| created                                                      | setup             |<br>| beforeMount                                                  | onBeforeMount     |<br>| mounted                                                      | onMounted         |<br>| beforeUpdate                                                 | onBeforeUpdate    |<br>| updated                                                      | onUpdated         |<br>| beforeUnmount                                                | onBeforeUnmount   |<br>| unmounted                                                    | onUnmounted       |<br>| errorCaptured                                                | onErrorCaptured   |<br>| renderTracked                                                | onRenderTracked   |<br>| renderTriggered                                              | onRenderTriggered |<br>| 其中onRenderTracked是每次<strong>页面刷新后重新收集响应式依赖时</strong>， |                   |<br>| 然后onRenderTriggered是每次<strong>页面重新渲染时</strong>                |                   |</p><p>需要注意，除了setup之外，其余的都要写到setup里面，比如：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp({</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span><br><span class="line">        <span class="keyword">let</span> name = <span class="string">'张三丰'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> {onMounted} = Vue</span><br><span class="line">        onMounted(<span class="function">()=&gt;</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'挂载成功'</span>)</span><br><span class="line">        })</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">            name</span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">}).mount(<span class="string">"#app"</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>在过去选项式API里面，data()中的数据会被处理从而能达到响应式的效果,<br>但是组件式API里面就不会自动处理<br><img src="https://img-blog.csdnimg.cn/bf5c5fd4430e4a9eaf1c59de699986ab.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>要是没了方便的响应式效果，那么框架也失去了一大亮点<br>所以我们需要一个东西来实现基础数据的响应式，于是乎ref就诞生了</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span></span><br><span class="line"><span class="javascript">        <span class="comment">//解构赋值，从Vue对象里拿到ref</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> {ref} = Vue</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">            <span class="comment">//像这样处理基础数据</span></span></span><br><span class="line"><span class="javascript">                <span class="attr">msg</span>: ref(<span class="string">'hello compositionAPI'</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">sayHi</span>: <span class="function">()=&gt;</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="built_in">this</span>,<span class="string">'hhh'</span>);</span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;h1&gt;{{msg}}&lt;/h1&gt;  </span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;button @click="sayHi"&gt;点击一下&lt;/button&gt;  </span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }).mount(<span class="string">"#app"</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/cdff4dc28fdd47d0810fcb6b0ffbed90.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>原理是通过proxy代理，<strong>包装成proxy（{value:….}）</strong>的形式<br>至于多次提到的proxy代理到底是什么，后面再细嗦</p><p>另外，需要注意，<strong>如果在代码中对msg的值进行修改，需要写成msg.value的形式</strong><br><strong>（在页面上不用这么写是因为底层会自动帮你转化为msg.value）</strong></p><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>其实作用和ref差不多，就是约定俗成地，<strong>在对 数组对象等引用类数据 进行响应式处理地时候，我们不使用ref，而使用reactive</strong><br>（其实ref也可以，处理引用类数据地时候，ref底层还是会自动使用reactive，不过这样一来效率就低多了，所以不推荐）</p><p>唯一需要注意的是，reactive没有value属性，访问值的时候需要这样写:</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> {computed, ref, reactive} = Vue</span><br><span class="line"><span class="keyword">let</span> num1 = reactive({<span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span>})</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> show = <span class="function">()=&gt;</span>{</span><br><span class="line"><span class="built_in">console</span>.log(num1)<span class="comment">//proxy代理</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num1.value)<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把num1作为了一个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(num1.one,num1.two)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/86729232441f411ab43a5d64b918910f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>用法都一样，这里就不再赘述了</p><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>顾名思义咯，只读<br>防止数据传递传着传着就变了</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> {readonly} = Vue</span><br><span class="line"><span class="keyword">const</span> myName = readonly(ref(<span class="string">'吴彦祖'</span>))</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/7d454f9f2694420a8fc4f691586b9717.png" alt="在这里插入图片描述"></p><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>在解构赋值的时候比较常用<br>比如，解构赋值一个具有响应式能力的对象时，<br>解构后的数据就成为了普通的数据而不再具有响应式能力<br><strong>如果我们希望其继续拥有响应式能力，那么就要使用到toRefs()</strong><br><img src="https://img-blog.csdnimg.cn/f9c1b3eafb08491c98a30f698d004030.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了方便阅读，往后尽量只给出关键的代码</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> {ref, toRefs, reactive} = Vue</span><br><span class="line"><span class="keyword">let</span> person = reactive({<span class="attr">name</span>:<span class="string">"古尔丹"</span>, <span class="attr">job</span>:<span class="string">"大酋长"</span>})</span><br><span class="line"><span class="comment">//解构赋值后的name和job也会拥有响应式的能力</span></span><br><span class="line"><span class="keyword">let</span> {name, job} = toRefs(person)</span><br></pre></td></tr></tbody></table></figure><p>原理还是proxy代理，把代理的对象拆开，给属性代理</p><h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><p>本质还是把里面的东西丢给代理<br>相关语法如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> {ref, toRefs, reactive,toRef} = Vue</span><br><span class="line"><span class="keyword">let</span> age = toRef(person, <span class="string">'age'</span>).value = <span class="number">233</span></span><br></pre></td></tr></tbody></table></figure><p>这里需要两个参数，第一个是对象名称，第二个是该对象的属性名称<br>toref返回一个proxy代理,也就有value值<br>和toRefs的差异大概也就和名字意义的差异一般</p><p>这里不得不说一下<strong>ref(),reactive(),toRef(),toRefs()的区别</strong><br>ref()深拷贝，获取数据时需要加上.value<br>reactive()深拷贝，不需要加.value（ref是在reactive的基础上实现的）<br>toRef()浅拷贝，获取数据时需要加上.value<br>toRefs()浅拷贝，获取数据时需要加上.value</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>context上下文<br>就是setup的参数</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span><br><span class="line"><span class="keyword">const</span> {ref, toRefs, reactive,toRef} = Vue</span><br><span class="line"><span class="keyword">let</span> {attrs, slots, emit} = context</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"这是attrs:"</span>,attrs)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"这是slots:"</span>, slots)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"这是emit:"</span>, emit)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"props:"</span>,props)</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>attrs在前面no-props提到过，也就是继承的属性，<br>slots是插槽<br>emit在前面组件通信提到过，是发射的事件<br>props是v-bind绑定传过来的参数<br><img src="https://img-blog.csdnimg.cn/713e6e13cd8544259be9e83f9580eb92.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>没错就是那个computed，现在又来了<br>不过这里需要引入一下<br>作用也没变，都是把东西放到缓存</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> {computed, ref} = Vue</span><br><span class="line"><span class="keyword">let</span> num1 = ref(<span class="number">233</span>)</span><br><span class="line"><span class="keyword">let</span> num2 = computed(<span class="function">()=&gt;</span>{</span><br><span class="line">     <span class="keyword">return</span> num1.value * <span class="number">10</span>;</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>还是侦听器，和以前一样</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = Vue.createApp({</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span><br><span class="line">        <span class="keyword">let</span> {computed, ref, reactive,watch} = Vue</span><br><span class="line">        <span class="keyword">let</span> myName= ref(<span class="string">''</span>)</span><br><span class="line">        <span class="comment">//监听myName</span></span><br><span class="line">        watch(myName,<span class="function">(<span class="params">cur, pre</span>)=&gt;</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"现在的值："</span>, cur)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"过去的值："</span>,pre)</span><br><span class="line">        })</span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">            myName</span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;input type="text" placeholder="请输入你的姓名" v-model="myName"&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;我的名字是：{{myName}}&lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">}).mount(<span class="string">"#app"</span>)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/871b2d0879614779972f96345d22dc9b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果监听多个值的话，写成如下形式即可</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watch([myName,myAge],<span class="function">(<span class="params">[curName, curAge], [preName, preAge]</span>)=&gt;</span>{</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"现在的值："</span>, curName, <span class="string">"和"</span>, curAge)</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"过去的值："</span>,preName, <span class="string">"和"</span>, preAge)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>另外，由于<strong>监听的对象不能是一个对象的属性</strong>，那么如果要监听对象的属性的话，需要这么写：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(<span class="function">()=&gt;</span>person.name,<span class="function">(<span class="params">cur,pre</span>)=&gt;</span>{</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">""</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>用一个函数返回一手，就可以变成一般的数据类型了（当然你可以解构之类的）</p><p>watch还有第三个参数，再说这个之前先了解<strong>watch的性质</strong>：</p><p>1.默认<strong>惰性</strong>（浏览器打开不会自动触发，要等到相关组件开始活动才触发，比如输入框要输入后才触发）</p><p>2.可调度（可以选择是否有惰性以及是否深度监视）<br>（tip：<strong>浅度监视</strong>是只监视如一个对象Obj1，发生如同Obj1 = Obj2这种操作Obj1本身发生的变化，会<strong>忽视对象内部的变化</strong>；相反地，<strong>深度监视</strong>就是会<strong>监视对象的所有变化</strong>）</p><p>具体语法：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch(<span class="function">()=&gt;</span>person.name, <span class="function">(<span class="params">cur, pre</span>)=&gt;</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"现在的值："</span>, cur)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"过去的值："</span>, pre)</span><br><span class="line">},{</span><br><span class="line">    <span class="comment">//是否立即执行（是否取消惰性）</span></span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//是否深度监视</span></span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">false</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>还是侦听器，不过默认深度监视，没有惰性，并且不能查询变化以前的值</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="function">()=&gt;</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'watchEffect开始监听:'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'myName:'</span>, myName.value)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'myAge'</span>, myAge.value)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/a1d8d165dfee4e678bbe7b4525286e03.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="provide与inject"><a href="#provide与inject" class="headerlink" title="provide与inject"></a>provide与inject</h3><p>由于<strong>Vue是单向数据流</strong>，孙组件要用父组件内的数据的话，得先经过子组件，也就是：<br>父组件—&gt;子组件—–&gt;孙组件<br>如果嵌套层级过多，那么数据传递效率就会相当慢<br>或者，两个毫不相干的组件之间传递数据的…</p><p>除了组件通信中提到的方法，这里还可以使用provide和inject</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> grandson = {</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div style="background-color:red;"&gt;我是孙组件&lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> son = {</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="string">'grandson'</span>: grandson </span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div style="background-color:orange"&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                我是子组件</span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;grandson&gt;&lt;/grandson&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;/div&gt;      </span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> father = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                <span class="attr">fatherMsg</span>: <span class="string">'我是father'</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="string">'son'</span>: son</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div style="background-color:yellow"&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                我是父组件</span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;son&gt;&lt;/son&gt;    </span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }).mount(<span class="string">"#app"</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/d263b927a6a148ab89ce2593de647e1d.png" alt="在这里插入图片描述"></p><p>如果需要跨越性传递数据：</p><p>使用provide向所有内部组件提供数据</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span><br><span class="line">    <span class="keyword">const</span> {ref, provide} = Vue</span><br><span class="line">    <span class="comment">//注意这里是value</span></span><br><span class="line">    <span class="keyword">let</span> fatherMsg = ref(<span class="string">'我是father'</span>).value</span><br><span class="line">    provide(<span class="string">'fatherMsg'</span>, fatherMsg)</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        fatherMsg</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>使用inject接收数据</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span><br><span class="line">    <span class="keyword">const</span> {inject} = Vue</span><br><span class="line">    <span class="keyword">let</span> grapaMsg = inject(<span class="string">'fatherMsg'</span>, <span class="string">'第二个参数:默认值'</span>)</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        grapaMsg</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/0bbf25548a8f4c4696796036e2adfe0d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4497a2b2d63c47209083a0d85aca566b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="ref获取真实DOM"><a href="#ref获取真实DOM" class="headerlink" title="ref获取真实DOM"></a>ref获取真实DOM</h3><p>注意这个ref不是之前的ref，而是写在标签里面作为属性的ref</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">"mark"</span>&gt;</span>我被ref标记了！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp({</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span><br><span class="line">        <span class="keyword">const</span> {ref, onMounted} = Vue</span><br><span class="line">       <span class="comment">//这样一来，mark在app被挂载之后就会获得真实DOM</span></span><br><span class="line">       <span class="comment">//下面这个ref纯属是为了让mark获得响应式</span></span><br><span class="line">        <span class="keyword">let</span> mark = ref(<span class="string">''</span>)</span><br><span class="line">        onMounted(<span class="function">()=&gt;</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(mark.value)</span><br><span class="line">        })             </span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">            mark</span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">}).mount(<span class="string">"#app"</span>)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/0cddca315821403a8da792d9223b9aeb.png" alt="在这里插入图片描述"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>到这里Vue篇大概也算完结了，不过我也会继续修改补充完善内容。<br>考虑到使用频率，部分没有提及的Vue知识点会在后续的<strong>Vue-Cli篇</strong>中补充。<br>感谢各位的阅读。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础</title>
      <link href="/2022/01/07/javabasic/"/>
      <url>/2022/01/07/javabasic/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>本来以前是学过Java的（指2021年1月左右）…但是..但是主要是使用前端的知识，久了没碰Java就快忘完了…<br>这也不是第一次把本就没学多少的Java知识忘得一干二净了，<br>这边正好赶上学校要开Java课程了，所以这次痛定思痛决定写个学习笔记，希望能帮助自己的同时