<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>EventLoop中同步异步和微宏任务</title>
      <link href="/2021/12/07/eventloop/"/>
      <url>/2021/12/07/eventloop/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器构成概述"><a href="#浏览器构成概述" class="headerlink" title="浏览器构成概述"></a>浏览器构成概述</h2><p>浏览器是多线程的<br>主要包括以下六个线程：</p><blockquote><p><strong>1.GUI渲染线程（DOM/BOM）<br>2.JS引擎线程（web worker）<br>3.浏览器事件线程 （onclick）</strong><br>4.定时器线程<br>5.Http网络请求线程<br>6.EventLoop线程</p></blockquote><p><strong>其中,123是常驻线程，始终存在；而456是在有需求是才会存在的线程</strong></p><h2 id="JS执行"><a href="#JS执行" class="headerlink" title="JS执行"></a>JS执行</h2><p>单线程异步（不考虑web worker）。<br>从前到后一行一行顺序执行，一行报错则就此终止执行</p><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>由<strong>调用栈</strong>和<strong>任务队列</strong>组成,<br>而消息队列又分为<strong>微任务队列</strong>和<strong>宏任务队列</strong></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>遇到同步任务，直接将其放入<strong>调用栈</strong>中执行<br>遇到异步任务，先托管到对应的<strong>线程</strong>，时机到了再放入<strong>任务队列</strong>，再排队进入<strong>调用栈</strong><br><img src="https://img-blog.csdnimg.cn/6e5e108e23574e65b0c6214187176af6.png" alt="事件轮询示意图"></p><p>即<strong>先同后异</strong><br>另外，需要注意，<strong>定时器的时间参数不能小于4ms</strong>，这一点在开发人工智能反作弊系统的时候也体会过</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>回顾一下Promise的三种状态：pending resolved rejected<br>即初始为pending，then正常执行返回resolved，报错则rejected</p><p>pending状态下是同步的，调用then方法（或者resolve、reject函数）的部分为异步</p><h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><p>本质上是Promise的语法糖<br>async修饰的函数就是以同步函数的形式表现异步函数的操作<br>但是如果async约束的函数里面没有用到await，那么<strong>async不会产生任何影响，其修饰的函数依旧是同步</strong><br>可以转化为Promise的形式，比如</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">await</span> async2()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">}</span><br><span class="line">async1()</span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">resolve()</span><br><span class="line">}).then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line">}</span><br><span class="line">async1()</span><br></pre></td></tr></tbody></table></figure><p>上述两段代码等价，结果都是1 3 2</p><h3 id="宏微任务"><a href="#宏微任务" class="headerlink" title="宏微任务"></a>宏微任务</h3><p>先微后宏和先微后宏只要解释得当都算是对的，<br>一般我们说是先微后宏，<br>但是如果硬要把主线程代码看成宏任务，那就是先执行宏<br><strong>微任务Micro-task</strong></p><blockquote><p>主线程代码（script中的代码）<br>setTimeOut<br>setInterval<br>setImmediate<br>requestAnimationFrame<br>I/O流<br>UI render<br>AJAX</p></blockquote><p><strong>宏任务Macro-task</strong></p><blockquote><p>process.nextTick<br>Promise（严格来说是new Promise().then()）<br>Async/Await（实际上和Promise一样）<br>MutationObserver（H5新特性）（这什么鬼啊）</p></blockquote><p><strong>示例图</strong><br>这里把主线程代码看做宏任务，所以是先宏后微的<br>但是记住，我们一般说是先微后宏<br><img src="https://img-blog.csdnimg.cn/075ffaf73b8b47bea6a9126ae7b772e1.png" alt="宏微任务执行流程示意图"><br>当微任务和宏任务多层嵌套时，大概过程如下：<br><img src="https://img-blog.csdnimg.cn/b648123e3587452da79503fbe96abff8.png" alt="宏微任务嵌套"></p><h3 id="完整的Event-Loop"><a href="#完整的Event-Loop" class="headerlink" title="完整的Event Loop"></a>完整的Event Loop</h3><p><img src="https://img-blog.csdnimg.cn/60a72ac05ece48c8aa764f44724ca2e3.png" alt="Event Loop完整流程"><br>总结就是<br>先同后异，先微后宏</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈web--持续更新--</title>
      <link href="/2021/12/06/webintro/"/>
      <url>/2021/12/06/webintro/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章主要是给刚接触web的同学们阅读的，</p><p>目的是希望他们能够对web开发有个大概的认识</p><p>不过由于我个人主要是做前端开发的，所以内容更多的是会侧重前端的知识</p><p>当然有什么问题的话直接来问我就行了，联系方式qq2779066456</p><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>如果你打算手写一下代码的话，那就可以看看这部分，没打算写的话就算了</p><h3 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h3><p>推荐一些</p><table><thead><tr><th>名称</th><th>评价</th></tr></thead><tbody><tr><td>sublime text</td><td>轻量级，适合入门</td></tr><tr><td>vscode</td><td>方便装插件，更加全面、美观</td></tr><tr><td>intelligent idea</td><td>相当全面，写前端的同时还方便写后端代码</td></tr><tr><td>webstorm</td><td>相对更倾向前端，大家用了都说好，适合进阶</td></tr></tbody></table><p>其实用记事本写也可以，只需要把扩展名txt改为html，然后用浏览器打开即可</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>web前端当然要有浏览器才能运行起来，这里注意使用大牌浏览器（比如某绿色浏览器、企鹅浏览器之类的就不要用了）</p><p>这里推荐六个浏览器</p><table><thead><tr><th>浏览器</th><th>评价</th><th>内核</th></tr></thead><tbody><tr><td>IE</td><td>万恶之源，前端人的噩梦，入门建议别用这个，不然出一堆兼容问题</td><td>Trident</td></tr><tr><td>Chrome</td><td>基于开源的Chromium的闭源浏览器，个人觉得必装</td><td>以前是Webkit，现在是Blink</td></tr><tr><td>Firefox</td><td>推荐装</td><td>Gecko</td></tr><tr><td>Opera</td><td>这个…国内好像没什么人用，那个人想装就装吧</td><td>最初是presto，再是Webkit，现在是Blink</td></tr><tr><td>Safari</td><td>mac的御用浏览器，这个能装就装吧</td><td>Webkit</td></tr><tr><td>Microsoft Edge</td><td>Windows自带的，相当于重生的IE，还是挺好用的，也是基于Chromium</td><td>Blink(?)</td></tr></tbody></table><p>上述六个浏览器中，除了IE的兼容性相对拉胯之外，其他都还行。<br>个人觉得入门至少要在Chrome、FireFox、Edge中三选一</p><h2 id="认识Web"><a href="#认识Web" class="headerlink" title="认识Web"></a>认识Web</h2><h2 id="什么是Web工程师"><a href="#什么是Web工程师" class="headerlink" title="什么是Web工程师"></a>什么是Web工程师</h2><p>Web工程师是一个宽泛的概念，从事Web开发相关方向的程序员都是Web工程师，其实以前端开发和后端开发为主<br>开发浏览器网页、App、小程序等项目</p><p>这里用网页来举例子，<br>由于网页需求量极大，一个网站可能存在几十上百个子页面，所以对Web工程师的需求量也是日益增多；<br>再加上经济迅速发展，如双十一这类购物活动所带来的超大数据量和超高并发度（比如一秒钟内上亿条数据需要处理），对Web工程师的要求也越来越高<br>所以Web工程师是一个需求量大，并且薪资待遇客观的职业<br>（比如我们的Cloud God，一个月30+k还有10+k的年终奖）</p><h2 id="什么是前端工程师"><a href="#什么是前端工程师" class="headerlink" title="什么是前端工程师"></a>什么是前端工程师</h2><p>前端工程师是Web工程师的一类。</p><p><font color="red">不是平面设计师或者UI设计师！</font></p><p>随着计算机技术的发展，Web也有了巨大的飞跃，一个人难以完成整个Web的工作，于是出现了前端工程师这一个分支（没错，后端算是Web工程师正统传人…）</p><p>最早的前端是很低端的工作，因为做前端有一种做ppt的感觉，一切都那么原始</p><blockquote><p>早期的三剑客时代，不过这个对于我来说也是很古早了，只知道三者之一的Flash，大概在20年的时候停止服务了<br>后面到三件套时代，分别由HTML CSS JavaScript三个部分组成，分别负责一个页面的结构、样式、逻辑行为,这些东西我们后面会一一做个大概地介绍。不过这个时期的开发依旧还是原始的。</p></blockquote><p>随着时间的推移…</p><blockquote><p>谷歌工程师为前端带来天火——Angular框架，还有Node.js的诞生后，加上2016年ES6标准出现后，就进入了百花齐放的大前端时代，这时候，无名之丘崛起为峰，尘埃与曙光共升腾！前端从此告别刀耕火种，JavaScript也从脚本语言飞升为面向对象高级语言，模块化、组件化等等一系列地全新技术爆发式地出现，前端展现出了蓬勃的生命力。</p></blockquote><p><strong>那么前端工程师能做什么呢</strong></p><p>主要是<strong>开发所有用户能够直接 看到的 和 操作到的 内容，并且和后端交互数据</strong>，比如各种微信小程序，手机上的淘宝京东等APP，电脑上的淘宝京东等网页，还有各种网页小游戏等等</p><p>另外也涉及大数据可视化、爬虫和反爬虫、web安全等等方面的知识</p><h2 id="什么是后端工程师"><a href="#什么是后端工程师" class="headerlink" title="什么是后端工程师"></a>什么是后端工程师</h2><p>由于我是前端的，所以只能凭借自己微薄的后端经验来说说这个<br>后端工程师作为Web工程师的正统传承，学习的知识体系目前仍然比前端大不少，而且使用的语言也是五花八门，包括C/C++, PHP, Python, Java, Go等等（但是<strong>感觉</strong>还是Java和Go居多）<br>而且还会涉及到各种数据库的操作，当然这个我就不了解了<br>总之就是学习难度确实比前端大，而且就业时要求会比前端稍微高一点（特别是在算法上体现得尤为明显）</p><p><strong>后端工程师能做什么</strong><br>以合理的方式接收前端传递过来的数据（接收<strong>请求</strong>），然后对数据进行合理的处理，再以合理的方式回传（<strong>响应</strong>）给前端</p><p>举个例子，前端的登录页面给后端传了用户名和密码，后端在数据库中查找信息，如果这个用户确实是已经注册过（信息记录在数据库中），那么就响应一个信息告诉前端登录成功，前端随机发生登录后的页面跳转</p><p>如果未登录的用户试图直接输入URL来跳转页面，那么后端的拦截器会阻止这个操作（当然，大前端时代下，这个工作交给前端来完成了）</p><h2 id="简单了解HTML"><a href="#简单了解HTML" class="headerlink" title="简单了解HTML"></a>简单了解HTML</h2><h3 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML"></a>什么是HTML</h3><blockquote><p>全称是Hyper Text Market Language（超文本标记语言），用来写超文本。<br>规范是由W3C指定的，大家都会遵循这个标准（除了IE）。</p></blockquote><p>那什么是<strong>超文本</strong>?</p><blockquote><p>普通文本就是文字，超文本指的是流媒体、图片、声音、视频等等</p></blockquote><h3 id="HTML基本结构"><a href="#HTML基本结构" class="headerlink" title="HTML基本结构"></a>HTML基本结构</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>上述代码就是一个最基本的HTML文件结构，我们一步一步分析</p><p><strong>标签</strong><br>这是构成HTML代码的基本单位<br><img src="https://img-blog.csdnimg.cn/82717e4b7ba44df384bb5285b94ce9fa.png" alt="在这里插入图片描述"><br>从图中我们可以得知：</p><blockquote><p>1.形如&lt;…&gt;的就叫标签<br>2.由&lt;…&gt;&lt;/…&gt;构成的叫双标签，前者为头标签，后者为尾标签，二者之间可以写东西<br>3.只有一个&lt;…&gt;的叫单标签<br>4.标签可以嵌套</p></blockquote><hr><p><strong>文档声明</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;! DOCTYPE html&gt;</span><br></pre></td></tr></tbody></table></figure><p>这其实不是HTML的标签，它是为了告诉浏览器用什么模式标准进行<strong>渲染</strong>（可以类比编译，把代码变成图形）<br>这样写就是采用<strong>HTML5</strong>进行渲染</p><p>我们也可以看一下其他模式的写法<br><strong>HTML 4.01 Strict</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD HTML 4.01//EN"</span> <span class="meta-string">"http://www.w3.org/TR/html4/strict.dtd"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>HTML 4.01 Frameset</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD HTML 4.01 Frameset//EN"</span> <span class="meta-string">"http://www.w3.org/TR/html4/frameset.dtd"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>当然，我们现在都采用HTML5</p><hr><p><strong>HTML文档</strong></p><p><img src="https://img-blog.csdnimg.cn/640c746ca690422593bd68c1cf094d98.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="HTML基本结构"></p><blockquote><p><strong>根标签</strong>，也叫html标签是一个双标签，之后我们所有内容将写在其头标签和尾标签之间；<br><strong>文档头</strong>也叫head标签，之间用于书写一些配置类的东西（正如其名，head，头部，作用和大脑一样）<br><strong>文档体</strong>也叫body标签，之间书写页面的主体内容（正如其名，body，身体，决定了整个页面的结构）</p></blockquote><h3 id="使用HTML"><a href="#使用HTML" class="headerlink" title="使用HTML"></a>使用HTML</h3><p>新建一个文件，将扩展名（后缀名）改为html，用编译工具打开即可<br><img src="https://img-blog.csdnimg.cn/31e67237428b476bb092a05c67bc7e6b.png" alt="在这里插入图片描述"><br>书写如下内容</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>你好，HTML<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>如果使用的是sublime text，那么直接按下F12即可渲染<br>如果是vscode，那么按下alt+b即可（需要安装插件）<br>如果是idea或者webstorm，那么点击右上角的浏览器图标即可<br>（不管用什么，鼠标右键之后应该都有“在浏览器打开的选项”）</p><p>我们这里采用sublime + chrome<br><img src="https://img-blog.csdnimg.cn/089fa3bdbd1b46c0a13245ca36961a76.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="你好HTML"></p><p>HTML准确地说并不算是编程语言，它最多是个脚本语言，因为它不具备逻辑运算等能力</p><h3 id="两类标签"><a href="#两类标签" class="headerlink" title="两类标签"></a>两类标签</h3><p>就好像水，如果要控制水，那么首先得想办法把它装起来，这时候我们就需要容器<br><strong>div标签</strong></p><blockquote><p>区隔标签（应该是divide的缩写），双标签</p></blockquote><p>先别问有什么用，后面再说用处</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>你好，HTML<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>有了容器之后，我们就能修改其内容的<strong>属性</strong><br>这里我们来修改一下style属性</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color: red"</span>&gt;</span>你好，HTML<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/87cf53e2254e4c70a1f20ec63888b799.png" alt="背景色为红色"></p><p>同样的还有<br><strong>span标签</strong></p><blockquote><p>意义不详（大雾）</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color: red"</span>&gt;</span>你好，HTML<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color: red"</span>&gt;</span>你好，HTML<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color: red"</span>&gt;</span>你好，HTML<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color: red"</span>&gt;</span>hhh<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color: red"</span>&gt;</span>hhh<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color: red"</span>&gt;</span>hhh<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/95fd2c6d07c64f57ab232354634de082.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="行级元素和块级元素"></p><p>上述两种标签默认的布局是有区别的</p><table><thead><tr><th>类型</th><th>效果</th><th>例子</th></tr></thead><tbody><tr><td>块级元素（block）</td><td>独占一行，可以修改大小</td><td>div，h1，p，ul，table</td></tr><tr><td>行级元素（内联元素，inline）</td><td>只占据内容的大小，在挤满一行之后才换行，无法修改大小</td><td>span,  td, a, img</td></tr></tbody></table><p><strong>tips：元素指的就是标签</strong></p><p>至于修改大小，举个例子：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color: red;height: 100px"</span>&gt;</span>你好，HTML<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color: red;height: 100px"</span>&gt;</span>hhh<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>style属性的不同内容之间用分号隔开，末尾可以省略空格<br>其中px是一个单位，即<strong>像素</strong><br><img src="https://img-blog.csdnimg.cn/4078b9f2338c43a480271ae299e84d72.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="更多常见的基础标签"><a href="#更多常见的基础标签" class="headerlink" title="更多常见的基础标签"></a>更多常见的基础标签</h3><p><strong>img标签</strong></p><p>首先找个图<br><img src="https://img-blog.csdnimg.cn/078f5bfc66ec4dbb9318c7742f61d3c8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_19,color_FFFFFF,t_70,g_se,x_16" alt="香甜的甲基橙？"></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://i2.hdslb.com/bfs/face/18b1c56221b25b1ed47543c6574a9562beb195f0.jpg@160w_160h_1c_1s.webp"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/62400a1152504bf495066ae7799af891.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img标签示例"></p><hr><p><strong>title标签</strong><br>这个写在head里面</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页hhh<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/416e317030e34504a61f8e219ecb607b.png" alt="网页标题"></p><hr><p><strong>a标签</strong></p><p>可以理解为超链接</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span>&gt;</span>比例比例<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/49c29061cce540ec949ce278e74a508f.png" alt="点击就能跳转到百度页面"><br>点击就可以实现跳转，访问到百度的首页</p><hr><p><strong>input标签</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>前者是输入框，后者是提交按钮（不过目前这样是没法提交的）</p><p>注意“输入”这个概念，对于计算机来说，不仅是键盘输入，鼠标点击等一系列产生了信息的事件都可以是输入</p><p><img src="https://img-blog.csdnimg.cn/236e9e24be114f7bbdc3016fbb9f241b.png" alt="输入框和输入按钮"></p><hr><p><strong>ul标签和ol标签</strong><br>ul是unordered list，ol是ordered list<br>它们都有二级标签li标签</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>芒果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>猕猴桃<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>铅笔<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>直尺<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>橡皮擦<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/3fae9fbf3fb4415cae92a91ab4fe6ad2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="无序列表和有序列表"><br>其实没有大家想的那么高级，什么有序无序，不过是有无序号的区别</p><hr><p><strong>table标签</strong></p><table><thead><tr><th>名字</th><th>内容</th></tr></thead><tbody><tr><td>a</td><td>1</td></tr><tr><td>b</td><td>2</td></tr><tr><td>c</td><td>3</td></tr></tbody></table><p>像上面这种表格，我们可以可以用代码实现：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>a<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>b<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>c<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>其实标题那里应该使用th标签，这样更规范，不过呢也不强求了</p><p>这里介绍一下emmet语法，我们可以输入上面的内容后按下tab，自动生成上述代码</p><p><img src="https://img-blog.csdnimg.cn/8cfc85f9326c4602926f7400dbc0f414.png" alt="emmet语法示例"></p><p><img src="https://img-blog.csdnimg.cn/b97ba4136e6c4f529132d8d0b0ed47b3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="一个表格"></p><hr><p><strong>注释标签</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是注释 --&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>由于这个符号手写很难打，所以我们一般都用ctrl+？的快捷键</p><p><strong>br标签</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>就是换行</p><h3 id="实体符号"><a href="#实体符号" class="headerlink" title="实体符号"></a>实体符号</h3><p>其实就是转义字符，比如我想在浏览器中展现&lt;或者&gt;符号，却与原有的语句冲突时，直接写会被解析为标签，所以需要有转义符号</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span><span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="comment">&lt;!--对比一下，其中lt是less than的简写，gt是greater than的简写--&gt;</span></span><br><span class="line"><span class="tag">&lt;&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/ef644451812146c8b187c729bcd45ebb.png" alt="大于小于符号"><br>还有空格<br>直接写多个空格会被解析为一个空格</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1               2          3 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">1<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>2<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>3</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/e2587207d30e416e83929fa3e9e23ffd.png" alt="记住啊，直接多个空格会被压缩为一个空格"></p><h3 id="扩展：meta标签"><a href="#扩展：meta标签" class="headerlink" title="扩展：meta标签"></a>扩展：meta标签</h3><blockquote><p>meta标签是写在head标签内部的一个辅助性的标签，我们可以通过它优化搜索引擎、自动刷新、页面跳转、响应式兼容以及浏览器打开html文档时的编码格式</p></blockquote><p>这里可以参考这位大神的博客：<br><a href="https://blog.csdn.net/zhangank/article/details/94014629">HTML meta 标签</a></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="特殊的属性"><a href="#特殊的属性" class="headerlink" title="特殊的属性"></a>特殊的属性</h4><p>看完上述代码，我们知道标签内部还是可以写东西的，但是除了style属性之外，不同的标签还可能有其他的属性，而有些属性只能作用于部分标签<br>比如之前看到的table<br>（这里的border属性其实是对style属性中border的一个封装</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>  <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>a<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>b<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>c<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/49eb5d6a5e3a4d228affa53e74b21bcd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>以及行内向下合并</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>  <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>a<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>b<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>c<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/614c9cec752c4595a2529ad667ba8ee8.png" alt="在这里插入图片描述"><br>也可以行合并</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>  <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>a<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>b<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>c<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/435cfe7967f84ad3a002a88c97deac89.png" alt="在这里插入图片描述"></p><hr><p>再比如</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入密码"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/bc65c24be4774f029773b6b8c2b75722.png" alt="在这里插入图片描述"><br>不过这些可以慢慢熟悉，现在我们只需要掌握常用到的</p><hr><h4 id="初步认识style属性"><a href="#初步认识style属性" class="headerlink" title="初步认识style属性"></a><strong>初步认识style属性</strong></h4><p><strong>颜色及其三种表示方式</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color: red;         background-color: black;"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color: #f00;        background-color: #000;"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color: rgb(255,0,0);background-color: rgb(0,0,0);"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/d7ecbe0b3a6c482a9ea4eb61dea1cce8.png" alt="在这里插入图片描述"></p><table><thead><tr><th>方式</th><th>简述</th></tr></thead><tbody><tr><td>英文词汇</td><td>很low，但是对于美术不好的人很亲和</td></tr><tr><td>十六进制</td><td>取值范围是0~ff（ff是16*16，即256，但是从0开始数，所以最大值是255）<br>比如#ffaa33,代表红色值为ff，绿色为aa，蓝色为33，当三种颜色的两位均一样时，可以简写为#fa3这种形式</td></tr><tr><td>rgb函数</td><td>采用十进制，最大值是255，依次对应red，green，blue<br>规则和十六进制一样<br>还有rgba函数，会多一个范围是0~1的参数代表透明度</td></tr></tbody></table><hr><p><strong>宽高</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 200px;background-color: red"</span>&gt;</span>456<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/93932ce55225493caa23942c1fdd7e08.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">这里是使用最最常见的px，像素为单位，一个像素有多大，是由个人的电脑的分辨率决定的。<br>当然还有其他单位，不过这里暂不讨论。</p><hr><p><strong>文字</strong><br>关于文字，那么属性就可多了<br>这里例举一些</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-weight: 900"</span>&gt;</span>文字0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 14px"</span>&gt;</span>文字1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-family:'宋体'"</span> &gt;</span>文字2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color: green"</span>&gt;</span>文字3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/30b3e4380fe64ed3b15352b394a57b5e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><table><thead><tr><th>名称</th><th>介绍</th></tr></thead><tbody><tr><td>font-weight</td><td>取值是100-900，决定文字的粗细</td></tr><tr><td>font-size</td><td>文字的大小，这里的单位是用的px，即像素。当然你也可以采用其他单位。</td></tr><tr><td>font-family</td><td>字体。如果设置字体的话，可能会因为字体限定了一些样式而导致对字体粗细等设置失效</td></tr><tr><td>color</td><td>文字颜色，注意，<font color="red">没有font-color</font></td></tr></tbody></table><hr><p>回顾总结一下</p><p>属性大概分为两种类型，一种是特有的属性，一种是通用的属性</p><p>特有的属性只能作用于部分标签，</p><p>通用的属性，比如style可以用于几乎所有标签</p><p>当然，这个分类只是为了初学者容易理解，实际上并没有这种规定</p><p>我们思考一个问题</p><p>当一个标签存在大量样式的时候，很明显是不易于阅读和后续改进</p><p><img src="https://img-blog.csdnimg.cn/4dac5cf06a604e619bc63ea45b1dcb27.png" alt="在这里插入图片描述"></p><p>所以，我们需要CSS</p><h2 id="简单了解CSS"><a href="#简单了解CSS" class="headerlink" title="简单了解CSS"></a>简单了解CSS</h2><h3 id="什么是CSS"><a href="#什么是CSS" class="headerlink" title="什么是CSS"></a>什么是CSS</h3><blockquote><p>CSS，Cascading Style Sheets，三个单词的意思分别是大量的，样式，表</p><p>官方给的翻译就是<strong>层叠样式表</strong>，用于存放大量的样式</p><p>所以HTML是管理结构的，CSS才是管理样式的，更多的样式我们会放到CSS这里讲</p></blockquote><h3 id="选择器的基本使用"><a href="#选择器的基本使用" class="headerlink" title="选择器的基本使用"></a>选择器的基本使用</h3><h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><p>我们想一下一张表长什么样子</p><p><img src="https://img-blog.csdnimg.cn/e7cbb7419f3344e6bb2a82c7a77de45b.png" alt="在这里插入图片描述"></p><p>所以CSS作为一张表也该有类似上图的样子</p><p><img src="https://img-blog.csdnimg.cn/7900cf33c55c4471992e6ed133a58f29.png" alt="在这里插入图片描述"></p><p>没错，CSS可以写在html文件里面，通常我们会把一个style标签写在head标签内部</p><p>（其实写哪都差不多，不过规范是这样罢了）</p><p>然后在style内写多个键值对来设置样式</p><h4 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h4><p>很明显，上述CSS影响到了所有div标签</p><p>而上述的这种用标签名字来选择样式作用的范围的方式，就叫做<strong>标签选择器</strong></p><p><img src="https://img-blog.csdnimg.cn/167c247ca6314c068923ca92f5d3c81a.png" alt="在这里插入图片描述"></p><p>假如我们想让第一个div独有这种样式，我们就给它取个名字</p><p><img src="https://img-blog.csdnimg.cn/a1c755d104ec424d81cc682eba5c1a9a.png" alt="在这里插入图片描述"></p><p>注意不要漏掉前面的点</p><p><img src="https://img-blog.csdnimg.cn/8ed6470f723b4388bd5ae6c27c571cb3.png" alt="image-20211203171156480"></p><p>注意，这里的<strong>后面覆盖前面</strong>，其前后顺序是<strong>以style标签中的内容顺序决定的而不是class名称的顺序</strong></p><p>这里的class并不是面向对象编程里面的类，不要混淆，二者没有联系。</p><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><p>和class选择器类似，但是id选择器名字前面的是#，并且<strong>id选择器不可复用，具有唯一标识性</strong></p><p><img src="https://img-blog.csdnimg.cn/58ebfc47aec14c58b1e686cfc087a9e5.png" alt="在这里插入图片描述"></p><p>比如看一个简单的例子</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#a-good-id"</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这个可以实现跳转到id为a-good-id的标签所在的位置。</p><p>那么可不可以写class呢？当然不能，因为class可能“重名”，这样就不知道到底该跳转到哪里。</p><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><p>根据标签所具有的属性来进行选择</p><p>看个例子</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[type=<span class="string">"text"</span>]</span></span><br><span class="line">{</span><br><span class="line"><span class="attribute">background-color</span>:<span class="number">#ff0000</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-attr">[type]</span></span><br><span class="line">{</span><br><span class="line"><span class="attribute">border</span>:<span class="number">5px</span> solid blue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述两个样式都能作用于</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>意思就是用属性来选择，可以只写属性名称，也可以限制属性值</p><h3 id="定位和布局"><a href="#定位和布局" class="headerlink" title="定位和布局"></a>定位和布局</h3><p>这个很重要，这里就直接看我的博客吧、</p><h4 id="定位基础"><a href="#定位基础" class="headerlink" title="定位基础"></a>定位基础</h4><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/121160329"><font color="fa8800">CSS:十分钟学会五种position定位🍓</font></a></p><h4 id="布局基础"><a href="#布局基础" class="headerlink" title="布局基础"></a>布局基础</h4><p>曾经提到过，块级元素和行级（内联元素）元素</p><p>看一段代码</p><p><img src="https://img-blog.csdnimg.cn/9af8ceb51f7448e69aa5017e0e170cb9.png" alt="行级元素不能直接改宽高"></p><p>显然，width和height并没有生效，这就和行级元素的性质有关系了，</p><p>不过我们可以通过修改display属性来改变元素的默认类型</p><p>很明显，这就生效了</p><p>这是因为，我们将其类型<strong>改变为块级（block）</strong></p><p><img src="https://img-blog.csdnimg.cn/0c12a49af1b5425ba64453cc4a4d0e66.png" alt="修改为块级元素"></p><p>同样地，还有非常多的类型可以尝试，特别是</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>inline-block</td><td>行级（内联）块元素。综合了二者</td></tr><tr><td>flex</td><td>弹性元素。非常好的一维布局</td></tr><tr><td>grid</td><td>网格元素。比较好的二维布局</td></tr><tr><td>none</td><td>不显示，配合js做一些特效</td></tr></tbody></table><p>通过上述知识可以至少可以完成多种形式的两栏或者说n栏布局。</p><p>当然，也不是所有布局都是要靠display完成的，比如流式布局等等。</p><p>这里就不再赘述，有兴趣自己研究</p><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>这里讲的是 <strong>标准盒模型</strong>，主要是了解margin padding border content 四个概念</p><p>这里我们准备两个标签：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>一号<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>二号<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>至于各种配色，我们这里是为了醒目，别说美感云云~~</p><h4 id="内容content"><a href="#内容content" class="headerlink" title="内容content"></a>内容content</h4><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span>{</span><br><span class="line"><span class="attribute">background-color</span>:<span class="number">#ff3700</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用width和height来设置content大小</p><p><img src="https://img-blog.csdnimg.cn/cecb09a44c8d478db2fc77d16b41acd6.png" alt="橙色部分是content"></p><h4 id="边界border"><a href="#边界border" class="headerlink" title="边界border"></a>边界border</h4><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span>{</span><br><span class="line"><span class="attribute">background-color</span>:<span class="number">#ff3700</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border</span>: <span class="number">10px</span> solid blue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>10px是边界宽度，</p><p>solid是边界样式，实心线，还有dashed等其他样式，</p><p>blue是边界颜色</p><p><img src="https://img-blog.csdnimg.cn/a8e348d6082d47428975c79a33cb78e8.png" alt="蓝色是边界border"></p><h4 id="内边距padding"><a href="#内边距padding" class="headerlink" title="内边距padding"></a>内边距padding</h4><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span>{</span><br><span class="line"><span class="attribute">background-color</span>:<span class="number">#ff3700</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border</span>: <span class="number">10px</span> solid blue;</span><br><span class="line"></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看图就知道了</p><p><img src="https://img-blog.csdnimg.cn/8079715748fb40859d55e5387b9a162d.png" alt="内容距离边界的距离就是内边距"></p><p>顾名思义，内容距离边界30px</p><h4 id="外边距margin"><a href="#外边距margin" class="headerlink" title="外边距margin"></a>外边距margin</h4><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span>{</span><br><span class="line"><span class="attribute">background-color</span>:<span class="number">#ff3700</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border</span>: <span class="number">10px</span> solid blue;</span><br><span class="line"></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/1554e0df41a943fcae12e0ed9e38621b.png" alt="外边距就是和其他元的距离啦"></p><p>顾名思义，和周围隔开30px</p><p>另外，我们可以打开浏览器，按下f12，点击右上角的这个图标，再用鼠标悬停在想要查看的图形上，就能查看包括盒子模型在内的相关信息</p><p><img src="https://img-blog.csdnimg.cn/039f7a232e1f460a98d36c8e1d37e338.png" alt="如图所示"></p><p>以上就标准盒模型的大概内容，如果有兴趣可以自行了解<strong>怪异盒模型</strong></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2021/12/06/mysql/"/>
      <url>/2021/12/06/mysql/</url>
      
        <content type="html"><![CDATA[<p>这是大一下暑假的时候写的，以前放在csdn上，现在搬迁到自己的博客了</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来学过的，结果太久没用就忘了<br>由于是做前端的，所这个就学个大概,笔记相对基础一点</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><img src="https://img-blog.csdnimg.cn/20210717142400480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>变量名别太离谱就行，<strong>变量值是mysql的bin文件的上级目录</strong><br><img src="https://img-blog.csdnimg.cn/20210717142609272.png" alt="在这里插入图片描述"><br>接下来找到这个，点击编辑<br><img src="https://img-blog.csdnimg.cn/20210717142807884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后点击新建<br><img src="https://img-blog.csdnimg.cn/20210717142905202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后输入bin文件路径<br><img src="https://img-blog.csdnimg.cn/20210717143204158.png" alt="在这里插入图片描述"></p><h2 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h2><p>win + r进入cmd窗口，进行如图所示操作<img src="https://img-blog.csdnimg.cn/20210717143808589.png" alt="在这里插入图片描述"><br>其中-u后紧跟的是用户名，-p紧跟的是密码，这些在mysql下载安装时有配置，我这里设置的是root和root<br><img src="https://img-blog.csdnimg.cn/20210717144018209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看到这一幕，说明MySQL的变量配置成功了，可以正常运行了</p><p><strong>另外，你可以这样输入密码</strong><br><img src="https://img-blog.csdnimg.cn/20210717144130558.png" alt="在这里插入图片描述"></p><p><strong>退出是exit指令</strong><br><img src="https://img-blog.csdnimg.cn/20210717144210447.png" alt="在这里插入图片描述"></p><h2 id="MySQL核心文件"><a href="#MySQL核心文件" class="headerlink" title="MySQL核心文件"></a>MySQL核心文件</h2><p>bin文件：存储命令文件<br>lib文件：存储库文件<br>include文件：存储头文件<br>Share文件：存储字符集、语言等信息<br>mysql.ini文件（隐藏文件）：mysql的配置文件</p><p><strong>了解即可，配置那些后面用可视化工具操作方便得多</strong></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>这一部分，可以暂时先跳过</p><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p><img src="https://img-blog.csdnimg.cn/20210718111810150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h4><p><img src="https://img-blog.csdnimg.cn/20210718111903906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p><img src="https://img-blog.csdnimg.cn/2021071811205639.png" alt="在这里插入图片描述"></p><h2 id="DDl-数据定义语言"><a href="#DDl-数据定义语言" class="headerlink" title="DDl:数据定义语言"></a>DDl:数据定义语言</h2><p>（当然这个标题并不是很严谨，只是大部分都是DDI的内容）</p><p>SQL是Structured Query Language结构化查询语言<br>而DDL是Data Definition Language，能对数据库进行操作</p><p>（<strong>注意:</strong><br>1.使用SQL语句时，记得结尾加；<br>2.使用SQL命令之前确保数据库已经开启<br><strong>3.mysql几乎不区分大小写，大部分内容最后都会统一转为小写</strong><br>）</p><h4 id="显示所有数据库SHOW-DATABASES"><a href="#显示所有数据库SHOW-DATABASES" class="headerlink" title="显示所有数据库SHOW DATABASES"></a>显示所有数据库<code>SHOW DATABASES</code></h4><p> 显示所有的数据库<br><img src="https://img-blog.csdnimg.cn/20210717145905852.png" alt="在这里插入图片描述"><br> 这几个是系统自带的数据库，具体情况由安装的版本决定，但无论如何，不要随便去动这几个</p><h4 id="创建数据库CREATE-DATABASE"><a href="#创建数据库CREATE-DATABASE" class="headerlink" title="创建数据库CREATE DATABASE"></a>创建数据库<code>CREATE DATABASE</code></h4><p>创建数据库，规范是这里要大写名字,但是实际上<strong>mysql会把名字统一转化为小写</strong><br>（毕竟命令都是大写，名称又都是大写实在是不方便阅读）<br><img src="https://img-blog.csdnimg.cn/20210717150832388.png" alt="在这里插入图片描述"><br>这里创建了一个名字叫myDataBase1的数据库，并且设置它的字符集是国标码 gbk<br><strong>（当然后面的CHARACTER SET gbk可以省略）</strong></p><p>再用SHOW DATABASES查询一下<br>（<em>这里我漏加了;不过会提示让你补上的</em>）<br><img src="https://img-blog.csdnimg.cn/20210717151215494.png" alt="在这里插入图片描述"><br>另外，如果你不确定某个数据库是否已经存在，可以这样写<br><img src="https://img-blog.csdnimg.cn/20210717152939962.png" alt="在这里插入图片描述"></p><h4 id="显示数据库的创建信息SHOW-CREATE-DATABASE"><a href="#显示数据库的创建信息SHOW-CREATE-DATABASE" class="headerlink" title="显示数据库的创建信息SHOW CREATE DATABASE"></a>显示数据库的创建信息<code>SHOW CREATE DATABASE</code></h4><p> 展示创建某个数据库时的相关信息<br> <img src="https://img-blog.csdnimg.cn/20210717152120378.png" alt="在这里插入图片描述"></p><h4 id="修改数据库ALTER-DATABASE"><a href="#修改数据库ALTER-DATABASE" class="headerlink" title="修改数据库ALTER DATABASE"></a>修改数据库<code>ALTER DATABASE</code></h4><p>修改某个数据库的某个信息<br><img src="https://img-blog.csdnimg.cn/20210717152455547.png" alt="在这里插入图片描述"><br>修改mydatabase1的字符集为utf8<br><strong>注意mysql中是utf8而不是utf-8</strong></p><h4 id="删除数据库DROP-DATABASE"><a href="#删除数据库DROP-DATABASE" class="headerlink" title="删除数据库DROP DATABASE"></a>删除数据库<code>DROP DATABASE</code></h4><p>删除某个数据库<br><img src="https://img-blog.csdnimg.cn/20210717153138676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="使用数据库USE"><a href="#使用数据库USE" class="headerlink" title="使用数据库USE"></a>使用数据库USE</h4><p>使用某个数据库<br>数据都在数据库里面，我们之前一直都在外面对众多数据库进行增删改查，还没有进去访问过<br><img src="https://img-blog.csdnimg.cn/20210717153436927.png" alt="在这里插入图片描述"></p><h4 id="查看当前数据库SELECT-DATABASE"><a href="#查看当前数据库SELECT-DATABASE" class="headerlink" title="查看当前数据库SELECT DATABASE()"></a>查看当前数据库SELECT DATABASE()</h4><p>假如你不知道你正在使用哪个数据库，你就可以这么写<br><img src="https://img-blog.csdnimg.cn/20210717153611248.png" alt="在这里插入图片描述"><br>正在使用mydatabase1<br><strong>如果没有使用任何数据库，那么结果是NULL</strong><br><img src="https://img-blog.csdnimg.cn/2021071715385160.png" alt="在这里插入图片描述"></p><p>那么这里我就突发奇想，数据库名字能叫NULL吗<br><img src="https://img-blog.csdnimg.cn/2021071715402028.png" alt="在这里插入图片描述"><br>果然不行。而且哪怕可以如此，数据库名字统一为小写，null仍能与NULL区分</p><p>==========================================================<br><strong>接下来的DDI语句内容可以先暂时跳过，后面看完了可视化数据库工具再折回来看</strong></p><h4 id="创建表CREATE-TABLE"><a href="#创建表CREATE-TABLE" class="headerlink" title="创建表CREATE TABLE"></a>创建表CREATE TABLE</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `subject`(</span><br><span class="line">subjectId <span class="type">INT</span>,</span><br><span class="line">`课序号` <span class="type">INT</span>,</span><br><span class="line">subjectName <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">subjectHours <span class="type">INT</span></span><br><span class="line">)CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></tbody></table></figure><p>以上代码运行的创建结果如图所示<br><img src="https://img-blog.csdnimg.cn/20210718200232542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="修改表ALERT-TABLE"><a href="#修改表ALERT-TABLE" class="headerlink" title="修改表ALERT TABLE"></a>修改表<code>ALERT TABLE</code></h4><h6 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a><code>ADD</code></h6><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `subject` <span class="keyword">ADD</span> gradeID <span class="type">INT</span>;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718200743443.png" alt="在这里插入图片描述"></p><h6 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a><code>DROP</code></h6><p>每次只能删除一列</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `subject` <span class="keyword">DROP</span>  gradeID;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718201530660.png" alt="在这里插入图片描述"></p><h6 id="MODIFY"><a href="#MODIFY" class="headerlink" title="MODIFY"></a><code>MODIFY</code></h6><p>修改该列的属性（不包括名称）</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `subject` MODIFY subjectName <span class="type">VARCHAR</span>(<span class="number">5</span>) ;</span><br></pre></td></tr></tbody></table></figure><p>修改前:<br><img src="https://img-blog.csdnimg.cn/20210718201917332.png" alt="在这里插入图片描述"><br>修改后：<br><img src="https://img-blog.csdnimg.cn/20210718202041410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="CHANGE"><a href="#CHANGE" class="headerlink" title="CHANGE"></a><code>CHANGE</code></h6><p>修改列的名称<br><img src="https://img-blog.csdnimg.cn/20210718203331714.png" alt="在这里插入图片描述"></p><h6 id="RENAME"><a href="#RENAME" class="headerlink" title="RENAME"></a><code>RENAME</code></h6><p>表重命名<br><img src="https://img-blog.csdnimg.cn/20210718205133463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="可视化数据库工具"><a href="#可视化数据库工具" class="headerlink" title="可视化数据库工具"></a>可视化数据库工具</h2><p>cmd <del>太丑了</del> 数据显示不是那么直观<br>所以诞生了许多可视化数据库工具</p><p>比如Navicate，SQLyog，SQL_Front，HeidiSQL，DBite for SQLite等等，根据自身情况随便选一个就行</p><p>我们这里采用SQL_yog<br>首先新建一个链接，名字随意取<br><img src="https://img-blog.csdnimg.cn/20210717155616692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后输入 用户名 和 密码 进入<br><img src="https://img-blog.csdnimg.cn/20210717160341399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>好耶，这可不比cmd香得多？<br><del>而且更棒的是还支持鼠标操作</del><br><img src="https://img-blog.csdnimg.cn/20210717160624108.png" alt="在这里插入图片描述"><br>有了大小写自动转化，而且还有了TAB补全！<br>甚至只执行单条语句都不用加分号</p><p>选中一条语句，然后按下F9，就可以在下方的区域看到执行结果<br><img src="https://img-blog.csdnimg.cn/20210717160811539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210717161006952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(注意创建新的库之后要刷新一下才能显示）</p><p>并且现在可以通过#创建注释了<br><img src="https://img-blog.csdnimg.cn/20210717161338216.png" alt="在这里插入图片描述"></p><h2 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL:数据查询语言"></a>DQL:数据查询语言</h2><p>hmmmmm查数据至少得先有数据吧….<br>那这里先用鼠标手动添加数据，或者也可以直接先去看后面的<strong>DML数据操作语言的内容</strong></p><h4 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h4><p>操作数据之前我们先做一点前置准备:<br><strong>鼠标创建一张表</strong><br>名字是t_persons<br><img src="https://img-blog.csdnimg.cn/20210717162852313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>然后打开表继续鼠标添加数据</strong><br><img src="https://img-blog.csdnimg.cn/20210717163449725.png" alt="在这里插入图片描述"></p><h4 id="查询SELECT-FROM"><a href="#查询SELECT-FROM" class="headerlink" title="查询SELECT FROM"></a>查询<code>SELECT FROM</code></h4><p>最简单的查询<br><img src="https://img-blog.csdnimg.cn/20210717164146419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">注意name是一个关键字，这里需要使用反引号（就是tab上面那个）屏蔽一下</p><p>另外，* 是所有的意思，这样写也可以<br>(不过这样写的话，底层还有一个展开的过程，所以执行速度会相对减慢)<br><img src="https://img-blog.csdnimg.cn/20210717164540901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><em>诶等等，之前不是录入了四组数据吗，某本伟怎么不见了！<br>看了看才发现我没保存….不过不影响…</em></p><p>另外，查询语句是可以进行运算的<br><img src="https://img-blog.csdnimg.cn/20210717165448925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里就要提到一个概念：<strong>虚拟表</strong><br>通过查询手段得到的新表是一个 <strong>处理过的</strong> <strong>节选的</strong> 原表 <strong>副本</strong>,即虚拟表<br>所以在查询的时候对数据进行操作并不会影响到原表</p><h4 id="重命名AS"><a href="#重命名AS" class="headerlink" title="重命名AS"></a>重命名<code>AS</code></h4><p>用来给出别称的</p><p><img src="https://img-blog.csdnimg.cn/20210717215129640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="有序查询ORDER-BY"><a href="#有序查询ORDER-BY" class="headerlink" title="有序查询ORDER BY"></a>有序查询<code>ORDER BY</code></h4><p>给查询结果排个序</p><p><strong>ASC</strong>（可省略，默认值）升序<br><img src="https://img-blog.csdnimg.cn/20210717221208990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>DESC</strong>降序<br><img src="https://img-blog.csdnimg.cn/20210717221306726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="条件查询WHERE"><a href="#条件查询WHERE" class="headerlink" title="条件查询WHERE"></a>条件查询<code>WHERE</code></h4><p>条件筛选<br><img src="https://img-blog.csdnimg.cn/20210717225828576.png" alt="在这里插入图片描述"></p><h4 id="逻辑AND和OR和NOT"><a href="#逻辑AND和OR和NOT" class="headerlink" title="逻辑AND和OR和NOT"></a>逻辑<code>AND和OR和NOT</code></h4><p>逻辑 且 或 非<br>(这里就演示一下OR，其他依葫芦画瓢)<br><img src="https://img-blog.csdnimg.cn/20210717230924632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="不等式"><a href="#不等式" class="headerlink" title="不等式"></a>不等式</h4><p>&lt;，&gt; ， &lt;，  &gt;=，  &lt;=，  !=， <strong>&lt;&gt;</strong></p><p> 最后一个&lt;&gt;<br> 也是不等于的意思，和!=一样<img src="https://img-blog.csdnimg.cn/20210717232133252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>另外还需要提一下的就只有<br>区间依旧需要分开写，然后用逻辑连接词链接<br><img src="https://img-blog.csdnimg.cn/20210717233048859.png" alt="在这里插入图片描述"></p><h4 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a><code>NULL</code></h4><p>空值<br>对于NULL值，判定不能用=或者！=以及&lt;&gt;<br>而需要用到</p><h4 id="IS"><a href="#IS" class="headerlink" title="IS"></a><code>IS</code></h4><p><img src="https://img-blog.csdnimg.cn/20210717234020106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="枚举IN"><a href="#枚举IN" class="headerlink" title="枚举IN"></a>枚举<code>IN</code></h4><p>枚举<br>选出id为1或2的<br><img src="https://img-blog.csdnimg.cn/20210717234721554.png" alt="在这里插入图片描述"></p><h4 id="模糊查询LIKE"><a href="#模糊查询LIKE" class="headerlink" title="模糊查询LIKE"></a>模糊查询<code>LIKE</code></h4><p>模糊查询<br>第一种是<strong>有限个数字符</strong>模糊，比如一个 张某<br><strong>每模糊一个字符，都要在相应的位置加上一个 _</strong><br><img src="https://img-blog.csdnimg.cn/20210717235948247.png" alt="在这里插入图片描述"></p><p>第二种是<strong>任意个数字符</strong>模糊<br><img src="https://img-blog.csdnimg.cn/20210718000234522.png" alt="在这里插入图片描述"></p><h4 id="CASE-END"><a href="#CASE-END" class="headerlink" title="CASE END"></a><code>CASE END</code></h4><p>就是一个分支结构，when这里翻译为   <strong>当…时</strong><br>注意别漏掉CASE前面的逗号<br><img src="https://img-blog.csdnimg.cn/20210718001904277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="时间类函数"><a href="#时间类函数" class="headerlink" title="时间类函数"></a>时间类函数</h2><p>这部分内容比较多，就不一一用代码演示了<br>以下几张图片都来自于视频截图<br><a href="https://www.bilibili.com/video/BV1BZ4y1H7LZ?p=13">图片来源</a><br><img src="https://img-blog.csdnimg.cn/2021071802393026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="字符类函数"><a href="#字符类函数" class="headerlink" title="字符类函数"></a>字符类函数</h2><p>同上<br><img src="https://img-blog.csdnimg.cn/20210718023945753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>同上<br><img src="https://img-blog.csdnimg.cn/20210718024005382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="分组查询GROUP-BY"><a href="#分组查询GROUP-BY" class="headerlink" title="分组查询GROUP BY"></a>分组查询<code>GROUP BY</code></h2><p>首先给表增加一点东西<br><img src="https://img-blog.csdnimg.cn/20210718025704334.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,<span class="built_in">COUNT</span>(sex)</span><br><span class="line"><span class="keyword">FROM</span> t_persons </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sex</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>下表中的1，2代表1男2女<br><img src="https://img-blog.csdnimg.cn/20210718030404342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="限定查询LIMIT"><a href="#限定查询LIMIT" class="headerlink" title="限定查询LIMIT"></a>限定查询<code>LIMIT</code></h2><p>0,2代表是<strong>从0行开始   查询2行数据</strong>（下标从0开始）<br><img src="https://img-blog.csdnimg.cn/202107180316225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>其实也就是套娃<br>需要注意的就是注意 子查询结果 参与比较的时候 的数据类型<br>别用int和char比，不然只能稀里糊涂地改半天bug<br>1.子查询的结果是单行单列<br><img src="https://img-blog.csdnimg.cn/20210718032905509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.子查询的结果是单行多列<br>记得开枚举，不然你怎么用单个数据去和整个返回内容比较呢<br><img src="https://img-blog.csdnimg.cn/20210718034055805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.如果结果是多行单列</p><h2 id="任意与存在：ALL与ANY"><a href="#任意与存在：ALL与ANY" class="headerlink" title="任意与存在：ALL与ANY"></a>任意与存在：<code>ALL</code>与<code>ANY</code></h2><p>其实就是字面意思</p><p>另外，这里的sex用0,1表示的<br><img src="https://img-blog.csdnimg.cn/20210718034612437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.子查询的结果是多行多列（一张表）</p><p>注意as的作用是将整个临时的子查询结果（一张表里的数据）看做一个整体（一张表），不能少<br><img src="https://img-blog.csdnimg.cn/20210718035539294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="合并查询UNION-ALL"><a href="#合并查询UNION-ALL" class="headerlink" title="合并查询UNION (ALL)"></a>合并查询<code>UNION (ALL)</code></h2><p><strong>合并指的是把 查询结果 合并，并不合并原表</strong></p><p>再改一点数据<br><img src="https://img-blog.csdnimg.cn/20210718041237144.png" alt="在这里插入图片描述"><br><strong>合并的前提是，列数得相同</strong><br>说白了就是把后者硬塞进前者<br>这是UNION<br>完全重复的内容直接没了<br><img src="https://img-blog.csdnimg.cn/20210718041422957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这是UNION ALL<br>哪怕完全一样都还是保留<br><img src="https://img-blog.csdnimg.cn/20210718041444230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="表连接查询JOIN-ON"><a href="#表连接查询JOIN-ON" class="headerlink" title="表连接查询JOIN ON"></a>表连接查询<code>JOIN ON</code></h2><p>合并查询 是 合并 查询的结果，是个动宾短语<br>但是表连接查询中的“表连接”是一个定语后置的倒装，<br>作为一个偏正短语的定语修饰省略的中心词查询（结果）….啊吧啊吧<br>好吧扯远了….<br>表连接查询是指的，<strong>先把表（暂时）合并再查询</strong></p><p>先新建一个表叫做t_myfriends<br><del>叔叔我啊，最喜欢交朋友了</del><br><img src="https://img-blog.csdnimg.cn/20210718063425818.png" alt="在这里插入图片描述"></p><h3 id="1-内连接"><a href="#1-内连接" class="headerlink" title="1.内连接"></a>1.内连接</h3><p>我们先来观察一下</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_persons <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_myfriends;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718064413446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><code>SELECT * FROM t_myfriends INNER JOIN t_persons</code><br><img src="https://img-blog.csdnimg.cn/20210718064652326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>唔，在不加ON的情况下，表的行数变成了2 * 3 = 6（布尔积）行，我们可以发觉，两张表合并的时候的一些规律了，</p><p>那就是取二者行数的最小公倍数作为新的行数，并且均匀复制数据到新的表中</p><p>另外，INNER JOIN 语句左边的表，就是新合成的表的左部分，语句右边的便是新表的右部分。</p><p>我们再来观察一下</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_persons </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_myfriends </span><br><span class="line"><span class="keyword">ON</span> t_persons.`id` <span class="operator">=</span> t_myfriends.`id`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_myfriends </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_persons </span><br><span class="line"><span class="keyword">ON</span> t_persons.`id` <span class="operator">=</span> t_myfriends.`id`；</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718065402806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以ON其实就是加上了一个条件<br>只有两个表的id相等的数据才被放入新表，并且按照id相匹配<br>而且左右分布依旧遵循上文所述规则</p><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_persons</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_myfriends</span><br><span class="line"><span class="keyword">ON</span> t_persons.`id` <span class="operator">=</span> t_myfriends.`id`;</span><br></pre></td></tr></tbody></table></figure><p><strong>以左边的t_persons为主表，即t_persons的左外连接</strong><br><img src="https://img-blog.csdnimg.cn/20210718072515546.png" alt="在这里插入图片描述"><br>可以看出，右边的表会适应左边的表，</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_persons</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> t_myfriends</span><br><span class="line"><span class="keyword">ON</span> t_persons.`id` <span class="operator">=</span> t_myfriends.`id`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_myfriends</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> t_persons</span><br><span class="line"><span class="keyword">ON</span> t_persons.`id` <span class="operator">=</span> t_Myfriends.`id`;</span><br></pre></td></tr></tbody></table></figure><p>以右边的表为主表，即右外连接<br>（在左/右 还是由 在right join的左/右决定）<br><img src="https://img-blog.csdnimg.cn/20210718101559269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="DML-数据操纵语言"><a href="#DML-数据操纵语言" class="headerlink" title="DML:数据操纵语言"></a>DML:数据操纵语言</h2><p>鼠标操作虽好，但总不能只会鼠标操作吧</p><h4 id="增INSERT-INTO-VALUES"><a href="#增INSERT-INTO-VALUES" class="headerlink" title="增INSERT INTO VALUES"></a>增<code>INSERT INTO VALUES</code></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_persons(id,`名字`,`name`,`性别`,sex,age)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">'杨掉坑'</span>,<span class="string">'Yang Diodio'</span>,<span class="string">'男'</span>,<span class="number">1</span>,<span class="number">18</span>);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/2021071810301517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>也就是类似于形参实参的写法</p><h4 id="删DELETE"><a href="#删DELETE" class="headerlink" title="删DELETE"></a>删<code>DELETE</code></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t_myfriends</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'Cherry'</span>;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718105317910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="改UPDATE"><a href="#改UPDATE" class="headerlink" title="改UPDATE"></a>改<code>UPDATE</code></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t_persons </span><br><span class="line"><span class="keyword">SET</span> age <span class="operator">=</span> <span class="number">3</span> </span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'Yang Diodio'</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718105105733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="清空TRUNCATE"><a href="#清空TRUNCATE" class="headerlink" title="清空TRUNCATE"></a>清空<code>TRUNCATE</code></h4><p>清空整张表</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> t_myfriends;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718105848317.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t_myfriends;</span><br></pre></td></tr></tbody></table></figure><p>也可以达到类似的效果，<br>不过truncate是销毁整张表之后重新创建一个同样格式的空表<br>DELETE是清空表的数据</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>这里只介绍三种常用的约束</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `全国人民身份信息`(</span><br><span class="line">`身份证号` <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">`名字` <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">`驾照证件号` <span class="type">INT</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">`年龄` <span class="type">INT</span></span><br><span class="line">)CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210719200609953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="主键约束PRIMARY-KEY"><a href="#主键约束PRIMARY-KEY" class="headerlink" title="主键约束PRIMARY KEY"></a>主键约束PRIMARY KEY</h4><p>举个例子，当你要在全国范围内找到具体的某个人，用哪条信息找最准确呢？<br>如果是名字，那么重名的有很多，这样一来查询结果就不唯一。<br>如果用身份证号查找，那么就是唯一的。<br>这其实和一维数组类似，这里所说的<strong>主键类似于数组的下标。</strong><br><img src="https://img-blog.csdnimg.cn/20210719200859421.png" alt="在这里插入图片描述"><br>主键约束不能为空，也不能重复，<br>可以联想数组下标，不能重复也不能为空</p><h6 id="自增AUTO-INCREMENT"><a href="#自增AUTO-INCREMENT" class="headerlink" title="自增AUTO_INCREMENT"></a>自增AUTO_INCREMENT</h6><p>这个是<strong>主键约束的附属物</strong><br>只能用于主键约束<br><img src="https://img-blog.csdnimg.cn/20210719202418428.png" alt="在这里插入图片描述"><br>其实也是数组下标的模式，自动地依次递增</p><h4 id="唯一约束UNIQUE"><a href="#唯一约束UNIQUE" class="headerlink" title="唯一约束UNIQUE"></a>唯一约束UNIQUE</h4><p>就是不能重复<br>比如驾驶证号，这个重复了那还得了？<br><img src="https://img-blog.csdnimg.cn/20210719202906857.png" alt="在这里插入图片描述"><br>当然也不是每个人都有驾驶证，<strong>所以可以为NULL</strong></p><h4 id="非空约束NOT-NULL"><a href="#非空约束NOT-NULL" class="headerlink" title="非空约束NOT NULL"></a>非空约束NOT NULL</h4><p>一个人总有年龄和名字吧<br><img src="https://img-blog.csdnimg.cn/20210719203025790.png" alt="在这里插入图片描述"></p><h4 id="默认约束DEFAULT"><a href="#默认约束DEFAULT" class="headerlink" title="默认约束DEFAULT"></a>默认约束DEFAULT</h4><p>这里多加一条<br>…过亿这种毕竟是少数，如果给你十三亿的数据量，给个默认值肯定会减少工作量<br>（但是不知道为什么感觉有点悲伤….）<br><img src="https://img-blog.csdnimg.cn/2021071921004135.png" alt="在这里插入图片描述"></p><h4 id="引用约束CONSTRAINT-FOREIN-KEY-REFERENCES"><a href="#引用约束CONSTRAINT-FOREIN-KEY-REFERENCES" class="headerlink" title="引用约束CONSTRAINT FOREIN KEY REFERENCES"></a>引用约束CONSTRAINT FOREIN KEY REFERENCES</h4><p>直接用其他表里有的数据，不用手动重复地执行添加操作<br><img src="https://img-blog.csdnimg.cn/20210719215033790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> fk_t_persons_sex </span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(`性别`) </span><br><span class="line"><span class="keyword">REFERENCES</span> t_persons(sex)</span><br></pre></td></tr></tbody></table></figure><p>也就是当前表的里 <strong>性别 这个数据<br>是从t_persons这张表的sex里面引用来的</strong>，而这个<strong>引用关系我们命名为fk_t_persons_sex</strong></p><p>其余的约束相对来说不是特别常用，所以这里就不介绍了</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务就是“整体化”，就是如果其中有一条语句失败，事务内所有语句失效</p><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#开启事务</span><br><span class="line">#事务就是“整体化”，就是如果其中有一条语句失败，事务内所有语句失效</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line">#模拟借钱</span><br><span class="line"></span><br><span class="line">#(更新id <span class="operator">=</span> <span class="number">1</span>的用户的账户</span><br><span class="line">UPDATE account </span><br><span class="line"><span class="keyword">SET</span> money  <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#（更新id <span class="operator">=</span> <span class="number">2</span>的用户的账户</span><br><span class="line">UPDATE account <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">#全部成功就提交(<span class="keyword">COMMIT</span>)</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line">#出现失败就取消,</span><br><span class="line">#然后重置到执行前的状态，</span><br><span class="line">#这就叫回滚（<span class="keyword">ROLLBACK</span>）</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></tbody></table></figure><p>如果用户1借1000块钱给用户2<br>第一步：用户1的账户上先减少1000<br>第二步：用户2的账户上再增加1000</p><p>如果第一步成功，第二步失败，用户1就会凭空少1000块，这合理吗？？？</p><p>但好在我们开始了事务，这使得这个事件是一个整体，一步失败则回滚事件开始之前</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p><strong>原子性：</strong><br>即不可分割，是一个整体，要么全部成功，要么全部失败<br><strong>一致性：</strong><br>一旦失败，操作涉及到的所有数据回会回滚到与操作前一致<br><strong>隔离性：</strong><br>事务开始前的状态和完成后的状态相隔离，不存在中间状态<br><strong>持久性：</strong><br>持久性事务完成之后，它对整个系统的影响是永久的</p><h2 id="管理权限"><a href="#管理权限" class="headerlink" title="管理权限"></a>管理权限</h2><h4 id="相关命令-1"><a href="#相关命令-1" class="headerlink" title="相关命令"></a>相关命令</h4><p>就是谁能用这个数据库，并且能用哪些操作</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#创建用户</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> `Serio` </span><br><span class="line">IDENTIFIED <span class="keyword">BY</span> <span class="string">'123'</span>;</span><br><span class="line"></span><br><span class="line">#授权</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> companydb.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">TO</span> `Serio`;</span><br><span class="line"></span><br><span class="line">#撤销权限（和授权一样，在账户重新连接客户端后生效）</span><br><span class="line">REMOVE <span class="keyword">ALL</span> <span class="keyword">ON</span> companydb.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> `Serio`;</span><br><span class="line"></span><br><span class="line">#删除用户</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> `Serio`;</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是，撤销权限后，需要重启一次客户端才可以生效</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图就是一种可以保存下来的虚拟表，说白了就有点像你把某张节选某张表的数据形成一张新的表再打印下来，打印下来这个就是视图.</p><p>可以运用在保存查询结果等方面，<br>然后达到简化查询的目的</p><h4 id="创建视图CREATE-VIEW"><a href="#创建视图CREATE-VIEW" class="headerlink" title="创建视图CREATE VIEW"></a>创建视图CREATE VIEW</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> t_personsInfo</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> `name`, age <span class="keyword">FROM</span> t_persons;</span><br></pre></td></tr></tbody></table></figure><p>有了这个视图，当下次你要查询name和age的时候，就不需要select写那么多字了<br>直接一句</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_personsInfo;</span><br></pre></td></tr></tbody></table></figure><h4 id="修改视图CREATE-OR-REPLACE-VIEW"><a href="#修改视图CREATE-OR-REPLACE-VIEW" class="headerlink" title="修改视图CREATE OR REPLACE VIEW"></a>修改视图CREATE OR REPLACE VIEW</h4><p>顾名思义是创建或者修改视图，总结就是 覆盖</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> t_personsInfo</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> `名字` age <span class="keyword">FROM</span> t_persons;</span><br></pre></td></tr></tbody></table></figure><p>当然这也还有其他修改方式</p><h4 id="修改视图ALTER-VIEW"><a href="#修改视图ALTER-VIEW" class="headerlink" title="修改视图ALTER VIEW"></a>修改视图ALTER VIEW</h4><p>这个依旧是覆盖</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#修改视图<span class="number">2</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> t_personsInfo</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> `名字` age <span class="keyword">FROM</span> t_persons;</span><br></pre></td></tr></tbody></table></figure><h4 id="删除视图DROP-VIEW"><a href="#删除视图DROP-VIEW" class="headerlink" title="删除视图DROP VIEW"></a>删除视图DROP VIEW</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> t_personsInfo;</span><br></pre></td></tr></tbody></table></figure><p>删除也没什么好说的</p><h4 id="视图的性质总结"><a href="#视图的性质总结" class="headerlink" title="视图的性质总结"></a>视图的性质总结</h4><p>形式上与表一样，主要区别在于 <strong>增 删 改</strong>，<br>表的增删改比较自由，<strong>但是视图只能通过整体覆盖的形式来进行增删改</strong><br>视图常作为表的节选内容的副本存在，方便用户<strong>查</strong>找数据<br>但是并不会从查询速率上优化，<strong>只是单纯地减少代码量</strong></p><p>另外，如果视图包含有 由 聚合函数、DISTINCT、GROUP BY、HAVIG UNION等语句处理过 的结果，那么视图不可更新</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Router</title>
      <link href="/2021/12/03/vue-router/"/>
      <url>/2021/12/03/vue-router/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><font color="fa3700">这是几个月前写的，当时放在CSDN上的，现在放到自己的博客上，广告气息很重就是了</font></p><p>学完了一堆后端的知识之后呢，又去学了下git…<br>嘛，现在又回到了前端的学习<br>前置内容：<br><a href="https://blog.csdn.net/Serio_gugugu/article/details/119416221">😍Vue全家桶学习笔记_零基础入门到入坑:Vue篇✨</a></p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/120253610">😘Git学习笔记:告别单机开发从此处开始😝</a></p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/118059067">🤑ES6学习笔记:使前端锦上添花的必看内容🧐</a></p><p>这个学过后端的servlet的话就再清楚不过了。<br>后端的内容可以参考：</p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/119833436">❤❤❤Java基础学习笔记：零基础快速入门❤❤❤</a></p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/118856246">😃😃😃Mysql学习笔记：两小时学完mysql数据库😃😃😃</a></p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/119874047">😜😏😳JDBC学习笔记：半小时学会Java操作数据库😜😏😳</a></p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/119976821">🍠🥩🥙JavaWeb学习笔记：后端极速入门教学🥪🌯🥟</a></p><p>另外，文章末尾还有更多学习资料献给大家~~</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><blockquote><p>路由就是通过网络，把网络信息从源地址传输到目标活动地址</p></blockquote><p>（大概就是URL和页面之间的映射吧）<br>路由本来是后端负责的，但是随着前端的不断发展，路由也进入了前端的范围。</p><h3 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h3><p>嘛，就是浏览器给后端发个请求，后端直接把整个页面（包括html css js等等）响应给浏览器<br>这个过程中，页面已经在后端形成，并且由后端决定URL和页面之间的映射关系。</p><h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><p>随着前后端分离的发展<br>后端变得只负责提供数据和资源<br>前端负责页面内部所有业务（那页面表面呢？html css很多直接丢给美术老师做了..）<br>一个网页的大部分内容都将由前端渲染，并且一个网站中会为了多个网页多次请求</p><p>前后端分离时工作流程如图所示<br>（图片来自网络）<br><img src="https://img-blog.csdnimg.cn/72bd089a5101432c835c156e49efea3e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>只能说是前端渲染，但是路由依旧是后端路由！</strong></p><p>这种技术条件下就有了：</p><h3 id="单页面应用程序（SPA）"><a href="#单页面应用程序（SPA）" class="headerlink" title="单页面应用程序（SPA）"></a>单页面应用程序（SPA）</h3><p><strong>SPA是建立在前后端分离的基础上的</strong><br><strong>整个站点只有一个网页（只有一个index.html）</strong>，请求时会一次性请求全部内容，然后根据前端路由的映射关系，对应的url展示对应的页面内容<br>这种情况下，改变url，不会发起服务端请求，页面也不进行整体刷新</p><p>工作流程如图所示<br>（图片来自网络）<br><img src="https://img-blog.csdnimg.cn/1d9a290aa62f44a18d50e0aa2392621b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="前端路由的基本使用"><a href="#前端路由的基本使用" class="headerlink" title="前端路由的基本使用"></a>前端路由的基本使用</h2><h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><p>有两种模式：第一种是hash模式，第二种是history模式<br><strong>hash模式</strong><br>hash模式是通过监听浏览器的onhashchange()事件变化，查找对应的路由。由<strong>createWebHashHistory（）</strong>创建<br><img src="https://img-blog.csdnimg.cn/3f2f9f20469e4a8cbc11e69e86261f4f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>并且，不会刷新页面，而是在页面上直接加载<br>上图使用了location.hash修改，但是由于b站这个页面本身没有使用hash模式，所以页面没有发生变化</p><p><strong>history模式</strong><br>利用了HTML5 History Interface中新增的**pushState()<strong>和</strong>ReplaceState()**方法<br><img src="https://img-blog.csdnimg.cn/59f7c89313ec44ff9e4fce4b4afc5dd5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>相当于是pushState()把url压栈，然后back()弹出</p><p>刷新一下可以尝试访问<br><img src="https://img-blog.csdnimg.cn/56c9cf83bbaa473393a39f1c9a172cd3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>进一步了解两种模式</strong><br><strong>兼容性</strong><br>hash模式兼容性比较好，history其实也不错（除了IE）<br><strong>是否会发起请求（是否影响后端）</strong><br>hash模式不会，直接在前端解析了#后面的内容<br>history模式则会发起http请求，在路由嵌套的时候会导致404<br>（因为现在路由配置是在前端，http请求时发给后端，后端没有相应配置，所以就会404）</p><h3 id="vue-router实例"><a href="#vue-router实例" class="headerlink" title="vue-router实例"></a>vue-router实例</h3><p>打开cmd，输入vue ui，然后跳转到可视化界面<br><img src="https://img-blog.csdnimg.cn/8d0e409b41044fb382a937910b550ce9.png" alt="在这里插入图片描述"><br>新建一个项目，记得插件要安装<strong>vue-router</strong></p><p>这里我们用idea打开<br>可以在App.vue中找到这个<br><img src="https://img-blog.csdnimg.cn/7d20dc3d3ca5489095d134c5db70f34a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>实际上呢，这个东西实际上就可以看作</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>（其实在vue较早的版本中，就是用的上述语法实现的路由跳转）</p><p>相应的页面会被挂载到图中的view-router标签上</p><p>我们运行一下，在页面中点击About，页面就会变化为<br><img src="https://img-blog.csdnimg.cn/0364fe9ec32444a9a1a85b42a52fdaf2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这其中的路由配置是在router文件下的index.js中配置的<br>routes是创建的路由对象<br><img src="https://img-blog.csdnimg.cn/1d8a18b2b35f421188b71ee2a27cbdbc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>path就是对应的相对url<br>component就对应的组件<br>name就是这个路由的名字罢了</p><p>至于下面的这一行</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'../views/About.vue'</span>)</span><br></pre></td></tr></tbody></table></figure><p>其实也可以在上面import然后再在下面写名称，<br>不过直接合在一起更方便一些不是吗</p><hr><p><strong>点击Home之后我们可以看url变化，就是#后面加了个/<br>/是Home对应的url<br>#说明这是hash模式</strong><br><img src="https://img-blog.csdnimg.cn/e420c559e82445f297463526a42b5e94.png" alt="在这里插入图片描述"><br><strong>可以在下面这里做更多配置（设置模式等等），</strong><br>但是这里就只是确定路由关系为routes，其他配置后面再提</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter({</span><br><span class="line">  routes</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>然后导出</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></tbody></table></figure><p>在main.js里面接收，一切都大工告成</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="简单使用vue-router"><a href="#简单使用vue-router" class="headerlink" title="简单使用vue-router"></a>简单使用vue-router</h3><p>大概看了长啥样，不写的话很快就会忘，这还不得写一下加深印象和理解？<br><strong>第一步：写一个router-link</strong><br>这个放到app.vue就好</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> |</span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span>|</span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/mine"</span>&gt;</span>来康康我写的东西<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#app</span> {</span></span><br><span class="line"><span class="css">  <span class="attribute">font-family</span>: Avenir, Helvetica, Arial, sans-serif;</span></span><br><span class="line"><span class="css">  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span><br><span class="line"><span class="css">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span><br><span class="line"><span class="css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#nav</span> {</span></span><br><span class="line"><span class="css">  <span class="attribute">padding</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#nav</span> <span class="selector-tag">a</span> {</span></span><br><span class="line"><span class="css">  <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#nav</span> <span class="selector-tag">a</span><span class="selector-class">.router-link-exact-active</span> {</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="number">#42b983</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>实际上就是多加了一行：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/mine"</span>&gt;</span>来康康我写的东西<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>第二步：配置路由</strong><br>它对应的url是/mine，所以我们要去router里面的index.js做相应的配置<br>增加这一段</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">path</span>: <span class="string">'/mine'</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'Mine'</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'../views/Mine.vue'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>第三步：配置对应的组件</strong><br>可以看到其对应的组件式import导入的，所以我们还得在对应的位置添加一个Mine.vue文件</p><p>随便写写就行</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>没错这就是我写的路由<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img0.baidu.com/it/u=2976614615,180926968&amp;fm=11&amp;fmt=auto&amp;gp=0.jpg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">'Mine'</span></span></span><br><span class="line"><span class="javascript">}</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>效果如下</strong><br><img src="https://img-blog.csdnimg.cn/391e9e75e57b4a62852090c8e4b45c81.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/230444f180604e2d9e85ef9e3a2d270a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="进一步学习路由"><a href="#进一步学习路由" class="headerlink" title="进一步学习路由"></a>进一步学习路由</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>就是跳转到URL1,然后URL1说：“别找我，你去找URL2”<br>比如这样</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">path</span>: <span class="string">'/'</span>,</span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">'/mine'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>访问‘/’时，被转到了’/mine’<br>所以，我们每次访问/，都会跳到这个页面<br><img src="https://img-blog.csdnimg.cn/97517af679514d0dbf4a43f621c08b43.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="修改模式"><a href="#修改模式" class="headerlink" title="修改模式"></a>修改模式</h3><p>上面提到过的两种模式：hash模式和history模式<br>默认情况下是hash模式，标志是url会带有#（哈希字符）</p><p>之后呢我们开始使用Vue3.x的写法了！</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Vue2.x的写法!</span></span><br><span class="line"><span class="comment">// const router = new VueRouter({</span></span><br><span class="line"><span class="comment">//   routes</span></span><br><span class="line"><span class="comment">// })</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue3.x的写法！</span></span><br><span class="line"><span class="keyword">const</span> router = createRouter({</span><br><span class="line">  <span class="comment">//路由</span></span><br><span class="line">  <span class="attr">routes</span>: routes,</span><br><span class="line">  <span class="comment">//模式（此处为hash模式；如果要改为history模式就写createWebHistory()）</span></span><br><span class="line">  <span class="attr">history</span>: createWebHashHistory(),</span><br><span class="line">  <span class="comment">//router-link在被选中时的css class</span></span><br><span class="line">  <span class="attr">linkActiveClass</span>: <span class="string">'zhe-shi-yi-ge-class'</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>导入对应的内容</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Vue2.x的写法</span></span><br><span class="line"><span class="comment">//import VueRouter from 'vue-router'</span></span><br><span class="line"><span class="comment">//Vue3.x的写法</span></span><br><span class="line"><span class="keyword">import</span> { createRouter, createWebHashHistory } <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br></pre></td></tr></tbody></table></figure><p>至于给它的class呢，就是在App.vue里面给一个对应的就行了</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.zhe-shi-yi-ge-class</span>{</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/b1886364c7e1491c8aeb62b083c5cc3d.png" alt="在这里插入图片描述"></p><h3 id="不可回退约束：replace"><a href="#不可回退约束：replace" class="headerlink" title="不可回退约束：replace"></a>不可回退约束：replace</h3><p>像下面这么写就行</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home"</span> <span class="attr">replace</span>=<span class="string">"replace"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> |</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span> <span class="attr">replace</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span>|</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/mine"</span> <span class="attr">replace</span>&gt;</span>来康康我写的东西<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>众所周知浏览器有前进和回退的功能：<br><img src="https://img-blog.csdnimg.cn/265ea84439c544bfbd6e068d08743d14.png" alt="在这里插入图片描述"><br>实现原理是压栈和出栈<br>但是有些东西我们不想让它入栈，这时候就可以使用replace来约束它<br>即 <strong>被replace约束则不会入栈，并且不可参与路由嵌套</strong></p><h3 id="触发事件进行路由跳转"><a href="#触发事件进行路由跳转" class="headerlink" title="触发事件进行路由跳转"></a>触发事件进行路由跳转</h3><p>这里将就用一下about.vue文件</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"about"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an about page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"toMine"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'../router'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">    <span class="attr">name</span>: <span class="string">'About'</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> toMine = <span class="function">() =&gt;</span> {</span></span><br><span class="line"><span class="javascript">      <span class="comment">//没错，replace是跳转，并且会用replace约束</span></span></span><br><span class="line"><span class="javascript">          router.replace(<span class="string">'/mine'</span>)</span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">        toMine</span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">  }</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>比如我们打开csdn首页，很明显是一个网页，但是打开多次，每次显示的内容却不一样<br>说明这里的路由是个变量！这就是动态路由！<br><img src="https://img-blog.csdnimg.cn/01ef0d407a1e4dcabd21f64c2f1bef3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>来写一个动态路由</strong><br><strong>第一步：写路由跳转</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"'/news/' + newsId"</span> <span class="attr">replace</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>其实就是v-bind绑定一下，所以script部分如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { ref } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">const</span> newsId = ref(<span class="string">'lc666'</span>)</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      newsId</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>第二步：写路由</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">path</span>: <span class="string">'/news/:id'</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'News'</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/News.vue'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>记住这里的id，它将作为后面的键值对的键<br><strong>第三步：写组件</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"news"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>大新闻<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>编号：{{ $route.params }}<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img2.baidu.com/it/u=4244264354,1813450227&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=GIF?w=300&amp;h=300"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>产品经理被打啦！！！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">"News"</span></span></span><br><span class="line"><span class="javascript">}</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-id">#news</span>{</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">#ddd</span> solid <span class="number">1px</span>;</span></span><br><span class="line"><span class="css">  }</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>效果图</strong><br><img src="https://img-blog.csdnimg.cn/4dd8af180d7a438ba7adc98d913074c7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如图所示，url部分是我们动态绑定的lc666，然后编号部分是一个键值对<br>如果我们修改编号部分的代码如下，就可以访问到其值：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>编号：{{ $route.params.id }}<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/d83cac08bfaf4f619a3d7f658ddd4570.png" alt="在这里插入图片描述"><br>当然，我们还可以用js获取id</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> {useRoute} <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"News"</span>,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">const</span> route = useRoute()</span><br><span class="line">    <span class="built_in">console</span>.log(route.params.id)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/83d2c67a91c2415d9b7ae3f91317d6df.png" alt="在这里插入图片描述"></p><hr><p><strong>扩展</strong><br>这里我们是本地写的内容<br>但是我们是动态绑定的url，所以我们能够从服务器请求到id、文章内容之类的话，就可以实现真正的动态加载内容了</p><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>就咱们写的这个页面来说，比如我首屏是Home界面，这个时候我又看不到About等其他三个界面。<br>那要是我一开始就把所有资源请求下来了，那加载岂不是慢得一批？<br>为什么不优化一下？<strong>只有在访问某个界面的时候才请求资源——这就是，懒加载</strong><br>实际上之前也看到过懒加载的方式了：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">   <span class="attr">path</span>: <span class="string">'/news/:id'</span>,</span><br><span class="line">   <span class="attr">name</span>: <span class="string">'News'</span>,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/News.vue'</span>)</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>比如上述的component的写法就是懒加载，是利用了函数的性质：只有被使用的时候才会执行</p><p><strong>懒加载的内容在打包的时候，会被被单独分为一个文件</strong>，而不是像原来一样所有内容都在一个文件里</p><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><p><img src="https://img-blog.csdnimg.cn/530914aa4f5742bfb9e3df40fe465062.png" alt="在这里插入图片描述"><br>比如http:localhost:8080/Mine/msg<br>新建一个组件命名规范如图所示<br>然后写一个新组件</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mine_msg"</span>&gt;</span>咕咕咕<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">'MineMsg'</span></span></span><br><span class="line"><span class="javascript">}</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-id">#mine_msg</span>{</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: aqua;</span></span><br><span class="line"><span class="css">    <span class="attribute">font-size</span>: <span class="number">32px</span>;</span></span><br><span class="line"><span class="css">  }</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>再到路由配置里面，找到Mine，增加一个children属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">   <span class="attr">path</span>: <span class="string">'/mine'</span>,</span><br><span class="line">   <span class="attr">name</span>: <span class="string">'Mine'</span>,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'../views/Mine.vue'</span>),</span><br><span class="line">   <span class="attr">children</span>: [</span><br><span class="line">     {</span><br><span class="line">       <span class="attr">path</span>: <span class="string">'msg'</span>,</span><br><span class="line">       <span class="attr">name</span>: <span class="string">'MineMsg'</span>,</span><br><span class="line">       <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/MineMsg.vue'</span>)</span><br><span class="line">     }</span><br><span class="line">   ]</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>在到Mine里面写，大概写成这样就行</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>没错这就是我写的路由<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img0.baidu.com/it/u=2976614615,180926968&amp;fm=11&amp;fmt=auto&amp;gp=0.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-nav"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/mine/msg"</span>&gt;</span>我的消息<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">'Mine'</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> {}</span></span><br><span class="line"><span class="javascript">}</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.content</span>{</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">    <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span></span><br><span class="line"><span class="css">  }</span></span><br><span class="line"><span class="css">  <span class="selector-class">.content-nav</span>{</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: gold;</span></span><br><span class="line"><span class="css">  }</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>效果大概是这样<br><img src="https://img-blog.csdnimg.cn/6433832382ac4c1cb6846a65e5d6c7dc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>点一下<br><img src="https://img-blog.csdnimg.cn/85741f6f9f2046d480ca27e61f46a439.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>大概就是这样啦</p><hr><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>参数传递有两种方式，一种是parmas类型，另一种是query类型</p><table><thead><tr><th>类型</th><th>传递方式</th><th>路由配置格式</th><th>传递后形成的路径格式</th></tr></thead><tbody><tr><td>parmas</td><td>在path后跟上传递的参数</td><td>/router/:params</td><td>/router/xxx</td></tr><tr><td>query</td><td>对象种使用query的key作为传递方式</td><td>/router</td><td>/router?id=xxx</td></tr></tbody></table><p><strong>query类型</strong><br>就是经典的?username=xxx&amp;pswd=xxx，比如<br><img src="https://img-blog.csdnimg.cn/51902b46592e4fbfb391950532f99e91.png" alt="在这里插入图片描述"></p><p>说白了也就是Cookie和Session嘛….<br>不过vue为我们提供了一手高效便捷的封装操作<br>再建一个<br><img src="https://img-blog.csdnimg.cn/d362765cc74e462d8f96ae99de7d775d.png" alt="在这里插入图片描述"><br>路由…</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">path</span>: <span class="string">'/circle'</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'Circle'</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Circle.vue'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>组件里面随便写点，反正也不重要</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>雀食蟀啊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后到App.vue里面加上这个</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"{path:'/circle', query:{name:'大帅逼',id:'666666'}}"</span>&gt;</span>朋友圈<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>点一下就来了<br><img src="https://img-blog.csdnimg.cn/4c0a0c02b1bf4811abcf321b22e72205.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>也可以拿到上面的数据</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>雀食蟀啊<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{$route.query}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{$route.query.name}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{$route.params}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>注意params拿的是vue组件里面传递的参数，query拿的才是URL里面的参数（Cookie）<br><img src="https://img-blog.csdnimg.cn/d10235c2f0d845db96d8112f6934da0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>parmas类型</strong><br>About里面这样写</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"about"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an about page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"toMine"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"toCircle"</span>&gt;</span>朋友圈<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'../router'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> { ref } <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">    <span class="attr">name</span>: <span class="string">'About'</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> circleId = ref(<span class="string">'2333'</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> toMine = <span class="function">() =&gt;</span> {</span></span><br><span class="line"><span class="javascript">          router.replace(<span class="string">'/mine'</span>)</span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> toCircle = <span class="function">() =&gt;</span> {</span></span><br><span class="line"><span class="javascript">          router.push(<span class="string">'/circle/'</span> + circleId.value)</span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">        toMine,</span></span><br><span class="line"><span class="javascript">        toCircle</span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">  }</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/c4f365c964eb437c88e28d55a0eff582.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/651842a39c9240dba54cbd70886a73c1.png" alt="在这里插入图片描述"><br>仔细观察一下，“点击跳转”按钮用的是router.replace，而“朋友圈”按钮是用的router.push，那么二者的区别是什么呢？<br><strong>replace是替换栈顶，push是压入一个新的</strong><br>那么参数传递大概也就是这样了</p><hr><h2 id="路由的高阶使用"><a href="#路由的高阶使用" class="headerlink" title="路由的高阶使用"></a>路由的高阶使用</h2><h3 id="Router和Route对象"><a href="#Router和Route对象" class="headerlink" title="Router和Route对象"></a>Router和Route对象</h3><p>如果要简单地概括router和route的关系的话，那么就是：<br>router是全局的，route是具体的某一个组件<br>| 名称   | 区别                                                         |<br>| —— | ———————————————————— |<br>| router | router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router实例对象 |<br>| route  | route是一个可跳转的路由对象，是一个局部对象，可以通过它获取相应的name，path，params，query等 |</p><p>另外，router3.x里面都还用的JS，到了4.x就都用TS了（完了没学过根本看不懂）</p><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p>大概就是你进入这个页面的时候，了解“你是谁”“你从哪里来”“你要到哪里去”<br>（大雾），并且决定是否“<strong>放行</strong>”<br><strong>全局路由前置守卫</strong><br>说白了就是全局的前门守卫</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter({</span><br><span class="line">  <span class="attr">history</span>: createWebHistory(process.env.BASE_URL),</span><br><span class="line">  <span class="attr">routes</span>: routes,</span><br><span class="line">  <span class="attr">linkActiveClass</span>: <span class="string">'zhe-shi-yi-ge-class'</span></span><br><span class="line">})</span><br><span class="line"><span class="comment">//全局路由的前置守卫，三个参数:去、来、是否放行的函数</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>)=&gt;</span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"贫僧来自"</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">from</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"欲前往"</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(to)</span><br><span class="line">  <span class="comment">//放行</span></span><br><span class="line">  next()</span><br><span class="line">})</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/c5d27ddb70114755870c8e1a54cc323b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>记得一定要有next()，不然无法成功跳转<br>既然有前置的那也有后置的，把beforeEach改成afterEach就行了，但是还是前置的常用一些</p><p>有全局那应该还有局部的，这就是<strong>路由元信息</strong><br>通过设置路由元信息可以把<strong>任意信息</strong>附加到路由上，比如过渡名称<br>谁可以访问这个路由等等，这些效果通过meta属性实现：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">path</span>: <span class="string">'/circle'</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'Circle'</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Circle.vue'</span>),</span><br><span class="line">  <span class="attr">meta</span>: {<span class="attr">title</span>: <span class="string">'呜呼呼是朋友圈诶'</span>}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后我们就能在路由守卫中的对象参数to中<code>在这里插入代码片</code>的属性中找到这个title</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>)=&gt;</span>{</span><br><span class="line">  <span class="built_in">document</span>.title = to.meta.title</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"贫僧来自"</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">from</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"欲前往"</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(to)</span><br><span class="line">  <span class="comment">//放行</span></span><br><span class="line">  next()</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/b87b254ec6b54a0f832d08e8141fc90e.png" alt="在这里插入图片描述"><br>当然，其他没有设置meta.title的自然是undefined了</p><p>当然，守卫的主要作用之一其实是<strong>判断用户登录状态并做出响应的跳转！</strong></p><p><strong>其他守卫的形式</strong><br>除了上述介绍的在路由中写守卫的方式，还有就是通过事件监听的方式来做</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> {onBeforeRouteLeave, onBeforeRouteUpdate} <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br></pre></td></tr></tbody></table></figure><p>引入之后自己写一下事件监听就好了(参数依旧是那三个</p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>组件A跳转到组件B时，创建组件B，销毁组件A。再由A返回B时，又创建A，销毁B…如果这样的过程多，那么开销就太大，不如让AB始终存在，就免去了创建销毁的成本</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  一般的写法--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  &lt;router-view/&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- vue2.x的写法 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  &lt;keep-alive&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;router-view&gt;&lt;/router-view&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  &lt;/keep-alive&gt;  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- vue3的写法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">"{ Component }"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"Component"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>用插槽的话能够动态匹配（虽然我也快忘完了）<br>那怎么体现它没有销毁重建呢，比如你可以加一个勾选框或者输入框之类的，输入一些东西然后跳转过去再回来，发现输入内容还在，这就说明还是原来那个没有销毁</p><p><strong>附带的生命周期钩子</strong><br>这两个钩子是<strong>专门服务于被keep-alive包裹的router-view</strong><br>分别是：<strong>onActived和onDeactived</strong>，也就是当访问某个页面和离开某个页面时</p><p><strong>常用的属性</strong><br>| 属性    | 数据类型                     |                                    |<br>| ——- | —————————- | ———————————- |<br>| include | String，RegExp（正则）,Array | 只有名称匹配的组件才会被渲染       |<br>| exclude | String, RegExp, Array        | 任何名称匹配的组件都<strong>不会</strong>被渲染 |<br>| max     | String                       | 最多可以渲染多少组件实例           |</p><p>比如：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">"{ Component }"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">name</span>=<span class="string">"fade"</span> <span class="attr">exclude</span>=<span class="string">"{'News', 'Home'}"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"Component"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样一来，它就不会保存News和Home，News和Home每次还是会销毁和重新创建</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>今天是2021.10.22<br>一晃就学了半年的前端了，半年收获还是挺多的…<br>唔，vue-router的大致内容就是这些了，由于本人才疏学浅，也难以将所有的知识全部概括，所以要完全掌握vue-router还需要各位自行学习了<br>这之后我还会继续更新 <strong>操作系统</strong> 和 <strong>VueX</strong>（估计至少也得十二月去了）的内容<br>以下是操作系统的内容，希望对大家有帮助<br><a href="https://blog.csdn.net/Serio_gugugu/article/details/120575984">本科操作系统学习笔记:从入门到精通🥰</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2021/12/03/os/"/>
      <url>/2021/12/03/os/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>操作系统因为翘课太多只能自学啊~~<br>而且计算机基础知识是很重要的，必须要认真对待才是（那为啥翘课？翘课学前端去了…）<br>不管怎么说，还是做个笔记方便日后复习<br>（图片均出自中国大学MOOC或bilibili视频截图）</p><h2 id="计组和操作系统杂谈"><a href="#计组和操作系统杂谈" class="headerlink" title="计组和操作系统杂谈"></a>计组和操作系统杂谈</h2><p>随便写点（这个部分可以跳过）</p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p><strong>计算机系统</strong>：处理机+外围设备</p><p><strong>处理机</strong>：包括CPU，主存储器、输入输出设备</p><p><strong>CPU</strong>：中央处理器+控制核心<br>(<strong>下文有时会把处理机称为CPU，见谅</strong>)<br>(<strong>后面网上一查才发现，好多人都把处理机和处理器混淆了</strong>)</p><p><strong>中央处理器</strong>：运算单元+控制单元<br><strong>主存储器</strong><br><strong>外围设备</strong>：输出设备 输入设备 存储设备 网络通信设备（比如鼠标键盘等）<br><strong>总线</strong>：Bus,是CPU，内存，输入输出设备传输信息的共用通道；外围设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统</p><p>存储器的层次：<br><img src="https://img-blog.csdnimg.cn/cf49c35e358f4d20a82d616b4466ae36.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>外围设备及其控制：<br><img src="https://img-blog.csdnimg.cn/a0c3bf94ddf941af87fec900e3433fd7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>总线的类型：<br><img src="https://img-blog.csdnimg.cn/2471b066836144e8b159b58b9001887c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>上述内容是<strong>冯诺依曼提出的存储程序计算机模型</strong><br><img src="https://img-blog.csdnimg.cn/1ac6e9d9460e48b8aa877a0817fc23d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="指令执行的过程"><a href="#指令执行的过程" class="headerlink" title="指令执行的过程"></a>指令执行的过程</h3><p><strong>前置概念</strong><br>（引用自<a href="https://blog.csdn.net/qq_34801169/article/details/102782643">CSDN博主「快乐的一只小喵喵」的原创文章</a>）</p><blockquote><p><strong>程序计数器（PC，Program counter）</strong><br>用于存放指令的地址。为了保证程序(在操作系统中理解为进程)能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，此过程称，为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。<br><strong>指令寄存器（IR，Instruction Register）</strong><br>用来保存当前正在执行的一条指令。是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一条指令。当执行一条指令时，先把它从内存取到数据寄存器（DR，Data<br>Register）中，然后再传送至IR。指令划分为操作码和地址码字段，由二进制数字组成。为了执行任何给定的指令，必须对操作码进行测试，以便识别所要求的操作。指令译码器就是做这项工作的。指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号。<br><strong>&gt; 通用寄存器（GR，General register）</strong><br>通用寄存器可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。除此之外，它们还各自具有一些特殊功能。通用寄存器的长度取决于机器字长，汇编语言程序员必须熟悉每个寄存器的一般用途和特殊用途，只有这样，才能在程序中做到正确、合理地使用它们。</p></blockquote><p>————————————————</p><p>一种较为简单的指令执行步骤:<br><strong>1.取指</strong>：根据PC从存储器或高速缓冲存储器中取指令到IR<br><strong>2.解码</strong>：解译IR中的指令来决定其执行行为<br><strong>3.执行</strong>：连接到CPU部件，执行运算，产生结果并写回，同时在CC里设置运算结论标志；跳转指令操作PC，其他指令递增PC值</p><p><strong>指令执行的流水线</strong><br><img src="https://img-blog.csdnimg.cn/9352d87c2e9246558b6d9ddce89c5de5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>其中流水线的过程有点<strong>并发</strong>的意思</p><h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><p>用户的程序并不能够使用全部的计算机指令（比如app总是要你授权就是这个道理），<strong>计算机核心资源的特殊指令会被保护起来</strong>，它们只能被操作系统程序使用<br>至于特权指令是怎么被实现的，就要提到<strong>处理器模式</strong>：<br>计算机一般设置0 1 2 3四种模式<br>0是操作系统内核<br>1是系统调用<br>2是共享库程序<br>3是用户程序</p><p>数值越大权限越低<br>tip：现代操作系统很多都只是用了0和3两个模式，<strong>内核模式</strong>和<strong>用户模式</strong>（下图以红色的括号为准）<br><img src="https://img-blog.csdnimg.cn/b5fedf610b114ce3b33a21bc84b51d55.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>嘛。。。其实就是字面意思嘛。。。<br>就是程序执行过程中，遇到突发状况，就暂时终止处理机上当前程序的运行，转去处理突发事件，<strong>处理完成之后再回到刚才暂停的地方继续执行</strong> 这个过程，就是中断</p><p><strong>中断是并发的基础</strong></p><hr><p><strong>中断源</strong><br>那引起中断的事件就称为中断源<br>它可能是处理器执行机器指令引起的，比如除数为0，操作数溢出等算数异常或者其他异常</p><hr><p>对于简单的问题，处理器会简单处理然后报告用户；也可以由用户编写的中断续元程序处理</p><p>但是复杂的问题（比如I/O中断，来源于外围设备报告I/O状态的中断事件)（比如打印机打印一般了发现缺纸了）<br>就需要人工干预了</p><hr><h2 id="初步认识操作系统"><a href="#初步认识操作系统" class="headerlink" title="初步认识操作系统"></a>初步认识操作系统</h2><p>终于进入主题。由于学校的视频资源给的好像不是很系统，所以我决定自己找视频再结合教材作书摘一样地写<br><img src="https://img-blog.csdnimg.cn/00a410ed4e5940efaad2e96334c6f6b7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>定义</strong></p><p>Operating system，即OS，是配置在计算机硬件上的第一层<strong>软件</strong>,也就是说，<strong>操作系统是计算机硬件的第一次扩充</strong></p><hr><p><strong>目的</strong></p><p><strong>管理硬件，提高利用率和系统吞吐量</strong>，具体实现了以下四个方面</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>方便性</td><td>没有操作系统的话用户只能用机器语言操作了</td></tr><tr><td>有效性</td><td>合理组织计算机工作流程，提高效率</td></tr><tr><td>可扩充性</td><td>方便地增加新的功能和模块</td></tr><tr><td>开放性</td><td>很好地应用于网络环境</td></tr></tbody></table><p><strong>功能</strong></p><p>不同的场合下身份不同，一共可以充当三个角色</p><table><thead><tr><th>身份</th><th>功能</th></tr></thead><tbody><tr><td>资源的管理者</td><td>管理 处理机、 存储器、 文件、 设备</td></tr><tr><td>用户的服务者</td><td>向用户提供接口（定义见后续内容）</td></tr><tr><td>硬件的扩充者</td><td>扩充机器</td></tr></tbody></table><p>管理处理机、存储器、文件和设备</p><hr><p><strong>接口</strong></p><p>学过开发的大家应该清楚什么意思。<br>这里指的是用户和计算机硬件之间的接口，即用户操控计算机硬件资源的途径<br>以下是三种主要的接口</p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>命令接口</td><td>允许用户直接使用</td></tr><tr><td>程序接口</td><td>允许用户通过程序间接使用</td></tr><tr><td>GUI</td><td>现代操作中最流行的图形用户接口（比如windows，这里我们不讨论GUI）</td></tr></tbody></table><p>其中，<strong>命令接口</strong>又可以分为：<br>| 类型                       | 内容                   |<br>| ————————– | ———————- |<br>| 联机命令接口               | 用户说一句，系统做一句 |<br>| 脱机命令接口               | 用户说一堆，系统做一堆 |<br>| 然后，<strong>程序接口</strong>具体是： |                        |</p><blockquote><p>由一组系统调用组成（系统调用 就是 程序接口，有的地方也叫广义指令）</p></blockquote><h3 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h3><p>一共有四个特征：<strong>并发 共享 虚拟 异步</strong><br>其中 <strong>并发 和 共享 是最基本的特征</strong>， 二者互为存在条件</p><hr><p><strong>并发</strong></p><blockquote><p>并发是两个或多个事件在同一时间间隔内发生<br>这些事件在宏观上是同时发生，但是微观上是交替发生的</p></blockquote><p>这是书上的话，其实就是说<br><strong>并发是一个时间段里面多个事件先后发生</strong><br>（并且不是一贯到底的）<br>（如果时间段比较短的话，就像是同时完成了多个事件）</p><p><strong>另外，并发的基础是中断</strong></p><hr><p>这里有一个容易混淆的概念：<strong>并行</strong></p><blockquote><p>两个或多个事件在同一时刻同时发生</p></blockquote><p>这个才是真正的同时进行<br>如下图所示：<br><img src="https://img-blog.csdnimg.cn/dc310655319c4db7bacf383c78715bc9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><p><strong>那么问题来了——为什么是并发而不是并行</strong><br>对于计算机来说，并行不是明显更高效吗，为什么操作系统的特征是并发呢？<br>主要是硬件限制，以前单核的CPU，同一时刻只能执行一个程序，所以就需要并发；<br>现在呢，保底都是四核了，也就是同一时刻四个程序，但是现在用电脑同一时刻才几个程序？所以还是会有并发…</p><hr><p> <strong>共享</strong></p><blockquote><p>共享指的是资源共享，是指系统中的资源可供内存中多个并发执行的进程使用</p></blockquote><hr><p><strong>资源共享的方式</strong><br>| 方式     | 内容                           |<br>| ——– | —————————— |<br>| 互斥共享 | 一个时间段内只能给一个进程访问 |<br>| 同时共享 | 一个时间段内由多个进程轮流访问 |</p><p>同时共享 和 并发 类似，也只是宏观上的同时，微观上是几个程序轮流占用</p><p>（当然有些时候也真的是同时，比如一边打游戏一边听歌，扬声器可以同时播放两者的音乐）</p><hr><p><strong>并发和共享的关系</strong><br>单核CPU下，没有并行这种操作，那要是并发都没有，计算机隔很久才执行一个程序，那共享从何而来？<br>另外，要是没有共享性质，极短的事件内，一个资源不能被两个或者多个程序访问，那么并发也无法继续进行</p><p>所以二者是相互依存</p><hr><p> <strong>虚拟</strong></p><blockquote><p>把一个物理上的实体变为若干个逻辑上的对应物；实体是实际存在的，对应物是用户感受到的</p></blockquote><p><strong>举例1：空间的虚拟</strong><br><strong>一个程序需要放入内存并且给它分配cpu才能执行</strong><br>那么比如运行一个游戏要10G内存，但是我们的电脑只有4G的内存，但是我们就是可以让它运行，好像我们电脑的内存不止10G的样子</p><p>这个例子中，4G内存就是实体，10G是用户感受到的，也就是逻辑上的对应物体<br>这里涉及到的技术叫做 <strong>空分复用术</strong></p><p><strong>举例2：时间的虚拟</strong><br>单核CPU的计算机 看上去 似乎可以“同时”执行多个程序（体现为 并发），可是它的原理是什么呢？<br>这里涉及到的技术叫做<strong>时分复用术</strong><br>（这里也看出，如果没有并发，就不需要（时间上的）虚拟；如果没有虚拟，就难以并发）</p><hr><p><strong>异步</strong></p><blockquote><p>在多道程序环境下，允许多个程序并发执行，但是资源有限，每个进程的执行不是一贯到底（进程是并发的），而是走走停停（轮流使用一段时间资源），以不可预知的速度向前推进</p></blockquote><p>说到异步啊….最开始学前端学到async和ajax的时候接触到了异步，当时我以为的异步实际上是并行（因为当时学的时候，有人说异步是生活中的同步，同步才是生活中的异步）….所以我之前一直理解错了….</p><hr><p><strong>图示举例</strong><br><img src="https://img-blog.csdnimg.cn/d75d734e01634f84ad34e566cb267da7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><h3 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h3><p>我们学习的范围包括：</p><blockquote><p>1.手工操作系统<br>2.批处理操作系统（包括单道和多道）<br>3.分时操作系统<br>4.实时操作系统<br>5.网络操作系统<br>6.分布式操作系统<br>7.个人计算机操作系统</p></blockquote><p>发展顺序自上而下，每一个阶段都是为了解决上一代的主要缺点</p><p>其中重点掌握2 3 4，1 5 6 7了解即可</p><hr><p><strong>1.手工操作系统</strong><br>其实这个都算不上操作系统<br>当时的程序员用<strong>纸带打孔</strong>的方式 表示0和1 进行编程</p><p>流程大概是：</p><blockquote><p>纸带A（代码）–&gt;纸带机–&gt;计算机（计算）–&gt;纸带机–&gt;纸带B（运行结果）</p></blockquote><p><strong>计算机速度很快</strong>，但是啊<strong>纸带机很慢</strong>，整个流程中大部分时间都在等待纸带机读取数据</p><p>这种流程有两个主要缺点：</p><blockquote><p>计算机有很多时间在等待 ，<br>一次只能有一个用户占用资源（机器）<br>上述两点概括为 <strong>人机速度矛盾</strong></p></blockquote><hr><p><strong>2.1批处理操作系统：单道</strong></p><p>这个阶段引入了<strong>脱机输入/输出技术</strong>，并且引入<strong>监督程序</strong>（操作系统的雏形）负责控制作业的输入输出</p><p>流程大概是（对称的，看一半就行）</p><blockquote><p>纸带-&gt;纸带机-&gt;外围设备-&gt;磁带-&gt;计算机-&gt;磁带-&gt;外围设备-&gt;纸带机-&gt;纸袋</p></blockquote><p>其实就是<strong>引入了外围设备和磁带</strong>，外围设备可以把数据快速存到磁带里面，然后磁带内的数据可以被计算机快速处理，输出同理</p><p>这个过程中，<strong>监督程序负责调控 计算机读取磁带内数据</strong></p><p>图示<br><img src="https://img-blog.csdnimg.cn/0a3218f01fe94443b05c235a1bf2b629.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>缺点是</p><blockquote><p>只有一个程序能运行，CPU依旧有很多时间在等待I/O，资源利用率还是不高</p></blockquote><hr><p><strong>2.2批处理操作系统：多道</strong><br>流程同上，但是每次可以使用多个磁带向计算机输入数据了<br><strong>引入了中断技术，并发由此出现，操作系统正式诞生</strong><br>（再次强调，中断是并发的基础）</p><p>图示<br><img src="https://img-blog.csdnimg.cn/136015b304454cc7929165d0ce62b2cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>缺点</strong></p><blockquote><p>响应时间长，没有人机交互能力（用户提交之后就只能等，不能手动控制调度）</p></blockquote><hr><p><strong>3.分时操作系统</strong><br>引入了<strong>时间片</strong>的概念(就是一个较小的时间段，大概是一个定值)</p><blockquote><p>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可以通过终端与计算机进行交互</p></blockquote><p><strong>举例</strong><br>比如时间片是0.01s，那么每个任务轮流执行0.01s，在1s内可能会完成多个任务，给用户的感受就是多个“同时”完成</p><p><strong>缺点</strong></p><blockquote><p>没有优先级，完全公平地处理任务，不能分轻重缓急</p></blockquote><hr><p><strong>4.实时操作系统</strong><br>引入了优先级</p><blockquote><p>在分时操作系统的基础上，能够优先响应一些紧急任务（它们不需要时间片排队）</p></blockquote><p><strong>分类（了解即可）</strong></p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>硬实时系统</td><td>必须在绝对严格的固定时间内完成处理</td></tr><tr><td>软实时系统</td><td>能够接受偶尔违反时间规定</td></tr></tbody></table><hr><p><strong>5-7其他几种操作系统（了解即可）</strong><br><strong>网络操作系统</strong></p><blockquote><p>实现网络中各种资源的共享和各台计算机之间的通信</p></blockquote><p><strong>分布式操作系统</strong></p><blockquote><p>有分布性和并行性，由多台计算机分工，工作可以分布在这些计算机上并行、协同完成</p></blockquote><p><strong>个人计算机操作系统</strong></p><blockquote><p>比如windows，方便个人使用</p></blockquote><hr><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p> <strong>两种指令</strong><br>这里的指令是指机器语言指令（高级语言翻译过来的）</p><p>两种指令主要是：<strong>特权指令</strong>和<strong>非特权指令</strong></p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>特权指令</td><td>不允许用户随意使用</td></tr><tr><td>非特权指令</td><td>允许用户随意使用</td></tr></tbody></table><p>出现这种分类的原因正如其名——有的指令可能造成的影响较大（比如删库？），不允许用户随便使用，即“特权”</p><p>但是，计算机怎么识别当前是否可以执行特权指令呢？<br>这就是接下来将要提到的处理器状态了</p><hr><p> <strong>两种处理器状态</strong><br>处理器状态分为 <strong>用户态（目态）</strong> 和 <strong>核心态（管态）</strong></p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>用户态（目态）</td><td>此时处理器不可执行特权指令</td></tr><tr><td>核心态（管态）</td><td>此时处理器可以执行特权指令</td></tr></tbody></table><p>这是利用<strong>程序状态字寄存器PSW</strong>中的某标志位来标识当前处理器处于什么状态。（比如可以让用户态为0，核心态为1）</p><p>上述内容体现在处于不同状态的程序上</p><hr><p><strong>两种程序</strong><br>也就是<strong>内核程序</strong>和<strong>应用程序</strong>，正如其名，不再多言<br>(当然，如果提到“管态程序”、“核心态程序”这些等价的概念时，也要反应得过来才是)</p><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><blockquote><p>是计算结配置上的底层软件，是操作系统最基本、最核心的部分</p></blockquote><p>就是常常听到的什么四核八核十六核CPU那个核<br>大概是这么一个地位：<br><img src="https://img-blog.csdnimg.cn/7c5250cd7e24460887cd5f091490a10c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><p> <strong>时钟管理</strong></p><blockquote><p>实现计时的功能</p></blockquote><hr><p> <strong>中断</strong><br>前面说并发的时候提到过</p><blockquote><p>负责实现中断机制（并发的前提）</p></blockquote><p><strong>分类</strong><br>广义的中断的分类标准主要根据信号的来源——CPU的内部还是外部</p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>内中断（异常、例外、陷入/陷阱）</td><td>指令中断的则为<strong>自愿中断</strong>；硬件故障或者软件中断的则为<strong>强迫中断</strong></td></tr><tr><td>外中断(中断)</td><td>一般是人工干预或外围设备请求导致的</td></tr></tbody></table><p><strong>运作过程</strong><br>配合时钟管理的计时器，发出中断信号</p><p>中断处理是内核的一部分，<strong>所以中断发生时，CPU进入核心态</strong><br>（<strong>中断是 用户态 转为 核心态 的唯一途径</strong>）</p><p>（<strong>而核心态 转为 用户态 的途径是执行一个特权指令，将PSW设置为“用户态”</strong>）</p><p>中断发生后，当前运行的进程暂停，接下来操作系统内核将对其进行处理</p><p>那么具体一点就是：</p><blockquote><p>执行每个指令后，CPU都会检测是否有外部中断信号： 如果没有，那么执行下一个指令；<br>如果有，那么保存即将被中断的CPU环境（相当于游戏存档，方便下次继续），然后进行中断处理。</p></blockquote><hr><p><strong>原语</strong></p><blockquote><p>一种特殊的程序<br>处于操作系统最底层，最接近硬件<br>运行时间短、调用频繁<br>具有原子性（就是数据库事务提到的那个）</p></blockquote><hr><p> <strong>系统资源管理</strong></p><blockquote><p>包括进程管理、存储器管理和设备管理等</p></blockquote><hr><p> <strong>内核分类</strong><br>有不同的分类标准，比如：</p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>单内核</td><td>内核中各个部件混杂的形态</td></tr><tr><td>大内核</td><td>在微内核基础上，还包括进程、存储器、设备管理等</td></tr><tr><td>微内核</td><td>结构性部件与功能部件分离</td></tr><tr><td>混合内核</td><td>微内核和单内核的折中，较多组件再核心态中运行</td></tr><tr><td>外内核</td><td>尽可能减少内核的软件抽象化和传统微内核的消息传递机制</td></tr></tbody></table><hr><p>这里主要讨论 <strong>大内核 和 微内核</strong><br><strong>大内核</strong><br>把操作系统主要模块都作为系统内核，运行在核心态（管态）<br>优点：高性能（一直是核心态不用切换）<br>缺点：代码庞大，结构乱，难维护<br>（这个缺点是很多早期计算机技术的通病）</p><p><strong>微内核</strong><br>内核只保留基本功能<br>优点：内核功能少，结构清晰，方便维护<br>缺点：需要频繁地在核心态和用户态之间切换，低性能</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>就是程序接口（严格意义上说操作系统是由一组系统调用组成的），上面有提到过</p><blockquote><p>操作系统提供给应用程序（编程人员）使用的接口。可以理解为一种可供应用程序调用的特殊函数，应用程序可以请求系统调用来获得操作系统的服务。</p></blockquote><p><strong>系统调用背后的过程</strong><br><img src="https://img-blog.csdnimg.cn/d007fb671aff4eceba98feecac3295a5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="定义和组成"><a href="#定义和组成" class="headerlink" title="定义和组成"></a>定义和组成</h3><p>进程就是一个程序地执行过程<br>当一个程序被放到内存中，才能够被CPU处理，才能执行<br>(我们双击exe文件，就是把程序放入内存的操作)</p><p>其中，程序的定义是<strong>一个指令序列</strong><br>而进程可以从不同角度进行定义，比如这些：</p><blockquote><p>程序段，数据段，PCB（进程控制块）三部分组成了进程实体（也叫进程映像，简称为进程）</p></blockquote><blockquote><p>进程是程序的一次执行过程</p></blockquote><blockquote><p>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</p></blockquote><blockquote><p>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</p></blockquote><blockquote><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p></blockquote><p>程序段，数据段，PCB三者都在内存中：<br>程序段、数据段分别是CPU中存放程序代码和所需数据的地方，<br>PCB则存储了程序段和数据段在CPU中的地址等信息</p><p>严格地说，<strong>进程实体是静态的，进程是动态的</strong></p><p><strong>PCB的存在时进程存在的唯一标志</strong></p><hr><h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><p>一个系统中，会存在众多PCB。必须用适当的形式来组织管理他们。<br>主要有两种组织方式：<br>| 方式     | 内容                                                         |<br>| ——– | ———————————————————— |<br>| 链接方式 | 按照进程状态将PCB分为多个队列；操作系统持有指向各个队列的指针 |<br>| 索引方式 | 根据进程状态的不同，建立几张索引表；操作系统持有各个索引表的指针 |</p><p><strong>链接方式</strong><br>拥有<strong>执行指针</strong>，指向当前处于运行态（执行态）的进程的控制器PCB；<br>拥有<strong>就绪队列指针</strong>，指向当前处于就绪态的进程；<br>拥有<strong>阻塞队列指针</strong>，指向当前处于阻塞太的进程，很多操作系统会因为阻塞原因不同而划分多个阻塞队列；</p><p><strong>索引方式</strong><br>和链接方式类似，拥有<strong>执行指针</strong>和<strong>阻塞队列指针</strong><br>并且拥有<strong>就绪表指针</strong>，指向一张就绪索引表的地址</p><hr><h3 id="进程的五大特征与三大状态"><a href="#进程的五大特征与三大状态" class="headerlink" title="进程的五大特征与三大状态"></a>进程的五大特征与三大状态</h3><p><strong>五大特征</strong><br>| 特征   | 内容                                                         |<br>| —— | ———————————————————— |<br>| 动态性 | 进程是程序的一次执行过程，是动态地产生、变化和消亡           |<br>| 并发性 | 内存中存在多个进程实体，可以并发执行                         |<br>| 独立性 | 进程是<strong>能够独立地运行、获取资源、接受调度的基本单位</strong>       |<br>| 异步性 | 各个进程以独立的、不可预知的速度向前推进。操作系统需要提供“进程同步机制”来解决问题 |<br>| 结构性 | 每个进程都由PCB、结构段、数据段组成                          |</p><p>其中，<strong>动态性</strong>是进程的最基本特征</p><p><strong>三大状态</strong><br>| 状态                            | 内容                                                         |<br>| ——————————- | ———————————————————— |<br>| 运行态                          | 占有CPU并且在CPU上运行                                       |<br>| 就绪态                          | 已经具备运行条件，但是由于没有闲置CPU，暂时不能运行          |<br>| 阻塞态(等待态)                  | 因为等待某一件事暂时不能运行                                 |<br>| 以上是基本的状态                |                                                              |<br>| 进程还能被细分为更多的状态,比如 |                                                              |<br>| 其他状态                        | 内容                                                         |<br>| –                              | –                                                           |<br>| 创建态                          | 进程正在被创建，操作系统为进程分配资源、初始化PCB            |<br>| 终止态                          | 进程正在从系统中被撤销，操作系统将会回收资源、撤销PCB        |<br>| 挂起态                          | 还可以细分为<strong>就绪挂起态</strong>和<strong>阻塞挂起态</strong>，是在内存不够的时候，被<strong>调度</strong>（后面会说）到<strong>外存</strong>（硬盘;这是和阻塞的最大区别）暂时保存的状态 |</p><hr><p><strong>状态转换</strong><br>还是比较好懂，大概内容如图所示<br><strong>三态四转换模型</strong><br><img src="https://img-blog.csdnimg.cn/f124ce79f2cc4245a91b912267b4d629.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>五态六转换模型</strong></p><p><img src="https://img-blog.csdnimg.cn/f7eba01b479b4f3eb3dc7b9af053809a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>七态十二转换模型</strong><br><img src="https://img-blog.csdnimg.cn/2edc211422384c1aa41561d59ac76c4b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>内存不够可以理解为内存中的就绪/阻塞队列满了，只能先放到外存</p><hr><p>五态转换详细过程的如下<br><img src="https://img-blog.csdnimg.cn/c70fe6f5db5c4ae98a410f717bfd5bb7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>但是上图也看出了一个问题：<br>就绪态的任务在CPU修改PCB状态为执行之后，进入执行态，执行态开始请求，进入阻塞态，请求完成，阻塞态回归到就绪态——问题就出现了，这个时候，PCB的状态依旧是执行！<br>为了解决这个问题，利用了<strong>原语</strong></p><hr><h3 id="原语控制进程"><a href="#原语控制进程" class="headerlink" title="原语控制进程"></a>原语控制进程</h3><p><strong>原语的实现</strong><br>具有原子性的操作，不允许中断<br>原语是通过<strong>关中断指令</strong>和<strong>开中断指令</strong>实现的:</p><blockquote><p>在原语代码执行前，先执行关中断指令，之后代码执行不会引起中断；</p></blockquote><blockquote><p> 在原语代码执行后，再执行开中断指令，此后都将执行中断处理；</p></blockquote><hr><p><strong>进程的创建</strong></p><p>有两种常见的进程创建方式：</p><p><strong>发生引起创建进程的事件</strong></p><blockquote><p>用户登录、应用请求、作业调度和提供服务等</p></blockquote><p><strong>执行创建原语</strong></p><blockquote><p>1.申请空白PCB<br>2.为新进程分配所需资源<br>3.初始化PCB<br>4.将PCB插入就绪队列</p></blockquote><hr><p><strong>进程的终止</strong></p><p>也有两种常见的进程终止方式：</p><p><strong>发生引起进程终止的事件</strong></p><blockquote><p>任务正常结束、异常结束或被外界干预</p></blockquote><p><strong>执行撤销原语</strong></p><blockquote><p>1.从PCB集合中找到终止进程的PCB<br>2.如果进程正在执行，则将其占有的CPU剥夺然后分配给其他进程<br>3.终止其所有子进程<br>4.将该进程拥有的所有资源归还给父进程或操作系统<br>5.删除其PCB</p></blockquote><p><strong>注意，撤销原语可以直接让进程变为终止态——无论该进程正处于何种状态</strong></p><hr><p><strong>进程的阻塞</strong></p><p>还是两种方式：</p><p><strong>发生引起阻塞进程的事件</strong></p><blockquote><p>需要等待 系统分配资源 或 其他与之合作的进程完成工作</p></blockquote><p><strong>执行阻塞原语</strong></p><blockquote><p>1.找到阻塞进程对应的PCB<br>2.保护进程运行环境，将PCB信息修改为阻塞态，暂停该进程<br>3.将PCB插入相应事件的等待队列</p></blockquote><hr><p><strong>进程的唤醒</strong></p><p>依旧是两种方式：</p><p><strong>发生引起唤醒进程的事件</strong></p><blockquote><p>等待结束</p></blockquote><p><strong>执行唤醒原语</strong></p><blockquote><p>1.在事件等待队列中找到PCB<br>2.将PCB从等待队列中移除<br>3.将PCB插入就绪队列，等待被调度</p></blockquote><p>阻塞和唤醒其实就是等待和等待结束的意思<br>另外，阻塞和唤醒一定成双成对出现</p><hr><p><strong>进程的切换</strong><br>还是两种：<br><strong>发生引起切换进程的事件</strong></p><blockquote><p>1.当前时间片用完<br>2.有更高优先级的进程到达<br>3.当前进程主动阻塞<br>4.当前进程终止</p></blockquote><p><strong>执行切换原语</strong></p><blockquote><p>1.将运行环境存入当前进程的PCB<br>2.该PCB移入相应的队列<br>3.选择另一个进程执行，并更新其PCB<br>4.根据PCB中信息恢复进程需要的运行环境</p></blockquote><hr><p>其实无论哪种原语，其作用无非以下三点：<br><strong>1.更新PCB信息</strong><br>    1.1所有进程控制原语一定会修改进程状态标志<br>    1.2剥夺当前进程的CPU使用权必然要保存其运行环境<br>    1.3某进程回复运行前必然要恢复其运行环境<br><strong>2.将PCB插入合适的队列</strong><br><strong>3.分配/回收资源</strong></p><hr><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>由于进程是分配系统资源的基本单位，所以各个进程的内存地址相互独立<br>进程通信即进程之间的信息交换，但是为了保证安全性，一个进程不能直接访问其他进程的地址空间，所以进程通信会通过以下方式实现</p><p><strong>方式1：共享存储</strong></p><p>开辟一个共享空间，用来进程间传递信息<br><img src="https://img-blog.csdnimg.cn/37558959115b4394bae6ceaaa630f66b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>进程对这个空间的访问必须是互斥的，这由操作系统提供的工具实现（同步互斥工具，如P/V操作）</p><p><strong>实现原理</strong><br>两种…..<br>| 类型         | 内容                                                         |<br>| ———— | ———————————————————— |<br>| 基于数据结构 | 低级通信方式，速度慢，限制多，每次只能传格式固定的某种数据结构，如长度为10的串 |<br>| 基于存储区   | 高级通信方式，速度快，在内存中开辟共享存储区，<strong>存放的位置由进程决定</strong> |</p><p><strong>方式2：管道通信</strong></p><p><strong>实现原理</strong></p><blockquote><p>“管道”指的是用于连接读写进程的一个共享文件，又叫pipe文件，其实就是在内存中开辟的一个大小固定的缓冲区</p></blockquote><p>tips：<br>1.管道只能采用<strong>半双工通信</strong>（可以正向传输也可以逆向传输，但是同一时间只能朝一个方向传输；双向同时通信则需要两个管道）</p><p>2.各个进程对管道的访问是互斥的（哪怕是同向也一样）</p><p>3.其中，数据以字符流的形式传输，读写操作是用write()和read()程序接口（系统调用）实现的。</p><p>4.管道没写满，就不允许读；如果没读空，就不允许写（会被阻塞）</p><p>5.数据一旦被读出，就从管道中清除，无法再次使用（这意味着最多一个读进程，否则可能出现读取错误）</p><hr><p><strong>方式3：消息传递</strong></p><blockquote><p>进程之间的数据交互以格式化的信息为单位<br>通过操作系统提供的<strong>发送消息/接受消息</strong>两个原语进行数据交换</p></blockquote><p>上述的<strong>“格式化的信息”</strong>指的是消息头+消息体<br>（类似于请求/响应的头/体）<br>| 名称   | 内容                                                   |<br>| —— | —————————————————— |<br>| 消息头 | 发送进程ID，接受进程ID，消息类型，消息长度等格式化信息 |<br>| 消息体 | 消息的内容等等                                         |</p><p><strong>实现原理</strong></p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>直接通信</td><td>消息会被直接挂到接受进程的缓冲队列上</td></tr><tr><td>间接通信</td><td>消息先发送到中间实体“信箱”，所以间接通信也称“信箱通信”（可以通过消息头的信息确定收发对象）</td></tr></tbody></table><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>背景</strong><br>上古之世，未有进程之说，企鹅和企鹅音乐竟然无法同时运作!<br>先贤鬼斧神工以创进程，自此以后，企鹅和企鹅音乐才得以“同时”运作…<br>再后来，随着科技发展，企鹅作为一个进程却可以同时进行文字传输，视频播放，文件传输等等操作<br>单个进程是如何做到同时进行多项任务的？</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>众所周知，传统的进程只能串行（顺序）执行一系列程序（传统进程是程序执行流的最小单位），无法达到“同时”的效果</p><p>所以引入了线程的概念：</p><blockquote><p>一个进程会包含多个线程，各个线程独立的、并发的运行，CPU轮流为每个线程服务。<br>这样一来，<strong>线程是程序执行流的基本单位</strong>，可以看做<strong>轻量级的进程</strong><br>和进程类似，拥有TCB（线程控制块）等</p></blockquote><p><strong>和子进程的区别</strong><br>1.线程是进程的一部分，一个没有线程的进程可以看做单线程<br>2.引入线程的概念后，<strong>进程是（除了CPU以外的）资源分配的基本单位，而线程是程序执行（调度）的基本单位。线程几乎没有系统资源。</strong><br>3.进程有独立的地址空间，而多个线程总是共享地址空间和公共变量</p><hr><p><strong>影响和意义</strong><br>1.同一个进程内的线程切换不需要切换进程环境，系统开销减小<br>2.线程可以并发，提高了并发度</p><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><p><strong>方式1:用户级线程</strong><br>User-Level Thread(ULT)<br><img src="https://img-blog.csdnimg.cn/4d789aab865e4a928ac9d43f3b56a2b1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>用户可以感知到多个线程，但是操作系统内核只能感知到进程</p></blockquote><p>tips：<br>用户级线程是由 应用程序 通过 线程库 实现的<br>所有的<strong>线程管理都由应用程序负责</strong><br>用户级线程中，线程切换可以在用户态下完成，无需操作系统干预</p><hr><p><strong>方式2：内核级线程（内核支持线程）</strong><br>Kernel-Level Thread，KLT<br><img src="https://img-blog.csdnimg.cn/33f7f9aaa9a54209b3b975f04b42fd73.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>即操作系统内核可以感知到的线程，线程切换需要在核心态下进行</p></blockquote><hr><p><strong>方式3：组合线程</strong><br><img src="https://img-blog.csdnimg.cn/072a015c0c2d45d682e77558479d4638.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>将ULT和KLT混合使用（当然并不是每个操作系统都支持这么做)</p><blockquote><p>将n个用户级线程映射到m个内核级线程上（n &gt;= m)</p></blockquote><p>这里，分配CPU资源的单位是内核级线程（毕竟内核只看得见它们啊..）<br>如上图所示的情况，哪怕是4核CPU，也只能并行两个用户级线程</p><p><strong>混合线程的思路，引出了多线程模型</strong></p><hr><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p><strong>模型1：多对一模型</strong><br><img src="https://img-blog.csdnimg.cn/e64a39c14c03415483c0f89251f08117.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>概述</strong><br>多个用户级线程映射到一个内核级线程</p><p><strong>优点</strong><br>用户级线程的切换可以在用户态完成，无需切换核心态，开销小，效率高</p><p><strong>缺点</strong><br>当一个（内核级）线程被阻塞后，整个进程都会被阻塞，并发度低；<br>并且，多个线程不可以在多核CPU上并行。</p><hr><p><strong>模型2：一对一模型</strong><br><img src="https://img-blog.csdnimg.cn/fdeb388e1fd0482b91c05f1afb94ddf0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>概述</strong><br>一个用户级线程映射到一个内核级线程</p><p><strong>优点</strong><br>一个（内核级）线程阻塞，不影响线程，并发性强；<br>可以在多核CPU上并行。</p><p><strong>缺点</strong><br>一个用户进程会占用多个内核级线程，并且切换操作需要在核心态完成，<br>线程的管理成本高，开销大。</p><hr><p><strong>模型3：多对多模型</strong><br><img src="https://img-blog.csdnimg.cn/2de20aad87014cd29637bf096230edb4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>正是之前提到的组合模式的图示</p><p><strong>概述</strong><br>n个用户级线程映射到m个内核级线程（n&gt;=m)</p><p><strong>优/缺点</strong><br>是模型1和模型2的中和，并发度居中，开销和管理成本也居中</p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><blockquote><p>在多道程序系统中，进程的数量总是多于CPU个数，不可能并行所有进程。<br>所以需要CPU调度，从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行</p></blockquote><h3 id="三层调度"><a href="#三层调度" class="headerlink" title="三层调度"></a>三层调度</h3><p> <strong>高级调度（作业调度）</strong></p><blockquote><p>按照一定原则，从后备队列中的作业中筛选一个或多个作业，为之分配资源、建立PCB，使它们获得竞争处理机的权力</p></blockquote><p>后备队列是因为有时候用户提交的作业过大，无法一次性全部放入内存，所以先放到处于外存的后备队列，等操作系统调度安排</p><blockquote><p>高级调度是外存（辅存，硬盘）与内存之间的调度，每个作业只调入一次（此时为之建立PCB），调出一次（作业结束菜调出）<br>主要是解决调入的问题，由操作系统决定何时调入</p></blockquote><p>tips:<br><strong>作业</strong></p><blockquote><p>是一个比程序/进程更加宽泛的概念，不仅包含通常的程序和数据，还配有一份程序说明书，系统根据说明书对进程进行控制</p></blockquote><hr><p><strong>中级调度（内存调度）</strong></p><blockquote><p>把暂时不能运行的进程调度到外存等待，直到其重新具备了运行条件才再次调入内存</p></blockquote><p>与高级调度的区别是这个可以多次调入调出，把进程放到外存等待（此时状态变为<strong>挂起</strong>，PCB放到内存中的挂起队列），给其他进程空间</p><p>这样做<strong>提高了内存的利用率和系统吞吐量</strong></p><hr><p><strong>低级调度（进程调度）</strong></p><blockquote><p>按照某种方法和策略，从就绪队列中选取一个进程，将处理机分配给它<br><strong>进程调度是操作系统中最基本的一种调度</strong>，频率较高，几十毫秒便会执行一次</p></blockquote><hr><p><strong>总结：</strong><br><img src="https://img-blog.csdnimg.cn/973a2560c87c461e8a582b2b01e045ae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="进程调度时机、方式、切换与过程"><a href="#进程调度时机、方式、切换与过程" class="headerlink" title="进程调度时机、方式、切换与过程"></a>进程调度时机、方式、切换与过程</h3><p><strong>时机</strong></p><p>进程调度即低级调度<br><strong>什么时候需要进程调度</strong><br>1.当前运行的进程<strong>主动</strong>放弃处理机</p><blockquote><p>进程正常终止、运行过程中发生异常而终止、进程主动请求（阻塞）</p></blockquote><p>2.当前运行的进程被<strong>动放</strong>弃处理机</p><blockquote><p>该进程的时间片用完、由优先级更高的进程进入就绪队列、有更紧急事件需要处理</p></blockquote><hr><p><strong>什么时候不能进程进程调度</strong></p><p>（对于大部分操作系统而言）</p><blockquote><p>1.处理中断的过程中（据说是因为中断处理很复杂，与硬件关联大…阿巴阿巴）<br>2.进程处于操作<strong>系统内核程序临界区</strong>（但是在普通临界区是可以进行的）<br>3.在原子操作中（比如原语），不可中断</p></blockquote><hr><p><strong>方式</strong></p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>非剥夺调度方式（非抢占方式）</td><td><strong>只允许进程主动放弃处理机</strong>。就算有优先级更高的任务到达，当前任务依旧会继续执行，知道该进程终止或者主动发出申请进入阻塞态</td></tr><tr><td>剥夺调度方式（抢占方式）</td><td>当一个进程在处理机上执行时，有优先级更高的进程到达，当前进程立刻暂停，处理机将被分配给更优先级更高的进程</td></tr></tbody></table><p><strong>优劣</strong><br><strong>非剥夺调度方式（非抢占方式）</strong>：<br>实现简单，系统开销小<br>但是无法实现紧急任务<br>适合早期的批处理系统</p><p><strong>剥夺调度方式（抢占方式）</strong>：<br>能优先处理紧急任务，也可以以时间片轮流执行<br>适合分时操作系统、实时操作系统</p><hr><p><strong>切换与过程</strong></p><p><strong>狭义的进程调度 与 进程切换 的区别</strong></p><blockquote><p>狭义的进程调度指的是，从就绪队列中选中一个要运行的进程这一行为。</p></blockquote><blockquote><p>进程切换是指，一个进程让出处理机，由另一个进程占用处理机的过程。</p><p>进程切换主要完成了<br>1.保存原来运行的进程中数据（保存到PCB）<br>2.恢复新的进程的数据（从PCB读取）</p></blockquote><p>而<strong>广义的进程调度</strong>包含 选择一个进程 和 进程切换 两个步骤（这也是我们通常所说的进程调度）</p><p>tips:<br>进程切换是有代价的，需要消耗时间，过于频繁必将拉低效率</p><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><p><strong>CPU利用率</strong></p><blockquote><p>即 忙碌时间/总时间</p></blockquote><p>如某个作业需要在CPU上运行5s，再用打印机输出5s，之后再执行5s，那么利用率就是10/15<br>（这里打印机的利用率是5/15）</p><hr><p><strong>系统吞吐量</strong></p><blockquote><p>即 完成的作业量/总时间</p></blockquote><p>比如完成10道作业，花费100秒，则系统吞吐量为<br>10/100 = 0.1 </p><hr><p><strong>周转时间</strong></p><blockquote><p>即 作业提交到作业完成的用时<br>（站在用户的视角看待）</p></blockquote><p>tip：<br>实际运行时间是指<strong>占用处理机的时间</strong>（<strong>不包括输入输出的时间</strong>）</p><p> <strong>带权周转时间</strong></p><blockquote><p>（作业完成时间  -  作业提交时间）/  作业实际运行时间<br>即 <strong>周转时间 / 作业实际运行时间</strong></p></blockquote><p>对于周转事假相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，<strong>带权周转时间更小，用户满意度更高</strong></p><p>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高</p><hr><p><strong>等待时间</strong></p><blockquote><p>进程/作业处于等待处理机状态时间之和。</p></blockquote><p>对于进程来说，等待时间是指进程建立之后等待被服务的时间之和，但是等待I/O的期间也算是被服务，所以不计入等待时间</p><p>对于作业来说，还要加上作业在外存后备队列的等待时间</p><hr><p><strong>响应时间</strong></p><blockquote><p>指从用户提交请求到<strong>首次</strong>产生响应所用的时间</p></blockquote><hr><p><strong>响应比</strong></p><blockquote><p>（等待时间+要求服务时间） /  要求服务时间</p></blockquote><p><strong>举个例子</strong></p><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>7</td></tr><tr><td>P2</td><td>2</td><td>4</td></tr><tr><td>0时刻：只有P1在就绪队列，P1占用处理机</td><td></td><td></td></tr><tr><td>7时刻：P1主动放弃处理机，就绪队列中有P2，其响应比是(5 + 4)/4=2.25</td><td></td><td></td></tr></tbody></table><hr><h3 id="几种调度算法"><a href="#几种调度算法" class="headerlink" title="几种调度算法"></a>几种调度算法</h3><p>前置概念：<strong>饥饿</strong></p><blockquote><p>作业/进程长期得不到服务（意思是可能一直被插队而无法得到处理，不是说需要等待的时间较长）</p></blockquote><p><strong>先来先服务FCFS</strong></p><blockquote><p>First Come First Serve，先来先服务</p></blockquote><table><thead><tr><th>属性</th><th>内容</th></tr></thead><tbody><tr><td>思想</td><td>公平（分先来后到）</td></tr><tr><td>规则</td><td>按照作业/进程的先后顺序进行服务</td></tr><tr><td>用于作业/进程调度</td><td>用于作业调度：考虑哪个作业先到达后备队列；用于进程调度：考虑哪个进程先到达就绪队列</td></tr><tr><td>是否为抢占</td><td>非抢占</td></tr><tr><td>优缺点</td><td>优点：公平、简单；缺点：不利于排在长作业/进程后的短作业/进程用户体验 和 长作业/进程的运行</td></tr><tr><td>是否会产生饥饿现象</td><td><strong>不会</strong></td></tr></tbody></table><hr><p><strong>短作业优先SJF</strong></p><blockquote><p>Shortest Job First，最先服务（服务时间）最短的<br>用于进程就是Shortest Process First</p></blockquote><table><thead><tr><th>属性</th><th>内容</th></tr></thead><tbody><tr><td>思想</td><td>追求最少的平均等待时间、平均周转时间、平均带权周转时间</td></tr><tr><td>规则</td><td><strong>从已经到达的作业/进程中，选择服务时间最短的优先服务</strong></td></tr><tr><td>用于作业/进程调度</td><td>用于作业调度：考虑哪个作业先到达后备队列；用于进程调度：考虑哪个进程先到达就绪队列</td></tr><tr><td>是否为抢占</td><td><strong>非抢占</strong></td></tr><tr><td>优缺点</td><td>优点：“最短的”（不严谨地说）平均等待/周转时间；缺点：不利于厂作业，可能导致饥饿，难以做到真正的短作业优先</td></tr><tr><td>是否会产生饥饿现象</td><td><strong>会</strong></td></tr></tbody></table><hr><p><strong>最短剩余时间优先SRTN</strong></p><blockquote><p>Shortest Remaining Time Next，是短作业优先算法SJF的抢占版本</p></blockquote><hr><p><strong>高响应比优先HRRN</strong></p><table><thead><tr><th>属性</th><th>内容</th></tr></thead><tbody><tr><td>思想</td><td>综合考量作业进程的等待时间和要求服务的时间</td></tr><tr><td>规则</td><td>每次调度优先考虑响应比最高的</td></tr><tr><td>用于作业/进程调度</td><td>同上</td></tr><tr><td>是否为抢占</td><td>非抢占</td></tr><tr><td>优缺点</td><td>优点：综合考量了….；缺点：（不明显）</td></tr><tr><td>是否会产生饥饿现象</td><td><strong>不会（随着等待时间变长，响应比也会越来越大，被调用的几率就越来越大）</strong></td></tr></tbody></table><hr><p><strong>时间片轮转RR</strong></p><blockquote><p>Round-Robin<br>需要注意，如果一个任务剩余的时间小于一个时间片，那么它会在完成时主动放弃处理机，然后发生调度，其他就绪态的任务开始执行<br>这种调度方式常用于分时系统</p></blockquote><table><thead><tr><th>属性</th><th>内容</th></tr></thead><tbody><tr><td>思想</td><td>公平</td></tr><tr><td>规则</td><td>轮流执行一个时间片</td></tr><tr><td>用于作业/进程调度</td><td>用于进程调度（只有作业放入内存建立相应的进程后才能被分配处理机时间片）</td></tr><tr><td>是否为抢占</td><td>抢占（原理是中断）</td></tr><tr><td>优缺点</td><td>优点：响应快、公平；缺点：高频的进程切换开销太大、公平</td></tr><tr><td>是否会产生饥饿现象</td><td><strong>不会</strong></td></tr></tbody></table><hr><p><strong>优先级调度</strong></p><blockquote><p>优先级越高越先执行（注意优先级和优先数不一样，优先数还得看题目的定义）</p></blockquote><p>tips:</p><blockquote><p>1.优先级也有静态和动态两种，顾名思义<br>2.系统进程&gt;用户进程，前台进程&gt;后台进程<br>3.操作系统更偏好（优先处理）I/O型进程（也叫I/O繁忙型进程，与I/O相对的是计算型进程，也叫CPU繁忙型进程)。这样设计是因为I/O操作可以和CPU并行工作，如果让I/O繁忙的进程优先运行的话，那么就能让I/O设备尽早投入工作，资源利用率，系统吞吐量都会得到提升<br>| 属性               | 内容                                                     |<br>| —————— | ——————————————————– |<br>| 思想               | 轻重缓急                                                 |<br>| 规则               | 先执行优先级高的                                         |<br>| 用于作业/进程调度  | 用于进程和作业调度，甚至还会用于之后会提到的I/O调度      |<br>| 是否为抢占         | 两种都有                                                 |<br>| 优缺点             | 优点：能分清轻重缓急；缺点：可能会有高频的切换和饥饿现象 |<br>| 是否会产生饥饿现象 | 会                                                       |</p></blockquote><hr><p><strong>那么问题来了</strong><br>这么多算法，各有千秋但是也各有缺点，所以，能不能有一个集大成者出现呢？<br><strong>多级反馈队列调度算法</strong><br>| 属性               | 内容                                                         |<br>| —————— | ———————————————————— |<br>| 思想               | 其他算法的综合                                               |<br>| 规则               | 1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大 <br>2.新进程到达时进入第一级队列，按照FCFS等待分配时间片；若时间片用完进程还未结束，那么进程进入下一级队列队尾（如果此时已经是最低一级的队列，那么重新放到本队列末尾)<br>3.只有第K级队列为空时，才会为K+1级队列的进程分配时间片 |<br>| 用于作业/进程调度  | 用于进程                                                     |<br>| 是否为抢占         | 抢占                                                         |<br>| 优缺点             | 优点：综合性强，适应多种情况 缺点：可能导致饥饿              |<br>| 是否会产生饥饿现象 | 会（短进程不断，并且在一个时间片内可以被处理完，那么已经被降级的进程就得不到处理） |</p><hr><h2 id="进程同步-与-进程互斥"><a href="#进程同步-与-进程互斥" class="headerlink" title="进程同步 与 进程互斥"></a>进程同步 与 进程互斥</h2><p><strong>进程同步</strong><br>众所周知，进程具有异步性。异步性是指，各并发执行的进程以自己独立的、不可预知的速度向前推进。</p><p>但是在读写进程的时候，写 一定要发生在 读 的前面，这种情况就需要<strong>解决异步性带来的问题</strong>——这便是<strong>进程同步</strong>要讨论的</p><blockquote><p>进程同步 也叫 <strong>直接制约关系</strong>，它是为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p></blockquote><p><strong>进程互斥</strong><br>一个资源在同一时间内只能被一个进程使用<br>对临界区的互斥访问，从逻辑上可以分为以下四个部分：</p><blockquote><p>do{<br>    entry section;            //进入区:负责检测<br>critical section;        //临界区<br>exit section;                //退出区<br>    remainder section;  //剩余区<br>}</p></blockquote><table><thead><tr><th>区域</th><th>内容</th></tr></thead><tbody><tr><td>entry section进入区</td><td>负责检查是否可以进入临界区，若可进入，则应设置正在访问临界资源的标指（可以看作<strong>上锁</strong>），阻止其他进程进入临界区</td></tr><tr><td>critical section临界区</td><td>也叫临界段。就是访问临界资源的那段代码</td></tr><tr><td>exit section退出区</td><td>“解锁”</td></tr><tr><td>remainder section剩余区</td><td>做一些其他处理</td></tr></tbody></table><p>tips:<br><strong>进入区</strong>和<strong>退出区</strong>是 <strong>负责实现互斥</strong> 的代码段</p><p>遵循了四个原则：<br>| 原则     | 内容                                                         |<br>| ——– | ———————————————————— |<br>| 空闲让进 | 临界区空闲时，允许 一个请求进入临界区的进程 立刻 进入临界区  |<br>| 忙则等待 | 当已经有进程进入临界区的时候，其他试图进入这里的进程必须等待 |<br>| 有限等待 | 等待时间不能是无限的（不能饥饿）                             |<br>| 让权等待 | 当进程不能进入临界区时，应该立即释放处理机，防止进程忙等待   |</p><hr><h3 id="软件实现方法"><a href="#软件实现方法" class="headerlink" title="软件实现方法"></a>软件实现方法</h3><p><strong>1.单标志法</strong></p><blockquote><p>两个进程在访问完临界区之后，把临界区的权限交给另一个进程。也就是<strong>每个进程进入临界区的权限只能被另一个进程授予</strong><br><strong>违背了空闲让进原则</strong><br><img src="https://img-blog.csdnimg.cn/e74855743ed94d5888de6c1a54b69c94.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></blockquote><hr><p><strong>2.双标志先检查法</strong></p><blockquote><p>设置一个布尔型数组（习惯性叫flag)，数组中每个元素用来标记进程想进入临界区的意愿。比如flag[0] = true表示0号元素想要进入，每个进程进入临界区之前都要检查当前有没有别的进程想要进入临界区。<br>如果没有，那么就把自身对应的表示设为true</p></blockquote><p><img src="https://img-blog.csdnimg.cn/08b8df5ca4a349d68037e0071d5908e4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>上图的问题是，两者同时进入了临界区</p><hr><p><strong>3.双标志后检查法</strong></p><blockquote><p>双标志先检查法的改版。前一个算法（先检查）的问题是，先“检查”后“上锁”，但是这两个操作无法一气呵成，因此导致了两个进程同时进入临界区。<br>所以机智的人类就提出了先上锁后检查的操作<br><img src="https://img-blog.csdnimg.cn/c86ea433dd7049619ab0e84fe5571cae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></blockquote><p>然后又发现，这不是会导致两个都进不去吗（注意<strong>这是饥饿，不是死锁</strong>）</p><hr><p><strong>4.peterson算法</strong></p><blockquote><p>在双标志检查法的基础上，如果出现了几个进程争着进入临界区的情况，那么让进程变得“谦让”<br>方法是，依旧设置一个flag数组表示自身的意愿，但是额外地增加一个turn值表示愿意谦让哪个进程(比如turn=1，就是在发生冲突时，愿意把机会让给1号进程)</p></blockquote><p><img src="https://img-blog.csdnimg.cn/75720710fb4d48998fcb1688e65970fc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果按①⑥②⑦⑧的顺序执行<br>P0谦让，然后P1不甘落后又谦让，并且执行⑧循环等待，所以最终P0先使用</p><hr><h3 id="硬件实现方法"><a href="#硬件实现方法" class="headerlink" title="硬件实现方法"></a>硬件实现方法</h3><p><strong>1.中断屏蔽法</strong></p><blockquote><p>利用 开/关中断指令 实现（和原语一样，在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个进程同时访问临界区的情况）</p></blockquote><p>优点：简单高效<br>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令，只能运行在内核态，这组指令如果能让用户随意使用会很危险)</p><hr><p><strong>2.TestAndSet指令</strong></p><blockquote><p>简称TS指令，也有叫做TestAndSetLock指令的，简称TSL指令<br>他们是通过硬件控制做到的，暂不细究</p></blockquote><p>优点：实现简单；适用于多处理机环境；<br>缺点：不满足“让权等待”</p><hr><p><strong>Swap指令</strong></p><blockquote><p>也叫Exchange简称XCHG指令，同上，暂不细究</p></blockquote><p>优点：实现简单；适用于多处理机环境；<br>缺点：不满足“让权等待”</p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><blockquote><p>分为两大类，整型信号量 和 记录型信号量<br>主要思想是，设置一个变量（即信号量），可以用这个量表示系统中某种资源的数量<br>常用到一对原语：wait(S)和signal(S)，分别简称为P、V（来自荷兰语），操作其中S是信号量</p></blockquote><p><strong>整形信号量</strong></p><blockquote><p>只支持三种操作：初始化、p、v</p></blockquote><p><img src="https://img-blog.csdnimg.cn/0c897e1d1a5b44529e10e61d1c55f455.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>注意这里的while只是为了方便理解，实际上当资源不够的时候，进程会被挂起而中断</strong></p><p>优点：检查和上锁一气呵成，避免了并发异步导致的问题<br>缺点：不满足让权等待原则，会发生忙等</p><hr><p><strong>记录型信号量</strong></p><blockquote><p>即在整型信号量的基础上，用记录型数据结构表示的信号量</p></blockquote><p><img src="https://img-blog.csdnimg.cn/1d5c5b1a820744778b95e5020311eb1b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>至于signal那里，<br>由于wait保证了，在没资源的情况下，进程会进入阻塞队列（block），<br>所以<br><strong>value为正数的时候表示空闲资源数量，<br>为负数的时候其绝对值表示阻塞队列中进程的数量</strong></p><hr><p><strong>使用信号量实现进程互斥</strong><br><img src="https://img-blog.csdnimg.cn/c222b06ad5564f0e8bd3d00b39f363f2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><p><strong>使用信号量实现进程同步</strong><br><img src="https://img-blog.csdnimg.cn/b7331da4c8ca4aaf868323600600d35c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><p><strong>信号量机制实现前驱关系</strong><br><img src="https://img-blog.csdnimg.cn/458be36075aa454c82418fa33726841f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><p>tip:缓冲区等临界资源为互斥访问，不为临界资源可以不用互斥</p><p><strong>生产者消费者问题</strong></p><blockquote><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一组数据放入缓冲区，消费者每次从缓冲区拿出一组数据使用。<br>生产者消费者共用一个初始为空、大小为n的缓冲区。</p></blockquote><p>只有当缓冲区不满的时候，生产者才能生产，否则进入阻塞直到收到缓冲区不满的信号才被唤醒，重新进入就绪队列；<br>消费者只有当缓冲区不为空的时候，才能拿出使用，否则阻塞知道收到缓冲区不为空的信号才被唤醒，重新进入就绪队列；</p><p>规则很简单，但是存在问题：<br>如果并发（或者并行）环境下，有多个生产者，它们几乎同时检测了缓冲区，都发现还没满，结果两个都试图写入，结果其中一个生产者写入之后就已经满了，其他的生产者就写入失败发生写入错误</p><p>解决这个问题之前，我们先要<strong>分析</strong></p><blockquote><p>1.缓冲区是临界资源，需要<strong>互斥</strong>访问<br>2.缓冲区满的时候，消费者先取，生产者后放，是一种<strong>同步</strong>关系；缓冲区为空的情况同理</p></blockquote><p><img src="https://img-blog.csdnimg.cn/8c64f235e3314b61b9c1cde460d920d3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>但是如果我们这么执行呢？<br><img src="https://img-blog.csdnimg.cn/08e99cca3c4a48db85b7312af2b94de3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这就会引发死锁</p><hr><p><strong>多生产者-多消费者问题</strong><br>是对上一个问题的拓展<br><img src="https://img-blog.csdnimg.cn/7b88b9a3118a452287d8810fe06be3d5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>我们再来分析一手：</p><blockquote><p>互斥（其实就是先V后P）：<br>1.盘子相当于缓冲区，是临界资源，需要互斥访问<br>同步：<br>2.父亲放苹果后，女儿才能取苹果，是同步关系。母亲和儿子同理。<br>3.只有盘子为空，父母才能放，也是同步关系。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/3166525c3a064162bfeedab2f3ace993.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果不设互斥信号量mutex会怎么样？</p><blockquote><p>不会怎么样。因为缓冲区大小为1，并且存在三个同步信号量，这三个同步信号量中同一时刻最多有一个为1。因此在任何时刻，最多只有一个进程的P操作<strong>不会</strong>被阻塞，从而顺利进入临界区<br>(但是还是设置一个吧，保险</p></blockquote><p><strong>分析技巧</strong><br><img src="https://img-blog.csdnimg.cn/f6a6915aa72842638bb172680c562eb1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>其实是站在缓冲区的角度看问题，而不是站在进程上看问题</p><hr><p><strong>吸烟者（单生产者-多消费者）问题</strong><br><img src="https://img-blog.csdnimg.cn/f132573e2d6149d3babb6bf3af8de72d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>再来分析一手：</p><blockquote><p>这里桌子是缓冲区，但是注意容量应该是1！桌上摆了两个东西但是不能看作是2，应该 把两个东西看做捆绑出现的一种组合！<br>所以有三种组合：纸+胶水、烟草+胶水、烟草+纸<br>互斥：<br>1.桌上只能摆放一种组合，需要互斥访问<br>同步：<br>1.桌上有组合一，那么第一个抽烟者取走<br>2.桌上有组合二，那么第二个抽烟者取走<br>3.桌上有组合三，那么第三个抽烟者取走<br>4.抽烟完毕，供应者提供下一组材料<br>另外，还需要设置一个变量来使得三个抽烟者轮流抽烟（如果是随机给材料的情况那么就不用了）<br><img src="https://img-blog.csdnimg.cn/419f972cd19f4e458d3ee9cae0f72562.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>伪代码如下（建议把P（finish）放到前面去，这样更符合表达）<br><img src="https://img-blog.csdnimg.cn/1567e0f45e6545f7a9758437d3b1ad86.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></blockquote><hr><p><strong>读写（带计数器的互斥）问题</strong><br><img src="https://img-blog.csdnimg.cn/37fb365530be4d979330926870c37547.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>这个问题我也深有体会，在CSDN写博客的时候，如果对同一个文字打开多个编辑窗口，分别写入不同的内容发布，最后以后者的内容为最终内容。</p><p>分析一手：</p><blockquote><p>由于这里出现了两种类型的进程，所以不能够再从缓冲区出发了<br>互斥：<br>1.写进程和写进程互斥<br>2.写进程和读进程互斥</p></blockquote><p><strong>初步设想</strong><br><img src="https://img-blog.csdnimg.cn/f0c564bdb77e4ac29c6db3407829c7c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"> 由于会出现无法<strong>一气呵成</strong>的情况，count还没自增就一起进去了，所以我们发现读进程之间还是得互斥的来</p><blockquote><p>（3.读进程也得先后读取，主要是先后上锁）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/c61c864004444faaad7d02e12ecc0772.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p> 但是我们还忽略了一个问题就是，写进程优先级比读进程高，那么从实际角度来说，应该是内容更新更为重要，而这种可能导致写进程<strong>饥饿（因为最后一个读进程负责解锁，所以读进程可以一直插队到写进程前)的算法</strong>不太好，所以我们进一步优化为：</p><hr><p><strong>哲学家进餐问题</strong><br><img src="https://img-blog.csdnimg.cn/f7de3e41beae4dd79345311ce27ba10f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>上述伪代码的问题是，由于异步和并发，可能出现，每个人依次拿起自己左边的筷子，然后就出现<strong>死锁</strong>，所有人都没法进行下一步于是全体尬住乐<br>所以我们还得先分析一手：</p><p><img src="https://img-blog.csdnimg.cn/ef20f104f1b2433dae0d89b50be4f980.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>互斥：<br>1.每只筷子都是临界资源，要互斥访问<br>同步：<br>1.需要组织一定的先后顺序，比如设置一个初值为4的同步信号量 或者 让每个人互斥地取筷子</p></blockquote><p><img src="https://img-blog.csdnimg.cn/4bc9cb9c203b4e5e8581d5603d85d8d9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><blockquote><p>在管程出现之前，使用信号量机制较为普遍，但是这样很容易出错<br>管程是一种特殊的软件模块，属于一种高级的同步机制，由<br>1.共享数据结构<br>2.初始化数据结构的语句<br>3.一组用来访问数据结构的过程（函数）</p></blockquote><p>如果感觉不容易理解，那么可以把管程看做是PV操作的封装，这样一来直接调用就不容易出错</p><p><strong>管程的基本特征</strong></p><blockquote><p>1.外部进程/线程只能通过管程提供的特定入口才能访问共享数据<br>2.每次仅允许一个进程在管程内执行某个内部过程</p></blockquote><p><strong>补充</strong></p><blockquote><p>各个进程必须互斥访问管程的特性，是由编译器实现的<br>可以在管程设计条件变量及等待/环形操作来解决同步问题</p></blockquote><hr><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><blockquote><p>并发环境下，各进程竞争资源而造成的一种互相等待其他进程占有的资源，导致各个进程都阻塞、都无法进一步推进的现象</p><p><strong>死锁、饥饿、死循环的区别</strong><br>先来看看各个名词的定义<br>| 名称   | 定义                                                         |<br>| —— | ———————————————————— |<br>| 死锁   | 各个进程互相等待对方手里的资源，导致各个进程阻塞、都无法推进 |<br>| 饥饿   | 由于长期得不到想要的资源，某个进程无法向前推进               |<br>| 死循环 | 某个进程一直执行，没有跳出某个循环（有时是bug，有时是有意为之） |</p></blockquote><p>再来分析一下区别<br>| 名称   | 区别（特点）                                                 |<br>| —— | ———————————————————— |<br>| 死锁   | 1.两个或者两个以上的进程<br>2.一定处于阻塞态                 |<br>| 饥饿   | 1.不限数目<br>2.可能是 阻塞态 或 就绪态                      |<br>| 死循环 | 1.不限数目<br>2.前两个是管理者（OS）的问题，死循环是被管理者的逻辑问题引发的（除非有意为之）<br>3.是运行态 |</p><hr><h3 id="死锁的发生"><a href="#死锁的发生" class="headerlink" title="死锁的发生"></a>死锁的发生</h3><p><strong>死锁的四个必要条件</strong><br>死锁发生必须<strong>同时满足</strong>四个条件：<br>| 条件       | 内容                                               |<br>| ———- | ————————————————– |<br>| 互斥条件   | 对必须互斥使用的资源的争抢会导致死锁               |<br>| 不剥夺条件 | 进程保持的资源只能主动释放，不能由其他进程强行夺走 |<br>| 请求和保持 | 保持某些资源不放的同时，请求别的资源               |<br>| 循环等待   | 存在进程资源的循环等待链                           |</p><p>这里需要注意</p><blockquote><p>死锁一定有循环等待，但是循环等待未必是死锁</p></blockquote><p>即 <strong>循环等待是死锁的必要不充分条件</strong><br>如果同类资源数大于1，即使循环等待，也未必死锁；<br>但是<strong>如果系统中每类资源都只有一个，那么循环等待就是死锁的充分必要条件了</strong></p><hr><p><strong>死锁发生的时候</strong></p><blockquote><p>概括就是<strong>资源分配不合理时就可能导致死锁</strong>，主要是以下三种情况：<br>1.对系统资源的竞争<br>2.进程推进顺序非法<br>3.信号量使用不当</p></blockquote><hr><h3 id="静态策略：死锁的预防"><a href="#静态策略：死锁的预防" class="headerlink" title="静态策略：死锁的预防"></a>静态策略：死锁的预防</h3><blockquote><p>核心思想是<strong>破坏</strong>死锁产生的四个必要<strong>条件</strong>中的一个或者几个</p></blockquote><p><strong>破坏互斥条件</strong></p><blockquote><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：<strong>SPOOLing技术</strong>。</p><p>SPOOLing技术可以把独占设备<strong>在逻辑上改造为共享设备</strong><br>这里由于涉及的硬件知识过多，所以我们不用深究该技术原理，只需要明白其过程：<br>比如进程1和进程2同时访问打印机，在使用SPOOLing之前会发生阻塞；使用该技术之后，宏观上看就不会阻塞，两个请求被“同时”接受了（或许是类似并发的技术吧）</p></blockquote><p><strong>缺点</strong></p><blockquote><p>1.并不是所有资源都能被改造为共享资源。<br>2.并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</p></blockquote><hr><p><strong>破坏不剥夺条件</strong></p><blockquote><p>我们有几种方案可供选择<br><strong>方案一</strong><br>当某个进程请求新的资源得不到满足，那<strong>使它立即释放保持的资源</strong>，待以后需要时再重新申请。<br><strong>方案二</strong><br>大概某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般要考虑各个进程的优先级。（比如剥夺调度方式，就是将处理及资源强行剥夺给优先级更高的进程使用）</p></blockquote><p><strong>缺点</strong></p><blockquote><p>1.实现起来比较复杂<br>2.释放已经获得的资源可能导致前一阶段的工作失效。因此这种方法一般只适用于容易保存和恢复的资源，比如CPU<br>3.反复地申请和释放资源会增加系统开销，降低系统吞吐量。<br>4.如果采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就需要放弃，以后再重新申请。如果一直发生这种情况，就会发生进程饥饿。</p></blockquote><p>嘶。看完第4点才意识到，原来饥饿中提到的“得不到处理”是指处理完毕！</p><hr><p><strong>破坏请求和保持</strong></p><blockquote><p>采用<strong>静态分配法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它资源未满足之前不开始运行。一旦请求完毕，这些资源一直归它所有，那么它就不会再请求资源，也就不会发生死锁。</p></blockquote><p>如果需要的资源都有，那它不争不抢（感觉也破坏了互斥条件），当然不会死锁呀~</p><p><strong>缺点</strong></p><blockquote><p>虽然简单，但是也有很明显的缺点呀：<br>1.如果整个运行期间都一直保持所有资源，就会造成严重的资源浪费而且利用率可能很低<br>2.可能导致其他进程饥饿<br>（比如有A类进程需要资源1，B类进程需要资源2，C类进程需要资源1和资源2。如果由源源不断的A或B进程，那么C就会饥饿）</p></blockquote><hr><p><strong>破坏循环等待</strong><br>说实话这个看上去很简单，但是我还是看得有点懵…</p><blockquote><p>采用<strong>顺序资源分配法</strong>，首先给系统资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完毕</p><p><strong>原理</strong><br>一个进程只有已经占有小编号的资源时，才有资格申请更大编号的资源。<br>按照这种规则，已经持有大编号的进程不可能逆向地申请小编号的资源，从而就不会产生循环等待现象。（懵逼，这说的啥看不懂啊(＃°Д°)）</p></blockquote><p><strong>缺点</strong></p><blockquote><p>1.不方便增加新的设备，因为可能需要重新分配所有编号<br>2.一个进程实际使用资源的顺序可能和编号递增顺序不一致，这样会导致资源浪费<br>3.必须按照规定次序申请资源，用户编程麻烦（(＠_＠;)这又是为啥啊）</p></blockquote><hr><h3 id="动态策略：死锁的避免"><a href="#动态策略：死锁的避免" class="headerlink" title="动态策略：死锁的避免"></a>动态策略：死锁的避免</h3><blockquote><p>用某种方法防止系统进入不安全的状态，比如<strong>银行家算法</strong></p></blockquote><p><strong>安全序列</strong><br>先看图<br><img src="https://img-blog.csdnimg.cn/38afac5b2919437f8e19e0caa96e9d75.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/21ad05f964e14c249e307ac02c5c1eab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>提炼一下：</p><blockquote><p><strong>安全序列</strong><br>如果按照这种序列分配资源，那么每个进程都能顺利完成。安全序列可能有多个<br><strong>不安全状态</strong><br>如果没有任何安全序列，那么就进入不安全状态。不安全状态可能会因为进程资源的提前归还，而重新进入安全状态<br>(死锁一定发生在不安全状态，但是不安全状态不一定死锁)<br><strong>安全状态</strong><br>在安全状态下<strong>一定不会发生死锁</strong></p></blockquote><p>上述内容可以得出<br><strong>银行家算法</strong><br>没错，这个算法又是DJ老哥提出的，一开始真的是为了解决银行贷款时避免资金不够的情况。</p><blockquote><p>在资源分配之前，预先判断这次分配是否会导致系统进入不安全状态，以此来决定是否分执行这次分配</p></blockquote><p><img src="https://img-blog.csdnimg.cn/d9858bc47b264ffca6e50bde12942367.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/6e712da2bdb24746bbd555e174ca98ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>此后继续检测（不检测已经加入安全序列的进程）<br>通俗地说就是，如果它我分配了之后它能够顺利完成，它就会归还——那就分配，然后把它加入安全序列，之后继续。<br>（类似贪心？)<br>考试中用笔算，注意技巧：如果现有资源可以分别满足几个进程，那么直接把它们全部扔进安全序列（反正可以先后完成）</p><p>至于计算机怎么实现…这个对于数学不好的人（比如我）简直劝退<br>这一部分有兴趣了解一下就行…<br><img src="https://img-blog.csdnimg.cn/cfd1bf0d37864a0f8df0133530918641.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><blockquote><p>允许死锁发生，不过操作系统会检测出死锁，然后采取某种措施解除死锁</p></blockquote><p>当然，这是 死锁预防措施 或 死锁避免措施 没有被系统启用（或者失效了)的情况下的处理方式</p><p><strong>两个算法</strong></p><p> <strong>1.死锁检测算法</strong></p><blockquote><p>用于检测系统状态，以确定系统中是否发生了死锁<br><strong>方式</strong><br>1.用某种数据结构(<strong>资源分配图</strong>)来保存资源的请求和分配信息<br>2.提供一种算法，利用上述信息来检测系统是否进入了死锁</p></blockquote><p><img src="https://img-blog.csdnimg.cn/6cc1da3f54714a16977d0674a5eda755.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>（注意，分配边表示<strong>已经</strong>分配了多少）<br>对于上图中P1 P2 R1 R2构成的资源分配图<br>首先看P1，因为P1的请求可以满足，那么和P1相连的边可以全部移除<br>然后看P2，也是同理，与之相连的边可以全部移除<br>这样一来所有的边都被移除了，这种资源分配图就是<strong>可完全简化的</strong>，这说明这是安全的，没有发生死锁；否则就是<strong>已经发生了死锁</strong>，而最终还有相连边的进程就是<strong>发生死锁的进程</strong></p><p>其实上述内容就是<br><strong>死锁定理</strong></p><blockquote><p>如果某时刻资源分配图是不可完全简化的，那么此时系统处于死锁</p></blockquote><p>(比如来看一个死锁的情况)<br><img src="https://img-blog.csdnimg.cn/e2ff05e67b6849d4a33baa8b3d3cc3c1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p> <strong>2.死锁解除算法</strong></p><blockquote><p>发生死锁时，解除死锁。有几种方法：<br><strong>1.资源剥夺法</strong><br>挂起某些死锁进程，抢占其资源，并且将其资源分配给其他资源。但是要防止被挂起的进程发生饥饿。<br><strong>2.撤销进程法</strong><br>也叫<strong>终止进程法</strong>。强制撤销部分甚至全部死锁进程，并剥夺这些进程的资源。（这种方式简单粗暴，但是代价可能巨大，比如一个进程运行很久已经快结束了结构又被撤销直接白干了）<br><strong>3.进程回退法</strong><br>让一个或多个死锁进程回退到足以避免死锁的地步<br>（这需要系统记录进程的历史信息，设置还原点）</p></blockquote><p>有了方法，现在还要讨论对哪个进程出手<br>我们一般从一下几个方面进行考虑：</p><blockquote><p>1.进程优先级（干掉优先级低的）<br>2.已经执行时间（干掉执行时间少的）<br>3.剩余执行时间（干掉剩余时间多的）（和上面那个有点矛盾）<br>4.已经使用多少资源（先干掉资源用的多的）<br>5.交互式进程还是批处理式进程（先干掉批处理进程，让用户感受好些）<br>…..</p></blockquote><h2 id="存储与查询"><a href="#存储与查询" class="headerlink" title="存储与查询"></a>存储与查询</h2><h3 id="内存基础知识"><a href="#内存基础知识" class="headerlink" title="内存基础知识"></a>内存基础知识</h3><blockquote><p>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</p></blockquote><p><strong>内存单元</strong><br>即每一个内存地址对应的存储空间，至于存储空间的大小，分两种情况：<br><strong>1.按字节编址</strong></p><blockquote><p>每个内存单元大小为1字节（byte，b）</p></blockquote><p><strong>2.按字长编址</strong></p><blockquote><p>每个内存单元大小为1字（每个字大小是2字节)</p></blockquote><p><strong>冷知识</strong><br>1K  = 2^10<br>1M = 2^20,<br>1G = 2^30 </p><p>所以4G内存表示，内存中可以存储4<em>2^30字节——如果是按字节编址，也就有4</em>20^30个地址，即2^32个地址</p><hr><p> <strong>逻辑地址 与 物理地址</strong><br>其实就相当于直接路径和相对路径这样的，很好理解<br>比如实际的地址（物理地址）是666，把666当成0，那么667就是1</p><hr><p><strong>编辑、编译、链接 和 装入</strong></p><blockquote><p>编辑：高级语言写代码<br>编译：高级语言编译为(机器语言)多个目标模块，分散在多个逻辑地址段中<br>链接：多个模块组装成一个<strong>装入模块</strong>，有一个完整的<strong>逻辑地址</strong>段<br>装入：把装入模块装入内存中，有完整的物理地址</p></blockquote><hr><h3 id="三种装入-与-三种链接"><a href="#三种装入-与-三种链接" class="headerlink" title="三种装入 与 三种链接"></a>三种装入 与 三种链接</h3><p>首先是三种装入：<br><strong>绝对装入</strong></p><blockquote><p><strong>在编译时</strong>，如果知道程序放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。<br><strong>概述为：编译时产生绝对地址</strong></p></blockquote><p>比如你知道大小为装入模块要从物理地址为100的地方开始存放，那就直接装入100</p><p>只适用于<strong>单道程序环境</strong>，且通常是编译或汇编环节给出绝对地址(其实也可以由程序给)</p><hr><p><strong>静态重定位</strong></p><blockquote><p>又称<strong>可重定位装入</strong>，装入模块中的地址是逻辑地址，直至真正装入时逻辑地址换为物理地址。程序运行期间无法移动。<br><strong>概述为：装入时将逻辑地址转为物理地址。</strong></p></blockquote><p><strong>这是早期多道批处理操作系统采用的</strong></p><hr><p><strong>动态重定位</strong></p><blockquote><p>又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的逻辑地址都是从0开始的。装入程序（负责把装入模块装入的程序)把装入模块装入内存之后，并不会把逻辑地址转为物理地址，而是把地址转换推迟到<strong>程序真正要执行时</strong>才进行。因此，装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持（进行的操作是物理地址+目标逻辑地址）。<br><strong>概述为：运行时将逻辑地址转为物理地址</strong></p></blockquote><p>通过重定位寄存器，可以将程序分配到不连续的内存中（意思是每段只有部分的程序代码，这也是<strong>虚拟</strong>的体现，这样使用户能够使用一个比存储空间大得多的地址空间）<br><strong>这也是现代操作系统普遍采用的</strong></p><hr><p>再来看看三种链接：</p><p><strong>静态链接</strong></p><blockquote><p>在程序运行之前，将各目标模块及它们所需要的库函数连接成一个完整的可执行文件(也就是装入模块)，之后不再拆分。</p></blockquote><hr><p><strong>装入时动态链接</strong></p><blockquote><p>将各目标模块装入内存时，边装入边链接。</p></blockquote><hr><p><strong>运行时动态链接</strong></p><blockquote><p>在程序执行中需要该目标模块时，才对他进行链接。其优点时便于修改和更新，便于实现对目标模块的共享。</p></blockquote><hr><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><blockquote><p>管理内容大概分为以下3个方面：<br>1.内存空间的分配与回收<br>2.从逻辑上对内存空间进行扩充<br>3.地址转换（逻辑地址和物理地址的转换)<br>4.内存保护</p></blockquote><hr><p>专门说一下</p><p><strong>内存保护</strong></p><blockquote><p>只允许各个进程访问自己拥有的内存，保证各个进程互不干扰</p></blockquote><p><strong>方式一</strong></p><blockquote><p>cpu中有上下限寄存器，存放进程的上下限地址，进程访问地址时，cpu据此检测是否越界</p></blockquote><p><strong>方式二</strong></p><blockquote><p>采用<strong>重定位寄存器（也叫基址寄存器）</strong> 和  <strong>界地址寄存器（也叫限长寄存器）</strong>，分别存放<strong>起始物理地址</strong>和<strong>最大逻辑地址</strong>，同样检测是否越界</p></blockquote><h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><blockquote><p>早期计算机额内存很小，比如IBM的第一台PC机器，最大就1MB内存。所以得想办法解决一下内存过小从而导致程序无法顺利运行的情况——<strong>覆盖技术</strong>因此诞生</p></blockquote><p><strong>覆盖</strong></p><blockquote><p>思想是<strong>将程序分为多个段（多个模块)</strong><br>常用的段常驻内存，不常用的段在需要时调入内存</p></blockquote><p>这样就使得1mb的内存可以运行2mb甚至更大程序！</p><p>这其中，内存被划分为两个区域<br>| 区域名称 | 数量   | 简介                                             |<br>| ——– | —— | ———————————————— |<br>| 固定区   | 1个    | 常驻内存的段就被放入这里，在运行结束之前不会调出 |<br>| 覆盖区   | 若干个 | 选取可能放入这个区域中最大的段的内存             |</p><p><img src="https://img-blog.csdnimg.cn/b4ec013df1844f488b5a7cdc4e8293e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>橙色是常驻区，BC是不会被同时调用的两个段，分别是D、EF的前驱</p><p>这种技术</p><blockquote><p>优点：由程序员声明覆盖结构，操作系统自动完成覆盖<br>缺点：对用户不透明，增加了编程负担</p></blockquote><hr><p><strong>交换技术</strong></p><blockquote><p>思想是内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某系已经具备运行条件的进程换入内存（进程在内存与外存间动态调度)</p></blockquote><p>没错，就是<strong>挂起与就绪之间的转换</strong>的<strong>中级调度（内存调度）</strong></p><p><strong>1.至于如何交换呢？</strong></p><blockquote><p>一般来说，具有交换功能的操作系统中，通常把磁盘空间分为 <strong>文件区</strong> 和 <strong>对换区</strong>两个部分。<br>文件区主要用于存放文件，追求存储空间的利用率，因此对文件区的空间管理采用<strong>离散匹配方式</strong>；<br>对换区只占很小的空间，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此通常对换区采用<strong>连续分配方式</strong>。<br>（总之，对换区的I/O速度比文件区要快）</p></blockquote><p><strong>2.那么什么时候发生交换？</strong></p><blockquote><p>交换通常在内存紧张时进行，在内存充裕时暂停。比如在许多进程运行时发生缺页，就说明内存紧张，此时可以换出一些进程。</p></blockquote><p><strong>3.换出哪些进程？</strong></p><blockquote><p>优先换出阻塞进程。可以换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。（注意PCB常驻内存）</p></blockquote><hr><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>由于时间紧迫，这里开始先水一点了，后面再细细地补上</p><p><strong>连续分配</strong></p><blockquote><p>指为用户进程分配一个连续的内存空间</p></blockquote><hr><p><strong>固定分区分配</strong></p><blockquote><p>把整个内存的用户区域（对换区）分为n个大小固定的分区</p></blockquote><hr><p><strong>动态分区分配</strong></p><blockquote><p>动态分区分配又称为可变分区分配，在进程装入内存时，根据进程动态地建立分区</p></blockquote><p><strong>动态分区分配算法</strong><br>这个算法是为了解决一个问题：在动态分配过程中，当很多歌空闲分区都能满足需求时，应该选择哪个分区进行分配？</p><p>这里举例四种动态分区分配算法：<br><strong>1.首次适应算法</strong></p><blockquote><p>每次从低地址开始查找，找到第一个满足的空闲分区<br>查找方式是通过空闲分区链或者空闲分区表来查找的(其实就是空闲的内存的首地址和大小等信息会以顺序或者链式存储，可以据此遍历）</p></blockquote><p><strong>2.最佳适应算法</strong></p><blockquote><p>和首次适应算法类似，不过存储空闲分区地址的数据结构将以<strong>递增</strong>的形式存储，所以空间越大的分区排在越后面</p></blockquote><p>这样一来每次都能找到大小最接近的，使得内存利用率很高<br>可是问题也很明显，每次使用，都可能会留下非常小的空间（比如10mb的程序占用了11mb内存，空闲的1mb难以利用），这种空间叫做<strong>内部碎片</strong><br>内部碎片多了之后，利用率又下来了</p><p><strong>3.最坏适应算法</strong></p><blockquote><p>和最佳适应算法相反，最坏适应算法存储是<strong>递减</strong>的</p></blockquote><p>主要是想着防止小碎片产生，那我就每次用最大的空间不就好了？（10mb程序占用100mb内存，还有90mb这不是很容易用出去吗）</p><p>但是问题是，可能导致后面来的大进程没有空间<br><strong>4.邻近适应算法</strong></p><blockquote><p>递增存储并且是环形结构，每次查找从上一次查找结束的位置开始继续查找</p></blockquote><h3 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h3><blockquote><p>上一节中提到的算法，虽然各有千秋，但是无一例外地都可能产生碎片<br>（虽然可以使用<strong>紧凑技术</strong>来解决碎片问题，但是其时间开销太大）</p></blockquote><p>所以出现了<strong>基本分页存储管理</strong></p><blockquote><p>就是把内存分为一个个大小相等的小分区，再按照分区大小把进程拆分为一个个小部分<br><strong>每一个分区就是一个“页框”</strong>，或者叫“页帧”、“内存块”、“物理块”，每个页框都有一个编号，即“页框号”（或者叫“内存块号”之类的），从0开始</p></blockquote><p>tips：内存可能不能整除页框大小，所以最后一个页面可能没有一个页框那么大，因此页框不能太大，否则可能产生较大的内部碎片</p><p><strong>装入</strong><br>类似于一个程序的链接装入过程<br><img src="https://img-blog.csdnimg.cn/3ffe3e28e17c4ceb91cdbc873529da8f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>其中涉及到一些关于 <strong>页号</strong> 和 <strong>页内偏移量</strong>的计算</p><blockquote><p>页号 = 逻辑地址 / 页面长度<br>页内偏移量 = 逻辑地址 % 页面长度</p></blockquote><p>另外，为了方便计算页号、页内偏移量，页面大小一般用2的整数幂</p><hr><p><strong>页表</strong><br>为了能够知道进程中每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表<br><img src="https://img-blog.csdnimg.cn/9017ebfe3cf34f45a928e5e96e46093b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>（完了卧槽啊，吃个饭回来发现电脑重启了，一下午的笔记就没了，7k字一个字一个字码上去的啊，淦哦，缺失的内容先简单写一下了，心态有点炸）</p><p><strong>基本概念</strong></p><blockquote><p>核心思想是把进程分成很多大小相等的段，内存也分为与进程等大的段，然后前者叫做页面，后者叫页框，它们之间的对应关系用页表来存，页表也放在页框中</p><p>1.页面：简称页，也就是进程的分段<br>2.页框：大小和页面相同，也叫内存块的（有一堆名字），是内存的分段<br>3.页表：记录了页面和页框的对应关系，其中每一项叫做页表项<br>4.页号：页表中某个页面的编号，其值为 <strong>逻辑地址 / 页面大小</strong><br>5.页面偏移量：即 <strong>逻辑地址位数 % 页面大小</strong>（页面长度）的值<br>6.<strong>逻辑地址构成 = 页号 + 页内偏移量</strong><br>（比如30位的逻辑地址 = 10位页号 + 20位页内偏移量;<br>如果有m位页号，那么说明一个进程中最多有m个页面；<br>如果有k位页内偏移量，那么一个页面的大小是2^k^个内存单元）<br>7.页面大小：就是一个页面的大小，是2的整数幂</p></blockquote><hr><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p><strong>基本地址变换机构</strong></p><blockquote><p>基本地址变换机构通过页表将逻辑地址转为物理地址<br>通常会在系统中设置一个<strong>页表寄存器（PTR）</strong>，存放在内存中的<strong>起始地址F</strong>和<strong>页表长度M</strong>。地址变换的过程如下：<br>1.进程未执行时，页表的  起始地址F 和  页表长度M 放在进程控制块PCB中，当进程被调度时候，操作系统内核将F和M放到寄存器中<br>2.根据页表中记录的逻辑地址计算出 <strong>页号</strong> 和 <strong>页内偏移量</strong><br>3.与PTR里面的数据进行比较，如果页号<strong>大于等于</strong>页表长度，那么发生越界，内中断；如果小于，那么判定合法，进入下一步。<br>4.根据页号查询页表，找到对应的页框号<br>5.用页框号和页内偏移量得到物理地址<br>6.访问目标单元</p></blockquote><p>这个过程中，<strong>访问了两次内存</strong><br>（访问内存开销比较大，所以减少访问内存的次数可能会得到优化）</p><hr><p><strong>带有快表的地址变换机构</strong></p><p><strong>局部性原理</strong><br>先看如下代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">100</span>)</span><br><span class="line">{</span><br><span class="line">arr[i ++] = i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>时间局部性</strong><br>如果执行了程序中某条指令，那么不久后这条指令可能被再次执行；<br>如果某个数据被访问过，那么不久后该数据可能再次被访问；<br><strong>空间局部性</strong><br>如果某个存储单元被访问，那么不久之后其附近的存储单元也可能被访问。（比如很多具有连续存储这一性质的数据）<br><strong>至于为什么叫局部</strong><br>我个人的理解是，限制在某一个时间段，限制在某一个空间内，这就是局部。<br><strong>有什么意义</strong><br>其实上述内容暗示我们，一个较短的时间段内，进程只有一部分被访问了。这就说明我们每次只需要访问一部分就能运行一个进程，那么就没有必要一次性存储全部的内容。</p></blockquote><p>我们上面提到过，访问内存开销大，那么我们尽量减少访问内存的次数。<br>这样重复的访问内存，却只是找同样的东西，那么我们能不能把这个东西保存到内存外面，下次访问就不需要从内存里面找了？</p><p><strong>快表</strong></p><blockquote><p>又称<strong>联想寄存器（TLB） 或者 地址变换高速缓存</strong>，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问过（当前指的是当前运行的进程）的若干页表。<br>与之对应的<strong>慢表</strong>通常指的是内存中的页表</p></blockquote><p>在加入快表后，地址变换过程变为：<br><strong>（黑色斜体字表示新加入的步骤）</strong></p><blockquote><p>1.进程未执行时，页表的  起始地址F 和  页表长度M 放在进程控制块PCB中，当进程被调度时候，操作系统内核将F和M放到寄存器中<br>2.根据页表中记录的逻辑地址计算出 <strong>页号</strong> 和 <strong>页内偏移量</strong><br>3.与PTR里面的数据进行比较，如果页号<strong>大于等于</strong>页表长度，那么发生越界，内中断；如果小于，那么判定合法，进入下一步。<br><em><strong>3.查询快表，如果查询成功（命中），就进入第5步；失败则进入第4步</strong></em><br>4.根据页号查询页表，找到对应的页框号，<em><strong>并把该页表项中的页号和页框号放入快表中</strong></em><br>5.用页框号和页内偏移量得到物理地址<br>6.访问目标单元</p></blockquote><p>上述过程中，如果第3步命中，那么地址变换就只需要访问一次内存<br>可以根据以下例题感受效率的变化<br><img src="https://img-blog.csdnimg.cn/dbec1330a0bc457b860dd742beb9241e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>tips：<br>至于第3步为什么会有<strong>查询失败</strong>的情况，有两种可能：</p><blockquote><p>1.第一次访问某个页号，快表中没有存储（快表一开始是空的）<br>2.快表满了，装不下全部数据，所以就出现访问过也查找失败的情况（因为快表造价要贵点，空间比较小。不）（然要主存干啥，干脆全用快表了）</p></blockquote><hr><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>其实主要还是二级页表….多级同理…</p><p><strong>单级页表存在的问题</strong><br>首先看一个计算<br><img src="https://img-blog.csdnimg.cn/2532254450104700b1a82f52e115f05b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>首先是告诉我们这个系统支持32位逻辑地址，然后页面大小是4KB = 2^12^位，结合前面的知识（逻辑地址位数 = 页面大小位数 +<br>页号位数）,我们知道<strong>页号位数 = 32 - 12 = 20位</strong>，<br>然后页号就是页面的编号嘛，所以有2^20^个页面，一个页面在页表中都有一个对应的页表项，那么就有2^20^个页表项，题目告知一个页表项大小为4B，那么整个页表的大小就是2^22^B。<br>这时候，不要忘了页框和页面等大，所以一个页框也是4KB = 2^12^B，于是乎，页框个数就是 <strong>2^22^/ 2^12^ =<br>2^10^个</strong> ，也就意味着，要分配1024个连续的页框来存储页表，这将是不小的开销</p></blockquote><p>所以存在两个问题：<br>1.页表必须连续存放，当页表很大时，存放起来比较困难（最起码开销很大吧）<br>2.由于存在局部性原理，所以让整个页表常驻内存并不明智</p><p>为了解决问题1，大佬们提出<br><strong>二级页表</strong></p><blockquote><p>将页表分组，使得每一个内存块正好可以放入一个分组（比如页面大小4KB，页表项4B，每个页框可以存放1K个页表项，所以每1K个页表项分为一组，然后离散地存入各个页框）<br>此后，为了记录这些离散存储的页表组，我们再建一张页表，称为<strong>页目录表，或者外层页表、顶层页表</strong>等等</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2939689873d1496ea6f392f42572d470.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>需要注意的几个细节：<br><img src="https://img-blog.csdnimg.cn/a009ca69fdd146d193e6d5b65a6b7c6d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>让我鹦鹉学舌来一手（主要是为了巩固，加深印象）</p><blockquote><p>40位逻辑地址就是2^40^B，而一个页面是4KB = 2^12^B，那么可以容纳2^28^个页面，也就是有2^28^个页号，因为按字节编制，所以页号有28位。<br>页面和页框等大，都是2^12^B，一个页表项是4B，那么一个页面可以容纳2^10^个页表项，因此一个页表项对应的页号是10位。<br>由于<strong>各级页表的大小不能超过一个页面的容量</strong>，所以一级最大就是10位，那么对于28位的页号来说就是10 + 10 + 8三级页表才能完成存储</p></blockquote><p>但是n级页表的缺陷也很明显：<br>（不考虑快表）需要访问n+1次内存</p><hr><p>至于问题2，后面细说，这里先大概了解</p><blockquote><p>大佬们提出了虚拟存储技术，就是在内存只放一部分，然后访问的时候如果内存中没有那么就产生缺页中断（内中断），从外存中调进来就可以了</p></blockquote><h3 id="分段存储"><a href="#分段存储" class="headerlink" title="分段存储"></a>分段存储</h3><blockquote><p>与分页存储的最大区别就是离散分配时，所分配的地址空间的基本单位不同：<br>进程的地址空间指的是，按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址。<br><strong>段成为内存分配的单位</strong>，每个段在内存中占据连续的空间，但是<strong>各段之间可以不相邻</strong>。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/336dcb1cdd7346cdbad992866805e425.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>段名会在编译过程中被处理为段号</p><h3 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h3><p><strong>分页分段的优缺点</strong></p><table><thead><tr><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页管理</td><td>内存利用率高，没有外部碎片，几乎没有页内碎片（很少）</td><td>不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td>分段管理</td><td>很方便按照逻辑模块实现信息的共享和保护</td><td>如果段长过大，为其分配连续的内存空间不方便，另外也可能产生较多外部碎片</td></tr></tbody></table><p><strong>段页式的具体过程</strong></p><blockquote><p>段页式便是段和页的结合<br>是先分段，分成大大小小不同的段，然后再装进一样大小的页框中</p><p><img src="https://img-blog.csdnimg.cn/0db198d7e86c4c3fa5f286ac9c16823b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统段页式管理中分段分块"></p></blockquote><p>（仔细一想，这不应该是产生了更多没有利用的内存空间吗，不过考试迫在眉睫，暂时先背着吧）</p><p>之后的对应关系大概是<br><img src="https://img-blog.csdnimg.cn/be8a44faa43e40908d76887ff54a13c3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统段页式管理离散匹配"></p><blockquote><p>段页式管理中，一个进程可以对应<strong>一个段表</strong>，这个段表又对应了<strong>多个页表</strong>（即一个段表项对应了一个页表）<br>注意这里的段表，其每个段表项是等长的，短号是隐含的（不记录，默认从0开始升序），<br>记录了页表长度和页表存放的块号</p></blockquote><blockquote><p>至于进程分段后是怎么确定在内存中的位置这件事情：<br>0.先把<strong>段表始址F</strong>和<strong>段表长度M</strong>存放到段表寄存器中<br>1.根据逻辑地址得到<strong>段号S</strong>、<strong>页号P</strong>、页内<strong>偏移量W</strong><br>2.判断是否越界：如果段号S&gt;=偏移量M那么产生越界，中断；否则进行下一步<br>3.查询页表，找到对应的段表项，段表项的存放地址为F+S*段表项长度<br>4.判断是否越界，若页号&gt;=页表长度，中断；否则进行下一步<br>5.根据页表存放块号、页号查询页表，找到对应页表项<br>6.根据内存块号页内偏移量得到最终物理地址<br>7.访问目标内存单元</p></blockquote><p><img src="https://img-blog.csdnimg.cn/784b552e912e4e34885c43f2869ee095.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统段页式访问内存的过程"></p><p>上述过程会访问三次内存（访问段表、页表、最终目标内存）</p><p>当然如果引入<strong>快表</strong>，那么可能只需要一次访问</p><h2 id="虚拟内存及相关存储管理方式"><a href="#虚拟内存及相关存储管理方式" class="headerlink" title="虚拟内存及相关存储管理方式"></a>虚拟内存及相关存储管理方式</h2><h3 id="虚拟内存概述"><a href="#虚拟内存概述" class="headerlink" title="虚拟内存概述"></a>虚拟内存概述</h3><p><strong>传统内存</strong></p><blockquote><p>即之前提到的连续分配和非连续分配内存的方式。<br>很多暂时用不到的数据也会长期占用内存，导致内存利用率不高。<br>其特征如下：<br><strong>一次性</strong>：作业必须一次性全部装入内存后才能开始运行<br>这就造成了两个问题：<br>（<br>1.作业很大时，不能全部装入内存，大量作业无法运行；<br>2.大量作业运行时，由于内存无法容纳所有作业，只有少量作业能运行，导致多道程序并发度下降<br>）<br><strong>驻留性</strong>：一旦作业被装入内存，就会一直驻留在内存中，直到作业运行结束。<br>（事实上，在一个时间段内，只要访问作业的一小部分数据即可正常运行，导致了大量内存空间浪费）</p></blockquote><p><strong>虚拟内存的原理</strong></p><p>上一篇提到过<strong>局部性原理</strong>，还有<strong>时空局部性</strong><br>虚拟内存就是利用了（理论上的原理）空间的局部性原理实现的<strong>空分复用术</strong>，其技术上的原理是<strong>高速缓冲技术</strong></p><blockquote><p>高速缓冲技术的思想是将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放到更低速的存储器中<br>（存储器速度：寄存器&gt;cache(高速缓存)&gt;内存&gt;外存）</p></blockquote><p><strong>虚拟内存的具体体现</strong></p><blockquote><p>比如，程序执行过程中，访问的信息不在内存中时，由操作系统负责将所需要的信息从外存调入内存，然后继续执行程序<br>如果内存空间不够，那么就把暂时用不到的信息调到外存<br>在操作系统的管理下，在用户看来似乎有一个比实际内存大的多的内存，这就是<strong>虚拟内存</strong></p></blockquote><p><strong>虚拟内存三大特性</strong><br>（就是单纯想总结一下，不要求掌握）<br>| 名称   | 内容                                                         |<br>| —— | ———————————————————— |<br>| 多次性 | 无需作业运行时一次性全部装入内存，而是允许被分为多次调入内存 |<br>| 对换性 | 在作业运行时，无需一直常驻，而是在作业运行的过程中，将作业换入换出（请求调页 + 页面置换） |<br>| 虚拟性 | 从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量 |</p><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><p> <strong>与 基本分页管理 的主要区别：</strong></p><blockquote><p>在程序执行过程中，当所<strong>访问的信息不在内存时</strong>，由操作系统负责将<strong>所需要的信息从外存调入内存</strong>，然后继续执行程序<br>若内存空间不够，由操作系统将<strong>内存中暂时用不到的信息换出外存</strong></p></blockquote><p>为了更好的实现调入调出，请求分页存储管理的页表增加了四个字段：<br><img src="https://img-blog.csdnimg.cn/5f3b5dd82d1748eca44ca2cde6997bc7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_请求分页存储管理的页表"></p><table><thead><tr><th>新增字段</th><th>作用</th></tr></thead><tbody><tr><td>状态位</td><td>是否已经调入内存</td></tr><tr><td>访问字段</td><td>可记录最近被访问过几次，或者记录上次访问的时间，供置换算法选择换出页面时参考</td></tr><tr><td>修改位</td><td>页面调入内存后是否被修改过</td></tr><tr><td>外存地址</td><td>页面在外存中的存放位置</td></tr></tbody></table><p>和基本分页存储管理<strong>不同之处</strong><br><strong>请求调页</strong><br>如果访问页面不在内存中，那么就产生一个<strong>缺页中断</strong>（属于内中断），然后由操作系统的缺页中断处理程序处理中断，此时缺页的进程阻塞，被放入阻塞队列末尾，调页完成后再被唤醒加入就绪队列。</p><p><strong>页面置换</strong><br>如果内存不够，则会根据<strong>页面置换算法</strong>淘汰页面，若该页面在内存时期被修改过，那么还得将其在外存中的内容同步修改（写回外存）；未修改则不用写回；<br>具体过程是：<br>请求调页、页面置换、需要请求页表中新增的表项</p><p><strong>引入快表</strong><br>同样地，又是需要多次访问内存，所以我们就容易想到快表</p><p><img src="https://img-blog.csdnimg.cn/2ec9fb40089646ca9091459b2b41e08b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_具有快表的请求分页管理"></p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>这里时间有些紧迫，所以长话短说，暂时先不举出例子了<br><strong>OPT最佳置换算法</strong></p><blockquote><p>每次选择淘汰<strong>不再使用 或 以后最长时间不使用</strong>的页面</p></blockquote><p>这是最优的算法，但是<strong>无法实现</strong>，因为无法预知未来</p><hr><p><strong>FIFO先进先出置换算法</strong></p><blockquote><p>淘汰最先到达的页面</p></blockquote><hr><p><strong>LRU最近最久未使用置换算法</strong></p><blockquote><p>利用访问字段记录上次自上次使用后经历的时间，据此淘汰目前最长时间未使用的页面。需要硬件支持才能实现。<br>该算法是最性能最接近OPT的</p></blockquote><p>乍一想好像和FIFO一样，我对此只能说，<br><em>想的好，下次不许想了</em><br>验证过了，有些时候结果不一样，所以别想了，先背着要考了<br><strong>手写做题的时候，可以倒过来找，当前的几个页面里最后出现的就是淘汰的</strong></p><hr><p><strong>CLOCK时钟置换算法</strong></p><blockquote><p>也叫<strong>NRU最近未使用算法</strong>，或者<strong>第二次机会算法</strong><br>页面访问字段为1表示最近访问过，0反之；<br>循环扫描当前几个页面，修改访问字段，如果是1就改为0，如果是0那就淘汰当前页面，循环结束</p></blockquote><p>也就是最多循环两次</p><p>这个算法性能是很好的，虽然次于OPT和LRU，但是实现难度相对小，均衡</p><hr><p><strong>改进的CLOCK时钟置换算法</strong></p><blockquote><p>简单的CLOCK时钟置换只考虑页面最近是否被访问，但是没考虑最近是否被修改（因为只有被修改过的页面才有必要调出内存、写回外存）<br>改进就是，其他条件相同的时候，优先淘汰没有被修改的页面（利用修改位判断是否被修改过）</p></blockquote><p>这个至多访问四轮：</p><blockquote><p>第一轮是找<strong>最近没使用的、且 没有 修改过的</strong>，这一轮不会修改访问位，如果没找到：<br>第二轮就查找<strong>最近没使用的、且修改过的</strong>，这一轮要是再失败，就把所有扫描到的访问位置为0——表示没使用过<br>第三轮就重复第一轮的过程，如果还失败，（就再来一轮） 第四轮就重复第二轮的过程，由于第二轮的修改，那这次一定会找到</p></blockquote><hr><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><p><strong>驻留集</strong></p><blockquote><p>指请求分页存储管理中给进程分配的物理块（内存块）的集合，在虚拟存储技术中，驻留集一般小于进程的总大小</p></blockquote><p>驻留集大小过大，并发度下降，资源利用率低下<br>驻留集过小，系统大量时间用于处理缺页，进程推进的实际时间太小</p><hr><p><strong>页面分配、置换策略</strong><br>分配</p><blockquote><p><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不在改变。即，驻留集大小不变。<br><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可以根据情况做适当的增加或减少。即，驻留集大小改变。</p><p>置换</p></blockquote><blockquote><p><strong>局部置换</strong>：发生缺页时，只能选进程自己的物理块进行置换<br><strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存</p></blockquote><p>组合起来：</p><p><strong>可变分配全局置换</strong>：刚开始会为每个进程分配一定数量的物理块，当某天进程发生缺页的时候<br><strong>可变分配局部置换</strong>：根据发生缺页的频率来动态地增加或减少进程的物理块</p><hr><p><strong>调入页面的时机 及 从何处调入</strong></p><p><strong>调入时机</strong></p><blockquote><p>1.<strong>预调页策略</strong>：根据局部性原理，一次性调入若干个相邻的页面比一次性调入一个页面更高效，但是如果提前调入的页面中有大多数都不被访问，则又是低效的。<br>这种策略需要程序员指出应该先调入哪些部分。<br>2.<strong>请求调页策略</strong>：进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都因I/O操作而有较大的开销</p></blockquote><p><strong>从外存的何处调入内存</strong><br><strong>外存</strong>有对换区和文件区，<br>对换区I/O操作速度快，采用连续分配方式；<br>文件区I/O操作速度慢，采用离散分配方式；</p><blockquote><p>1.系统对换存空间足够： 页面调入调出都是在<strong>内存和对换区</strong>之间进行的（进程运行前，将进程相关数据复制到对换区）</p></blockquote><blockquote><p>2.系统对换区空间不足： 凡是不会被修改的数据都会直接从文件区调入内存，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。</p></blockquote><hr><p><strong>抖动现象</strong></p><blockquote><p>页面在内外间过于频繁的切换。（一般是发生在进程频繁访问的<strong>页面数目高于可用的内存块数</strong>）</p></blockquote><p><strong>工作集</strong></p><blockquote><p>指在某段时间间隔里，<strong>进程实际访问页面</strong>的集合</p></blockquote><p><img src="https://img-blog.csdnimg.cn/656565ffeaca46b19c568871db11bebd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统工作集示例"></p><p>一般来说，驻留集大小不能小于工作集大小，否则容易<strong>抖动</strong></p><h2 id="文件管理（待补充）"><a href="#文件管理（待补充）" class="headerlink" title="文件管理（待补充）"></a>文件管理（待补充）</h2><p>这部分咱学校考试考得稍微少点，所以这部分先水过，后面有空再回来补上</p><h3 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h3><blockquote><p>类似数据结构，逻辑结构指的从用户的视角看的结果<br>分为两大类：无结构文件 和 有结构文件</p></blockquote><hr><p><strong>无结构文件</strong><br>文件内部的数据就是一系列二进制流或字符流组成。又称“<strong>流式文件</strong>”。如：windows操作系统中的txt文件。</p><hr><p><strong>有结构文件</strong><br>由一组相似的记录组成，又称“<strong>记录式文件</strong>”。每条记录又由若干个数据项组成，又可以分为“<strong>可变长记录</strong>”和“<strong>定长记录</strong>”。如：数据库表文件。一般来说，每条记录有一个数据项可作为关键字（主码/主键）</p><p>我们重点讨论的就是有结构文件，它又有三种：<br><strong>顺序文件</strong>、<strong>索引文件</strong>、<strong>索引顺序文件</strong></p><p><strong>顺序文件</strong></p><blockquote><p>（逻辑上的顺序）类似线性表，（物理上的存储结构）即链表和数组；(考试通常是数组)</p></blockquote><p>其结构可以分为<br>串结构：记录之间的顺序与关键字无关；<br>顺序结构：记录之间的顺序按关键字顺序排列；</p><hr><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><strong>文件控制块</strong></p><blockquote><p>FCB，类似进程控制块，这是实现文件目录的关键数据结构<br>FCB中包含了文件的<br>基本信息（文件名、物理地址、逻辑结构、物理结构）<br>存取控制信息（是否可读/可写、禁止访问的用户名单）<br>使用信息（如文件的建立时间、修改时间）</p></blockquote><p>由于目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该目录下的文件，这些记录项也正是FCB。<br><strong>FCB实现了文件名和文件之间的映射，使用户可以实现“按名存取”</strong><br>以及以下四种操作：<br>| 操作     | 具体内容                                                   |<br>| ——– | ———————————————————- |<br>| 搜索     | 当用户使用一个文件时，系统要根据文件名搜索目录             |<br>| 创建文件 | 创建一个文件时，需要在其所属的目录中增加一个目录项         |<br>| 删除文件 | 当删除一个文件时，需要在目录中删除相应的目录项             |<br>| 显示目录 | 用户可以请求显示目录的内容，如显示该目录中的所有文件及属性 |</p><hr><p><strong>单级目录结构</strong></p><blockquote><p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项</p></blockquote><p>单级目录实现了“按名存取”，但是不允许文件重名<br>所以建立一个新的文件时，要先优先查看有无重名文件。</p><hr><p><strong>两级目录结构</strong></p><blockquote><p>早期的多用户操作系统，采用两级目录结构。分为<strong>主文件目录</strong>（MFD）和<strong>用户文件目录</strong>（UFD）</p></blockquote><p>其实就是允许建文件夹了（但是不能在文件夹建文件夹）</p><hr><p><strong>多级目录结构</strong></p><blockquote><p>也叫<strong>树型目录结构</strong></p></blockquote><p>也就是现在大家常见的这种，文件夹可以进行套娃<br>每访问一层，都要进行一次读磁盘的I/O操作</p><p>从这里开始引入<strong>绝对路径</strong>和<strong>相对路劲</strong>的概念，这个大家dddd，不再赘述</p><hr><p><strong>无环图目录结构</strong></p><blockquote><p>在树形目录结构的基础上，增加了一些指向同一节点的有向边，方便多个文件夹之间共享文件</p></blockquote><p>其实就是，文件夹A里面的文件，在文件夹B里面创建了个快捷方式，所以B可以访问到A的文件</p><hr><h3 id="非空闲磁盘块管理（文件的物理结构）"><a href="#非空闲磁盘块管理（文件的物理结构）" class="headerlink" title="非空闲磁盘块管理（文件的物理结构）"></a>非空闲磁盘块管理（文件的物理结构）</h3><p>讨论这点的目的是为了更好地对磁盘块进行管理，具体内容和内存分页很像</p><p>这里有一个前置概念是<strong>磁盘块</strong>，也就是类似内存分页，即<strong>外存的内存分配单元，其大小与一个页面等大</strong></p><p><strong>文件的物理结构 ，也叫文件的分配方式，即文件数据应该怎样存放在外存中</strong>，这里讨论三种方式：<br>1.连续分配<br>2.链接分配：又有隐式链接和显式链接两种形式<br>3.索引分配</p><hr><p><strong>1.连续分配</strong></p><blockquote><p>连续分配方式要求每个文件在磁盘上占有一组连续的块</p></blockquote><p>这里提前介绍一下，读取磁盘块的时候，要移动磁头。<strong>访问的两个磁盘块相隔越远，移动磁头所需时间就越长</strong></p><table><thead><tr><th>优缺点</th><th>具体内容</th></tr></thead><tbody><tr><td>优点</td><td>连续分配的文件在<strong>顺序读写</strong>时速度是最快的</td></tr><tr><td>缺点</td><td>1.在对文件进行拓展时，可能因为当前位置连续的空间不足而发生整体的迁移，最坏的情况是没有足够的连续空间从而无法进行拓展<br> 2.容易产生难以利用的磁盘碎片</td></tr></tbody></table><hr><p><strong>链接分配</strong></p><blockquote><p>采用离散匹配的方式，可以为文件分配离散的磁盘块（FCB增加两个字段：起始块号和结束块号，然后串起来）<br>分为<strong>隐式链接</strong>和<strong>显示链接</strong>两种形式<br>隐式指的是（静态链表），使用指针链接<br>显示指的是（邻接表），建立一张文件分配表（FAT）记录所有前驱后继关系</p></blockquote><p>隐式链接<br>| 优缺点 | 具体内容                                 |<br>| —— | —————————————- |<br>| 优点   | 空间利用率高                             |<br>| 缺点   | 1.只能顺序访问<br>2.指针会占用一定的空间 |</p><p>显式链接<br>| 优缺点 | 具体内容                                                     |<br>| —— | ———————————————————— |<br>| 优点   | 1.空间利用率高<br>2.文件拓展方便<br>3.支持随机访问，并且.地址转换时不需要访问磁盘，速度会快很多<br> |<br>| 缺点   | 1.文件分配表需要占用一定的空间                               |</p><hr><p><strong>3.索引分配</strong></p><blockquote><p>类似页表地，文件离散分配在各个磁盘块中，系统会为每个文件建立一张索引表，其中记录了文件的各个逻辑块对应的物理块。<br>索引表存放的磁盘块称为索引块，文件数据存放的磁盘块称为数据块。</p></blockquote><p><strong>和显示链接的区别在哪？</strong><br>显示链接是把所有链接关系都放到了一起集中存储（只有一张FAT）<br>索引分配中，每个文件的索引表也是离散存储在各个磁盘块中的（有多张表）<br>这样带来的优势就是，更灵活，也就引申出了以下三种索引分配方案：<br>1.链接方案<br>2.多层索引<br>3.混合索引<br>（暂不细究）</p><hr><h3 id="空闲磁盘块管理（文件存储空间）"><a href="#空闲磁盘块管理（文件存储空间）" class="headerlink" title="空闲磁盘块管理（文件存储空间）"></a>空闲磁盘块管理（文件存储空间）</h3><p><strong>文件卷、存储空间的划分与初始化</strong></p><blockquote><p>安装windows操作系统的时候，一定经历过磁盘分区（C、D、E盘等等），这些盘就是文件卷<br>（有的系统支持超大型文件，可以由多个物理磁盘合并为一个文件卷）<br><strong>初始化</strong>是将各个文件卷划分为<strong>目录区</strong>和<strong>文件区</strong></p></blockquote><blockquote><p>目录区主要存放文件目录信息（FCB）和用于磁盘管理的信息<br>文件区用于存储各种普通文件</p></blockquote><hr><p><strong>空闲空间分配方式</strong><br><strong>1.空闲表法</strong></p><blockquote><p>建议一张表，包含首个空闲盘块号 和 空闲盘块数 两个信息<br>同样可以采用首次适应、最佳适应、最坏适应等算法来解决这个问题</p></blockquote><p><strong>2.空闲链表法</strong></p><blockquote><p>分为两种：<br>1.空闲盘块链<br><img src="https://img-blog.csdnimg.cn/046c1b20f42d4ec0907cfb429c2c50bc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_文件_空闲盘块链"><br>2.空闲盘区链<br><img src="https://img-blog.csdnimg.cn/5906fd2cf9904e589ef5c7716cf37f9c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_文件_空闲盘区链"></p></blockquote><p><strong>3.成组链接法</strong></p><blockquote><p>空闲表法和空闲链表法可能不适用于大型文件系统，因为空闲表和空闲链表可能过大<br>而成组链接法实在目录区中专门用一个磁盘块作为“<strong>超级块</strong>”，系统启动时，将超级块读入内存并保证内外存中超级块数据一致<br><img src="https://img-blog.csdnimg.cn/453d304e67474a6c840a5de424308206.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_文件_成组链接法"></p></blockquote><h3 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h3><table><thead><tr><th>操作</th><th>系统调用（接口）</th></tr></thead><tbody><tr><td>创建文件</td><td>create</td></tr><tr><td>删除文件</td><td>delete</td></tr><tr><td>读文件</td><td>read</td></tr><tr><td>写文件</td><td>write</td></tr><tr><td>打开文件</td><td>open</td></tr><tr><td>关闭文件</td><td>close</td></tr></tbody></table><h3 id="文件共享和保护（暂不细究）"><a href="#文件共享和保护（暂不细究）" class="headerlink" title="文件共享和保护（暂不细究）"></a>文件共享和保护（暂不细究）</h3><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h3><p><img src="https://img-blog.csdnimg.cn/a4ca03a865444899ae941c48eaf1b85b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_磁盘结构"><br><img src="https://img-blog.csdnimg.cn/9bf7417d2f2049e1973d8518336a0c57.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_磁盘的磁道"><br><img src="https://img-blog.csdnimg.cn/2848f22bf8f847138125958d9bfebf1f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_磁盘的扇区"><br><img src="https://img-blog.csdnimg.cn/1f83c409f0f64834aaca3e908e477924.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_磁盘_磁臂_盘面_柱面"></p><table><thead><tr><th>结构名称</th><th>介绍</th></tr></thead><tbody><tr><td>磁盘</td><td>磁盘表面由一些磁性物质组成，可以记录二进制数据</td></tr><tr><td>磁道</td><td>磁盘的盘面被划分为多圈，每一个圈都是一个磁道</td></tr><tr><td>扇区</td><td>磁盘被划分为多个扇形区域，这些区域就是扇区，<strong>每个扇区都是一个磁盘块</strong>，<strong>各个扇区存放的数据量相同</strong>，所以每个扇区最内的磁道数据密度最大</td></tr><tr><td>盘面</td><td>盘片<strong>记录了数据的表面</strong>，有的可能是两面都能记录</td></tr><tr><td>柱面</td><td>所有盘面中相对位置相同的磁道组成柱面</td></tr><tr><td>磁头</td><td>用于读取数据的结构，磁头可以移动的磁盘是<strong>活动头磁盘</strong>，不可移动的是<strong>固定头磁盘</strong>（固定头磁盘是为每个磁道设置一个磁头，贵）</td></tr><tr><td>磁臂</td><td>固定磁头的结构，一般有多个磁头</td></tr></tbody></table><p><strong>磁盘中读写数据</strong><br>读写数据首先要把<strong>磁头移动</strong>到指定扇区的指定磁道，之后磁盘转动起来，让目标扇区从磁头下面划过，才能进行数据的读写</p><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>由于固定头磁盘很贵，通常还是采用活动头磁盘，所以如何高效地移动、读写数据就成了问题，这就需要我们使用算法去解决这个问题</p><p>先分析问题所在：</p><blockquote><p>消耗时间 = 寻找时间 + 延迟时间 + 传输时间<br><strong>寻找时间（寻道时间）</strong><br>启动磁臂 和 移动磁头到指定磁道的时间<br><strong>延迟时间</strong><br>由硬件决定，无法通过算法优化<br>旋转磁盘，使磁头进入目标扇区所要的时间<br><strong>传输时间</strong><br>由硬件决定，无法通过算法优化<br>读写数据所用的时间</p></blockquote><p>所以我们通过算法能够优化的就是<strong>寻道时间</strong></p><p><strong>调度算法</strong><br><strong>1.先来先服务算法FCFS</strong></p><blockquote><p>按照请求的顺序先后执行</p></blockquote><p><img src="https://img-blog.csdnimg.cn/1f5a736d9ee9470c8358831a8eaed6f3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="先来先服务算法"></p><p><strong>2.最短寻找时间优先算法SSTF</strong></p><blockquote><p>相当于是优先找最近的<br><img src="https://img-blog.csdnimg.cn/b576d35133f44f59bf3029a911cba694.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="最短寻找时间优先算法"><br><strong>可能产生饥饿</strong></p></blockquote><p><strong>3.扫描算法SCAN</strong></p><blockquote><p>也叫<strong>电梯算法</strong>,只有磁头移动到最外侧磁道的时候才能往内侧移动，反之同理<br><img src="https://img-blog.csdnimg.cn/7a0ef86e0252452a86b316aa4abe94ed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这就<strong>避免了死锁</strong>，<br>但是每次都要移动到头，这是没有必要的，<br>而且它对各个位置磁道的响应频率不平均</p></blockquote><p>所以对于SCAN算法来说，还存在以下几种改进版本</p><p><strong>4.LOOK调度算法</strong></p><blockquote><p>是改进的扫描算法，<br>即如果在磁头移动的方向上已经没有新的请求了，那么就允许立刻改变方向<br><img src="https://img-blog.csdnimg.cn/90a0ed9e464741fda7364ffca065334f.png" alt="LOOK调度算法"></p></blockquote><p><strong>5.循环扫描算法C-SCAN</strong></p><blockquote><p>再次改进，规定磁头移动到头之后立刻返回初始位置而不处理之间的任何任务<br><img src="https://img-blog.csdnimg.cn/8a8ef6cdcdce4654a3b8afb476e30bb7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="循环扫描算法"><br><strong>6.C-LOOK调度算法</strong><br>再次改进，就是C-SCAN依旧没有必要移动到头，如果移动方向上已经没有任务要处理，那么就立刻返回初始位置<br><img src="https://img-blog.csdnimg.cn/1e73acb19e684e83a064cc03029985cb.png" alt="C-LOOK调度算法"></p></blockquote><p>需要注意一个事情，大部分时候，题目如果没有特别说明，那么其所指的SCAN就是LOOK，C-SCAN就是C-LOOK</p><h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h3><p><strong>磁盘初始化</strong></p><blockquote><p>磁盘刚被制造出来的时候，只有磁道：<br>1.需要进行<strong>低级格式化（物理格式化）</strong>，即划分扇区，而一个扇区又可以分为头、数据区域、尾三个部分（计组阿巴阿巴）<br>2.<strong>磁盘分区</strong>，每个分区由若干柱面组成（即C、D、E盘）<br>3.进行<strong>逻辑格式化</strong>，创建文件系统的根目录、初始化存储空间管理所用的数据结构</p></blockquote><p><strong>引导块</strong></p><blockquote><p>计算机刚开机的时候，需要初始化一系列东西，而这初始化是通过执行<strong>初始化程序（自举程序）</strong> 完成的<br>ROM中存在一个自举装入程序，完整的自举程序会放在磁盘的引导块（启动块）内，引导块又位于磁盘的固定位置<br>拥有引导块的磁盘被称为<strong>系统磁盘（引导磁盘）</strong> （比如C盘）</p></blockquote><p><strong>坏块及其管理</strong></p><blockquote><p>坏块就是坏掉的部分，可以在逻辑格式化的时候检查出来，<br>并且会通过一系列操作来<strong>忽略或者启用备用扇区来替换</strong>它，这些操作对于操作系统是透明的</p></blockquote><h2 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h2><p><del>这部分算是计组的内容，暂时不写了，很多科目要考试了，得预习了~~~<br> （几天后）<br> ~~做了套真题回来发现考的还不少，回来补上…..</del> </p><p>其实这部分内容相对于前面的内容来说已经算是简单的了<br> <strong>基本概念</strong></p><blockquote><p><strong>什么是I/O设备</strong><br>input/output设备，输入输出设备，能讲数据输入计算机的设备，比如鼠标键盘等是输入设备，显示屏等是输出设备，而U盘、触摸屏等则是可以是输入设备也可以是输出设备<br><strong>系统管理I/O设备</strong><br>一些系统会将接入计算机的输入输出设备抽象为一种特殊的文件，用户可以通过相关的文件操作来对实现对输入输出设备进行操作<br> 比如我们这个数位板，就可以通过其相关的软件来管理<br> （为了避免打广告嫌疑，这里图只放一半）<img src="https://img-blog.csdnimg.cn/72a4dc3a19ef41baa8e078f47e7a61f4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统管理输入设备的体现"></p></blockquote><h3 id="I-O设备的几种分类"><a href="#I-O设备的几种分类" class="headerlink" title="I/O设备的几种分类"></a>I/O设备的几种分类</h3><p><strong>按使用特性分类</strong><br>虽然都是输入输出设备，但是也会有不同的特性<br>| 分类           | 特点                           | 举例                 |<br>| ————– | —————————— | ——————– |<br>| 人机交互类外设 | 数据传输速度慢，用于人机交互   | 鼠标、键盘、数位板等 |<br>| 存储设备       | 数据传输速度快，用于存储数据   | 移动硬盘、光盘等     |<br>| 网络通信设备   | 数据传输速度介中，用于网络通信 | “猫”，路由器等       |</p><p><strong>按传输设备分类</strong><br>| 分类     | 大致速度范围         | 举例         |<br>| ——– | ——————– | ———— |<br>| 低速设备 | 每秒几个到几百个字节 | 鼠标、键盘等 |<br>| 中速设备 | 每秒几千上万个字节   | 激光打印机等 |<br>| 高速设备 | 每秒几千只几千兆字节 | 磁盘等       |</p><p><strong>按信息交换的单位分类</strong><br>| 分类     | 单位                                                         | 举例       |<br>| ——– | ———————————————————— | ———- |<br>| 块设备   | “块”，即之前的学习中常常提到的那个概念，传输速率高。可以寻址，即可以对块设备进行随机读写 | 磁盘等     |<br>| 字符设备 | “字符”，较慢。不可寻址，输入输出时常采用<strong>中断驱动</strong>的方式   | 鼠标键盘等 |</p><h3 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I/O控制器"></a>I/O控制器</h3><p><strong>概念</strong></p><blockquote><p>I/O设备由机械部件和<strong>电子部件</strong>（I/O控制器，也称设备控制器）组成，<br>机械部件是鼠标、键盘、硬盘、显示器等我们看见的结构<br>电子部件一般是一块<strong>电路板</strong>，它的存在相当于操作系统 和 机械部件 间建立联系的桥梁</p></blockquote><p><strong>结构组成</strong><br>涉及部分计组知识，此处大概了解即可<br><img src="https://img-blog.csdnimg.cn/7155bf1b276c4588b93d6b7415fd1c3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="I/O控制器组成结构"></p><p><strong>功能</strong></p><blockquote><p>四个主要功能：<br><strong>1.接受和识别CPU发出的命令</strong><br>I/O控制器内包含<strong>控制寄存器</strong>，存放CPU发来的命令和参数<br>2.<strong>向CPU报告设备的状态</strong><br>I/O控制器内包含<strong>状态寄存器</strong>，记录I/O设备的状态，比如1代表空闲，0代表忙碌<br>3.<strong>数据交换</strong><br>I/O控制器内包含<strong>数据寄存器</strong>，用于暂存CPU发来的数据<br>4.<strong>地址识别</strong><br>类似于内存地址，为了区分各个寄存器，I/O控制器也给各个寄存器设置了一个“地址”<br>tips：地址编码方式有两种，一种是<strong>内存映射I/O</strong>，另一种是<strong>寄存器独立编址</strong>：<br>前者是，寄存器地址是接着内存地址递增；<br>后者是，各个寄存器采用独立的地址。<br><img src="https://img-blog.csdnimg.cn/b2f8274bb7154ab0b00d569a9aa81159.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="I/O控制器的两种编址方式"></p></blockquote><h3 id="四种I-O控制方式"><a href="#四种I-O控制方式" class="headerlink" title="四种I/O控制方式"></a>四种I/O控制方式</h3><p>究竟用什么样的方式来控制I/O设备的数据读写</p><p> <strong>1程序直接控制方式</strong><img src="https://img-blog.csdnimg.cn/f553e513a899475a90facefc2b76a2b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="程序直接控制方式"></p><table><thead><tr><th>行为</th><th>内容</th></tr></thead><tbody><tr><td>完成一次读写操作的流程</td><td>轮询</td></tr><tr><td>CPU干预频率</td><td>I/O操作之前、之后需要CPU介入，并且等待I/O完成的过程中CPU会不断轮询状态寄存器</td></tr><tr><td>数据传输</td><td>低速，每次传输一个字符，读操作是从I/O设备-&gt;CPU-&gt;内存；写操作是则是读操作反过来</td></tr><tr><td>优点</td><td>实现简单，在读写指令之后加上一些循环检测指令即可（因此才叫程序直接控制）</td></tr><tr><td>缺点</td><td>CPU和I/O只能串行工作，CPU一直轮询长期忙等，利用率低</td></tr></tbody></table><p> <strong>2.中断驱动方式</strong><br> <img src="https://img-blog.csdnimg.cn/f2ee849ac24445e5ac3d9037bd20091b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_15,color_FFFFFF,t_70,g_se,x_16" alt="中断驱动方式"><br>| 行为                   | 内容                                                         |<br>| ———————- | ———————————————————— |<br>| 完成一次读写操作的流程 | 中断                                                         |<br>| CPU干预频率            | I/O操作之前、之后需要CPU介入，但是且等待I/O完成的过程中<strong>CPU可以处理别的进程</strong> |<br>| 数据传输               | 低速，每次传输一个字符，读操作是从I/O设备-&gt;CPU-&gt;内存；写操作是则是读操作反过来 |<br>| 优点                   | 通过<strong>中断信号</strong>主动报告进程完成，而不用CPU不停轮询，此时CPU则可以和I/O设备并行工作，CPU利用率明显提升 |<br>| 缺点                   | 每个字在设备与内存之间的传输，都要经过CPU，频繁的中断会消耗CPU较多时间 |</p><p> <strong>3.DMA方式</strong></p><blockquote><p>即直接存储器存储，主要用于块设备<br>主要做了以下几个改进：<br>1.用“块”作为数据传送的单位，而不再是字，可以读写连续的多个块<br>2.数据的流向是从设备直接放入内存，或者从内存直接到设备。而不再需要CPU作为中介。<br>3.仅在传送一个或多个数据块的开始和结束时，才需要CPU干预 </p></blockquote><p>硬件结构大概如下，了解即可</p><p><img src="https://img-blog.csdnimg.cn/7de7e500971146dc99a6f37f78736ecb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="DMA方式"><br><img src="https://img-blog.csdnimg.cn/33ebc6915c6f4499ab803a190aa95c43.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="DMA方式"></p><table><thead><tr><th>行为</th><th>内容</th></tr></thead><tbody><tr><td>CPU干预频率</td><td>I/O操作之前、之后需要CPU介入</td></tr><tr><td>数据传输</td><td>高速，每次传输<strong>一个或连续的多个块</strong>，读操作是从I/O设备-&gt;内存；写操作是则是读操作反过来</td></tr><tr><td>优点</td><td>CPU介入频率降低，数据传输不再需要先经过CPU</td></tr><tr><td>缺点</td><td>读取离散的数据时，开销较大</td></tr></tbody></table><p> <strong>4.通道控制方式</strong></p><blockquote><p>通道是一种硬件，可以理解为低配版CPU<br><img src="https://img-blog.csdnimg.cn/8a113ddd950344fa834f54ad490e25c9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="通道控制方式"></p></blockquote><p><img src="https://img-blog.csdnimg.cn/b53e7cbeae9d47bf9578654d65519c5f.png" alt="通道控制方式的执行过程"></p><table><thead><tr><th>行为</th><th>内容</th></tr></thead><tbody><tr><td>CPU干预频率</td><td>极低，通道根据CPU的指令执行响应的通道程序，只有完成一组数据块的读写后才需要发出中断信号，请求CPU干预</td></tr><tr><td>数据传输</td><td>高速，每次传输<strong>一个或连续的多个块</strong>，读操作是从I/O设备-&gt;内存；写操作是则是读操作反过来</td></tr><tr><td>优点</td><td>CPU介入频率相当低，CPU、通道、I/O设备可以并行工作</td></tr><tr><td>缺点</td><td>实现复杂，需要专门的硬件设备支持</td></tr></tbody></table><p><strong>总结</strong><br><img src="https://img-blog.csdnimg.cn/3e134741fb1e4a8e97cfbe107329d08e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="四种控制方式的比较"></p><h3 id="I-O软件的结构层次"><a href="#I-O软件的结构层次" class="headerlink" title="I/O软件的结构层次"></a>I/O软件的结构层次</h3><p>如图所示<br><img src="https://img-blog.csdnimg.cn/7a6cc78b61104a8eb4c953ee356e7e50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="I/O软件的结构层次"></p><p><img src="https://img-blog.csdnimg.cn/ad2d8a3a2ad249bd8b939763ccb6cd6b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="库函数与系统调用"></p><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p><strong>什么是缓冲区</strong><br>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可用内存作为缓冲区<br>其中，硬件成本较高，容量也较小，适用于对速度要求较高的场合（比如快表作为缓冲区）<br><strong>有什么作用</strong><br><strong>1.减少了CPU的中断频率</strong><br>CPU可以把要输出的数据快速放入缓冲区，之后就可以去做别的事情，慢速的I/O设备就可以从缓冲区里拿数据。<br>就比如两个人交换物品，没有缓冲区的话，就得一个人等另一个人来了之后才完成交接。<br>有缓冲区的话，先到的人把东西放到缓冲区里面就可以走了，后到的人自己拿就行<br>（如下图就是一个单缓冲）<img src="https://img-blog.csdnimg.cn/7a72283e0dd5472197dd7092659b96bf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="缓冲区"><br><strong>2.解决数据粒度不匹配（人机速度不匹配）</strong><br>输出进程每次只能生成一块数据，但是I/O设备每次只能输出一个字符<br><strong>3.提高了CPU和I/O设备之间的并行度</strong></p></blockquote><h3 id="几种类型的缓冲区"><a href="#几种类型的缓冲区" class="headerlink" title="几种类型的缓冲区"></a>几种类型的缓冲区</h3><p>其实在上篇的进程同步互斥章节的内容中我们已经提到过一些了<br><strong>1.单缓冲</strong></p><blockquote><p>只有一个缓冲区，如果没有特殊说明，默认其是一个内存块。</p></blockquote><table><thead><tr><th>状态</th><th>写（冲入数据）</th><th>读（传出数据）</th></tr></thead><tbody><tr><td>空</td><td>可</td><td>不可</td></tr><tr><td>非空</td><td>不可</td><td>可</td></tr></tbody></table><p><strong>2.双缓冲</strong></p><blockquote><p>也就是两个缓冲区，这里我们将其称为A和B<br>设置两个缓冲区的目的是，在遇到如A非空B空的情况时，读写操作可以并行执行<br>另外，在遇道两机通信时：<br><img src="https://img-blog.csdnimg.cn/7aa3106d85b3468295df4a393d8ae658.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="缓冲区在两机通信中的应用"><br>上图中的两台机器都只有单缓冲区，这意味着它们同一时间只能单向通信<br>而双缓冲就是：<br><img src="https://img-blog.csdnimg.cn/e9520ba9ad9244bb9620f32831134e0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="双缓冲区在两机通信时的优势"><br>其实，上篇提到过的<strong>管道通信</strong>中的<strong>管道就是缓冲区</strong><br>而上述两机通信的情形，就是管道通信</p></blockquote><p><strong>循环缓冲</strong></p><blockquote><p>将多个大小相等的缓冲区链接成一个循环队列<br><img src="https://img-blog.csdnimg.cn/f236aaf7b4804a5e8d8ece7b0411d26d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="循环缓冲"></p></blockquote><p><strong>缓冲池</strong><br><img src="https://img-blog.csdnimg.cn/4d35c1577c334b75972dca8484e95296.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="缓冲池"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex学习笔记</title>
      <link href="/2021/11/01/vuex/"/>
      <url>/2021/11/01/vuex/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到身边的大佬一个二个的秀到飞起，我也要加把劲才是</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>什么是Vuex？</p><blockquote><p>Vuex是一个专为Vue.js应用开发的状态管理模式（与Vue 3.x对应的是Vuex 4），</p><p>采用集中式存储管理应用的所有组件的状态，并且已响应的规则来保证状态以一种可以预测的方式发生变化。</p><p>Vuex集成到Vue的官方调试工具devtools extension，提供了诸如零件配置的time-travel调试、状态快照导入导出等高级调试功能</p></blockquote><p><strong>那么什么又是状态管理模式呢？</strong></p><p><img src="C:\Users\MSI-pc\AppData\Roaming\Typora\typora-user-images\image-20211101174925189.png" alt="image-20211101174925189"></p><p>由于vue提倡的是单向数据流，如果组件与组件层层嵌套，那么利用父子间通信的方式进行数据传递就相当麻烦</p><p>（其实也可以通过 发布和订阅 来解决这种问题）</p><p>vuex就相当于给所有需要数据通信的组件创建一个公共的父级，这样进行数据传递的话就快多了</p><p>（但是使用Vuex的成本比较高，所以只有中大型项目才使用）</p><blockquote><p>“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：</p><ol><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li></ol></blockquote><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>先创建这么一个结构</p><p><img src="C:\Users\MSI-pc\AppData\Roaming\Typora\typora-user-images\image-20211102021222629.png" alt="image-20211102021222629"></p><p><img src="C:\Users\MSI-pc\AppData\Roaming\Typora\typora-user-images\image-20211102023154400.png" alt="image-20211102023154400"></p><p><img src="C:\Users\MSI-pc\AppData\Roaming\Typora\typora-user-images\image-20211102024100820.png" alt="image-20211102024100820"></p><p><img src="C:\Users\MSI-pc\AppData\Roaming\Typora\typora-user-images\image-20211102023317457.png" alt="image-20211102023317457"></p><p>其中，如果是同步的内容，那么可以用dispatch或commit，异步只能dispatch</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p><img src="C:\Users\MSI-pc\AppData\Roaming\Typora\typora-user-images\image-20211101180019687.png" alt="image-20211101180019687"></p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><h4 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h4><p>用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (<a href="https://en.wikipedia.org/wiki/Single_source_of_truth">SSOT (opens new window)</a>)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段</p><h4 id="在-Vue-组件中获得-Vuex-状态"><a href="#在-Vue-组件中获得-Vuex-状态" class="headerlink" title="在 Vue 组件中获得 Vuex 状态"></a>在 Vue 组件中获得 Vuex 状态</h4><p>那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在<a href="https://cn.vuejs.org/guide/computed.html">计算属性 (opens new window)</a>中返回某个状态：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Counter 组件</span></span><br><span class="line"><span class="keyword">const</span> Counter = {</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;{{ count }}&lt;/div&gt;`</span>,</span><br><span class="line">  <span class="attr">computed</span>: {</span><br><span class="line">    count () {</span><br><span class="line">      <span class="keyword">return</span> store.state.count</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每当 <code>store.state.count</code> 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。</p><p>Vuex 通过 <code>store</code> 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 <code>Vue.use(Vuex)</code>）：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue({</span><br><span class="line">  <span class="attr">el</span>: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  <span class="comment">//这个写法是es6的简写，相当于store:store</span></span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">components</span>: { Counter },</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="app"&gt;</span></span><br><span class="line"><span class="string">      &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>通过在根实例中注册 <code>store</code> 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 <code>this.$store</code> 访问到。让我们更新下 <code>Counter</code> 的实现：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = {</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;{{ count }}&lt;/div&gt;`</span>,</span><br><span class="line">  <span class="attr">computed</span>: {</span><br><span class="line">    count () {</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a><code>mapState</code> 辅助函数</h3><p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> { mapState } <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: mapState({</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    <span class="attr">count</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class="line">    <span class="attr">countAlias</span>: <span class="string">'count'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState (state) {</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="built_in">this</span>.localCount</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">'count'</span></span><br><span class="line">])</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: {</span><br><span class="line">  doneTodosCount () {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。</p><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>Getter 接受 state 作为其第一个参数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  <span class="attr">state</span>: {</span><br><span class="line">    <span class="attr">todos</span>: [</span><br><span class="line">      { <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> },</span><br><span class="line">      { <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> }</span><br><span class="line">    ]</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">getters</span>: {</span><br><span class="line">    <span class="attr">doneTodos</span>: <span class="function"><span class="params">state</span> =&gt;</span> {</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="通过属性访问"><a href="#通过属性访问" class="headerlink" title="通过属性访问"></a>通过属性访问</h4><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// -&gt; [{ id: 1, text: '...', done: true }]</span></span><br></pre></td></tr></tbody></table></figure><p>Getter 也可以接受其他 getter 作为第二个参数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">doneTodosCount</span>: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</strong></p><h4 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h4><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p><p>（这个方法真的是震撼我一年）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getters: {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">getTodoById</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">store.getters.getTodoById(<span class="number">2</span>) <span class="comment">// -&gt; { id: 2, text: '...', done: false }</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</strong></p><h4 id="mapGetters辅助函数"><a href="#mapGetters辅助函数" class="headerlink" title="mapGetters辅助函数"></a>mapGetters辅助函数</h4><p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { mapGetters } <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: {</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">'doneTodosCount'</span>,</span><br><span class="line">      <span class="string">'anotherGetter'</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><p>（待续）</p><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios学习笔记</title>
      <link href="/2021/10/26/axios/"/>
      <url>/2021/10/26/axios/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>axios是对ajax的高度封装，也是vue推荐的通信方式，有大量的请求方式，所以很重要</p><p>（更完这篇我就去更新操作系统的内容了，有兴趣的同学可以点击下方链接查看）</p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/120575984">😘<font color="#ff6700">本科操作系统笔记（持续更新)：万字长文一篇搞定</font></a></p><p>另外，以后我的文章会优先发布到我的个人博客上，之后再挑选一部分发布C站。欢迎大家访问:</p><p><a href="https://serio.gitee.io/">😘<font color="#ff3377">本科操作系统笔记（持续更新)：万字长文一篇搞定</font></a></p><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>axios什么意思</strong></p><blockquote><p>axios 是 ajax i/o system的缩写，即”**异步 JavaScript 和 XML 输入输出 系统”</p><p>是一个基于promise网络请求库，作用域node.js和浏览器中。</p></blockquote><p><strong>前置准备</strong></p><p>首先得建立一个vue项目，然后安装相关依赖</p><p>如果不清楚vue基础知识的话可以阅读我的博客：<a href="https://blog.csdn.net/Serio_gugugu/article/details/119416221"><font color="#faee00">Vue全家桶学习笔记_零基础入门到入坑:Vue篇</font></a></p><p>这里我们采用的是vue-cli，语法是vue3.x</p><p>此处建议使用vue的GUI项目管理器进行创建，顺便把axios的相关依赖安装上（当然，使用npm或者yarn安装都行)</p><p>打开vue的GUI项目管理器只需要用cmd打开命令控制符然后输入下方的指令即可</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></tbody></table></figure><p>GUI的话就把<strong>依赖和插件</strong>都装上就行了</p><p><img src="C:\Users\MSI-pc\AppData\Roaming\Typora\typora-user-images\image-20211023160417870.png" alt="image-20211023160417870"></p><hr><h2 id="原生ajax示例"><a href="#原生ajax示例" class="headerlink" title="原生ajax示例"></a>原生ajax示例</h2><p>下面段代码就是原生js写的ajax请求，请求的内容是本地的json文件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">httpRequest = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">           </span><br><span class="line"><span class="keyword">if</span> (!httpRequest) {  </span><br><span class="line">    alert(<span class="string">"创建请求失败"</span>);      </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">httpRequest.open(<span class="string">"GET"</span>, <span class="string">"./JSONtest.json"</span>);</span><br><span class="line">           </span><br><span class="line">httpRequest.send();</span><br><span class="line"></span><br><span class="line">httpRequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{       </span><br><span class="line">    <span class="keyword">if</span> (httpRequest.readyState === <span class="number">4</span>) {         </span><br><span class="line">        <span class="keyword">if</span> (httpRequest.status === <span class="number">200</span>) {  </span><br><span class="line">            <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(httpRequest.responseText);              </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'AJAX'</span> + data[<span class="string">'key'</span>]);</span><br><span class="line">                        <span class="comment">//别忘了和data.key的区别             </span></span><br><span class="line">        }          </span><br><span class="line">        <span class="keyword">else</span> {              </span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">'请求失败'</span>);            </span><br><span class="line">        }          </span><br><span class="line">    }          </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="使用axios"><a href="#使用axios" class="headerlink" title="使用axios"></a>使用axios</h2><p>axios封装了很多通信方式</p><table><thead><tr><th>名称</th></tr></thead><tbody><tr><td>request</td></tr><tr><td><strong>get</strong></td></tr><tr><td><strong>post</strong></td></tr><tr><td>delete</td></tr><tr><td>head</td></tr><tr><td>options</td></tr><tr><td>put</td></tr><tr><td>patch</td></tr></tbody></table><h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><p>以下两种写法都是可以的</p><p>(url随便给的，赋值粘贴之后记得换成后端的接口，或者本地的文件路径之类的)</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axiosGetTest = <span class="function">() =&gt;</span> {</span><br><span class="line">        axios.get(<span class="string">'http://rap2api.taobao.org/xxx'</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">          <span class="built_in">console</span>.log(res.data)</span><br><span class="line">        }).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">          <span class="built_in">console</span>.log(error)</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> axiosGetTest2 = <span class="function">() =&gt;</span> {</span><br><span class="line">      axios({</span><br><span class="line">        <span class="attr">method</span>: <span class="string">'get'</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">'http://rap2api.taobao.org/xxx'</span>,</span><br><span class="line">      }).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(res.data)</span><br><span class="line">      }).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">      })</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>get方法还可以写第二个参数，那就时配置信息</p><p>可以按住ctrl+鼠标左键点击get方法看源码，再如此操作第二个参数，就可以查看能够填写哪些内容作为第二个参数</p><p>这里我们加一个params，就可以实现传参了</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axiosGetTest = <span class="function">() =&gt;</span> {</span><br><span class="line">        axios.get(<span class="string">'http://rap2api.taobao.org/app/mock/292586/user/list'</span>,{</span><br><span class="line">          <span class="attr">params</span>: {</span><br><span class="line">            <span class="attr">username</span>: <span class="string">'千尊'</span>,</span><br><span class="line">            <span class="attr">id</span>: <span class="number">666</span></span><br><span class="line">          }</span><br><span class="line">        }).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">          <span class="built_in">console</span>.log(res.data)</span><br><span class="line">        }).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">          <span class="built_in">console</span>.log(error)</span><br><span class="line">        })</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>这里似乎没有用utf-8所以中文部分乱码了</p><p><img src="C:\Users\MSI-pc\AppData\Roaming\Typora\typora-user-images\image-20211023192211496.png" alt="image-20211023192211496"></p><p>get请求就是以这种拼接的形式传递数据</p><h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><p>依旧是两种，post和get相比就多了中间一个参数data</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axiosPostTest = <span class="function">() =&gt;</span> {</span><br><span class="line">      axios({</span><br><span class="line">          <span class="attr">method</span>: <span class="string">'post'</span>,</span><br><span class="line">          <span class="attr">url</span>:<span class="string">'http://rap2api.taobao.org/yyy'</span>,</span><br><span class="line">          <span class="attr">data</span>: {</span><br><span class="line">            <span class="string">"isOk"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"errMsg"</span>: <span class="string">"失败了诶1"</span></span><br><span class="line">          }</span><br><span class="line">      }).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(res.data)</span><br><span class="line">      }).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">      })</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> axiosPostTest2 = <span class="function">() =&gt;</span> {</span><br><span class="line">      axios.post(</span><br><span class="line">          <span class="string">'http://rap2api.taobao.org/yyy'</span>,</span><br><span class="line">          {</span><br><span class="line">            <span class="string">"isOk"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"errMsg"</span>: <span class="string">"失败了诶2"</span></span><br><span class="line">          },</span><br><span class="line">          {}).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(res.data)</span><br><span class="line">      }).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">      })</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><img src="C:\Users\MSI-pc\AppData\Roaming\Typora\typora-user-images\image-20211023194416353.png" alt="image-20211023194416353"></p><p>信息是以请求头+请求体的形式发送的</p><p>当然还有其他通信方式，它们的专长不一样，但是使用方式类似，这里就不再赘述了</p><h2 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h2><p>什么是并发？</p><p>如果不清楚的话可以参考我放在文章开头的<strong>操作系统笔记</strong>，系统地学习并发并行异步等专业术语</p><p>如果知道什么是并发的话，那么请接着往下看</p><p>并发请求要用到axios.all方法，其返回结果是一个数组，可以用axios.spread将数组的值展开</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axiosAll =  <span class="function">() =&gt;</span> {</span><br><span class="line">  axios.all([</span><br><span class="line">      axios.get(<span class="string">'http://rap2api.taobao.org/app/mock/292586/user/list'</span>),</span><br><span class="line">      axios.post(<span class="string">'http://rap2api.taobao.org/app/mock/292586/user/login'</span>)</span><br><span class="line">  ]).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> res){</span><br><span class="line">      <span class="built_in">console</span>.log(i.data);</span><br><span class="line">    }</span><br><span class="line">  }).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>至于axios.spread方法，感觉很多时候没什么用，还不如for循环，所以这里就不再演示了</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/24/myself/"/>
      <url>/2021/10/24/myself/</url>
      
        <content type="html"><![CDATA[<p>我是一个学习前端开发的学生，很菜</p><h2 id="可别忘了怎么使用HEXO"><a href="#可别忘了怎么使用HEXO" class="headerlink" title="可别忘了怎么使用HEXO"></a>可别忘了怎么使用HEXO</h2><h2 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
