<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript</title>
      <link href="/2022/03/31/javascript/"/>
      <url>/2022/03/31/javascript/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="一堆废话"><a href="#一堆废话" class="headerlink" title="一堆废话"></a>一堆废话</h3><p>最近事情挺多的，好几个项目还得继续赶进度，各个学科的作业也得完成，还有一些PPT要做，另外还有很多活动要安排、交各种表、找各种负责人，后面很快也有比赛要打</p><p>不过挤一挤总是有时间的</p><p>言归正传，JS是很重要的，比如让一个后端的问前端会些什么：</p><blockquote><p>“HTML，CSS，JS，ES…“——”那不还是JS吗“<br>“TS..“——“那不还是JS吗”<br>“Node…”——“那不还是JS吗”<br>“Vue-React-Angular…”——“那不还是JS吗”<br>“Next-Nuxt”——“那不还是JS吗，我会CURD不比你H5C3JS厉害？”</p></blockquote><p>虽然槽点很多，但是仔细一想可能真是这样，万物都是JS</p><p>以前写过一篇JS笔记的草案，但是写得实在太烂，决定废掉重新写一篇，这是废掉那篇的前言部分:</p><blockquote><p>现在是2022/01/28 3:11 AM</p><p>四个小时前初步完成了一个项目并上传了git</p><p>作为一名前端学习者，我对JavaScript是又爱又恨，爱是慨叹其功能强大，恨则是这些功能中充斥了各种稀奇古怪的让人难以捉摸的特性</p><p>但是JS黄书上说的很好，垃圾的不是JS，而是不懂JS特性的人</p><p>学好JS，对于一个前端开发者来说是必要的——我虽然总是说JS是垃圾语言，但是我并不喜欢听到别人这么说，因为我这里是心口不一的，我本身还是非常喜欢这门语言的，它的独特性让我非常欣赏——我也快编不下去了，所以在我词穷之前我要结束这段冗余的开场白——接下来，希望看到这篇博文的各位认真学习JS！</p><p>本文侧重本人复习之用，内容并不系统。</p></blockquote><p>而现在我觉得我还是要系统的写一写JS基础部分的笔记，所以再写一段话为本篇拉开序幕</p><blockquote><p>前面提到了万物都是JS，这也反映了JS举足轻重的地位。<br>但是JS作为一个设计到使用只用了10天的语言，问题实在是太多，之后相当长一段时间内的标准也是极其<strong>混乱</strong>。<br>这个混乱是两个方面而言的——一是说奇怪的语法和特性，另一是说其高度的无羁自由</p><p>“一切能用JS实现的内容，最终都会以JS实现”</p><p>JS功能强大，但是要学好并不容易，要是谁说他精通JS，那我觉得他要么是一叶障目，要么就是行业顶尖——我到现在应该是看了至少200小时的JS视频，书也是看过几本权威著作（虽然很多看不懂），网上看的各种资料更是不计其数，然而我现在感觉我终于看到了JS的冰山一角</p><p>用10天创造出JS的那个男人，绝对想不到这个被他自己厌恶的语言会蓬勃发展至今。<br>我对JS的看法就是，JS是世界上最垃圾，但是也是最好的语言。</p><p>之前我花了一个多月的时间整理以前学到的JS知识，起初我是直接写到markdown上，但是我发现这样不系统也很难组织，所以我选择灵活度更高的手写，现在再基于手写记录的内容将这份笔记发到博客上。</p><p><strong>本篇博客主要是JS基础知识，严格模式 和 with关键字 等部分当今较为少见的内容不做讨论。</strong></p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/28</strong><br>开始写了一些内容，但是后来作废了<br><strong>2022/03/31</strong><br>一个多月以来手写整理到了笔记本上，现在依据其内容整理到博客上<br>更新了数据类型部分，手都给我敲痛了，纸上写的不到一页，打字就敲了4000字..<br><strong>2022/04/01</strong><br>更新JavaScript基础部分，更新到了DOM，增加3000+字</p></blockquote><h2 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><p>如果看过我曾经写的HTML&amp;&amp;CSS，那么你可能知道margin塌陷的历史由来，也才能真正理解它而不只是把它看做一种现象</p><p>同样的，JS也需要我们知道它的一些历史，这样才能更好地知道它为什么这么<strong>混乱</strong></p><p>这里整理一些前端重大事件的历史年表</p><table><thead><tr><th>时间</th><th>事件</th></tr></thead><tbody><tr><td>1990</td><td>Tim巨佬发明世界上第一个浏览器ViolaWWW，仅支持纯文本，</td></tr><tr><td>1991</td><td>Tim巨佬发明世界上第一个网站，其内容用于解释WWW是什么、如何使用该网站等</td></tr><tr><td>1993</td><td>HTML1.0规范发布，但仅作为草案<br>Mosaic浏览器问世，是世界上第一个被大众使用且能显示图片的浏览器</td></tr><tr><td>1994</td><td>HTML2.0规范发布，正式投入使用<br>PHP诞生，最初是为了为了个人主页，原意是Personal Home Page<br>CSS的前身——CHSS层叠HTML样式表提出<br>Mosaic浏览器开发者成立Netspace公司，Mosaic改名为Navigator<br>Tim巨佬带领建立World Wide Web Consortium万维网联盟，即W3C<br>世界进入了Web1.0时代，信息能从服务器到客户端单向流通</td></tr><tr><td>1995</td><td>NetSpace公司发明Mocha，后改名LiveScript，再后来为了蹭Java热度改名JavaScript(一共用了10天)<br>JavaScript植入Navigator2.0正常运行<br>微软发布Internet Explor浏览器，即IE，第一次浏览器战争爆发<br>进入三剑客时代：DreamWeaver、FireWorks、Flash</td></tr><tr><td>1996</td><td>W3C发布CSS1.0规范<br>Microsoft公司发布VBScript和JScript并植入IE 3.0，用于抗衡NetSpace公司的JavaSscript</td></tr><tr><td>1997</td><td>W3C发布HTML3.2规范<br>NetSpace为了确保JavaScript的地位，使ECMA发布ECMAScript 1标准，以便进行国际标准化<br>W3C发布HTML4.0规范</td></tr><tr><td>1998</td><td>W3C发布CSS2.0规范<br>ECMA发布EMCAScript 2标准<br>Netspace公司创立Mozilla社区，埋下伏笔</td></tr><tr><td>1999</td><td>ECMA发布EMCAScript 3标准<br>JSP1.2规范发布<br>微软发布ActicveX，即AJAX的雏形</td></tr><tr><td>2000</td><td>第一次浏览器战争结束后的长草期，大赢家Microsoft公司的IE浏览器市场份额高涨，IE不再遵循W3C，成为事实标准<br>Microsoft公司发布safari浏览器</td></tr><tr><td>2001</td><td>W3C发布CSS 3.0规范</td></tr><tr><td>2004</td><td>Mozilla社区发布Firefox浏览器，被视为Netspace精神续作，第二次浏览器战争爆发，浏览器标准碎片化问题加剧<br>三剑客时代结束，仅有Flash苟延残喘</td></tr><tr><td>2005</td><td>AJAX出现，前端轻后端重的局面开始有所转变，世界进入了Web2.0时代，服务端客户端双向通信</td></tr><tr><td>2006</td><td>W3C将AJAX的XMLHttpRequest纳入标准<br>JQuery问世，开启了后端思维的前端开发模式</td></tr><tr><td>2008</td><td>Google公司发布Chrome浏览器，并开源chromium，第三次浏览器战争爆发<br>Google公司发布V8引擎，埋下伏笔<br>HTML5.0规范新特性逐一问世，它是HTML CSS JavaScript的下一代标准的统称</td></tr><tr><td>2009</td><td>以V8引擎为基础，NodeJS问世<br>ECMA发布ECMAScript 5.0规范</td></tr><tr><td>2010</td><td>Apple公司提出移动端开发的概念</td></tr><tr><td>2012</td><td>Microsoft发布TypeScript</td></tr><tr><td>2016</td><td>Angular-React-Vue三足鼎立局面形成<br>腾讯公司提出小程序开发的概念</td></tr><tr><td>2021</td><td>各种新技术的大爆发<br>碳苯开始学习前端</td></tr></tbody></table><p>总结，前端发展的过程非常乱，对于JS，官方有两个组织W3C和ECMA，分别从两个方面制定了JS的标准，而民间又由像IE这种不遵守标准的太爷，一时间语法是相当乱</p><p>而且JS它的设计者Brendan Eich，非常痛恨这个自己亲手造就语言——所以说早期的JS是真的…</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>JavaScript主要是由两个部分组成:</p><blockquote><p><strong>ECMAScript标准</strong><br>ECMA，欧洲计算机制造商协会（European Computer Manufacturers Association）的简称<br>规定了JavaScript语法的标准</p><p><strong>W3C标准</strong><br>W3C，万维网联盟(World Wide Web Consortium)的简称，<br>规定了WebAPI相关的标准，比如DOM和BOM</p><p>当然，两大官方标准在实际上可能并不被完全遵守，比如BOM的标准，<br>可能因为浏览器厂商不同而导致实际使用情况不同</p></blockquote><h3 id="ECMAScript标准部分"><a href="#ECMAScript标准部分" class="headerlink" title="ECMAScript标准部分"></a>ECMAScript标准部分</h3><blockquote><p>这部分是<strong>ES6以前的JS基础语法</strong>，指的是变量声明赋值、条件语句、循环语句等编程基础常识，<br>具体的语法<strong>可以通过观察之后的笔记进行了解，此处一笔带过不再赘述</strong></p><p>注意，为了讲述JS的各种特性，本篇我们都以ES5为准——比如声明方式我们都采用var<br>至于ES6的知识，可以参考我的另一篇博客，返回首页自习搜索即可浏览</p><p>另外，由于IE再过几个月就停运了，我们就不过多讨论兼容的方式了</p></blockquote><h4 id="声明及输入输出"><a href="#声明及输入输出" class="headerlink" title="声明及输入输出"></a>声明及输入输出</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token comment">// 初始化一个数字变量</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">'1234'</span><span class="token comment">// 初始化一个字符</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'asc'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token comment">// 初始化一个数组， 数组什么都能装</span><span class="token keyword">var</span> <span class="token function-variable function">d</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//初始化一个函数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'哈哈哈哈'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 调用这个函数</span><span class="token keyword">function</span> <span class="token function">e</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 声明一个函数e</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'哈哈哈哈'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 调用这个函数</span><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">// 初始化一个对象</span>    name<span class="token operator">:</span> <span class="token string">'张三'</span><span class="token punctuation">}</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">'请输入一个值'</span><span class="token punctuation">)</span> <span class="token comment">// 输入一个值</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token comment">// 在控制台(console)打印(log)上述变量</span><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token comment">// 在弹框中输出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环、条件语句"><a href="#循环、条件语句" class="headerlink" title="循环、条件语句"></a>循环、条件语句</h4><p>基本没有什么不一样</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">break</span>    <span class="token keyword">default</span><span class="token operator">:</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'others'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>这里再举例一些常用，相信大家的编程基础应该能够快速上手</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">in</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//关键字in，表示是否存在</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'yes'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token operator">:</span> <span class="token string">'张三'</span><span class="token punctuation">}</span><span class="token keyword">with</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 关键字with，表示基于某个对象</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">// 就是obj.name</span><span class="token punctuation">}</span><span class="token keyword">var</span> b<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">&gt;</span> <span class="token number">4</span> <span class="token operator">?</span> b <span class="token operator">=</span> <span class="token number">666</span> <span class="token operator">:</span> b <span class="token operator">=</span> <span class="token number">233</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token operator">++</span> b <span class="token operator">:</span> <span class="token operator">--</span> b<span class="token punctuation">)</span> <span class="token comment">// 三目运算 + 逗号运算，逗号运算取后者的值</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，剩下的一些，就不再赘述了，通过观察之后的代码，应该也能够直接上手</p><h3 id="W3C标准部分"><a href="#W3C标准部分" class="headerlink" title="W3C标准部分"></a>W3C标准部分</h3><p>主要是WebAPI，它主要由BOM构成，而BOM标准</p><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><h4 id="window概述"><a href="#window概述" class="headerlink" title="window概述"></a>window概述</h4><p>在浏览器中具有双重身份：</p><blockquote><p><strong>W3C标准中</strong><br>可以看做浏览器对象，代表着浏览器窗口，是BOM对象的核心<br><strong>ECMAScript标准中</strong><br>代表了全局对象<br>（实际上真正的全局对象是Global，但是Global.window = Global）</p></blockquote><blockquote><p>这里我没有使用’顶级对象’这个词，我个人认为顶级对象应该是Object.prototype<br>若说window或者global是顶级对象，那应该是从其’社会工作‘这个方面上去阐述的；<br>而Object.prototype是顶级对象则是从物种进化这个方面阐述的</p></blockquote><p>所有在全局声明的变量和函数都将自动成为window上的属性</p><p>当然，window也自带了巨量属性和方法</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168421780e0b79b3e30ce42719b8b4e953d46c2ab34857471980e/0.png" alt="window上的部分属性和方法"> </p><p>相当之多，这里我们只会挑出一些重要的分析</p><h4 id="window的次级对象"><a href="#window的次级对象" class="headerlink" title="window的次级对象"></a>window的次级对象</h4><p>window是浏览器的全局对象，其上还挂载着其他二级对象，主要有</p><blockquote><p><strong>history</strong><br>历史对象，负责历史记录这部分的操作</p><ul><li>length 历史记录的长度</li><li>forward() 前进1个页面</li><li>back() 后退1个页面</li><li>go(n) 前进n个页面，n可以为负数</li></ul><p><strong>location</strong><br>地址栏对象，负责地址栏部分的操作</p><ul><li>href 当前URL(Uniform Resource Locato)</li><li>port 当前端口号</li><li>protocal 当前的协议</li><li>search URL字符串拼接携带的参数</li><li>hash 锚点</li><li>assign() 跳转到新的页面(类似于push)</li><li>replace() 替换当前页面（类似于修改top）</li><li>reload() 刷新当前页面，可以传参true进行强制刷新</li></ul><p><strong>navigator</strong><br>导航栏对象</p><ul><li>userAgent 浏览器的信息对象，可以用于判断设备</li></ul><p><strong>screen</strong><br>电脑显示屏对象（真的就是电脑屏幕而不是浏览器窗口)</p><ul><li>width 就是显示屏的宽度</li><li>height 就是显示屏的高度</li></ul><p><strong>document</strong><br>即DOM的核心对象，后面<code>DOM章节</code>单独分析</p></blockquote><h4 id="window的常用属性方法"><a href="#window的常用属性方法" class="headerlink" title="window的常用属性方法"></a>window的常用属性方法</h4><blockquote><ul><li>moveTo(x, y), moveBy(x, y)<br>移动浏览器窗口</li><li>outerWidth/outerHeight, innerWidth/outterHeight<br>浏览器大小，视口大小</li><li>resizeTo(x, y), resizeBy(x, y)<br>设置浏览器大小</li><li>scrollTo(x, y), scrollBy(x, y), scroll(x, y)<br>滚动滚动条</li><li>setTimeout(), setInterval(), clearTimeout(), clearInterval()<br>定时器，后面<code>事件轮询机制</code>章节细说</li></ul></blockquote><h3 id="DOM-待续"><a href="#DOM-待续" class="headerlink" title="DOM(待续)"></a>DOM(待续)</h3><p>其实是BOM的一个子级，上述内容也说了，DOM的核心对象document是window的次级对象，但是由于DOM相较于其他几个次级对象，更加重要，所以我们单独开辟一个章节讨论它。</p><blockquote><p>虽然从章节目录结构上看DOM和BOM是平级的，但是一定要记住，BOM是DOM的parent</p></blockquote><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h3 id="浏览器机制"><a href="#浏览器机制" class="headerlink" title="浏览器机制"></a>浏览器机制</h3><h2 id="数据类型概述"><a href="#数据类型概述" class="headerlink" title="数据类型概述"></a><strong>数据类型概述</strong></h2><p>JS是解释性弱类型语言，在声明的时候不会区分数据类型，但是这并不意味着JS没有数据类型</p><p>这里先来一个简单的了解，部分需要深入的数据类型放到后面讨论</p><p>JS中所有的变量无论类型，都可以通过至少两种方式(构造函数式 和 字面量赋值式)初始化</p><p>例如</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span> <span class="token comment">// 字面量赋值式</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token comment">// 构造函数式 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="JS中的内存模型"><a href="#JS中的内存模型" class="headerlink" title="JS中的内存模型"></a>JS中的内存模型</h3><p>严格地说，JS并没有区分堆栈内存，但是我们依旧把它看做是两个部分——堆内存，栈内存，这样有助于我们理解JS对于不同数据类型的处理，以及如何进行内存管理</p><blockquote><p>另外，不知道大家有没有想过，栈内存之所以叫做栈内存是因为可以把它看成一个栈，那么问题来了，堆内存和堆有什么关系呢？</p><p>答案是，现代意义上的堆内存和堆没有关系。</p></blockquote><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote><p>基本数据类型，也叫简单数据类型、值类型<br>特点是，存储在栈内存中</p></blockquote><p>先来一个基本数据结构总览</p><blockquote><p>Number（数字）<br>String（字符串）<br>null（空）<br>Boolean （布尔）<br>undefined（未定义）<br>Symbol（唯一值）（本文不进行讨论，详情参阅ES6部分）<br>BigInt（大数）（本文不进行讨论，后续ES10再补充）</p><p>基本数据结构 =&gt; NS-USB-NB </p></blockquote><p>简单提一提</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>这里要和C/C++等语言中的字符串类型区别，这个区别我们需要在心里大喊三遍：</p><blockquote><p>JS中，String是基本数据类型，具有不可变性<br>JS中，String是基本数据类型，具有不可变性<br>JS中，String是基本数据类型，具有不可变性</p></blockquote><p>但是我们依然可以通过下标去访问一个字符串，不过并不支持地址偏移的形式去访问</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'Hello~~JavaScript'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 不能像str[1] = 'a'这样修改字符串</span><span class="token comment">// 这就是字符串的不可变性</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><h5 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h5><p>JS非常体贴为我们提供了2 8 10 16进制的语法糖</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token number">0B10100</span><span class="token keyword">var</span> num8 <span class="token operator">=</span> <span class="token number">024</span><span class="token keyword">var</span> num10 <span class="token operator">=</span> <span class="token number">20</span><span class="token keyword">var</span> num16 <span class="token operator">=</span> <span class="token number">0x14</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num2<span class="token punctuation">,</span> num8<span class="token punctuation">,</span> num10<span class="token punctuation">,</span> num16<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述输出结果都是10进制的20</p><h5 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h5><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span> <span class="token comment">// 1.7976931348623157e+308</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">)</span><span class="token comment">// 就是上述第一个值的整数表示</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span><span class="token punctuation">)</span><span class="token comment">// 默认最小阈值,2.220446049250313e-16</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token constant">POSITIVE_INFINITY</span><span class="token punctuation">)</span><span class="token comment">// 无穷大，Infinity</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token comment">// 无穷大，Infinity</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 无穷大，Infinity</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token comment">// 非数字，NaN，Not a Number</span><span class="token comment">// 冠词简写时不大写</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无穷小那就是0，负无穷大就是-Infinity，NaN用于标记运算的非数字结果，它们都被视为Number类</p><h5 id="NaN的判断"><a href="#NaN的判断" class="headerlink" title="NaN的判断"></a>NaN的判断</h5><p>至于结果是否为NaN，可以通过两种方式判断</p><p>isNaN()和Number.isNaN()</p><blockquote><p>前者是Window.isNaN()，它们的判断标准不太一样，前者并不是后者的语法糖</p><p>注意，不能用==或===判断NaN，就像是无穷大不等于无穷大一个道理</p></blockquote><p>它们的区别在于：</p><blockquote><p>Number.isNaN()<br>宽泛标准，会用尽一切办法对判断的数据进行类型转换直到数据变成Number类型，或者没有方法可用，才会得出判断结果</p><p>isNaN()<br>严格标准，直接判断而不会试图转换数据类型</p></blockquote><p>这就意味着，如果Number.isNaN()判断的结果为true，那么传入的数据就绝对无法通过JS类型转换变成Number</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">'123asdasdas'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'123asdasdas'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 123，意味着可以转化</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">'123asdasdas'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>一样的，我们需要默念</p><blockquote><p>JS中，null是基本数据类型，字母小写！<br>JS中，null是基本数据类型，字母小写！<br>JS中，null是基本数据类型，字母小写！</p></blockquote><p>null最早是作为空对象的占位符，但是null本身不是对象，也不是引用数据类型，所以{}==null返回false</p><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>布尔类型，依旧存在隐式类型转换 非0即1</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">233</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">233</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 最后全都运行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>未定义，标记未定义的变量，也是全小写</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> aconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment">// undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token comment">// 报错: b is not defined </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">undefined</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">undefined</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">undefined</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>区别undefined和xxx is not defined还是不难，前者是一个值，后者是一个报错</p><p>至于0, null, undefined, false, 空数组，空对象之间到底存在怎样诡异的关系后面再提</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><blockquote><p>引用数据类型，也叫复杂数据类型</p><p>特点是，把值放到堆内存，栈内存只存值的引用</p></blockquote><p>先来个总览：</p><blockquote><p>Object（后面的都可以看做特殊的Object）<br>       Array (数组，存数据的有序Object)<br>    Date（日期对象，和日期相关的Object)<br>    RegExp（正则表达式，和正则相关的Object）<br>    Function （传说中的函数，和Object关系混乱）</p><p>以及（当然这些还是特殊的Object）</p><p>所有 基本数据类型的包装类 (Number, String…，除了undefined和null以外的基本数据类型都有)<br>所有 单体内置对象 (global，Math等已经new过了的)</p></blockquote><p>这里就是万物皆对象的体现之一的，由于引用数据类型的知识体系实在过于庞大，此处先简单介绍概念，Array、Date等在另外的章节深入讨论</p><h4 id="基本数据类型的包装类"><a href="#基本数据类型的包装类" class="headerlink" title="基本数据类型的包装类"></a>基本数据类型的包装类</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'xyz'</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ['x', 'y', 'z']</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的’xyz’明明是一个基本数据类型String，为什么可以使用可以用类似对象调用自身方法的形式去使用split()方法呢？</p><p>原理参见后续的原型和原型链,现在只用知道这里存在一个概念叫基本数据类型的包装类，可以理解为’xyz’的split()方法是从包装类String上继承下来的</p><blockquote><p>除了null和undefined之外，基本数据类型都有对应的包装类</p></blockquote><h4 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h4><p>比如Math，window，global对象，window是浏览器的顶级对象，而global是全局对象，它们之间的关系我们在BOM部分进行讨论，这里只说Math</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 产生随机数,范围是[0,1)</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 最大值</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 最小值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面提到了包装类，这里是内置对象，这就意味着Math不是构造函数而已经是实例化过了，所以不需要new就能直接使用</p><p>其他常见单体内置对象:</p><blockquote><p>global全局对象，其上有个著名属性window，global.window = window<br>具体细节参考后续执行上下文</p></blockquote><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h4><p>要转换数据类型之前，我们先要有判断数据类型的方法:</p><blockquote><p>typeof<br>返回变量类型<br>用法类似于sizeof，或许也是运算符吧<br>能够准确判断null以外的基本数据类型，<br>遵循以下规则</p><ul><li>null判断为object（历史遗留Bug）</li><li>函数/方法判断为function</li><li>其余引用类型全部判断为object</li></ul><p>instanceof<br>返回一个布尔值<br>用法是：a instanceof A ，判断a是否为A的实例对象（或者说A是否为a的构造函数）<br>基本数据类型传入返回false</p><p>tip：<br>如果是以字面量赋值形式创建的基本数据类型变量，则没有构造函数；<br>以构造函数创建的基本数据类型变量，实质上是对象，是引用数据类型。</p></blockquote><p>另外，这里附上instanceof的底层实现</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> <span class="token constant">A</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> a <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> a <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取a.__proto__</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                          <span class="token keyword">if</span><span class="token punctuation">(</span>proto <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>proto <span class="token operator">===</span> <span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeof</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码看着有那么多，其实就是什么，就是遍历链表找有无目标值嘛<br>（当然，首先要判断一下是不是对象，不是对象那肯定没有构造函数的说）<br>找到null就是遍历完了都没找到目标值，就返回false；找到了自然就返回true</p><h4 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h4><h5 id="转换为Number"><a href="#转换为Number" class="headerlink" title="转换为Number"></a>转换为Number</h5><blockquote><p>其他类型转显式换成Number有三个方法：<br>Number() ==&gt; 处理任意类型<br>parseInt(), parseFloat() ==&gt; 主要处理字符串</p></blockquote><p>​    这里说明一下Number.parseInt和parseInt的关系：</p><blockquote><p>一开始只有parseInt，后来ES6规范来了，觉得你这不对啊，怎么一个裸的方法挂window上啊——然后parseInt就被扔到Number上 了。但是为了向后兼容，parseInt就像是种民俗习惯一样被保留下来了。</p><p>它们在效果上没有区别。</p></blockquote><blockquote><p>Number()转换</p><p>1.对于Boolean，true、false分别返回1、0<br>2.对于Number，返回原值<br>3.对于null，返回0<br>4.对于undefined，返回NaN<br>5.对于String：</p><ul><li>如果字符串只包含 数字以及正负号，就尽可能转为符合人类思维的正确的值。即：“1”返回1，“3413”返回3413，’’-33”返回-33，‘-011’返回-11</li><li>如果字符串中包含 有效的小数格式，则转换为对应的小数，同样地会忽略掉前缀0</li><li>有效的16/8/2进制格式，返回对应大小的十进制数值</li><li> 如果是 空串或者空格串，返回0</li><li> 非以上格式的字符串返回NaN</li></ul><p>6.如果是Object:</p><ul><li>先处理其valueof方法的返回值，按照前面的规则返回值。如果返回值为NaN，则处理其toString()方法的返回值，把结果放入Number()进行转换，再按前面的规则返回值</li></ul></blockquote><blockquote><p>parseInt()转换</p><p>1.对于String:</p><ul><li>忽略所有前置空格后，第一个字符如果是 数字 或 正负号，<br>则继续向后读取，直到解析到非数字字符为止；</li><li>忽略所有前置空格后， 第一个字符如果不是 数字或正负号，则返回NaN<br>(空串也是NaN)</li></ul><p>2.对于Number:</p><ul><li>若为16进制或10进制，则返回对应的10进制值</li><li>可传入第二个参数，取值范围是[2,36]，表示第一个参数所采用的进制，然后返回其10进制值。<br>这种情况下，第一个参数可以省略进制的特殊标识，比如’0x’,’0b’等<br>比如 parseInt(‘ff’,16)  返回 256    </li></ul></blockquote><blockquote><p>parseFloat()转换</p><p>和parseInt一样，只是可以解析成浮点数。<br>parseFloat不支持第二个参数。</p></blockquote><h5 id="转换为String"><a href="#转换为String" class="headerlink" title="转换为String"></a>转换为String</h5><p>其他类型显示转换成String有两种方法</p><blockquote><p>toString()<br>除了null和undefined之外，其他数据类型都有toString方法<br>（包括String类型，String类型调用的话则可以返回深拷贝的副本)<br>字面量不可直接调用，需要用由变量调用</p><p>String()<br>可以把任何值传入该函数，该函数会返回对应的字符串</p></blockquote><h5 id="转换为Boolean"><a href="#转换为Boolean" class="headerlink" title="转换为Boolean"></a>转换为Boolean</h5><blockquote><p>Boolean()</p><ul><li>false，0，NaN，空串，null，undefined返回false</li><li>其他值都转换为true。（[]和{}也是true)</li></ul></blockquote><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><h5 id="运算中的隐式类型转换"><a href="#运算中的隐式类型转换" class="headerlink" title="运算中的隐式类型转换"></a>运算中的隐式类型转换</h5><p>几乎所有隐式类型转换发生在表达式计算中</p><p>根据表达式的具体情况决定到底是转化为Number、String、Boolean或者其他东西</p><blockquote><ol><li>与String进行运算</li></ol><ul><li><p>运算符为+、+=、++时，发生字符串拼接</p></li><li><p>其他运算符: </p><ul><li>字符串由数字和正负号构成，则发生算术运算，返回计算结果</li><li>字符串含有 数字和正负号 以外的符号，返回NaN</li></ul></li></ul><ol start="2"><li>与Boolean进行运算</li></ol><ul><li>true转为1， false转为0，再进行算术运算，返回计算结果</li></ul><ol start="3"><li>与Obejct运算</li></ol><ul><li>先与对象valueOf()的返回值进行运算，若为NaN，则再与对象toSting()的返回值进行运算，依照上述规则返回运算结果</li></ul></blockquote><h5 id="逻辑判断中的隐式类型转换"><a href="#逻辑判断中的隐式类型转换" class="headerlink" title="逻辑判断中的隐式类型转换"></a>逻辑判断中的隐式类型转换</h5><p>要记得有这种转换方式<br>就是在 if，while，do-while 里的 各种逻辑判断运算 中会把值转为Boolean</p><blockquote><ol><li><p>对于String</p><ul><li>若为空串，则返回false；否则为true</li></ul></li><li><p>对于Number</p><ul><li>非0即1</li></ul></li><li><p>对于undefined、null、NaN</p><ul><li>返回false</li></ul></li><li><p>对于{}，[]</p><ul><li>返回true</li></ul></li></ol></blockquote><p>另外，这里再补充一下JS的逻辑大小判断规则</p><blockquote><ul><li>Number之间，则进行数字大小比较。</li><li>String之间，比较字典序，注意a &lt; b，这里是升序</li><li>Boolean之间，则先把布尔值转换为数字进行比较。</li><li>Number和String，则先把字符串转换为数字进行比较。如果字符串的转换结果为NaN，NaN与任何类型的值都为false。</li><li>Object之间，先用valueOf()的返回值进行比较，如果不能有结果，再用toString()的返回值进行比较</li></ul></blockquote><h5 id="严格相同比较"><a href="#严格相同比较" class="headerlink" title="严格相同比较"></a>严格相同比较</h5><p>===三等号</p><blockquote><p>和==的区别及联系:</p><p>第一步： == 比较 两端数据类型，类型不同则进入第二步，类型相同则进入第三步<br>第二步： 发生一次类型转换，进入第三步<br>第三步：===比较，若为基本数据类型，则依次比较数据类型、数据值，出现不同立刻终止返回false，全部相同                则返回true；若为引用数据类型，则依次比较数据类型、数据值、地址，过程同上。</p></blockquote><p>典型例子</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">null</span> <span class="token operator">==</span> <span class="token keyword">undefined</span> <span class="token comment">// true, 都可以转为false和0</span><span class="token keyword">null</span> <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Object.is()<br>和三等号类似的，但是做了一定的调整，比如</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 这些例子和 === 判断的结果是相反</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span><span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token comment">// true</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>这两种严格比较最主要的区别也就是对上述两个值的比较了，其余效果基本一致</p></blockquote><p>Object.is()判断上述两者的关键代码如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 实现判断NaN等于NaN </span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">+</span>a <span class="token operator">!==</span> <span class="token operator">+</span>a<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">+</span>b <span class="token operator">!==</span> <span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token comment">// 实现判断+0和-0, 利用Infinity != -Infinity</span><span class="token number">1</span><span class="token operator">/</span><span class="token operator">-</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="面向对象基础（待更新）"><a href="#面向对象基础（待更新）" class="headerlink" title="面向对象基础（待更新）"></a>面向对象基础（待更新）</h2><p>其实说是面向对象吧，有点牵强附会了，因为面向对象三大特征是封装 继承 多态</p><p>ES6以前的JS似乎…说没有这些呢，它好像又可以模拟…但是总觉得怪怪的</p><p>此处的面向对象主要指的是研究 以Object为主要内容的引用数据类型</p><pre class="line-numbers language-胡言乱语" data-language="胡言乱语"><code class="language-胡言乱语">'面向对象' == '面向Object' // true'面向对象' === '面向Object' // false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="简单创建和访问"><a href="#简单创建和访问" class="headerlink" title="简单创建和访问"></a>简单创建和访问</h4><p>基础访问+迭代访问</p><h4 id="new关键字详解"><a href="#new关键字详解" class="headerlink" title="new关键字详解"></a>new关键字详解</h4><p>(以Date的实例化为例子并写一写Date相关的一些历史)</p><h2 id="面向对象进阶-（待更新）"><a href="#面向对象进阶-（待更新）" class="headerlink" title="面向对象进阶 （待更新）"></a>面向对象进阶 （待更新）</h2><p>这一部分有些内容看似和之前的内容重复，但实际上是进一步深入</p><p>从Object出发，能够对JS有一个更加深刻的认识</p><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="创建-4种"><a href="#创建-4种" class="headerlink" title="创建(4种)"></a>创建(4种)</h4><h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><h3 id="对象创建模式（7种）"><a href="#对象创建模式（7种）" class="headerlink" title="对象创建模式（7种）"></a>对象创建模式（7种）</h3><h3 id="继承模式（7-1种）"><a href="#继承模式（7-1种）" class="headerlink" title="继承模式（7 + 1种）"></a>继承模式（7 + 1种）</h3><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><h4 id="三种作用域"><a href="#三种作用域" class="headerlink" title="三种作用域"></a>三种作用域</h4><p>(指的是ES6以前)</p><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><h3 id="预处理机制"><a href="#预处理机制" class="headerlink" title="预处理机制"></a>预处理机制</h3><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><h4 id="两种上下文"><a href="#两种上下文" class="headerlink" title="两种上下文"></a>两种上下文</h4><h4 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h4><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuxt</title>
      <link href="/2022/03/24/nuxt/"/>
      <url>/2022/03/24/nuxt/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>仔细一想自己真是太菜了，太多技术没学，算法没刷，我真是何德何能自称一个程序员</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/03/24</strong><br>安装Nuxt，了解了基本概念</p><p><strong>2022/03/25</strong><br>开始使用Nuxt</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="CSR和SSR"><a href="#CSR和SSR" class="headerlink" title="CSR和SSR"></a>CSR和SSR</h3><p>CSR即客户端渲染，Client Side Render</p><p>SSR即服务端渲染, Server Side Render</p><p><strong>CSR</strong></p><blockquote><p>一开始没有数据，是通过前端模板（如Vue React等）引擎注入到页面内部，<br>不利于SEO，爬虫来的时候还没有太多数据</p></blockquote><p><strong>SSR</strong></p><blockquote><p>利用后端的渲染引擎（如Next， Nuxt），把我们提供的数据注入，然后完成渲染后将完整的页面结构返回，<br>数据无需再渲染，因为数据已经渲染完毕了<br>利于SEO，但是对服务器要求较高</p></blockquote><p>一般开发是CSR和SSR混合使用</p><h3 id="Vue的SPA结构的缺陷"><a href="#Vue的SPA结构的缺陷" class="headerlink" title="Vue的SPA结构的缺陷"></a>Vue的SPA结构的缺陷</h3><p>SPA结构优点是只需要做一次请求，缺点则是SEO不友好，除非渲染能够在服务端完成，这就是Node的真正用处——SSR服务端渲染</p><h3 id="渲染机制的探索历程"><a href="#渲染机制的探索历程" class="headerlink" title="渲染机制的探索历程"></a>渲染机制的探索历程</h3><p>最早的JSP和PHP就是纯SSR，后来有了CSR，现在又到了CSR+SSR</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="基本渲染"><a href="#基本渲染" class="headerlink" title="基本渲染"></a>基本渲染</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> Vue <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue'</span><span class="token punctuation">)</span><span class="token comment">// 创建一个Vue的实例</span><span class="token comment">// 注意这是Vue2.x才能new</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;HelloWorld&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">const</span> renderer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue-server-renderer'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 将Vue示例渲染成HTML</span><span class="token comment">// 渲染好了的html会被放入回调中</span>renderer<span class="token punctuation">.</span><span class="token function">renderToString</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> html</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> err    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>    <span class="token comment">// &lt;div data-server-rendered="true"&gt;HelloWorld&lt;/div&gt;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Promise化渲染"><a href="#Promise化渲染" class="headerlink" title="Promise化渲染"></a>Promise化渲染</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// renderToString在该包的2.5+版本中还支持promise</span>renderer<span class="token punctuation">.</span><span class="token function">renderToString</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">html</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>     <span class="token comment">// &lt;div data-server-rendered="true"&gt;HelloWorld&lt;/div&gt;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="响应到浏览器展示"><a href="#响应到浏览器展示" class="headerlink" title="响应到浏览器展示"></a>响应到浏览器展示</h3><p>这里我们使用express框架来做这个事情</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> Vue <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">'vue'</span><span class="token punctuation">)</span><span class="token keyword">const</span> server <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 注意express返回的是函数</span><span class="token comment">// 访问根目录时，创建一个Vue实例</span>server<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;HelloWorld&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">const</span> renderer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue-server-renderer'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    renderer<span class="token punctuation">.</span><span class="token function">renderToString</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">html</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token comment">// console.log(html)  </span>        res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">// 接下来访问localhost就好了</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3001</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器在3000端口上打开'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里就要提一下，res常用的方法一共有四种，分别是：</p><p><code>res.set()</code>, 可以设置响应头等信息</p><p><code>res.json()</code>   <code>res.end()</code>    <code>res.send()</code><br>三种方法都能响应给前端，但是它们有所区别</p></blockquote><h2 id="Nuxt框架基本概念"><a href="#Nuxt框架基本概念" class="headerlink" title="Nuxt框架基本概念"></a>Nuxt框架基本概念</h2><p>Nuxt是一个Vue-SSR框架</p><h3 id="npx安装Nuxt"><a href="#npx安装Nuxt" class="headerlink" title="npx安装Nuxt"></a>npx安装Nuxt</h3><p>npx是npm v5.2.0引入的一个新的命令，是一个npm包执行器、一个简单的Cli工具，目的是提高npm的使用体验<br>主要特点是：</p><blockquote><ol><li>npm是永久性安装，npx是临时安装用完后自动删除</li><li>命令语法有一定区别</li><li>npx可以执行文件，甚至可以直接开启静态服务器</li></ol></blockquote><p>当然，上述内容并非全部特点，但这里不准备着重介绍</p><p>好了，大概知道了npx是什么，我们就直接上手安装Nuxt框架</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npx create-nuxt-app@2 .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>Vue3对应的Nuxt3，这里用的Vue2，一定要装Nuxt2</p></blockquote><p>接下来就是一堆配置信息，比如项目名称、项目描述、作者等等</p><p>这是本次选择的内容，可以参考</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168422241f97df5fc4b087a32734068a9b791a30ccbda2291fee3/0.png" alt="Nuxt初始化配置"></p><h3 id="启动Nuxt"><a href="#启动Nuxt" class="headerlink" title="启动Nuxt"></a>启动Nuxt</h3><p>安装完后，我们直接npm run dev启动</p><blockquote><p>当然，也可以npm run build 然后 npm run start运行打包之后的文件</p><p>下面第一张图是Nuxt3的——没错，正如我一开始说的那样，我装错了</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168422241f97df5fc4b085551ecc00ebeacfb53389ceeaad7e84a/0.png" alt="Nuxt3"></p><blockquote><p>现在装回来——嗯，非常好，甚至还有汉化</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168429e59f0bacc4982505824e64878188df2f828ee111ef5e7ca/0.png" alt="Nuxt2"></p><h3 id="认识Nuxt生命周期"><a href="#认识Nuxt生命周期" class="headerlink" title="认识Nuxt生命周期"></a>认识Nuxt生命周期</h3><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168422241f97df5fc4b084f51f93b2695090f142102ddc27a893a/0.png" alt="Nuxt生命周期"></p><p><strong>在Render之后，才会开始Vue的生命周期</strong>，</p><p>Vue的两个钩子——创建前和创建后是服务器端到浏览器端的过渡，所以它们两个是特殊的生命周期钩子</p><p>另外，active这类可以重复的钩子不包括在内</p><p>我们解析一下各个生命周期:</p><blockquote><ol><li>nuxtServerInt 其中有些钩子只会执行一次，一般用于执行初始化数据</li><li>可以在图中的三个位置进行配置，在某个页面、组件加载前运行</li><li>实现成功则进入页面，否则404这样的功能</li><li>组件初始化前调用，要注意此时的this指向                        </li><li>开始渲染，此时如果请求新的页面，那就跳回第2步</li></ol></blockquote><h3 id="触发生命周期"><a href="#触发生命周期" class="headerlink" title="触发生命周期"></a>触发生命周期</h3><h4 id="nuxtServerInit"><a href="#nuxtServerInit" class="headerlink" title="nuxtServerInit"></a>nuxtServerInit</h4><p>由上图可以看出，是在store下配置触发的</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842534c2f1eab2d6dcd29c1b42ff96b07a2a92765641a21c5e8/0.png" alt="nuxtServerInit触发"></p><p>在store目录下建立index.js即可添加钩子</p><h4 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h4><p>这个钩子可以在三个位置编辑，nuxt.config.js，layouts下的组件中，pages下面的组件中，当对相关内容进行访问时，就会触发相应的方法</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253bca7b99d2b38898a72ddb85cbb76ed4f864ac5bebb93b0/0.png" alt="nuxt.config.js"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253bca7b99d2b38893858b7a3622dd9f2675369e1795e6f77/0.png" alt="auth.js"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253bca7b99d2b38898cf44203ea612136143bc04263979b87/0.png" alt="布局级别组件中"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253bca7b99d2b388932f9fd64367959455c0dc71cc2de45e8/0.png" alt="页面级组件中"></p><p>当然，都可以写成middleware:xxx这种形式来引入</p><h4 id="validate"><a href="#validate" class="headerlink" title="validate"></a>validate</h4><p>根据上面的流程图，validate是做参数校验的并且是放到页面级组件中的</p><blockquote><p>当然，上面说的validate是pages和children中，但是children是什么目前不太清楚</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253bca7b99d2b388936ebf8a41a18f4cf7779fafb474eac22/0.png" alt="image.png"></p><p>这个和路由守卫差不多</p><h4 id="asyncData-amp-fetch"><a href="#asyncData-amp-fetch" class="headerlink" title="asyncData&amp;fetch"></a>asyncData&amp;fetch</h4><p>和validate一样，依旧是用于pages和children</p><blockquote><p>下面说的返回Vuex是指的返回给vuex</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253bca7b99d2b388921c20b7d1265a18ecc74d537a9243618/0.png" alt="页面组件中"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253bca7b99d2b3889125dc6a5e18dfd66f04535e5fb51b0a8/0.png" alt="异步获取的数据"></p><p>asyncData返回的数据会合并到data</p><blockquote><p>上面都是SSR生命周期，这个时候都还在服务端，是没有办法访问到客户端的一些东西的，比如window对象，此时无法访问</p><p>另外，服务端不要使用this访问当前的环境变量，而是用context访问当前环境中的内容</p></blockquote><h4 id="CSR生命周期"><a href="#CSR生命周期" class="headerlink" title="CSR生命周期"></a>CSR生命周期</h4><p>这里开始就是Vue自带的一些钩子了</p><blockquote><p>// 从这里开始就是CSR了</p><p> beforeMount () {},</p><p> mounted () {},</p><p> beforeUpdate () {},</p><p> updated () {},</p><p> beforeDestroy () {},</p><p> destroyed () {}</p><p> // 注意服务端不存在 activated和deactivated，因为服务端无法缓存</p></blockquote><blockquote><p>我们提到过beforeMount和mounted比较特殊，是灰色地带，它们虽然是CSR生命周期，但是它们也不能保证能够成功访问到window等客户端的内容</p><p>它们的运行机制是，先试图在客户端运行，如果此时客户端来不及加载，那么则在服务端运行</p></blockquote><h2 id="Nuxt路由"><a href="#Nuxt路由" class="headerlink" title="Nuxt路由"></a>Nuxt路由</h2><h3 id="约定式-amp-amp-声明式"><a href="#约定式-amp-amp-声明式" class="headerlink" title="约定式&amp;&amp;声明式"></a>约定式&amp;&amp;声明式</h3><p><strong>声明式</strong><br>需要做文件的导入和声明等工作才能用，虽然麻烦但是灵活</p><p><strong>约定式</strong><br>不需要做文件的导入等工作，只需要按照一定的规定做就可以使用，Nuxt路由可以使用约定式，只要建立在pages下的文件，就能够直接访问到</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253bca7b99d2b388958ca4afaa830ca3cdbbf4fabdda89fd6/0.png" alt="image.png"></p><p>其中goods的二级路由里面有一点需要注意，这里命名为<code>_id.vue</code>，<code>_</code>表示这个id是一个动态的，这个二级路由是动态路由</p><blockquote><p>看到这里我们也就明白了约定式的多级路由就是通过文件层级来判断的级别，通过文件名称来判断从属关系</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253bca7b99d2b388998d43942d9908c32cbb7bdf72048bf5a/0.png" alt="路由的声明式和约定式"></p><p>注意这里二级路由还没有展示区，我们需要给一个<code>&lt;nuxt /&gt;</code>给予展示</p><h3 id="使用layout布局组件"><a href="#使用layout布局组件" class="headerlink" title="使用layout布局组件"></a>使用layout布局组件</h3><p>其实这个只是做了个分层，component是组件，layout是拼凑组件进行布局，最后再放到page中</p><p>之前我们把几个一级路由写到了default.vue这个layout组件中，现在我们再写一个一级组件叫做app-header.vue</p><p>这里的导出引入就和Vue完全一样了</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168423c67fb0cfa07dcffdf08d45d2ed5c981c0cb4b07a7b693e2/0.png" alt="image.png"></p><p>这里设置了一个 active-class，大概是Vue的东西（纳尼？？？）</p><p>就是路由活动的时候加载的class样式，而对于作用的路由的目标路由，采用的模糊匹配，比如搜索/class，那么/ 、/cla、/class都会被匹配到，所以当/goods等其他路由生效的时候，/也会生效</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket</title>
      <link href="/2022/02/25/websocket/"/>
      <url>/2022/02/25/websocket/</url>
      
        <content type="html"><![CDATA[<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>为了参与第二节字节跳动青训营前端项目比赛而学习，总的来说遇到了很多问题，但是好在最后还是拿了个第七名，从1000+人里面脱颖而出，很感谢我的队友的倾力付出<br><strong>（虽然说前端80%的代码是我写的…后端100%的代码是我写的…）</strong></p></blockquote><h3 id="更新日志-1"><a href="#更新日志-1" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/03/上旬</strong><br>忘了什么时候写的<br><strong>2022/03/11</strong><br>补充一些基本信息，比如上面那个时间。更多内容，比如net包的使用以后再补充。</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="什么是Socket"><a href="#什么是Socket" class="headerlink" title="什么是Socket"></a>什么是Socket</h3><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket</p><h3 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h3><p>socket所涉及的主要协议就是WebSocket协议，它是一种基于TCP的持久的网络协议，实现了浏览器与服务器的<strong>全双工通信</strong></p><h3 id="和AJAX的区别"><a href="#和AJAX的区别" class="headerlink" title="和AJAX的区别"></a>和AJAX的区别</h3><p>AJAX是基于HTTP请求的，是服务器端被动地响应浏览器的请求，数据的流向是<strong>单向的</strong>（说单向的也有点怪，但是又不知道该怎么说…算了就这样吧）</p><p>而在socket中，数据流向是双向的</p><blockquote><p>那么，在没有socket的年代，人们是如何用AJAX实现的全双工数据交互呢？</p><p>靠的是AJAX轮询….</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684270499aabdb7fc12ec2b3ea77248c0e28c115bc9567b6683f/0.png"></p><h2 id="简单使用Socket"><a href="#简单使用Socket" class="headerlink" title="简单使用Socket"></a>简单使用Socket</h2><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684257db326720634990564b69b772d437737a8f1d35d18d93d9/0.png" alt="Socket通信"></p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>H5更新中提供了WebSocket对象用于创建和管理WebSocket连接，以及可以通过连接发送和接收数据的API</p><p>非常容易，和AJAX类似的操作</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> input <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">const</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">const</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment">// 参数是ws地址，这里用一个官方的地址</span>    <span class="token comment">// 1. 创建websocket实例</span>    <span class="token keyword">const</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span> <span class="token punctuation">(</span><span class="token string">'ws://hostname:3000'</span><span class="token punctuation">)</span>    <span class="token comment">// 2. 建立连接的时候触发</span>    socket<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'open'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        div<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'连接成功了'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment">// 3. 主动给websocket发送消息</span>    button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> value <span class="token operator">=</span> input<span class="token punctuation">.</span>value        socket<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'你好啊!'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment">// 4. 接收websocket服务器的数据</span>    socket<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span>        div<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> res<span class="token punctuation">.</span>data    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment">// 5.关闭</span>    socket<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        div<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'服务断开连接'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>这里有非常多的模块来实现websocket，这里我们使用第三方包nodejs-websocket来实现</p><p>和http服务器非常像，所以上手也很快</p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">const ws = require('nodejs-websocket')const PORT = 3000// 每次有用户连接上来了，就执行一次，为这个用户创建一个conn对象const server = ws.createServer((conn) =&gt; {    console.log("NEW CONNECTION!!!")    conn.on("text", (data) =&gt; {        console.log("RECEIVED USER'S DATA: " + data)    conn.sendText("HelloWebSocket!!!")    })        conn.on("close", (code, reason) =&gt; {        console.log("CONNECTION CLOSED")    })        conn.on('error', () =&gt; {        console.log('用户连接异常')    })})server.listen(PORT, () =&gt; {    console.log('WEBSOCKET SERVER HAS STARTED!!!')})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2022/02/23/algorithm-heap/"/>
      <url>/2022/02/23/algorithm-heap/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于太久没有接触数据结构算法相关的知识了，所以以至于连堆的基本概念都忘了，在学习之后才发觉是学过的内容——所以我做下这篇笔记，一是为了自己复习，二是希望帮助到阅读这篇笔记的人</p><h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h2><p>说到堆，一般情况下是指的二叉堆，这里介绍二叉堆的概念，n叉堆以此类推，二项堆、斐波拉契堆、配对堆、树堆等需要另行学习</p><blockquote><p>n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆</p><p><strong>k<sub>i</sub>  &lt;=  k<sub>2i</sub>，k<sub>i</sub>  &lt;=  k<sub>2i+1</sub></strong><br><strong>或者</strong><br><strong>k<sub>i</sub>  &gt;=  k<sub>2i</sub>，k<sub>i</sub>  &gt;=  k<sub>2i+1</sub></strong></p><p>其中，i = 1,2,3,4…n/2</p></blockquote><p>一般情况，我们把二叉堆的逻辑结构看做是一棵<strong>特殊的完全二叉树</strong>，其特殊之处就是，</p><p>每个节点的子节点都大于其父节点（<strong>小根堆/小顶堆/最小堆</strong>）；</p><p>或者，每个节点的字节点都小于其父节点（<strong>大根堆/大顶堆/最大堆</strong>）</p><blockquote><p>至于为什么是要是<strong>完全</strong>二叉树，<br>一是因为要贴合定义，<br>二是因为堆一般用数组实现，<strong>完全</strong>则保证有效下标是连续的</p><p>当然了，只要符合定义都能是堆，不过看成完全二叉树会比较容易理解</p></blockquote><h2 id="堆的建立"><a href="#堆的建立" class="headerlink" title="堆的建立"></a>堆的建立</h2><p>先说STL，STL中的priority_queue就是一个堆</p><p>我们手写实现一般是用一个数组来模拟树状结构</p><p>所以只需要开一个数组就可以了，至于使数据符合定义的工作先不急</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int size = 1e5 + 10;int head[size];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>下标一般从1开始，因为这样一来下标为x的节点的左孩子下标为2x，右孩子下标则为2x+1</p></blockquote><blockquote><p>当然如果从0开始的话，则分别是2x+1和2x+2</p></blockquote><p>在讨论如何进行下一步前，我们先要了解堆的常用操作，就像是栈有push和pop一般，堆的常见操作是up和down——它们都是（递归地）操作根节的</p><h2 id="up操作"><a href="#up操作" class="headerlink" title="up操作"></a>up操作</h2><p>此处以小根堆为例，大根堆则需要参考down操作类比</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void up (int index) {  while (index / 2 &amp;&amp; heap[index] &lt; heap[index / 2]) {        swap(heap[index], heap[index / 2]);        index /= 2;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应该还是比较容易理解</p><h2 id="down操作"><a href="#down操作" class="headerlink" title="down操作"></a>down操作</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void down (int index) {    int temp = index;    if (index * 2 &lt;= heapSize &amp;&amp; heap[temp] &gt; heap[index * 2])        temp = index * 2;     if (index * 2 + 1 &lt;= heapSize &amp;&amp; heap[temp] &gt; heap[index * 2 + 1])        temp = index * 2 + 1;        if (temp != index) {        swap (heap[temp], heap[index]);        down (temp);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果触发了第一个if，那么第二个if的意思就是，如果<strong>左孩子比右孩子大</strong>——这里就完成了左右孩子中选择较大的一个</p></blockquote><p>down操作这里需要注意，temp和index不能随意混用，如果混用的话，在第一个if处可能不会有太大影响，但是这会给第二个if造成极大的干扰</p><h2 id="组合操作"><a href="#组合操作" class="headerlink" title="组合操作"></a>组合操作</h2><h3 id="插入一个数"><a href="#插入一个数" class="headerlink" title="插入一个数"></a>插入一个数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">heap[++ size] = x;up(size);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="求集合最小值"><a href="#求集合最小值" class="headerlink" title="求集合最小值"></a>求集合最小值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">heap[1];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="删除最小值"><a href="#删除最小值" class="headerlink" title="删除最小值"></a>删除最小值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">heap[1] = heap[size];size --;down(1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="删除任意值"><a href="#删除任意值" class="headerlink" title="删除任意值"></a>删除任意值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">heap[k] = heap[size];size --;down(1);up(k);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改任意值"><a href="#修改任意值" class="headerlink" title="修改任意值"></a>修改任意值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">heap[k] = x;down(k);up(k);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>实际上就是建立一个堆的过程</p><p>以小根堆为例说明选出最小的前m个值的过程，下面是完整代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;int n, m, heapSize;int heap[N];void up (int index) {    while (index / 2 &amp;&amp; heap[index] &lt; heap[index / 2]) {        swap(heap[index], heap[index / 2]);        index /= 2;    }}void down (int index) {    int temp = index;    if (index * 2 &lt;= heapSize &amp;&amp; heap[temp] &gt; heap[index * 2])        temp = index * 2;    if (index * 2 + 1 &lt;= heapSize &amp;&amp; heap[temp] &gt; heap[index * 2 + 1])        temp = index * 2 + 1;    if (temp != index) {        swap (heap[temp], heap[index]);        down (temp);    }}int main () {    cin &gt;&gt; n &gt;&gt; m;    heapSize = n;    for(int i = 1; i &lt;= n; i ++)        cin &gt;&gt; heap[i];    for(int i = n / 2; i; i --)         down (i);    while (m --) {        cout &lt;&lt;  heap[1] &lt;&lt; " ";        heap[1] = heap[heapSize];        heapSize --;        down (1);    }     return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2022/02/22/algorithm-kmp/"/>
      <url>/2022/02/22/algorithm-kmp/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>KMP也是困扰我许久的算法了，道理感觉能懂，但是一到代码就难以理解</p><p>但是所幸我现在终于是搞懂了</p><p>记一些笔记，希望帮到未来的自己和更多学习的人</p><h2 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h2><p><strong>主串</strong><br>也叫匹配串、模式串，相当于是要进行搜索的范围</p><p><strong>子串</strong><br>主串中包含的连续的字符</p><p><strong>模板串</strong><br>需要搜索的目标，如果能够在主串中找到与自身相同的子串即为匹配成功</p><p><strong>朴素匹配算法</strong><br>也叫幼稚匹配、简单匹配算法，就是暴力</p><h2 id="KMP思路"><a href="#KMP思路" class="headerlink" title="KMP思路"></a>KMP思路</h2><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168427385788add0a9e4dfd35857cd02bd295f1049f2f2f877d4e/0.png" alt="主串和模板串"></p><p>比如我们要在如图所示的主串中找到该模板串，</p><p>请先不要以计算机的思维去想如何实现，我们<strong>先以人类的思维入手</strong>——</p><p>我们总是会先找以g开头的部分，而不是一个一个去比对：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168427385788add0a9e4da98fea21485ec81d455393c4335f5823/0.png" alt="人类思维匹配示意"></p><p>如图，我们大概能在进行第三次匹配时成功</p><p>总结一下就是：</p><blockquote><p>顺序遍历主串，不回溯</p><p>移动模板串并<strong>跳过</strong>不必要的回溯</p><p>（这里的移动实际上就是遍历，移动只是一个利于结合图文进一步理解的说法——毕竟一个字符串能怎么动，还能在内存里面运动起来不成？）</p></blockquote><h2 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h2><p>既然要跳过不必要的回溯，那么该往哪里跳就成了我们要考虑的问题，先来看下面这个例子</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168427385788add0a9e4d0b7cc71b88049c02ddceb9c91806c67c/0.png" alt="KMP思路说明"></p><p>next数组是要记录“平移的距离”，其实也就是记录出现不匹配时，p指针应该回溯到的位置</p><p>那么该如何去求这个数组呢？</p><p>其实就是要记录（结合图片把下面这句话好好捋一捋）</p><blockquote><p> 出现不匹配的元素<strong>前面</strong>的 字符串中的 相同的<strong>最长</strong>的 <strong>前缀</strong> 和 <strong>后缀</strong> </p></blockquote><p>如果理解了这句话，那么也不难发现求next数组<strong>只需要观察模板串</strong></p><p><strong>举个例子</strong></p><p>这里我们习惯是下标从1开始，这样会有很多好处——我们后面再提</p><p>而且此处next[i]代表，<strong>当第i+1个元素不匹配时指针p应该回溯的位置</strong>——所以下标为0是有意义的</p><table><thead><tr><th>元素</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th></tr></thead><tbody><tr><td><strong>下标 i</strong></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td><strong>next[i]</strong></td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><p>手动求取的过程如下：</p><p>注意前缀和后缀是串的真子集</p><table><thead><tr><th>下标i</th><th>讨论的串</th><th>最长相同前后缀</th><th>结果</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>不讨论</td><td>i=1时，若回溯，则一定是到0</td></tr><tr><td>2</td><td>ab</td><td>无</td><td>不匹配则只能重新开始，回溯到0</td></tr><tr><td>3</td><td>abc</td><td>无</td><td>同上</td></tr><tr><td>4</td><td>abca</td><td>a</td><td>回溯到第一个a，也就是i = 1这里</td></tr><tr><td>5</td><td>abcab</td><td>ab</td><td>回溯到第第一个b，也就是i = 2这里</td></tr></tbody></table><p>其实对于i=5的情况来说已经不用讨论了，因为到了这一步已经是完全匹配上了，但是我们还是把它记录下来</p><p><strong>代码实现</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int N = 1e5 + 10;int next[N];char t[N];// 模板串// 数组下标均从1开始，但根据上文可知next[1]是默认为0的不用求，所以i从2开始// 而且从2开始相较于从1开始会省去不少麻烦// 而j从0开始是为了一种试探性的比较for (int i = 2, j = 0; i &lt;= n; i ++) {    // j + 1是试探性地比较，不匹配则递归回溯直到 匹配或者j为0while (j &amp;&amp; t[i] != t[j + 1])     {        j = next[j];    }    // 跳出while的原因有两种，如果是因为匹配而跳出    // 那么就让试探性的j + 1真正地进一步    if(t[i] == t[j + 1])     {        j ++;    }    // 可以自己推导一下，在经历上述步骤后，    // j已经代表了此时讨论的串中最长相同前后缀的长度    next[i] = j;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="开始匹配"><a href="#开始匹配" class="headerlink" title="开始匹配"></a>开始匹配</h2><p>在求完next数组后</p><p>就要开始进行匹配了，匹配的思路 和 求next异曲同工</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// i是主串的下标，j+1是模板串下标，j仍可以用来试探next数组for (int i = 1, j = 0; i &lt;= m; i ++) {    // S是主串，P是模板串    while (j &amp;&amp; S[i] != P[j + 1]) {        j = next[j];    }    if (S[i] == P[j + 1]) {        j ++;    }    if (j == n) {        cout &lt;&lt; i - n &lt;&lt; " ";        // 我们如果要找出主串中所有的模板串，那么就进行下一步，回溯        j = next[j];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;const int M = 1e6 + 10;int n, m;char P[N], S[M];int ne[N];int main() {    cin &gt;&gt; n &gt;&gt; P + 1 &gt;&gt; m &gt;&gt; S + 1;    for (int i = 2, j = 0; i &lt;= n; i ++) {        while (j &amp;&amp; P[i] != P[j + 1]) {            j = next[j];        }        if (P[i] == P[j + 1]) {            j ++;        }        next[i] = j;    }    for (int i = 1, j = 0; i &lt;= m; i ++) {        while (j &amp;&amp; S[i] != P[j + 1]) {            j = next[j];        }        if (S[i] == P[j + 1]) {            j ++;        }        if (j == n) {            cout &lt;&lt; i - n &lt;&lt; " ";            j = next[j];        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust（待更新）</title>
      <link href="/2022/02/20/rust/"/>
      <url>/2022/02/20/rust/</url>
      
        <content type="html"><![CDATA[<h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>发生了很多我意料之外的事情，我也因此感慨万分</p><p>虽然其中的道理我早有耳闻，但是切身体会后内心还是会泛起伤感</p><p>在此之后我不免对<strong>开源</strong>产生了怀疑——我为什么要开源？</p><p>这是我之后需要思考的问题，而现在则是认真地学习Rust</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/02/20</strong><br>这次准备对官方文档做摘要了</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Rust 语言为了高并发安全而做的设计</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><p>按照做摘要的原则，我会过滤掉那些过于简单和相对熟悉的内容，但是Rust的变量实在是太特别了</p><h4 id="不可变变量"><a href="#不可变变量" class="headerlink" title="不可变变量"></a>不可变变量</h4><p>Rust是强数据类型语言，但是能够做自动类型判断，变量声明语法如下：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再执行上述语句后，下面这些代码将会<strong>报错</strong></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">a <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span> <span class="token comment">// 类型发生了转变</span>a <span class="token operator">=</span> <span class="token number">4.56</span><span class="token punctuation">;</span>  <span class="token comment">// 精度发生了损失</span>a <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span>   <span class="token comment">// Rust的奇妙特性</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>重点解释第三种情况——要知道a是一个变量，要是不能改变那不就是常量了吗？<br> a 的值不可变。但这不意味着 a 不是”变量”（英文中的 variable），官方文档称 a 这种变量为**”不可变变量”**（就离谱）</p><blockquote><p>这就牵扯到了 Rust 语言为了高并发安全而做的设计：在语言层面尽量少的让变量的值可以改变</p></blockquote><p>但是以下代码是合法的</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样相当于“重新绑定”了，这也是不可变量和常量的区别</p><p>当然，”重新绑定”只能改变值而不能改变数据类型</p><blockquote><p>这里的”重新绑定”严格来说是指的<strong>重影</strong>，这个概念后面再提</p></blockquote><h4 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h4><p>当然，上面这种机制在很多情况下会比较难受，所以还是需要我们熟悉的正常变量</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>语法如下:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// 有符号三十二位</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>只讨论较为特殊的</p><p>虽然能自动判别数据类型，但是依旧是可以指定数据类型，语法类似TS</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> a<span class="token punctuation">:</span> <span class="token keyword">u64</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token comment">// 无符号64位</span><span class="token keyword">const</span> a<span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment">// 有符号32位</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果不指定类型，那么对于数字声明来说默认是有符号32位</p><h4 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h4><blockquote><p>Integer，简称整形，按照比特长度和有无负号分类</p></blockquote><table><thead><tr><th align="left">位长度</th><th align="left">有符号</th><th align="left">无符号</th></tr></thead><tbody><tr><td align="left">8-bit</td><td align="left">i8</td><td align="left">u8</td></tr><tr><td align="left">16-bit</td><td align="left">i16</td><td align="left">u16</td></tr><tr><td align="left">32-bit</td><td align="left">i32</td><td align="left">u32</td></tr><tr><td align="left">64-bit</td><td align="left">i64</td><td align="left">u64</td></tr><tr><td align="left">128-bit</td><td align="left">i128</td><td align="left">u128</td></tr><tr><td align="left">arch</td><td align="left">isize</td><td align="left">usize</td></tr></tbody></table><p>isize 和 usize 两种整数类型是用来衡量数据大小的，它们的位长度取决于所运行的目标平台，如果是 32 位架构的处理器将使用 32 位位长度整型。</p><table><thead><tr><th align="left">进制</th><th align="left">例</th></tr></thead><tbody><tr><td align="left">十进制</td><td align="left">98_222</td></tr><tr><td align="left">十六进制</td><td align="left">0xff</td></tr><tr><td align="left">八进制</td><td align="left">0o77</td></tr><tr><td align="left">二进制</td><td align="left">0b1111_0000</td></tr><tr><td align="left">字节(只能表示 u8 型)</td><td align="left">b’A’</td></tr></tbody></table><h4 id="浮点数型"><a href="#浮点数型" class="headerlink" title="浮点数型"></a>浮点数型</h4><blockquote><p>Floating - Point，</p><p>只需要记住有32位和64位，默认是64位即可</p></blockquote> <pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span> <span class="token comment">// f64</span>    <span class="token keyword">let</span> y<span class="token punctuation">:</span> <span class="token keyword">f32</span> <span class="token operator">=</span> <span class="token number">3.0</span><span class="token punctuation">;</span> <span class="token comment">// f32</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><blockquote><p>char，但是与C/C++不同的是，rust的char是4个字节，代表Unicode标量值，这意味着中文日文甚至是emoji表情符号在rust中都是有效的字符</p><p>当然，有时候我们对字符的认识可能会和rust不一致，并且由于现行的中文编码有GBK和UTF-8两套，所以中文仍可能会出现乱码</p><p>为了尽可能规避乱码，UTF-8字符尽可能使用字符串存储</p></blockquote><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>大体上和JS类似，主要是看一段示例：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"January"</span><span class="token punctuation">,</span> <span class="token string">"February"</span><span class="token punctuation">,</span> <span class="token string">"March"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// b 是一个长度为 3 的字符串数组</span><span class="token keyword">let</span> c<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">i32</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// c 是一个长度为 5 的 i32 数组</span><span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 等同于 let d = [3, 3, 3, 3, 3];</span><span class="token keyword">let</span> first <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> second <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 数组访问</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// 错误：数组 a 不可变</span><span class="token keyword">let</span> <span class="token keyword">mut</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><p>元组用一对()包括一组数据，可以包含不同类型的数据</p><p>这里和ES6中的解构赋值类似之处</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> tup<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">6.4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// tup.0 等于 500</span><span class="token comment">// tup.1 等于 6.4</span><span class="token comment">// tup.2 等于 1</span><span class="token keyword">let</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token operator">=</span> tup<span class="token punctuation">;</span><span class="token comment">// y 等于 6.4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="重影"><a href="#重影" class="headerlink" title="重影"></a>重影</h3><p>重影的概念与其他面向对象语言里的”重写”（Override）或”重载”（Overload）是不一样的。重影就是刚才讲述的所谓”重新绑定”，之所以加引号就是为了在没有介绍这个概念的时候代替一下概念</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of x is: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><blockquote><p>The value of x is: 12</p></blockquote><p>重影是指用<strong>同一个名字重新代表另一个变量实体</strong>，其类型、可变属性和值都可以变化。但可变变量赋值<strong>仅能发生值的变化</strong>，数据类型是不允许变化的！</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>rust有常规的两种注释形式，还有非常特殊的第三种注释：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Adds one to the number given.</span><span class="token comment">///</span><span class="token comment">/// # Examples</span><span class="token comment">///</span><span class="token comment">/// ```</span><span class="token comment">/// let x = add(1, 2);</span><span class="token comment">///</span><span class="token comment">/// ```</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的注释支持markdown语法，是作为说明文档注释的开头</p><p>能达到下面这样的效果，非常惊艳！</p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842c2cd079d8cfed1816b8eb70cf598cc998dad22a79e917e7e/0.png" style="zoom:150%;"><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><p>和C/C++类似，rust需要一个主函数，其基本格式如下：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>没有参数，也没有返回值！</strong></p><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p><strong>基本使用</strong></p><p>和JS一样，函数声明自动提升，所以不必在意调用和声明的先后顺序</p><p>但是需要注意，rust中声明函数需要指定类型，语法类似TS</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">another_function</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"x 的值为 : {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"y 的值为 : {}"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数体表达式</strong></p><p>大概是个语法糖</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        x <span class="token operator">+</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"x 的值为 : {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"y 的值为 : {}"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后输出的结果是：</p><blockquote><p>x 的值为 : 5<br>y 的值为 : 4</p></blockquote><p>没错，不仅没有输出花括号，而且y的值是4</p><blockquote><p>没有输出花括号是因为rust中的花括号可以理解为c中的%d%c%s等等</p></blockquote><p>可以将函数的形式简写成上述代码中的那样，其中<strong>最后一句必须是表达式 且 不加分号</strong>，作为返回值（最后一行加上分号则会变成一条语句）</p><blockquote><p> 而且如果要使用这种简写，那么<strong>一定要放到最后一行</strong>！！</p></blockquote><p>当然，return是随时都可以使用</p><h4 id="返回值类型声明"><a href="#返回值类型声明" class="headerlink" title="返回值类型声明"></a>返回值类型声明</h4><p>如果要限定返回值的类型，那么就可以使用如下形式：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在-&gt;后加上返回值类型即可声明</p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>如果是耳熟能详的内容，那我绝不会在这里大费周章</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>和python类似，这里不再需要括号（但是依然可以写，因为括号可以看做表达式的一部分）</p><p>而且条件表达式必须是bool类型</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">if</span> a <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>    b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> a <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>    b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>    b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于rust是注重安全的，所以非0即true这种自动类型转换时不被允许的</p><h4 id="结合函数体表达式"><a href="#结合函数体表达式" class="headerlink" title="结合函数体表达式"></a>结合函数体表达式</h4><p>这样的效果和三目运算差不多</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token keyword">if</span> a <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span> <span class="token number">1</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>两个函数体表达式的类型必须一样！且必须有一个 else 及其后的表达式块</p><p>（因为赋值操作的等号右边必须要有一个返回值）</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><blockquote><p> while只提两点：</p><ol><li>不需要括号</li><li>暂时没有do-while，do作为了保留字</li></ol></blockquote><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>没有像C那样的三元语句控制循环，而是用迭代器的形式遍历</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">for</span> i <span class="token keyword">in</span> a<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"值为 : {}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然还可以通过下标来访问:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span><span class="token number">5</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"a[{}] = {}"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看上去有点粗陋就是了额</p><h4 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h4><p>这个相当于加强版的while(true){}</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token char string">'R'</span><span class="token punctuation">,</span> <span class="token char string">'U'</span><span class="token punctuation">,</span> <span class="token char string">'N'</span><span class="token punctuation">,</span> <span class="token char string">'O'</span><span class="token punctuation">,</span> <span class="token char string">'O'</span><span class="token punctuation">,</span> <span class="token char string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token keyword">mut</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">let</span> location <span class="token operator">=</span> <span class="token keyword">loop</span> <span class="token punctuation">{</span> <span class="token comment">// 没错loop循环有一个类似返回值的操作</span>    <span class="token keyword">let</span> ch <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> ch <span class="token operator">==</span> <span class="token char string">'O'</span> <span class="token punctuation">{</span>        <span class="token keyword">break</span> i<span class="token punctuation">;</span><span class="token comment">// 可以通过break做到类似返回值的效果</span>    <span class="token punctuation">}</span>    i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022/02/04/git/"/>
      <url>/2022/02/04/git/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><p>今天是2021/9/12，计划和同学一起开发微信小程序了，看了下语法大概就是html和css以及Vue的魔改，这个问题应该不大。重点是我们觉得这也是第一个正正经经的可以算得上项目的东西了，所以还是决定好好打磨它，于是乎这个时候就想到了版本管理的问题，自然而然就得开始学习Git了</p><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/02/04</strong><br>现在是1:09 AM，计划在今天下午和逸飞大佬研究git技术，忽然想起自己写过一篇git的笔记，就打算放到自己的个人博客上了</p></blockquote><h2 id="关于版本控制的一些话"><a href="#关于版本控制的一些话" class="headerlink" title="关于版本控制的一些话"></a>关于版本控制的一些话</h2><h3 id="为什么要有版本控制"><a href="#为什么要有版本控制" class="headerlink" title="为什么要有版本控制"></a>为什么要有版本控制</h3><p>比如今天觉得第一版不好，就出了第二版，但是第一版怎么办呢，总不能删了吧——万一哪天又觉得第一版好怎么办？<br>存在本地又不好大家合作开发，所以我们需要一个中间的平台来储存众多版本</p><h3 id="版本控制的发展史"><a href="#版本控制的发展史" class="headerlink" title="版本控制的发展史"></a>版本控制的发展史</h3><p><strong>1.本地版本控制</strong><br>在本地记录保存每次更新，适合个人开发用</p><p>很方便，但是也很明显，很low</p><p><strong>2.集中版本控制——SVN</strong><br>所有版本都放到一个服务器，这样一来就方便协同开发了<br>（缺点是不联网就很难办，另外，要是服务器炸了就可以重开了）</p><p><strong>3.分布式版本控制——Git</strong><br>每个人都拥有完整的代码，所有的版本信息都会同步到每一个开发者，<br>断网的时候可以本地提交，有网络时会自动同步，这样一来只要有一个还保留着代码，就能很快恢复数据<br>（缺点是，安全隐患大，容易出内鬼；另外这同一份文件多次存储，加大了空间消耗）<br>（欸，等等，这难道是区块链？？w(ﾟДﾟ)w，算了，先学会用再说</p><h2 id="Git下载与安装"><a href="#Git下载与安装" class="headerlink" title="Git下载与安装"></a>Git下载与安装</h2><p>官网下载比较慢的话，<br>那么就试试镜像下载吧，相信用过npm的应该很熟悉了：<a href="https://npm.taobao.org/mirrors/git-for-windows/">git镜像下载</a><br>进去之后选一个稍微旧一点的版本下载<br><img src="https://img-blog.csdnimg.cn/ea98c417dc774e0aa0182ec04213e8b8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>64位就找64位咯<br><img src="https://img-blog.csdnimg.cn/9780be46e52142e190331cd947851598.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/3a98d56150a848e08e21911e608c13d5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/88dde751837f46fe8d8ad82485a5155d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里要注意，选择默认的文本编辑器<br><img src="https://img-blog.csdnimg.cn/0b625bbfb5714d0590bf1fe12903519b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>我选的visual studio code（虽然喜欢idea<br><img src="https://img-blog.csdnimg.cn/5a841580fe2a48f3866f3472a7860a73.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>然后管他三七二十一地，直接莽Next就完事，最后finish，安装完毕<br>此时鼠标右键可以看到Git的相关内容，<br>这里也可以看到<br><img src="https://img-blog.csdnimg.cn/3fc1663611d546cd8f147abcfc561c18.png" alt="在这里插入图片描述"><br>它们分别是：<br>Git Bash:Unix与Linux风格的命令行<br>Git CMD:Windows风格<br>Git GUI :图形界面版本Git，但是初学者嘛还是先学会用命令行比价好，所以暂时不推荐使用</p><p>为了以后更好地学习Linux，我们这里采用Git Bash</p><h2 id="基本Linux命令"><a href="#基本Linux命令" class="headerlink" title="基本Linux命令"></a>基本Linux命令</h2><p><img src="https://img-blog.csdnimg.cn/2546d8c8986943e68619b6b1c97d5d47.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>点开就能看到类似这样地画面<br><img src="https://img-blog.csdnimg.cn/21b4fcd991ca462881441e0e58871e63.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>好了，这下得开始学Linux命令才能继续玩下去了<br>大概就是这样，这里看看就像<br><img src="https://img-blog.csdnimg.cn/f5b8be004d014757a92b46d336a86841.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里就提一句：<br><strong>(不要尝试，不要尝试，不要尝试！</strong><br><strong>这是删库，难以跑路，后果自负)</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> -rf/<span class="token comment"># 要是你计算机文件全没了别怪我没提醒你别用这个指令</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>只是想说一下啊，rm是remove的简写，-r是递归，f是强制，/是根目录</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p> <strong>git config -l</strong><br>就是查看配置列表啦<br><img src="https://img-blog.csdnimg.cn/1975bd2990a6482682d7f09528ad9503.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>还可以细一点，使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --system --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看系统配置<br><img src="https://img-blog.csdnimg.cn/07ba27c335aa43c69f9b41ee7d497037.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>同样的可以查看用户配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config --global --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/4e9d54d0d6f1458d9dd0bb4b78959a99.png" alt="在这里插入图片描述"><br>现在我们来更改一下配置<br>其实如果不执行这一步配置操作的话，那么是不能提交项目的</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"Serio"</span>$ <span class="token function">git</span> config --global user.email <span class="token string">"2779066456@qq.com"</span>$ <span class="token comment">#第一个是配置名称，第二个是配置邮箱</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后再使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config --global --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看一下配置是否成功<br><img src="https://img-blog.csdnimg.cn/0e227ed71eaf40e3852e6b431cc99d4e.png" alt="在这里插入图片描述">系统配置会保存在Git安装目录下的etc文件中的config文件里面<br>用户配置会保存在C盘用户文件下的gitconfig中</p><p>在说下一个命令以前，先得提一下</p><h3 id="Git工作原理"><a href="#Git工作原理" class="headerlink" title="Git工作原理"></a>Git工作原理</h3><p>Git有三个工作区域：</p><blockquote><p>1.工作目录<br>2.暂存区<br>3.资源库<br>4.远程it仓库</p></blockquote><p> <img src="https://img-blog.csdnimg.cn/e9625b566e2d47a7a9ec01bb05947f44.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="git的三个工作区域"></p><blockquote><p>1.<strong>workspace/working directory</strong><br>工作区，就是平时存放代码的地方<br>2.<strong>index/stage</strong><br>暂存区，用于临时存储，是一个文件，存储将要提交到文件列表的信息<br>3.<strong>repository/history</strong><br>仓库区（本地仓库)，能安全存储数据的位置，存储了所有版本的数据。其中的HEAD指向最新版本<br>4.<strong>remote</strong><br>远程仓库，托管代码的服务器</p></blockquote><p><strong>git的工作流程是</strong><br>1.在工作目录中添加修改文件<br>2.将需要进行版本管理的文件放入暂存区域<br>3.将暂存区域的文件提交到git仓库</p><h3 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h3><p>有两种方式：<br>1.本地新建仓库<br>2.克隆远程仓库<br>大概涉及到以下六个命令<br>（没错，图片依旧来自狂神说）<br><img src="https://img-blog.csdnimg.cn/e1d0fa7b46294284b4ae1adc70be557a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>本地搭建</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/0f4a1719dfb74740ba38a589744a6e6f.png" alt="初始化"><br>注意这是个隐藏文件，所以要勾选显示隐藏文件才看得见<br><img src="https://img-blog.csdnimg.cn/8b0497c92e14465ea46b83dccdc108df.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>远程克隆</strong><br>首先我们先建立一个远程仓库<br>（由于hub比较卡顿，所以我们这里用ee）<br><img src="https://img-blog.csdnimg.cn/fff157437e3f4ecbbe756a81d992a253.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone <span class="token string">"https://gitee.com/Serio/test.git"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/7903edf67f654139a3e0f8a69e9220a1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后同样的我们就得到了这个库</p><p>这个时候可能就有人要问了，这都下载到c盘去了，要怎么下到指定路径呢？</p><p>这还是先得用cd等命令<br><img src="https://img-blog.csdnimg.cn/85d61f59e42d43f98fe089ea09969d34.png" alt="在这里插入图片描述"><br>比如这样就进入了e盘，然后建立仓库之类的就会在e盘下进行</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>文件有四种状态：<br>1.<strong>Untacked</strong>：未跟踪，这个文件在项目中，但是没有传到git库里面，不参与版本库，<br>在git add命令执行后改变为<strong>Staged</strong>暂存</p><hr><p>2.<strong>Unmondify</strong>：文件已经传入库，未修改，即版本库中文件快照内容与文件夹中内容完全一致，<br>此后如果执行git rm命令，那么就会被移除<br>如果被修改，那么状态变为<strong>Modified</strong></p><hr><p>3.<strong>Modified</strong>：修改过，<br>在执行git checkout命令后撤销修改内容，返回<strong>Unmodify</strong>状态<br>也可以在执行git add后变为<strong>Staged</strong></p><hr><p>4.<strong>Staged</strong>：暂存，<br>执行git commit后将提交到库中，此时库中文件又和本地文件一致了，文件又变为<strong>Unmodify</strong><br>执行git reset HEAD filename那么就会取消暂存，回退到<strong>Modified</strong>状态</p><p><strong>实际操作示例</strong><br>首先我们新建一个文本<br><img src="https://img-blog.csdnimg.cn/963090cbb7e849e29b3095a35274bf1e.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> status <span class="token string">"LEC牛逼"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/93fcbb191fce4d2394e964820b6b0a73.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="查看文件状态"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> <span class="token string">"LEC牛逼.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/a539a5679a8c4b2c95f13d6bb15d0027.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="添加"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"这是第一次提交测试"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/828adeb39f4b43cca0d38386fbd7396d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>当然，如果我们不想让每一个文件都上传，那么可以定义一个扩展名为gitignore的文件<br><img src="https://img-blog.csdnimg.cn/6d5232c581324790ae5154754ce2811e.png" alt="在这里插入图片描述"><br>配置内容依次解释为，忽略根目录下的TODO文件，忽略所有txt文件，但是”LEC牛逼.txt”除外</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>我们先得有一个ssh公钥</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-t表示采用加密，rsa是加密的方式<br>一路enter就好<br><img src="https://img-blog.csdnimg.cn/3bd51771f7e04261b167c8889519f49b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后去这里找找生成的公钥<br><img src="https://img-blog.csdnimg.cn/239106ea238f4cb49785249bcff2a4e4.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8370a33362d24046bae58663e56e673d.png" alt="在这里插入图片描述"><br>然后打开其中扩展名为pub的那个文件，复制里面的内容，粘贴到<br>（这里我们用国内的远程库吧）<br><img src="https://img-blog.csdnimg.cn/115cb00b73bc4c2ba779dcc634cd236c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>添加了ssh公钥之后<br>再新建一个库<br><img src="https://img-blog.csdnimg.cn/056e99704e7e4f01beb38976e430b5cf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果不太清楚开源协议的话，可以点框起来的部分<br><img src="https://img-blog.csdnimg.cn/dee06512bea842b6be3912dd4586809c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后一路我不在乎————下一步下一步（好吧这个根据个人需求来就行）<br><img src="https://img-blog.csdnimg.cn/3ecdb96f87cb45f886b1a68fc051dc8f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>得到远程仓库之后，我们就不同本地的了（原来那个可以删了）<br>来克隆一下</p><h3 id="使用IDEA集成开发"><a href="#使用IDEA集成开发" class="headerlink" title="使用IDEA集成开发"></a>使用IDEA集成开发</h3><p>idea创建一个普通项目<br><img src="https://img-blog.csdnimg.cn/2075b0171ce44a6ead2c5c4a1dc8920c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里我的IDEA帮我自动配置好了这两个东西<br>打开看看<br><img src="https://img-blog.csdnimg.cn/45bc4efd55be4ef1b8cd541a5742d356.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8d6259a29782475fbb5429bbda7065a6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后我们把下载到本地的git文件的内容移动到工程文件中<br><img src="https://img-blog.csdnimg.cn/427bb7592b2e4509a63c1e4d4f06d776.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里红色的就是代表选中状态,绿色代表已经提交<br>右上角也多了几个按钮<br><img src="https://img-blog.csdnimg.cn/8d7fa7209a9b4965b623b05196982841.png" alt="在这里插入图片描述"><br>底部也多了终端的几个选项<br><img src="https://img-blog.csdnimg.cn/8e03f6dc80b3454ab74c55182b4661ff.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>接下来我们在终端使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加所有文件到暂存区<br><img src="https://img-blog.csdnimg.cn/cfaa008c216141bd81113beb25132096.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>当然鼠标右键找到git选项中的add，也能实现同样的效果<br>添加到暂存区之后的文件都变绿了<br><img src="https://img-blog.csdnimg.cn/2858bea0e2bb42cf9468a4228126418e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后输入一下描述信息，直接提交就好了</p><p><img src="https://img-blog.csdnimg.cn/8739f86691834655a2af7fe7002d8b56.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>当然，使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"这是第一次提交阿巴阿巴阿巴.."</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也能达到同样的效果</p><p>当看到这个的时候<br><img src="https://img-blog.csdnimg.cn/a93be1af60414ec5829a4baaca24abe0.png" alt="在这里插入图片描述"><br>就已经提交到本地仓库了<br>如果要同步到远程，可以使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（终端不需要加$；push后面什么都不写）<br>或者点击IDEA的快捷按钮：推送，即可完成同步<br><img src="https://img-blog.csdnimg.cn/36dde07f366a4bc78e9aa5b00f8412cf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这就很棒了</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>主干叫master，一定要对应最优的稳定运行版本<br>查看本地库的分支</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/b6f43ba242494267a90fc36c755a8c62.png" alt="在这里插入图片描述"><br>查看远程库的分支</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/9820a853a2e345b2a9e71c1ef2906554.png" alt="在这里插入图片描述"><br>三个开发小组A B C<br>B会调用A的接口<br>C会调用A，B的接口<br>那么如果B在使用的过程中修改了A的代码<br>C要调用A原本的代码时，就产生了冲突</p><p>所以这就需要分支，使得各个版本不冲突<br>(C调用A1.0，B修改后产生的记为A2.0这样就可以了)</p><p>另外，最后ABC三组合并文件，如果发生冲突<br>那么可以修改冲突文件重新提交，选择保留其中一种可行的方案即可</p><p>相关操作见下图，当然下图依旧来自网络（好吧就是狂神说）<br><img src="https://img-blog.csdnimg.cn/0403f6b7c0c345799940b56bc310969c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="协同开发实操"><a href="#协同开发实操" class="headerlink" title="协同开发实操"></a>协同开发实操</h3><p>这个得等等队友了…<br>后面再更新<br><img src="https://img-blog.csdnimg.cn/002dee626d9041fdb3cbc2e3e6758cc8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web多媒体基础</title>
      <link href="/2022/02/03/webmedia/"/>
      <url>/2022/02/03/webmedia/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h2><blockquote><p>在这短短数十天的学习中，我的认知也有了长足的进步，不再把前端局限于web，因为我见识到了更为广大的前端，那是奇伟瑰丽的，也是人迹罕至的，当我见到这一幕时的心情，就像是远行者历经千辛万苦终于要翻过一个山头的时候怀揣的期待被山头那边高不可攀的<strong>“真正的顶峰”</strong>打破，随即而来的震撼</p><p>这次远足，没有终点</p><p>对于没有终点这种概念无需产生惶恐，心怀敬仰地用有限去博弈无穷，向世界献上赞歌，这何尝不是一种浪漫呢</p></blockquote><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><blockquote><p><strong>2022/02/03</strong><br>开始学习吧</p><p><strong>2022/02/04</strong><br>搜集各种资料，学习关于“信息熵”的知识并做好记录</p></blockquote><h1 id="浏览器原生多媒体和扩展"><a href="#浏览器原生多媒体和扩展" class="headerlink" title="浏览器原生多媒体和扩展"></a>浏览器原生多媒体和扩展</h1><h2 id="音频和视频"><a href="#音频和视频" class="headerlink" title="音频和视频"></a>音频和视频</h2><p>这里指的是audio标签和video标签<br>它们具有如下属性:</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab1d80a544e355be6571a20f66494aa68b/0.png" alt="两个标签的属性1"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab3bc48a6faf48e3507f87bcd5bf181da8/0.png" alt="两个标签的属性2"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab6540d6a86140386f8a3a29dd0517c936/0.png" alt="两个标签的属性3"></p><p>由于现在的浏览器很可能会避免随机噪声的出现，所以会禁用如autoplay这种属性，从而直接配置是无效的，所以我们需要使用JS来触发它们（我还没试过，可能也没效果）</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><blockquote><ol><li><p>不支持直接播放hls、flv等格式的视频</p></li><li><p>视频资源的请求和加载无法通过代码控制</p><p>(无法实现分段加载、清晰度无缝切换、精准预加载等功能)</p></li></ol></blockquote><h2 id="多媒体元素和扩展API"><a href="#多媒体元素和扩展API" class="headerlink" title="多媒体元素和扩展API"></a>多媒体元素和扩展API</h2><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168420129fe8edd9b5365abedda178b287ad511b808c5d4115c76/0.png" alt="MSE"></p><blockquote><p>MSE使用过程：</p><ol><li>创建mediaSource实例</li><li>创建指向mediaSource的URL</li><li>监听sourceopen事件</li><li>创建sourceBuffer</li><li>向sourceBuffer中加入数据</li><li>监听updateend事件</li></ol><p>而用MSE播放mp4的过程如下：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168420129fe8edd9b5365abf43c6184acf2aa006e3774b6af85e2/0.png" alt="MSE播放mp4过程"></p><p>对比一下播放器播放mp4：</p><ol><li>数据加载（ts flv mp4）</li><li>解封装（音频裸流、视频裸流）</li><li>重封装（fmp4）</li><li>appendBuffer（video、audio）</li><li>解码渲染（解码渲染）</li><li>音视频同步（时间戳）</li></ol></blockquote><h2 id="流媒体协议"><a href="#流媒体协议" class="headerlink" title="流媒体协议"></a>流媒体协议</h2><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168420129fe8edd9b536548804879f3a4982fe79604b406190403/0.png" alt="流媒体协议一览"></p><blockquote><p> 其中，HLS全称是<strong>HTTP Live Streaming</strong>，用于实时音视频流的传输，目前HLS协议被广泛应用于视频点播和直播领域</p></blockquote><p><strong>工作流程</strong></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168420129fe8edd9b53655ab2070bf4ff9db2eadf702d8f6958ca/0.png" alt="工作流程"></p><h1 id="Web多媒体基础知识"><a href="#Web多媒体基础知识" class="headerlink" title="Web多媒体基础知识"></a>Web多媒体基础知识</h1><h2 id="Web多媒体历史"><a href="#Web多媒体历史" class="headerlink" title="Web多媒体历史"></a>Web多媒体历史</h2><p>多媒体历史可以大致的分为三个阶段：</p><blockquote><ol><li><strong>Flash时代</strong><br>已经开摆了</li><li><strong>HTML5时代</strong><br>至今还在用，但是audio等标签完全不够用，亟待扩展</li><li><strong>Media Source Extension（MSE）时代</strong><br>媒体资源扩展，未来的发展趋势</li></ol></blockquote><h2 id="图像的基本概念"><a href="#图像的基本概念" class="headerlink" title="图像的基本概念"></a>图像的基本概念</h2><p><strong>图像分辨率</strong></p><blockquote><p>用于确定组成一副图像的像素数据<br>就是指在 水平和垂直方向上图像所具有的像素<strong>个数</strong></p></blockquote><p> <strong>图像深度</strong></p><blockquote><p>图像深度是指存储每个像素所需要的比特数<br>图像深度决定了图像的每个像素可能的颜色数，或可能的灰度级数<br>例如:<br>彩色图像每个像素用R,G,B三个分量表示,每个分量用8位，像素深度为24位，可以表示的颜色数目为2的24次方，既16777216个<br>单色图像存储每个像素需要8bit，则图像的象素深度为8位，最大灰度数目为2的8次方，既256个。</p></blockquote><h2 id="视频基本概念"><a href="#视频基本概念" class="headerlink" title="视频基本概念"></a>视频基本概念</h2><p><strong>分辨率</strong></p><blockquote><p>指的是构成视频的每一帧图像的分辨率</p></blockquote><p><strong>帧率</strong></p><blockquote><p>视频单位时间内包含的视频帧的数量</p></blockquote><p><strong>码率</strong></p><blockquote><p>视频单位时间内传输的数据量，一般用kbps表示——注意这里是bit不是Byte</p></blockquote><h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2><p><strong>I帧</strong></p><blockquote><p>又称<strong>帧内编码帧</strong>，是一种自带全部信息的独立帧，无需参考其他图像便可独立进行解码</p></blockquote><p><strong>P帧</strong></p><blockquote><p>又称<strong>帧间预测编码帧</strong>，需要参考前面的I帧或者P帧才能进行编码</p></blockquote><p><strong>B帧</strong></p><blockquote><p>又称<strong>双向预测编码帧</strong>，也就是B帧记录的是本帧与前后帧的差别</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fabc59002d34a0826d96fa797467f5b7d65/0.png" alt="I/P/B帧示意图"></p><p><strong>GOP</strong></p><blockquote><p>group of picture<br>指的是两个I帧之间的间隔</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fabc8d503f7eba1ac49cc861886ac6a3d26/0.png" alt="GOP示意图"></p><p>下面这些是常见的编码格式：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fabe9b50b94a16a56ec2be41c3a3b893891/0.png" alt="常见编码格式发展一览"></p><h2 id="为什么要进行编码"><a href="#为什么要进行编码" class="headerlink" title="为什么要进行编码"></a>为什么要进行编码</h2><blockquote><p>编码是将源对象内容按照一种标准转换为一种<strong>标准格式</strong>内容<br>解码是和编码对应的,它使用和编码相同的标准将编码内容还原<br><strong>最初是为了加密</strong>,经过加密的内容不知道编码标准的人很难识别<br>而<strong>现在主要是为了信息交换</strong></p></blockquote><p>编码可以做到压缩体积等效果，有效优化一些冗余问题</p><h2 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h2><blockquote><p>从信息论的角度来看，描述信息源的数据是信息和数据冗余之和，即：数据=信息+数据冗余。</p></blockquote><p><strong>空间冗余</strong></p><blockquote><p>又称<strong>几何冗余</strong></p><p>同一景物表面上采样点的颜色之间通常存在着空间关联性，相邻各点的取值往往近似或者相同，这就是空间冗余</p><p>例如图片中有<strong>一片连续的区域像素都是相同的颜色</strong>，那么空间冗余就产生了</p><p>图像数据中经常存在的一种数据冗余，是静态图像中存在的最主要的一种数据冗余</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab399bc15dbbe7ffba271eba1017a694a5/0.png" alt="空间冗余"></p><p>图中虚线划出的区域便是</p><p><strong>时间冗余</strong></p><blockquote><p>又称<strong>帧间冗余</strong></p><p>在视频、动画图像中，相邻帧之间往往存在着时间和空间的相关性</p><p>例如人们在会议室中开会，随着会议的进行，时间在改变，但是背景（房间、家具等）一直是相同的、而且没有移动，变化的只是人们的动作和位置</p><p>这里的背景就反映为时间冗余。同样，由于人在说话时产生的音频也是连续和渐变的，因此声音信息中也会存在时间冗余</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab5df4c67d50850706fb13e5edd03f90ea/0.png" alt="时间冗余"></p><p><strong>视觉冗余</strong></p><blockquote><p>又称<strong>心理视觉冗余</strong></p><p>在多媒体技术的应用领域中，人的眼睛是图像信息的接收端。视觉冗余是相对于<strong>人眼的视觉特性</strong>而言的，人类的视觉系统并不能对图像画面的任何变化都能感觉到，通常情况下具有以下特点：</p><ol><li>对亮度的变化敏感，对色度的变化相对不敏感</li><li>对静止图像敏感，对运动图像相对不敏感</li><li>对图像的水平线条和竖直线条敏感，对斜线相对不敏感</li><li>对整体结构敏感，对内部细节相对不敏感</li><li>对低频信号敏感，对高频信号相对不敏感（如：对边沿或者突变附近的细节不敏感）</li><li>…..</li></ol><p>因此，包含在色度信号、运动图像、图像高频信号中的一些数据，相对于人眼而言，并不能对增加图像的清晰度作出贡献，<strong>被人眼视为多余的</strong>，这就是视觉冗余。</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab3f9691179be372457bad67abeab8ece4/0.png" alt="视觉冗余"></p><p><strong>编码冗余</strong></p><blockquote><p>推测可能是指的<strong>信息熵冗余</strong></p><p>具体的例子可以参考哈夫曼编码解决的问题：如何用0 1两种字符代表26个字母——哈夫曼编码能在这个问题中得到最优解，解决的正是编码冗余问题（但是哈夫曼编码在特定的情况下无法得到最优解）</p><p>数据压缩的理论极限是信息熵原理:</p><p>信息论之父香农指出，任何信息都存在冗余，冗余大小与信息中每个符号（数字、字母或单词）的出现概率或者说不确定性有关。香农借鉴了热力学的概念，把信息中<strong>排除了冗余后的平均信息量</strong>称为“信息熵”，并给出了计算信息熵的数学表达式：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab7e1df10b1601636fc9eebf6bb1b61c0d/0.png" alt="信息熵计算公式"></p><p>其中，pi代表随机事件i出现概率,log通常是以2为底——这里对数的底数选择是任意的，因为信息熵其实是一个相对值，但是传统是以2为底，这样一来不仅可以使得数据有通用性，而且还能用bit作为单位</p><p>如果要求编码过程中不丢失信息量，即要求保存信息熵，这种信息保持编码叫<strong>熵编码</strong>，是<strong>无损压缩</strong>的</p><p>常用的熵编码：<br>香农编码、 哈夫曼编码、 算术编码、 BLE行程编码、CAVLC基于上下文的自适应变长编码、CABAC基于上下文的自适应二进制算术编码</p></blockquote><p><strong>更多的冗余</strong></p><blockquote><p>还有其他多种冗余形式，比如结构冗余、其他冗余等等..<br>此处不再一一例举</p></blockquote><h2 id="编码处理过程"><a href="#编码处理过程" class="headerlink" title="编码处理过程"></a>编码处理过程</h2><blockquote><p>基本顺序依次为：</p><ol><li><strong>预测</strong><br>减少空间冗余、时间冗余</li><li><strong>变换</strong><br>减少空间冗余</li><li><strong>量化</strong><br>减少视觉冗余</li><li><strong>熵编码</strong><br>去除编码冗余</li></ol></blockquote><h2 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a>封装格式</h2><blockquote><p>封装格式是存储音视频、图片或者字幕信息的一种容器</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fab6b93341d2a767ea7f83854dcf8b27176/0.png" alt="常见封装格式发展一览"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842b21a24a61bfc3fabea700ed355541bd0be62792b700aa7ff/0.png" alt="常见封装格式和文件映射关系表"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>又一次感受到数学对计算机的印象，多亏了本次学习探索，窥见图像处理这个领域的一隅。</p><p>同时也勾起了对WebGPU，WebVR，WebXR，Webassembly，WebCodecs的向往</p><p>期待这些技术成熟时为我们带来的惊艳！</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote><ol><li><p><strong>字节跳动青训营培训资料</strong></p></li><li><p><strong>百度百科</strong><br><a href="https://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%86%97%E4%BD%99">https://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%86%97%E4%BD%99</a><br><a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%86%97%E4%BD%99">https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%86%97%E4%BD%99</a><br><a href="https://baike.baidu.com/item/%E8%A7%86%E8%A7%89%E5%86%97%E4%BD%99">https://baike.baidu.com/item/%E8%A7%86%E8%A7%89%E5%86%97%E4%BD%99</a><br><a href="https://baike.baidu.com/item/%E7%86%B5%E7%BC%96%E7%A0%81">https://baike.baidu.com/item/%E7%86%B5%E7%BC%96%E7%A0%81</a></p></li><li><p><strong>《图像处理学习笔记》</strong><br><a href="https://blog.csdn.net/qq_33208851/article/details/95335809">https://blog.csdn.net/qq_33208851/article/details/95335809</a></p></li><li><p><strong>《走进Web多媒体技术》</strong><br><a href="https://juejin.cn/post/7000726903787094029">https://juejin.cn/post/7000726903787094029</a></p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端游戏开发理论基础</title>
      <link href="/2022/02/01/gamedev/"/>
      <url>/2022/02/01/gamedev/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>​    没想到啊，本来这几天在学linux的，结果现在又来学前端游戏开发了，我真的是被迫营业啊</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/30</strong><br>你说吧，都要过年了，我这还被迫学习容易吗<br>算了，开工开工</p><p><strong>2022/02/01</strong></p><p>发布发布</p></blockquote><h2 id="游戏的定义"><a href="#游戏的定义" class="headerlink" title="游戏的定义"></a>游戏的定义</h2><h3 id="广义定义"><a href="#广义定义" class="headerlink" title="广义定义"></a>广义定义</h3><blockquote><p>一种有组织的玩耍，一般以娱乐为目的，有时也有教育目的<br>在英语中，体育比赛（Game）也是游戏，只要其活动本质带有目的、规则、挑战和互动，我们都可以把其归为游戏</p></blockquote><h3 id="狭义定义"><a href="#狭义定义" class="headerlink" title="狭义定义"></a>狭义定义</h3><blockquote><p>通过游戏引擎制作的电子游戏</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168421427961456ee7bf7e45b9d73d13d35bf5bc19df37e1a1c96/0.png" alt="游戏分类"></p><p>那么问题来了，MOBA算是哪一类呢？</p><p>MOBA全称是多人在线战术竞技游戏，是即时战略游戏（RTS)的一个子类</p><h2 id="游戏开发流程"><a href="#游戏开发流程" class="headerlink" title="游戏开发流程"></a>游戏开发流程</h2><p>一个最小规模但是完整的游戏开发团队只需要三个角色：策划、程序、美术</p><p>当然，能力够强的话可以作为独立开发者</p><h3 id="策划"><a href="#策划" class="headerlink" title="策划"></a>策划</h3><blockquote><p>负责设计规划各种数值和游戏内容等</p></blockquote><h3 id="美术"><a href="#美术" class="headerlink" title="美术"></a>美术</h3><blockquote><p>负责设计和制作原画、2D/3D模型、音效/动效等</p></blockquote><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><blockquote><p>前端、后端</p></blockquote><h3 id="其他支持"><a href="#其他支持" class="headerlink" title="其他支持"></a>其他支持</h3><blockquote><p>包括QA、运营、运维、市场等</p></blockquote><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168421427961456ee7bf7f1e3573f499a5a0165e2d505f20d3297/0.png" alt="开发流程图"></p><p>Demo阶段是，能够有基础的图形界面（小方块代表人物这种），各项数值能够在对应的时刻触发</p><h3 id="游戏引擎"><a href="#游戏引擎" class="headerlink" title="游戏引擎"></a>游戏引擎</h3><p>游戏引擎最大的功效：<strong>渲染</strong></p><blockquote><p>引擎 的诞生就是因为一家公司做了一款游戏，做下一款游戏时复用了上一款游戏的代码，后来发现这些代码几乎每个游戏都会用到,抽离出来就成了一个引擎。<br>如果不使用引擎，你可以做复杂的动效渲染和交互吗?当然可以。方便吗?不一定。<br>所以游戏引擎更像是一套解决方案，让你在制作某一类型的产品的时候能够提高你的开发效率。<br>做多平台移植:  <strong>React Native、Weex、Cordova</strong>等方案也可以做到。<br>做物理效果: <strong>MatterJS、ammo.js</strong>等物理引擎可以用。</p></blockquote><p>为什么使用游戏引擎呢？</p><blockquote><p>因为你想要的它能够给你一套完整的实现方案，不需要你再自己去拼凑、封装,让你花更少的时间做出更好的效果，特别是关于渲染效率和性能优化。<br>它提供游戏开发时需要的常见功能:引擎会提供许多组件，使用这些组件能缩短开发时间，让游戏开发变得更简单;专业引擎通常会能比自制引擎表现出更好的性能。<br>游戏引擎通常会包含渲染器，2D/3D图形元素，碰撞检测，物理引擎，声音，控制器支持，动画等部分。</p></blockquote><h3 id="市面上常见的游戏引擎"><a href="#市面上常见的游戏引擎" class="headerlink" title="市面上常见的游戏引擎"></a>市面上常见的游戏引擎</h3><blockquote><p><strong>Unreal</strong>(虚幻引擎，代表作《PUBG》、《GTA5》)<br><strong>Source</strong> (起源引擎，代表作《CS》、《Dota2》)<br><strong>Frostbite Engine</strong>(寒霜引擎，代表作《战地》、《极品飞车18》) <strong>Unity3D</strong>(代表作《炉石传说》、《王者荣耀》)</p></blockquote><p>但是这种是专业级游戏开发引擎，我们从前端过渡的话先从入门级引擎入手</p><h2 id="前端到游戏开发的过渡"><a href="#前端到游戏开发的过渡" class="headerlink" title="前端到游戏开发的过渡"></a>前端到游戏开发的过渡</h2><p>需要先有一个明确的认知:前端开发和游戏开发<strong>不是相斥的</strong></p><p>以web前端开发的视角看2d游戏引擎、无非是一套框架、一套解决方案，但游戏开发理念上更注重内容而已</p><blockquote><p>现在市场上很多H5游戏、小游戏都是Web前端开发制作的，而不是专门的游戏开发团队、专业的游戏研发同学开发。<br>其原 因可能在于:<br>1.接触前端开发的研发数量远大于接触游戏开发的数量(招聘成本高)2.2d游戏引擎的上手门槛已经足够低(易上手)<br>3.活动H5中的游戏玩法的实现方式比较模糊(开发界限模糊)<br>现在很多<strong>主流的2d游戏引擎都支持使用Javascript</strong>进行开发同时使用相关的工程化能力，也是游戏开发向web前端开发靠拢的一种表现。</p></blockquote><h3 id="The-NVL-Maker"><a href="#The-NVL-Maker" class="headerlink" title="The NVL Maker"></a>The NVL Maker</h3><blockquote><p>No Code无代码形式的开发，只需要写文字脚本加上一点配置就可以生成一个文字冒险游戏</p><p>虽然有一种年代感，但是还是能用的</p><p>代表作《Fate/stay night》和steam上一大把GAL Game</p></blockquote><p>其内有一个适用于前端的库AVG.js Project（以pixiJS为渲染引擎）</p><h3 id="RPG-Maker"><a href="#RPG-Maker" class="headerlink" title="RPG Maker"></a>RPG Maker</h3><blockquote><p>No Code低代码形式开发，需要微量代码能力</p><p>可以图形化编辑制作地图，并使用少量代码的RPG游戏</p><p>代表作《To the Moon》</p></blockquote><h3 id="Web游戏引擎"><a href="#Web游戏引擎" class="headerlink" title="Web游戏引擎"></a>Web游戏引擎</h3><blockquote><p>利用<strong>Canvas和 WebGL</strong>为底层技术抽象的图像绘制库（往往还附带一些其他的功能)Web游戏引擎的通用能力:</p><ol><li><p><strong>预加载</strong>:</p><p>游戏中往往存在大量的静态素材，包括场景、元素、声音、动画、模型、贴图等，如果以原生JS进行请求，并统筹请求时间和加载的时机，将会非常麻烦。游戏引擎中的预加载引擎将加载时机、加载过程加以抽象，解决加载编码中的效率问题。</p></li><li><p><strong>展示与图层、组合系统</strong>:</p><p>对于Web游戏编程而言，往往选择Canvas或 WebGL作为渲染方式(大家可以想想为什么不用DOM作为渲染方式?）。而 Canvas和 WebGL作为底层的API，接口非常基础，需要用大量的编码来编写简单的展示。而且图形之间没有组合和图层，很难处理元素组合和图层问题。渲染引擎和图层、组合系统应运而生。</p></li><li><p><strong>动画系统</strong>:</p><p>动画往往被分为缓动动画和逐帧动画，这里讨论缓动动画系统。缓动动画系统在原生JS中需要搭配帧渲染进行考量而进行书写，代码量和思考量巨大，抽象程度低，所以需要游戏引擎动画系统。</p></li><li><p><strong>音效和声音系统</strong>︰</p><p>游戏相较于普通的 Web前端而言需要更加立体、及时的反馈，声音和音效是反馈的重要组成部分。所以声音和音效系统往往包含了声音的播放、音量、截止、暂停等功能的集成.</p></li></ol></blockquote><p>Web游戏引擎中值得推荐的有</p><blockquote><p><strong>Cocos</strong>:<br>生态较好，功能支持完整，但是3D能力还有待提高（版本高速迭代ing）</p><p><strong>Laya</strong>:<br>3D能力成熟，据说市场占有率90%，支持JS、TS、AS，相对轻量，但是界面据说不友好，生态一般</p><p><strong>Egret</strong><br>工具链完善，第三方支持好，企业定制能力强，但是版本更新屡遭瓶颈，生态薄弱</p><p><strong>CreateJS和 Phaser</strong></p><p>是多个库的集合，比如CreateJS包括了EASEJS，TWEENJS，SOUNDJS, PRELOADJS，通过预加载后的素材展示、动画、声音构成游戏</p><p>Phaser则是除了CreateJS已有的内容以外，还设计了摄像机、物理引擎、内置浏览器、插件系统等高级功能</p></blockquote><p><strong>功能引擎</strong></p><blockquote><p>大型游戏引擎往往是由小的功能引擎组装成的，一个大型游戏引擎往往包含渲染引擎、物理引擎、Ul系统、声音系统、动画系统、粒子系统、骨骼系统、网络系统等组合而成。其中最重要的便是渲染引擎和物理引擎。<br>功能引擎是专注某个方向能力的引擎，其特点是体积小、功能完善。特别是Pixil.js和Three.js这两个渲染引擎，通常被误以为是一个完整的游戏引擎，但它们是专注渲染能力的渲染引擎。<br>下面介绍几种可能会经常接触的功能引擎:</p></blockquote><p>比如 </p><blockquote><p> <strong>Pixi.js</strong> </p><p> 2d渲染引擎，轻量化，在需要复杂动画、复杂图片渲染、用Canvas不想自己手写、自己制作2d游戏引擎的时候可以考虑它</p><p>AVG.js和Phaser.js的渲染引擎就是Pixi.js</p><p><strong>Three.js</strong></p><p>3d渲染引擎，API简明，支持WebGL和CSS3D两种渲染模式，在做3D或者WevVR的时候可以考虑</p><p><strong>Box2D.js</strong></p><p>2d物理引擎，接口简单，物理效果强大，在做物理效果的时候可以考虑</p></blockquote><p>以Pixi.js为例了解其渲染流程：</p><blockquote><p>以Pixi的渲染流程为例子大致流程如下<br>1.创建一个Renderer渲染器，获取它的view (一个canvas对象)，添加到Dom Tree中。(或者指定Dom Tree中已经存在的canvas对象作为view)</p><p>2.在MainLoop(主循环)中调用Renderer.render()并传入一个DisplayObject作为根节点开发渲染。</p><p>3.从场景树的根节点开始，以zlIndex为序从小到大进行深度优先遍历，对每个节点进行渲染操作，由后往前把整个场景绘制一次。(CanvasRenderer)</p><ol start="4"><li>WebGL的render方法执行</li></ol></blockquote><h3 id="游戏开发技能树"><a href="#游戏开发技能树" class="headerlink" title="游戏开发技能树"></a>游戏开发技能树</h3><p>最大的差别在于不深入学习CSS，而是学习游戏相关的样式概念</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253ecd37dbe503202f5544b3a011e712a72a370b01a738975/0.png"></p><p>入门建议学习CoCos</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253ecd37dbe5032026c0135077b7920449691116ad7ab7936/0.png"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253ecd37dbe503202c9e3cadb4fe43125661b373c769edbd0/0.png"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253ecd37dbe503202ecf38946994e5f56c5a828505cc5681b/0.png"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253ecd37dbe5032028f6fc8c1947de5e234274bbfec4f11f0/0.png"></p><p>这些据说和React类似</p><p>具体内容这里暂时不提了，有兴趣就学，（现在我web都还没摸透呢…）</p><h3 id="游戏平台"><a href="#游戏平台" class="headerlink" title="游戏平台"></a>游戏平台</h3><p>众所周知国内游戏发布变得困难起来了，所以发布平台要选好啊，不然限流下架免不了啊，x399这个就不考虑了，入门可以考虑一下Web Mobile这些平台（小程序游戏的话可以考虑去对应的平台），以后有资金了能开注册公司的话就可以考虑一下Steam之类的平台了</p><p>另外，说一下H5和小程序游戏</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684253ecd37dbe503202d0eff5770fe98186958d786948ea19fd/0.png"></p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2022/01/28/webpack/"/>
      <url>/2022/01/28/webpack/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>说实话，我之前是没有系统学习过webpack的，对webpack技术的使用最多就是创建项目和打包文件</p><p>但是这样好吗，当然不好，所以我还是得找时间系统学一下<br>至于要学成什么样子，这里分几个阶段</p><ul><li>入门：灵活运用webpack</li><li>进阶：能够扩展webpack</li><li>大师：源码级理解打包编译过程</li></ul><p>这里我们先要做到入门，后面在不久后的学习实践中一步一步提升</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/28</strong><br>与JavaScript复习笔记一起，并发地更新！</p><p><strong>2022/02/07</strong><br>迂回前进，更新webpack基础使用部分</p><p><strong>2022/04/04</strong><br>迂回前进，更新webpack实战部分</p><p><strong>2022/04/10</strong><br>更新进阶部分</p></blockquote><h2 id="webpack概述"><a href="#webpack概述" class="headerlink" title="webpack概述"></a>webpack概述</h2><h3 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h3><p>前端项目由什么构成——资源:</p><blockquote><p>PNG,    JPG,    GIF,    WEBP,    JS,    TS,<br>CSS,    Less， Vue，  JSX，    Sass ……</p></blockquote><p>webpack默认只处理js、json等文件，所以如果要处理图片、css、html等文件的话还需要进行一些配置</p><p><strong>历史背景</strong></p><p>但是在上个世代（2009以前），如果手动管理资源却发现这里有N个script标签，而且它们之间或者它们和部分代码有前驱后继关系，并且N非常大时，整个项目变得不易维护</p><p><strong>出现的问题</strong></p><blockquote><ul><li><p>浏览器不识别Sass、Less ==&gt; 需要预编译成css ==&gt; 浏览器正确识别</p></li><li><p>项目中的模块化以及互相之间引用依赖造成文件分散 ==&gt; 需要把各个分散的模块集中打包成大文件，减少HTTP的链接的请求次数</p></li><li><p>文件体积大 ==&gt; 代码压缩</p></li><li><p>部分ES6语法有兼容问题 =&gt; ES5 ==&gt;浏览器使用 </p></li></ul></blockquote><p><strong>前端工程化</strong></p><p>随着时代的发展，越来越多的工具出现，而其中一些工具——诸如webpack，Gulp、rollup.js，browserify，Vite等，而正是这部分工具的出现才有了前端工程化这种概念</p><p>我们将其中的webpack定义为</p><blockquote><p><strong>一种前端资源编译、打包工具</strong></p></blockquote><h3 id="webpack能做什么"><a href="#webpack能做什么" class="headerlink" title="webpack能做什么"></a>webpack能做什么</h3><p>编译、打包这个说法还是太笼统了，webpack的功能具体如下：</p><blockquote><ul><li>多份资源文件打包成一个Bundle</li><li>支持Babel、Eslint、TS、CoffeScript、Less、Sass</li><li>支持模块化处理css、图片等资源文件</li><li>支持HMR + 开发服务器</li><li>支持持续监听、持续构建</li><li>支持代码分离</li><li>支持Tree-shaking</li><li>支持Sourcemap</li><li>……..</li></ul></blockquote><p>总的来说，webpack具有三种基本能力：处理依赖、模块化、打包</p><blockquote><p><strong>处理依赖</strong><br>方便引用第三方模块，让模块共容易复用，避免全局注入导致冲突、避免重复加载或者加载不必要的模块</p><p><strong>合并代码</strong><br>把各个分散的模块集中打包成大文件，减少HTTP请求，优化代码体积</p><p><strong>各种插件</strong><br>内置的babel能把ES6+转化为ES5-</p></blockquote><h3 id="最小规模使用"><a href="#最小规模使用" class="headerlink" title="最小规模使用"></a>最小规模使用</h3><p><strong>第一步： 初始化项目</strong></p><p>首先先要<strong>将项目初始化为一个包</strong>，</p><blockquote><p>如何初始化为一个包？<br>如果不太懂的话，建议先学习前置知识：<strong>Node.JS基础</strong></p></blockquote><p><strong>第二步：安装依赖</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i -D webpack webpack-cli# 上述代码是同时安装多个包，等价于：# npm install webpack --save-dev# npm install webpack-cli --save-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>第三步：开始打包</strong></p><p>在终端，到项目根目录下使用：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">webpack [入口文件路径] -o [输出路径] --mode=[模式]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>示例</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">webpack ./index.js -o ./dist/index.js --mode=production<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>效果</strong></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684272c1e41c87bbf21c1eb276d1dae2755edde3f631f5c99157/0.png" alt="image.png"></p><h3 id="五个核心概念"><a href="#五个核心概念" class="headerlink" title="五个核心概念"></a>五个核心概念</h3><blockquote><p> <strong>入口entry</strong><br> 指示以哪个文件为入口起点开始打包，分析内部依赖图</p><p> <strong>出口output</strong><br> 指示打包后的资源输出到哪里，以及如何命名</p><p> <strong>加载器loader</strong><br> 让webpack能够去处理非JS文件（webpack自身只能理解JS，loader相当于翻译其他类型)</p><p> <strong>插件plugins</strong><br> 插件可以用于执行范围更广的任务，比如打包优化和压缩，一直到重新定义环境中的变量（loader可以看做负责翻译的plugin，功能扩展就需要plugins来做)</p><p> <strong>模式mode</strong><br> 模式指示webpack使用相应模式的配置，一般只用两种：development和production模式</p></blockquote><p>按照上面这个介绍，我们在项目文件根目录下写一个webpack.config.js:</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>        entry<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>        output<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        module<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// loader的配置</span>        rules<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>        plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        mode<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基础配置及其注意事项"><a href="#基础配置及其注意事项" class="headerlink" title="基础配置及其注意事项"></a>基础配置及其注意事项</h3><p>上述配置还只是一个空的架子，需要填充一些具体的内容</p><p>这里以打包js，css，less为例进行说明，需要补充说明的内容都放到了注释里面</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*    所有的构建工具都是基于nodejs平台运行的，模块化默认采用commonjs*/</span><span class="token keyword">const</span> <span class="token punctuation">{</span>resolve<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment">// webpack配置</span>    entry<span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>    output<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token comment">// 输出文件名</span>        filename<span class="token operator">:</span> <span class="token string">"built.js"</span><span class="token punctuation">,</span>        <span class="token comment">// 输出路径</span>        <span class="token comment">// __dirname是当前项目(这个包)的绝对路径</span>        <span class="token comment">// 这里必须采用绝对路径，否则报错</span>        path<span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment">// loader的配置</span>    module<span class="token operator">:</span> <span class="token punctuation">{</span>        rules<span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token comment">// 详细的loader配置</span>            <span class="token punctuation">{</span>                <span class="token comment">// 匹配要处理的文件,这里是以css结尾的文件</span>                test<span class="token operator">:</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                <span class="token comment">// 使用哪些loader进行css的处理</span>                <span class="token comment">// loader有严格的先后关系，</span>                <span class="token comment">// ！执行顺序是从下往上 从右往左   </span>                use<span class="token operator">:</span> <span class="token punctuation">[</span>                    <span class="token comment">// 创建style标签，将js中的样式文件插入到其中，添加到head中生效</span>                    <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                    <span class="token comment">// 将css文件变成commonjs模块加载到js中，内容以字符串形式显示</span>                    <span class="token string">'css-loader'</span>                <span class="token punctuation">]</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.less$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                use<span class="token operator">:</span> <span class="token punctuation">[</span>                    <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                    <span class="token string">'css-loader'</span><span class="token punctuation">,</span>                    <span class="token string">'less-loader'</span>                <span class="token punctuation">]</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment">// plugin配置</span>    plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment">// 模式</span>    mode<span class="token operator">:</span> <span class="token string">'development'</span><span class="token comment">// 有development和production两种选择</span><span class="token comment">// 前者会保留注释，调试信息等，用于检测是否能够正确运行</span><span class="token comment">// 后者尽可能压缩代码，比如省去函数的运行过程而只保留结果，以及将全部代码压缩到一行</span><span class="token punctuation">}</span><span class="token comment">// 配置完毕之后，直接在要打包文件所在的目录层级下使用webpack命令就可以直接打包</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="webpack实战"><a href="#webpack实战" class="headerlink" title="webpack实战"></a>webpack实战</h2><p>初学者可以看做是练习题，一开始是题目要求，最后是答案</p><h3 id="打包JS和JSON文件"><a href="#打包JS和JSON文件" class="headerlink" title="打包JS和JSON文件"></a>打包JS和JSON文件</h3><p>webpack默认情况下是只支持打包JS和JSON文件的</p><p><strong>情景描述</strong></p><p>这里我们想把这个引用了JSON的JS文件打包到./build/built.js文件夹下面</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684272c1e41c87bbf21c050519cccd9c359bb832e091edd7d1a9/0.png" alt="image.png"></p><p><strong>答案</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">webpack ./src/index.js -o ./build/built.js --mode=development<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="打包CSS和Less"><a href="#打包CSS和Less" class="headerlink" title="打包CSS和Less"></a>打包CSS和Less</h3><p>webpack不能直接识别CSS和Less，这里就需要loader来翻译一下，也需要创建一个webpack.config.js文件进行配置</p><p><strong>情景描述</strong></p><p>将CSS和Less打包到js中</p><p>（build中的html文件为打包后手动创建，此处无需在意）</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684272c1e41c87bbf21cbf520f77d2a6475c0ab85971091ebc3f/0.png" alt="image.png"></p><p><strong>方案</strong></p><p>这里在webpack.config.js中进行配置<br>这里需要用到loader，每一个loader都需要手动安装依赖</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span>resolve<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>    output<span class="token operator">:</span> <span class="token punctuation">{</span>        filename<span class="token operator">:</span> <span class="token string">"built.js"</span><span class="token punctuation">,</span>        path<span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    module<span class="token operator">:</span> <span class="token punctuation">{</span>        rules<span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token operator">:</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                use<span class="token operator">:</span> <span class="token punctuation">[</span>                    <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                    <span class="token string">'css-loader'</span>                <span class="token punctuation">]</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.less$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                use<span class="token operator">:</span> <span class="token punctuation">[</span>                    <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                    <span class="token string">'css-loader'</span><span class="token punctuation">,</span>                    <span class="token string">'less-loader'</span>                <span class="token punctuation">]</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    mode<span class="token operator">:</span> <span class="token string">'development'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自动生成html且自动引入"><a href="#自动生成html且自动引入" class="headerlink" title="自动生成html且自动引入"></a>自动生成html且自动引入</h3><p><strong>情景描述</strong></p><p>如题</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168421849ddca20346d4924bcdd0e6d8cf2fcab20d78c54da2a8b/0.png" alt="image.png"></p><p><strong>方案</strong><br>这里需要用到plugins，配置一个HtmlWebpackPlugin插件，和loader一样，都需要手动安装依赖，但是比loader多了一个用require引入的过程</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// loader: 下载 使用</span><span class="token comment">// plugins: 下载 引入 使用</span><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span> resolve <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>    output<span class="token operator">:</span> <span class="token punctuation">{</span>        filename<span class="token operator">:</span> <span class="token string">'built.js'</span><span class="token punctuation">,</span>        <span class="token comment">// 必须使用绝对路径，不然webpack会报错</span>        path<span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    module<span class="token operator">:</span> <span class="token punctuation">{</span>        rules<span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                use<span class="token operator">:</span> <span class="token punctuation">[</span>                    <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                    <span class="token string">'css-loader'</span>                <span class="token punctuation">]</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token comment">// 复制template指定的html文件。并自动引入打包后输出的其他资源</span>        <span class="token comment">// 所以指定的html不能手动引入资源，不然会重复引入报错</span>        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            <span class="token comment">// 如果这个html文件里面什么都不写的话,那么打包后只有head标签和script标签</span>            template<span class="token operator">:</span> <span class="token string">'./src/index.html'</span><span class="token punctuation">,</span>            filename<span class="token operator">:</span> <span class="token string">'index.html'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    mode<span class="token operator">:</span> <span class="token string">'development'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="打包图片"><a href="#打包图片" class="headerlink" title="打包图片"></a>打包图片</h3><p>注意，这里的图片只包括了jpg，png，gif三种格式，至于webp等其他格式还需要别的loader，不过配置方式大同小异，具体方式读者自行查阅，此处不再赘述</p><p><strong>情景描述</strong><br>需要处理html中img标签和less中的图片url</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168421849ddca20346d49b905c3caa34ca1f1bd289b844484f93a/0.png" alt="image.png"></p><p><strong>方案</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"html-webpack-plugin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">{</span> resolve <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>    output<span class="token operator">:</span> <span class="token punctuation">{</span>        filename<span class="token operator">:</span> <span class="token string">'js/built.js'</span><span class="token punctuation">,</span>        path<span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    module<span class="token operator">:</span> <span class="token punctuation">{</span>        rules<span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.less$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                use<span class="token operator">:</span> <span class="token punctuation">[</span>                    <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                    <span class="token string">'css-loader'</span><span class="token punctuation">,</span>                    <span class="token string">'less-loader'</span>                <span class="token punctuation">]</span>             <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(jpg|png|gif)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                               <span class="token comment">// 这里需要安装 url-loader 和 file-loader,</span>                <span class="token comment">// url-loader会讲图片编为base64</span>                <span class="token comment">// file-loader可以加载本地图片</span>                <span class="token comment">// 仅有一个loader则不需要使用use</span>                loader<span class="token operator">:</span> <span class="token string">'url-loader'</span><span class="token punctuation">,</span>                options<span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token comment">// 如果图片大小小于8kb，那么就会被处理为base64</span>                    limit<span class="token operator">:</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span>                    <span class="token comment">// url-loader默认用es6模块去解析，</span>                    <span class="token comment">// html-loader引入图片是commonjs模块</span>                    <span class="token comment">// 为了防止冲突，这里统一用commonjs</span>                    esModule<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                    <span class="token comment">// 随机生成的文件名太长了，下面是指定命名：</span>  <span class="token comment">// image文件夹下，hash值的前10位.扩展名</span>                    name<span class="token operator">:</span> <span class="token string">'image/[hash:10].[ext]'</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>                       <span class="token punctuation">{</span>                test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.html$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>               <span class="token comment">// 处理html中的img标签，</span><span class="token comment">//负责引入img从而能够被url-loader进行处理</span>                loader<span class="token operator">:</span> <span class="token string">'html-loader'</span><span class="token punctuation">,</span>                options<span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token comment">// webpack4 只需要在url-loader配置，</span>                    <span class="token comment">// webpack5还需要在这里配置</span>                    esModule<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>        plugins<span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            filename<span class="token operator">:</span> <span class="token string">'index.html'</span><span class="token punctuation">,</span>            template<span class="token operator">:</span> <span class="token string">'./src/index.html'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    mode<span class="token operator">:</span> <span class="token string">"production"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="剥离、合并、压缩及兼容处理CSS"><a href="#剥离、合并、压缩及兼容处理CSS" class="headerlink" title="剥离、合并、压缩及兼容处理CSS"></a>剥离、合并、压缩及兼容处理CSS</h3><p><strong>情景描述</strong><br>基于上一个情景，这里需要把less和css全部打包到一个单独的css文件中，并且这个css会自动兼容大部分浏览器（加上私有前缀等操作），最后被自动引入html中</p><p><strong>方案</strong><br>这里的配置有一点繁琐，首先需要在package.json中加上新的字段:</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"browserslist"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"development"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token string">"last 1 chrome version"</span><span class="token punctuation">,</span>      <span class="token string">"last 1 firefox version"</span><span class="token punctuation">,</span>      <span class="token string">"last 1 safari version"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"production"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token string">"&gt;0.01%"</span><span class="token punctuation">,</span>      <span class="token string">"not dead"</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里就是说，<br>开发环境下，需要兼容的浏览器及其版本(chrome,firefox,safari的最新版)；</p><p>生产环境下，需要兼容的浏览器及其范围(兼容99.9%以上的属性，没有停运的浏览器)</p><p>注意，<strong>这里的生产环境和开发环境不是webpack决定的，而是node决定的！</strong><br>意思是，它不取决于webpack的mode字段，而是由下面这条语句进行配置：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">=</span> <span class="token string">'development'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>知道了这些之后，我们直接看看webpack.config.js该如何配置</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"html-webpack-plugin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span><span class="token comment">// 提取,合并css文件</span><span class="token keyword">const</span> CssMinimizerPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'css-minimizer-webpack-plugin'</span><span class="token punctuation">)</span><span class="token comment">// 压缩css文件内容</span><span class="token keyword">const</span> <span class="token punctuation">{</span> resolve <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置node的环境变量，</span><span class="token comment">// 这样就会去package.json中找到browserlist中的development</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">=</span> <span class="token string">'development'</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>    output<span class="token operator">:</span> <span class="token punctuation">{</span>        filename<span class="token operator">:</span> <span class="token string">'js/built.js'</span><span class="token punctuation">,</span>        path<span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    module<span class="token operator">:</span> <span class="token punctuation">{</span>        rules<span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                use<span class="token operator">:</span> <span class="token punctuation">[</span>                    <span class="token comment">// style-loader是从JS中插入到style标签，</span>                    <span class="token comment">// 这里我们把CSS单独提取出来所以不用它</span>                    <span class="token comment">// 'style-loader',</span>                    MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>                    <span class="token string">'css-loader'</span>                <span class="token punctuation">]</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.less$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                use<span class="token operator">:</span> <span class="token punctuation">[</span>                     <span class="token punctuation">{</span>                        loader<span class="token operator">:</span> MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>                        options<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>                      <span class="token punctuation">}</span><span class="token punctuation">,</span>                    <span class="token string">'css-loader'</span><span class="token punctuation">,</span>                    <span class="token comment">// postcss会去package.json里面找browserslist，并据此调整css的兼容性样式（比如加上浏览器的私有前缀等等)</span>                    <span class="token punctuation">{</span>                        loader<span class="token operator">:</span> <span class="token string">'postcss-loader'</span><span class="token punctuation">,</span>                        options<span class="token operator">:</span> <span class="token punctuation">{</span>                            postcssOptions<span class="token operator">:</span> <span class="token punctuation">{</span>                                plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'postcss-preset-env'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                    <span class="token string">'less-loader'</span>                <span class="token punctuation">]</span>             <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(jpg|png|gif)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                loader<span class="token operator">:</span> <span class="token string">'url-loader'</span><span class="token punctuation">,</span>                options<span class="token operator">:</span> <span class="token punctuation">{</span>                    limit<span class="token operator">:</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span>                    esModule<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                    name<span class="token operator">:</span> <span class="token string">'image/[hash:10].[ext]'</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.html$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                loader<span class="token operator">:</span> <span class="token string">'html-loader'</span><span class="token punctuation">,</span>                options<span class="token operator">:</span> <span class="token punctuation">{</span>                    esModule<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>        plugins<span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            filename<span class="token operator">:</span> <span class="token string">'index.html'</span><span class="token punctuation">,</span>            template<span class="token operator">:</span> <span class="token string">'./src/index.html'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            <span class="token comment">// 整合到一个CSS中，自动处理冲突</span>            filename<span class="token operator">:</span> <span class="token string">'./css/index.css'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token comment">// 下面这个是为了把单独剥离出来的CSS文件压缩成一行</span>        <span class="token comment">// 如果不装这个的话，纵使是生产环境，也只有html和js是一行的状态</span>        <span class="token keyword">new</span> <span class="token class-name">CssMinimizerPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    mode<span class="token operator">:</span> <span class="token string">"production"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="webpack进阶-待更新"><a href="#webpack进阶-待更新" class="headerlink" title="webpack进阶(待更新)"></a>webpack进阶(待更新)</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><blockquote><p>HMR<br>resolve<br>optimization<br>dll<br>production<br>development<br>eslint<br>babel<br>pwa<br>loader<br>plugin<br>devtool<br>性能优化<br>tree shaking<br>code split<br>caching<br>lazy loading<br>library<br>shimming</p></blockquote><h3 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>当我们修改一行代码，整个项目就得重新转译打包，效率十分低下，这时候就得考虑HMR了</p><blockquote><p><strong>Hot Module Replacement</strong>，即<strong>热模块替换</strong></p><p>这里需要知道，和五个核心字段平级的内容中有一个watch字段，可以通过设置<code>watch:true</code>自动重新打包，但是这样的自动更新依旧是打包整个项目，不能算是HMR（<code>watch:true</code>还有另一种写法就是在package.json中的scripts中配置<code>webpack (略) --watch </code>来达到同样的效果)</p><p><strong>永远不要再生产模式下启用HMR</strong></p></blockquote><h4 id="webpack服务器"><a href="#webpack服务器" class="headerlink" title="webpack服务器"></a>webpack服务器</h4><p>vscode插件live-server能够自动刷新页面实现类似的功能（热重载）</p><p>但是我们希望能够用webpack来实现，所以我们<strong>需要安装webpack-dev-server</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install webpack-dev-server -Dwebpack serve # 默认跑8080# 由于webpack的版本兼容问题，这里也可能不能运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个服务器是基于Node的express框架的</p><p>和直接使用webpack打包出的静态页面不同，这里不会生成任何文件，这是因为文件操作效率较低，所以webpack-dev-server选择将编译的结果放到内存中，再从内存中读取。</p><p>如果你想要基于其他的框架，那么可以这么做：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install webpack-dev-middleware express # 基于express<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在node的express后端文件中引入这个包，并使用<code>app.use()</code>来启用这个引入的包</p><p>此后便可以使用这个包来处理文件，返回express的中间件</p><blockquote><p>具体实现有一点繁琐，此处不再赘述</p></blockquote><h4 id="使用HMR"><a href="#使用HMR" class="headerlink" title="使用HMR"></a>使用HMR</h4><blockquote><p>这里主要是学习webpack5，需要注意其HMR配置方式与旧版本有所冲突</p><p>之前说的live-server，watch，（直接使用）webpack-dev-server这些，都是刷新整个页面；</p><p>HRM是需要在webpack-dev-server上使用的</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>entry<span class="token operator">:</span> <span class="token string">''</span>    <span class="token comment">// 略</span>    devServer<span class="token operator">:</span> <span class="token punctuation">{</span>    hot<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://ewr1.vultrobjects.com/imgur1/000/002/534/279_269_bef.JPEG" alt="HRM运行机制（图片来自网络）"></p><blockquote><p>1.webpack监听到文件的变化，进行新的编译和打包，而且以简单的js对象保存在内存中。web</p><p>2.webpack与devServer进行交互，告诉webpack要保存代码到内存中。json</p><p>3.devServer对文件的监控，而且经过配置来告诉devServer是刷新仍是进行热更新。浏览器</p><p>4.devServer经过sock.js和浏览器创建websock长连接，把webpack编译代码各阶段信息告诉浏览器(包括更新模块的hash)，就是经过这一个hash来进行更新的。服务器</p><p>5.webpack经过devServer的配置和传递给他的信息（也就是第二部监听的信息）来决定是否进行浏览器刷新或者热更新。</p><p>6.webpack的HotModuleReplacement经过JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了全部要更新的模块的hash值，获取到更新列表后，该模块再次经过jsonp请求，获取到最新的模块代码。这就是上图中 七、八、9 步骤。webpack-dev-server</p><p>10.HotModulePlugin将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。jsonp</p><p>11.当 HMR 失败后，回退到 live reload 操做，刷新浏览器。</p></blockquote><h3 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h3><blockquote><p>一种源代码到构建后代码映射技术</p><p>如果构建后的代码出错了，通过映射可以追踪到源代码的错误</p></blockquote><h4 id="使用source-map"><a href="#使用source-map" class="headerlink" title="使用source-map"></a>使用source-map</h4><p>配置方式很简单，就是参数有点多</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>entry<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>    <span class="token comment">// 略</span>    source<span class="token operator">-</span>map<span class="token operator">:</span> inline<span class="token operator">-</span>source<span class="token operator">-</span>map    <span class="token comment">// 参数的格式是[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>source-map是通过base64编码来映射的<br>下面是几种常见的参数:</p><blockquote><p><strong>source-mao</strong> 外部<br>包含 错误信息 和 错误在源代码的位置<br><strong>inline-source-map</strong> 内联<br>包含 错误信息 和 错误在源代码的位置<br>嵌入到构建后的js文件中<br><strong>hidden-source-map</strong> 外部<br>包含 错误信息<br>单独作为一个文件<br><strong>eval-source-map</strong> 内联<br>但是追加到相应的每个文件标识符后<br>包含 错误信息 和 错误在源代码的位置<br><strong>nosources-source-map</strong> 外部<br>包含错误代码准确信息<br><strong>cheap-source-map</strong> 外部<br>包含错误信息 和 错误在源代码的位置（只能精确到行）<br><strong>cheap-module-source-map</strong> 外部<br>包含错误信息 和 错误在源代码的位置（只能精确到行）</p></blockquote><h4 id="参数性能比较"><a href="#参数性能比较" class="headerlink" title="参数性能比较"></a>参数性能比较</h4><p><strong>速度</strong></p><blockquote><p>eval&gt;inline&gt;cheap&gt;…<br>eval-cheap-source-map<br>eval-source-map</p></blockquote><p><strong>调试友好</strong></p><blockquote><p>source-map<br>cheap-module-source-map<br>cheap-source-map</p></blockquote><p>所以结论是：</p><p>调试最友好：eval-source-map(脚手架默认)<br>速度最快：eval-cheap-module-source-map</p><h3 id="oneOf"><a href="#oneOf" class="headerlink" title="oneOf"></a>oneOf</h3><p>正常打包流程，是所有loader都会被走一遍，这样其实没有必要，所以我们可以用oneOf来处理一下，<strong>最多执行一次loader</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment">// 略</span>    module<span class="token operator">:</span> <span class="token punctuation">{</span>        rules<span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>               oneOf<span class="token operator">:</span> <span class="token punctuation">[</span>               <span class="token comment">// 这里面的东西仅会执行一个，不能有两个配置处理同一个类型文件</span>                   <span class="token punctuation">{</span>                       test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                       enforce<span class="token operator">:</span> <span class="token string">'pre'</span> <span class="token comment">// 优先级更高</span>                       <span class="token comment">// 略   </span>                   <span class="token punctuation">}</span><span class="token punctuation">,</span>                   <span class="token punctuation">{</span>                       test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.less$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                        <span class="token comment">// 略   </span>  <span class="token punctuation">}</span>               <span class="token punctuation">]</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="babel缓存"><a href="#babel缓存" class="headerlink" title="babel缓存"></a>babel缓存</h3><h4 id="使用babel缓存"><a href="#使用babel缓存" class="headerlink" title="使用babel缓存"></a>使用babel缓存</h4><p>和HMR有类似之处，比如100个模块，1个变了其他99个也得一起重新编译，<br>由于HMR是基于开发环境下的webpack-dev-server的，<br>所以生产环境下是用不了HMR的，这就得利用缓存来实现类似的功能</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment">// 略</span>    module<span class="token operator">:</span> <span class="token punctuation">{</span>        rules<span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>               <span class="token punctuation">{</span>                   test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                   cacheDirectory<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 开启babel缓存,下次构建就会读取缓存就更快了</span>                       <span class="token comment">// 略   </span>            <span class="token punctuation">}</span>              <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里读取缓存可能会有些问题<br>浏览器缓存是只有响应头才能设置的，前端这里设置的是本地缓存。<br>本地缓存中更新的内容大概是被浏览器缓存缓存的旧内容覆盖而没有呈现，所以提出给文件名做一些处理：<code>文件名+id</code>，这样处理后浏览器缓存中就没有这个更新的文件，自然会从本地读取</p><h4 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h4><p>基于<code>文件名+id</code>的可行性，我们需要思考如何找到一个唯一的id值</p><p><strong>hash</strong></p><blockquote><p>每次webpack构建时会生成一个唯一的hash值<br>因为js和css会同时使用一个hash值，所以会导致所有缓存失效</p></blockquote><p><strong>chunkhash</strong></p><blockquote><p>根据chunk生成的hash值，如果打包来源来源于同一个chunk，那么hash就是一样</p><p>chunk是代码块的意思，可以理解为模块的封装单元</p></blockquote><p><strong>contenthash</strong></p><blockquote><p>根据文件内容生成hash，不同文件hash值一定不同</p></blockquote><p>上述三种hash的使用方式都是类似的：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">filename<span class="token operator">:</span> <span class="token string">'index.[hash:10].html'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>这个tree要怎么理解呢，可以看看webpack的logo图，再想想webpack的入口文件这些，一切似乎就有了一个轮廓了——入口文件的代码就是根节点，引入的其他文件就是子节点，如是递归，就形成了一棵树</p><p>那么shaking是什么呢，就是一个比喻，通过摇晃这个树，抖掉书上没用的枯叶——没用到的代码</p><blockquote><p>速成就是<strong>树摇</strong>，但似乎也没有更官方的翻译了..<br>主要是针对JS代码，通过import和export确定树的结构</p></blockquote><p>这个性质是默认启用的，所以直接打包即可</p><h4 id="代码的副作用"><a href="#代码的副作用" class="headerlink" title="代码的副作用"></a>代码的副作用</h4><blockquote><p>「副作用」的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。</p></blockquote><p>如果在package.json中配置<code>sideEffects:false</code>，那么将把所有代码都视为没有副作用，都将进行tree shaking过滤</p><p>也可以配置为形如<code>sideEffects:["*.css"]</code>来指定哪些文件可以视为没有副作用，限制tree shaking的过滤范围</p><h3 id="code-split"><a href="#code-split" class="headerlink" title="code split"></a>code split</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><blockquote><p>将打包输出的一个文件输出为多个文件（切片），加载时就可以实现<strong>按需加载、并行加载</strong>等等</p></blockquote><h4 id="使用code-split"><a href="#使用code-split" class="headerlink" title="使用code split"></a>使用code split</h4><blockquote><p>有三种常用的代码分离方法：</p><ul><li>入口起点：使用 <a href="https://webpack.html.cn/configuration/entry-context"><code>entry</code></a> 配置手动地分离代码。</li><li>防止重复：使用 <a href="https://webpack.html.cn/plugins/commons-chunk-plugin"><code>CommonsChunkPlugin</code></a> 去重和分离 chunk。</li><li>动态导入：通过模块的内联函数调用来分离代码。</li></ul></blockquote><p><strong>入口起点</strong></p><p>有几个入口就有几个打包的文件</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token operator">:</span> <span class="token punctuation">{</span>main<span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>    test<span class="token operator">:</span> <span class="token string">'./src/test.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    output<span class="token operator">:</span> <span class="token punctuation">{</span>    filename<span class="token operator">:</span> <span class="token string">'js/[name].[contenthash:10].js'</span><span class="token punctuation">,</span>        path<span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>     plugins<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">HTMLWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>防止重复</strong></p><p>这事基于多入口的，在此基础上做出了改进</p><p>如果a.js，b.js都引用了c.js，那么以ab为入口打包的话生成的两个包都会包含c.js，导致重复打包，这样就需要设置optimization</p><blockquote><ol><li>会将node_modules中的代码单独打包到一个chunk中，供其他文件引用</li><li>自动分析多入口chunk的公共文件，如果有则会提取出作为一个单独的chunk</li></ol></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token operator">:</span> <span class="token punctuation">{</span>        index<span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>    test<span class="token operator">:</span> <span class="token string">'./src/test.js'</span>    <span class="token punctuation">}</span>    <span class="token comment">// 略</span>    optimization<span class="token operator">:</span> <span class="token punctuation">{</span>splitChunks<span class="token operator">:</span> <span class="token punctuation">{</span>            chunks<span class="token operator">:</span> <span class="token string">'all'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>动态导入</strong></p><p>有猜测说这可能是用了ES11的新特性</p><p>在JS文件中</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">'./xxx'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'动态导入成功'</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// es6的模块，导入成功后会被单独打包</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'动态导入失败'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="懒加载和预加载"><a href="#懒加载和预加载" class="headerlink" title="懒加载和预加载"></a>懒加载和预加载</h3><h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><h3 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h3><h3 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h3>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全基础攻防技术</title>
      <link href="/2022/01/26/websafety/"/>
      <url>/2022/01/26/websafety/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>二进制的计算机世界中黑白之中的灰色地带，一场剑与盾的战争悄然上演！<br>没有战火，没有硝烟，只有无数暗流涌动，这就是Web安全</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/25</strong><br>开始学习</p><p><strong>2002/01/26</strong><br>初步记录完毕</p></blockquote><h2 id="跨站脚本攻击XSS"><a href="#跨站脚本攻击XSS" class="headerlink" title="跨站脚本攻击XSS"></a>跨站脚本攻击XSS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Cross-Site Script，本该简称CSS，但为了避免歧义，所以就叫XSS<br>(X就是Cross嘛)<br>是最常见的一种攻击手段</p></blockquote><p>有如下几种常见的类型:</p><blockquote><ol><li><strong>Stored XSS</strong><br>存储型XSS，恶意脚本存到数据库中，在访问页面并进行数据读取时发动攻击，伤害最大，对全部用户可见</li><li><strong>Reflected XSS</strong><br>反射型XSS，从URL上攻击，将恶意脚本填入URL参数的值中，在执行GET请求时发动</li><li><strong>DOM-Based XSS</strong><br>基于DOM的XSS，不需要服务器参与，全程在浏览器完成。注入原理同反射型XSS，但是执行条件是JS利用URL参数创建DOM</li><li><strong>Mutation-based XSS</strong><br>基于变化的XSS，利用浏览器渲染DOM的特性，比如在标签的title属性中注入XSS，在渲染时进行攻击，作用于不同浏览器时可能会有差异<br>这种注入方式最为复杂，需要攻击者非常了解浏览器的渲染规则——同时也是最难防御的XSS攻击</li></ol></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">'XSS'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这段代码放到 数据库 或者 URL参数的值中则可以造成XSS攻击</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>用户提交的string转为DOM的过程中，可能使用到了下述代码片段</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write()</span><br><span class="line">element.innerHTML = <span class="string">''</span></span><br><span class="line"><span class="comment">// 或者使用了 SSR类的操作</span></span><br></pre></td></tr></tbody></table></figure><p>而XSS攻击具有以下特点:</p><blockquote><ol><li>通常难以从UI上感知</li><li>能窃取cookie/token等信息</li><li>绘制UI（如植入弹窗），欺骗用户填写、点击</li></ol></blockquote><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p><strong>核心思想</strong></p><blockquote><p><strong>永远不要相信用户提交的内容</strong>：<br>不要直接把用户提交内容转为DOM，尽可能转为字符串等相对安全的类型<br>小心类似于 “需要动态生成DOM” 这种客户需求</p></blockquote><p><strong>防御工具</strong></p><blockquote><p><strong>前端</strong></p><ol><li>主流框架默认防御XSS</li><li>google-closure-library</li></ol><p><strong>服务端（指Node）</strong></p><ol><li>DOMPurify</li></ol></blockquote><p><strong>注意事项</strong></p><blockquote><ol><li>string类型注意转义内容</li><li>如果允许用户上传SVG文件等，需要先预处理</li><li>小心自定义跳转连接，因为这样是可以传递JS代码的</li><li>小心自定义样式，因为CSS的URL也可能包含GET请求</li></ol></blockquote><h2 id="跨站请求伪造CSRF"><a href="#跨站请求伪造CSRF" class="headerlink" title="跨站请求伪造CSRF"></a>跨站请求伪造CSRF</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Cross-Site Request Forgery<br>（翻译是跨站请求伪造，但是口头上也常称为跨站伪造请求..总感觉一个是名词一个是动宾短语…）</p><p>这里举出一些较为特殊的CSRF：</p><ol><li><p><strong>iframe攻击</strong><br>由于iframe中发起请求是同源请求，所以检测是否来自安全源的防御机制对此近乎无效，而且攻击者可能更加高明，会利用事件冒泡\事件捕获等JS特性在看似安全的按钮等事件对象的背后隐藏恶意的事件对象</p></li><li><p><strong>anti-pattern攻击</strong></p><p>这是由于程序员本身因为疏忽（更大概率是因为懒），设置GET请求也可以作为POST请求使用，导致攻击者可以直接利用GET请求篡改数据</p></li></ol></blockquote><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><blockquote><ol><li>用户访问到了恶意页面，并输入、提交了个人信息</li><li>恶意页面利用这些信息设置cookie，请求另一个域名下的银行转账接口，由于cookie信息是有效的，转账的请求也被认为是有效的</li><li>请求执行成功，转账完毕，用户权益受到侵害</li></ol></blockquote><p>这些恶意的脚本可能隐藏在a、img等标签的属性中，或者直接不隐藏而是构建一个表单。<br>它们会在被点击时触发GET请求发动攻击</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>跨站请求伪造有如下几个特点:</p><blockquote><pre><code> 1. 用户不知情为前提 2. 利用用户的权限（cookie） 3. 构造指定的HTTP请求，窃取/修改信息</code></pre></blockquote><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><p><strong>核心思想</strong></p><blockquote><p><strong>（大部分情况下）尽可能判断请求的来源，如果来源异常，那么对其进行限制</strong></p></blockquote><p><strong>注意事项</strong></p><blockquote><p><strong>前端</strong></p><ol><li><p>同源请求中，GET、HEAD不会发送Origin字段，这种情况<br>判断来源的话就比较麻烦，所以同源请求尽量避免GET、HEAD</p></li><li><p>也可以结合Referer字段来进行判断</p></li><li><p>使用token和用户进行绑定，并设置过期时间，这样避免了token被他人利用，也避免了持续时间较长的攻击</p></li><li><p>对于iframe攻击，需要在服务器响应头部设置X-Frame-Options的值为DENY，意味着当前页面的值不能作为iframe进行加载；或者设置为SAMEORIGIN，意味着这个页面本身必须和当前页面同源，才能作为iframe加载</p></li><li><p>CSRF是因为Cookie被携带导致的，那么设置SameSite Cookie使得特定页面的Cookie只能在该页面生效，也就能从根源上解决CSRF<br>(这里要注意区分SameSite和CORS的区别，前者是和第三方域与页面域的Cookie相关；后者是和资源域与页面域间资源读写的白名单相关)</p><p><strong>后端（偏指Node）</strong></p><p>构建中间件（Middlewares）专门做CSRF防御</p></li></ol></blockquote><h2 id="注入攻击Injection"><a href="#注入攻击Injection" class="headerlink" title="注入攻击Injection"></a>注入攻击Injection</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><blockquote><p>通过发送注入 SQL语句的<strong>参数</strong> 的请求，使后端获取这些恶意的参数而执行恶意的SQL操作，导致数据库信息被修改<br>常见的注入攻击有以下几类：</p><ol><li>SQL</li><li>CLI</li><li>OS command</li><li>SSRF(Server-Side Request Forgery) 服务端伪造请求，严格意义上<strong>不算注入</strong>，但是原理类似</li></ol></blockquote><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p><strong>SQL注入示例</strong></p><p>假设现在后端有如下SQL语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> users;</span><br></pre></td></tr></tbody></table></figure><p>SQL注入:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'/api'</span>,{</span><br><span class="line">    <span class="attr">method</span>: <span class="string">"POST"</span>,</span><br><span class="line">    <span class="attr">headers</span>: {</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify({</span><br><span class="line">        <span class="attr">users</span>: <span class="string">'table1;DROP TABLE users;'</span></span><br><span class="line">    <span class="comment">// SQL注入关键语句</span></span><br><span class="line">    })</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>后端收到请求后，SQL会被解析为:</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> table1;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> users;</span><br></pre></td></tr></tbody></table></figure><p>结果就是数据库信息被删除</p><p><strong>OS command注入示例</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> command = <span class="string">'convert-cli video -o &amp;&amp; rm -rf xxx'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>SSRF示例</strong></p><blockquote><ol><li>请求用户自定义的callback URL</li><li>利用内网访问权限（前提是要有），此时访问acllback即可能暴露内网信息</li></ol></blockquote><p>（说实话这个没看太懂，不过还是先记下来吧）</p><p><strong>不知道是哪一类的注入示例</strong></p><blockquote><ol><li>篡改nginx.conf文件中的代理服务器</li><li>把该网站流量转发到第三方服务器</li><li>第三方服务器流量突增，可能无法继续支撑，从而崩溃</li></ol></blockquote><h3 id="防御-2"><a href="#防御-2" class="headerlink" title="防御"></a>防御</h3><blockquote><ol><li>使用prepared statement</li><li>遵循<strong>最小权限原则</strong>，所有命令都不要通过sudo执行</li><li>建立允许名单，并进行过滤，避免rm这种高危操作</li><li>（针对SSR注入）对URL类型参数进行协议、域名、ip等限制</li></ol></blockquote><h2 id="拒绝服务攻击DoS"><a href="#拒绝服务攻击DoS" class="headerlink" title="拒绝服务攻击DoS"></a>拒绝服务攻击DoS</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Denial of Server </p><p>通过某种方式（构造特定请求），导致服务器资源被显著消耗，来不及响应更多请求，导致请求挤压，进而雪崩，<br>大概有如下几种常见类型：</p><ol><li><strong>ReDoS</strong><br>正则表达式拒绝服务攻击，利用贪婪模式的正则表达式的回溯操作</li><li><strong>DDoS</strong><br>分布式拒绝服务攻击，直接发送大量请求</li></ol></blockquote><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p><strong>正则表达式拒绝服务攻击</strong></p><p>类似的情况可以在正则匹配的过程中遇到</p><p>在贪婪模式下，正则表达式的运作规律如下：</p><blockquote><p>正则表达式： /^((ab)*)+$/<br>试图匹配字符: ‘ababaa’</p><p>先尝试用3个ab去匹配，发现不匹配；<br>再尝试用2个ab去匹配，发现不匹配；<br>再尝试用1个ab去匹配，发现不匹配；<br>最终判断为不匹配</p><p>当这样的串长度非常大、并且数量非常多时，会使得响应时间极大地变长，吞吐量极大地下降，，那么服务器可能就有崩溃的风险</p></blockquote><p><strong>分布式拒绝服务攻击</strong></p><p>没什么技巧，就靠数量打人海战术</p><blockquote><p>可以访问任意IP、任意API，不区分接口，消耗大量的带宽</p><p>洪水攻击（SYN Flood）就属于DDoS的一种：<br>利用三次握手，发送大量SYN，服务器来不及确认响应进而崩溃</p></blockquote><h3 id="防御-3"><a href="#防御-3" class="headerlink" title="防御"></a>防御</h3><blockquote><p><strong>流量治理</strong></p><ol><li>负载均衡 —— 过滤</li><li>API网关 —— 过滤</li><li>CDN —— 抗量</li></ol><p><strong>快速自动扩容</strong> —— 抗量</p><p><strong>非核心服务降级</strong> —— 抗量</p></blockquote><h2 id="中间人攻击MITM"><a href="#中间人攻击MITM" class="headerlink" title="中间人攻击MITM"></a>中间人攻击MITM</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Man-in-the-Middle Attack,简称MITM</p><p>基于传输层，在浏览器和服务器之间进行伪装：</p><p>浏览器&lt;–交互–&gt;中间人&lt;–交互–&gt;服务器</p><p>中间人的身份可以有很多种，包括伪劣路由器、恶意网络服务提供商等，但浏览器和服务器却都没有察觉到中间人的存在</p></blockquote><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这种攻击有三个特点</p><blockquote><ol><li>明文传输：未加密的信息可以被直接获取</li><li>信息篡改不可知：浏览器和服务器没有有效地验证信息</li><li>身份未验证：没有验证交互对象的身份</li></ol></blockquote><h3 id="防御-4"><a href="#防御-4" class="headerlink" title="防御"></a>防御</h3><blockquote><p><strong>HTTPS</strong></p><p>（HTTP3(QUIC)内置了TLS1.3，所以非常安全，但是这里不提这个，太超前了，这里依旧介绍HTTPS）</p><p>HTTPS具有如下特性：</p><ol><li><p>可靠性（加密）</p></li><li><p>完整性 （MAC验证）</p></li><li><p>不可抵赖性 （私钥和内容可以加密生成数字签名，公钥可以解密；证书校验也是前面这个原理）</p></li></ol><p>  <strong>HSTS</strong><br>  HTTP Strict-Transport-Security，强制安全传输<br>  前提是一定要有一次HTTPS请求</p><p>  <img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684262bdd1851090ac95c9fcb976c5e4eb93ffc912a60efe43d1/0.png" alt="HSTS示意图"></p><p><strong>SRI</strong><br>Subresource Integrity，静态资源完整性</p><p>能够有效针对静态资源劫持，校验原理是原始内容hash对比实际内容hash</p><p><strong>Featrue Policy/Permission Policy</strong><br>能够限制一个源（页面），可以使用那些功能，比如camera、microphone、autoplay</p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote><p>web安全，不论攻防都振奋人心<br>安全没有小事可言，以上例举的内容只是九牛之一毛，web还存在太多潜在的风险，甚至使用的依赖（npm package）或者说作为中间服务器的Node，都可能成为出现问题的一环</p><p>web安全的学习到此就要告一段落了，但是学习的步伐不会就此停滞</p><p>前方是星辰大海</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2022/01/23/http/"/>
      <url>/2022/01/23/http/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>电脑坏掉了，现在使用的是备用机，性能不太好，用着也有点不太习惯，但是还是得学啊！<br>毕竟字节的课程还是很难得的，能学一点是一点吧！</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/22</strong><br>开始动工–HTTP其实应该补充到计算机网络一部分的，所以这里只是做一些补充和扩展</p><p><strong>2022/01/23</strong><br>骑着我心爱的小电驴去把修好的尕玛吉（我的电脑）背回了家，然后第一时间把这篇博文发布到我的个人博客上！<br>博文内容上没有做太大的改动，但是后面我知道后面我还会找时间做补充的！<br>之后一段时间，我可能会继续学习小程序开发、Linux、Web安全中的一个，至于究竟会做什么，我也不知道~</p><p><strong>2022/01/26</strong><br>更新了HTTPS部分</p></blockquote><h2 id="HTTP发展史"><a href="#HTTP发展史" class="headerlink" title="HTTP发展史"></a>HTTP发展史</h2><blockquote><p><strong>HTTP/0.9</strong><br>单行协议，请求html文件则至响应html文件<br><strong>HTTP/1.0</strong><br>构建扩展性，增加了请求头（Header）、状态码（status），支持多种文档类型<br><strong>HTTP/1.1</strong><br>标准化，增添了链接复用、缓存、内容协商等功能<br>截止至目前（2022年），是最常用的HTTP版本<br><strong>HTTP/2</strong><br>更优异的表现（更快、更稳定、更简单），支持二进制协议、压缩请求头、服务器推送等功能，数据传输使用的是帧而不是报文<br>目前国内大厂陆续开始采用该版本<br><strong>HTTP/3</strong><br>正在起草各种相关规则</p></blockquote><h2 id="协议分析-报文"><a href="#协议分析-报文" class="headerlink" title="协议分析-报文"></a>协议分析-报文</h2><h3 id="请求方法Method"><a href="#请求方法Method" class="headerlink" title="请求方法Method"></a>请求方法Method</h3><p>众所周知请求方法有GET、PUT、FETCH、POST等等，这些方法我们可以根据其安全性对其进行分类<br>这里就涉及到以下几个概念：</p><blockquote><p><strong>安全请求safe</strong><br>不会修改服务器数据的方法：<br>GET HEAD OPTIONS<br><strong>幂等请求idempotent</strong><br>同样的请求被执行一次与执行多次的的效果是一样的方法：<br>GET HEAD OPTIONS PUT DELETE<br>所有安全请求都是幂等请求</p></blockquote><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>这里总结一下常见状态码</p><blockquote><p><strong>1xx</strong><br>指示信息，表示请求已经接收，继续处理<br><strong>2xx</strong><br>成功，表示请求已经被成功接收、理解、接受，如：<br>200 — 客户端请求成功<br><strong>3xx</strong><br>重定向，要完成请求必须进行更进一步的操作，如：<br>301 — 资源被永久转移到别处<br>302 — 临时跳转<br><strong>4xx</strong><br>客户端错误，请求有语法错误或请求无法实现， 如：<br>401 — Unauthorized 未经授权的请求<br>404 — 访问资源不存在<br><strong>5xx</strong><br>服务器错误，服务器未能实现合法请求<br>500 — 服务器内部发生了不可预期的错误<br>504 — Gateway Timeout 网关或代理等待响应超时</p></blockquote><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>REST是Representational State Transfer，表现层状态转化<br>而RESTful API就是具有REST风格的API啦</p><p>具体规则是</p><blockquote><p>1.每一个URL代表一种资源<br>2.客户端和服务端之间，传递这种资源的某种表现层<br>3.客户端通过HTTP method，对服务器端资源进行操作，实现“表现层状态转化”</p></blockquote><p>那到底是什么样的API呢？在我看来，可以粗略地理解为——响应的状态码带有语义化的关键词<br>比如 200 OK， 201 CREATED， 400 INVALID REQUEST等等</p><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>这里也例举一些常用的请求头</p><blockquote><p><strong>Accept</strong><br>接收类型，表示浏览器支持的MIME类型<br>（MIME: Multipurpose Internet Mail Extensions,多用途互联网邮件扩展类型，是HTTP协议中迎来定义文档性质及格式的标准）<br>（对标服务端返回的Content-Type）<br><strong>Content-Type</strong><br>客户端发送出去实体内容的类型<br><strong>Cache-Control</strong><br>指定请求和响应遵循的缓存机制，比如no-cache<br><strong>if-Modified-Since</strong><br>对应服务端的Last-Modified，用来匹配看文件是否发生变动，只能精确到1s内<br><strong>Expires</strong><br>缓存控制，在这个时间内不会请求，直接使用缓存<br><strong>Max-age</strong><br>设置缓存有效时间（有效时间内不会请求而是使用缓存）<br><strong>if-None-Match</strong><br>对应服务器的ETag，用来匹配文件内容是否变动<br><strong>Cookie</strong><br>有cookie并且同域访问会自动带上<br><strong>Referer</strong><br>该页面的来源URL（适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用这个字段）<br><strong>Origin</strong><br>最初的请求是从哪里发起的（精确到端口）<br>Origin比Referer更保护隐私<br><strong>User-Agent</strong><br>用户客户端的一些必要信息，如UA头部<br>(UA:User Agent，用户代理)</p></blockquote><p>嗯，只有少数没印象</p><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>说了请求头，自然还得来响应头,说一说常见的几个</p><blockquote><p><strong>Content-Type</strong><br>服务端返回的实体内容的类型<br><strong>Cache-Control</strong><br>指定请求和响应遵循的机制，比如no-cache<br><strong>Last-Modified</strong><br>请求资源最后修改的时间<br><strong>Expires</strong><br>应该在什么时候认为资源已经过期并且不再缓存它<br><strong>Max-age</strong><br>客户端的本地资源应该缓存多少秒<br>（只有开启了Cache-Control才有效）<br><strong>ETag</strong><br>资源的特定版本的标识符，Etags类似于指纹<br><strong>Set-Cookie</strong><br>设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端<br><strong>Server</strong><br>服务器的一些相关信息<br><strong>Access-Control-Allow-Origin</strong><br>服务器端允许的请求Origin头部</p></blockquote><p>很好，对其中三四个有印象</p><p>进一步地，我们还需要重点学习其中提到的缓存</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>可以分为两类：</p><blockquote><p><strong>强缓存</strong><br><em>本地有缓存，则直接使用，这就是强缓存</em><br>Expires — 时间戳<br>Cache-Control —</p><ol><li>可缓存性：<br>   no-cache — 协商缓存验证<br>   no-store — 不使用任何缓存</li><li>到期：<br>   max-age — 存储的最大周期（相对于请求时间，单位是秒）</li><li>重新验证/重新加载<br>   must-revalidate — 如果资源过期，在成功向原始服务器验证之前，不能再使用</li></ol></blockquote><blockquote><p><strong>协商缓存</strong><br><em>本地有缓存，但是还需要和服务端协商判断该缓存状态（比如是否为最新版本的）才决定是否使用</em><br>Etag/If-None-Match — 资源的特有标识符，类似于指纹<br>Last-Modified/If-Modified-Since — 最后修改时间</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842810b59a6468a4f084f4efc419c8e58a2be2c80b3fcd51176/0.png" alt="缓存机制"></p><p>我们还得再进一步聊聊Cookie</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>我们通常只是给饼干一个名字和值，但是实际上还可以给它更多<br>Cookie包括以下内容<br>（响应头可以写在set-cookie字段的值）</p><blockquote><p><strong>Name = value</strong><br>设置名称<br><strong>Expires = Date</strong><br>设置有效期，缺省则默认为有效至浏览器关闭<br><strong>Path = Path</strong><br>指定cookie发送范围，默认为当前范围<br><strong>Domain = domain</strong><br>限制cookie生效的域名，默认为创建cookie的服务域名<br><strong>secure</strong><br>仅对HTTPS生效<br><strong>HttpOnly</strong><br>JS无法获取Cookie<br><strong>SameSite = [None|Strict|Lax]</strong><br>None:同站、跨站请求都可以发<br>Strict:仅在同站发送<br>Lax:允许与顶级导航一起发送，并将第三方网站发起的GET请求一起发送</p></blockquote><p>这里给出一个非常优雅的Cookie获取方式，为了方便称呼，我个人将其称为<strong>我爱Cookie算法</strong></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842810b59a6468a4f0888cc3221cd23d25dce4e9f6b558c2de5/0.png" alt="&quot;我爱Cookie&quot;算法"></p><p>另外，建议是后端来配置cookie</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>我们都知道多出来的S代表安全，<br>那么从本质上来说，<br>HTTPS究竟做了什么样的改动才变得更安全呢？<br>（总不能是把默认端口从80改到了443把）</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Hypertext Transfer Protocol Secure<br>相比HTTP来说，HTTPS多了一个TSL/SSL加密的过程<br>这个过程是在<strong>应用层和传输层之间</strong>完成的<br>这里提到了加密，那么又得学习两个概念：<br><strong>对称加密</strong><br>加密和解密用的同一个密钥<br><strong>非对称加密</strong><br>加密和解密需要使用两个不同的密钥，比如 公钥&amp;&amp;私钥</p></blockquote><h3 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h3><p>访问某个HTTPS协议的URL的验证过程：</p><blockquote><p>需要进行TLS握手，分为两个过程：对称加密和非对称加密</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684262bdd1851090ac95c22e96166ecd6088105de91696f5ce32/0.png" alt="TLS握手"></p><p>其中所谓的证书涉及到的概念如下</p><h3 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h3><blockquote><p>每个浏览器都会内置大量 证书机构（CA）签发的证书，这些证书是和私钥生成的，里面有证书机构的信息以及公钥，利用这些公钥即可解密，通过证书的内容判断签发者是否合法</p><p>当然，如果数字签名不够健壮的话，那么也可能被伪造，进而产生<strong>MITM中间人攻击</strong>的风险</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842810b59a6468a4f08f302aff72b4f2a23aeb79545c6d86956/0.png" alt="验证流程"></p><h2 id="静态资源部署"><a href="#静态资源部署" class="headerlink" title="静态资源部署"></a>静态资源部署</h2><h3 id="常用方案"><a href="#常用方案" class="headerlink" title="常用方案"></a>常用方案</h3><blockquote><p>缓存 + CDN + 文件名hash<br>CDN： Content Delivery Network<br>通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户提供请求</p></blockquote><h3 id="更新资源"><a href="#更新资源" class="headerlink" title="更新资源"></a>更新资源</h3><p>由于cookie保存时间可能设置得很长，那么旧版本的信息可能就长时间得不到替换更新，这时候，常见的一种处理操作就是更改这个信息文件的文件名，比如该版本号等等</p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p><strong>cross-origin</strong><br>是由于浏览器的Same-origin Policy同源策略导致的，只要协议（scheme）、域名（这里指的是host name，包括了domain和subdomain）、端口（port）有一个不一样，那么就形成了跨域</p><p><strong>同源策略</strong><br>即上述内容中提到的Same-origin Policy，简称SoP<br>协议、域名、端口均一致则为同源</p><p><strong>内容安全策略</strong><br>Content Security Policy，简称CSP<br>允许用户自定义被认为是安全的源（域名），对于安全源的脚本可以执行，否则直接抛出错误<br>此外，还可以直接拒绝eval和内联的script标签</p></blockquote><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><blockquote><p>大部分情况（指请求为复杂请求而非简单请求），发送预请求，获知服务端是否允许该跨域请求，这个请求的方法通常是options，如果允许则一如平常进行请求。</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><blockquote><p><strong>1.CORS</strong><br>大概就是后端配置一下Access-Control-Allow-Origin之类的<br><strong>2.代理服务器</strong><br>同源策略是浏览器的安全策略而不是HTTP的，所以只要用服务器绕开浏览器的限制就可以解决跨域<br><strong>3.Iframe/JSONP</strong><br>发送Iframe或者scirpt</p></blockquote><h2 id="Cookie、Session、Token"><a href="#Cookie、Session、Token" class="headerlink" title="Cookie、Session、Token"></a>Cookie、Session、Token</h2><p>我们以用户登录为背景，分析两种常见的模式</p><blockquote><p><strong>1.Session + Cookie</strong><br>Browser发送用户信息到Server试图登录，Server检验数据，如果匹配成功那么生成一个Session,（Session中最主要的是一个SessionID字段）Server会存储这个Session，并且放到响应头的Set-Cookie字段里面给Browser，这样Browser就拥有了一个带有Session的Cookie<br>由于HTTP请求是会自动带上Cookie信息的，所以在下次（Cookie有效期内）Browser试图登录的时候，就会自动将这个带有Session的Cookie发送给Server，Server根据这个Session就能直接响应而不会判断用户信息是否正确（当然如果SessionID被修改，那么服务器就无法识别了，也就不会响应）<br>这样就实现了用户登录一次之后，短时间内保持登录状态的效果</p></blockquote><blockquote><p><strong>2.JWT: JSON Web Token</strong><br>Browser发送用户信息到Server试图登录，Server检验数据，如果匹配成功那么生成JWT，其中包含一个独一无二的字符串（Token令牌），Server只保存这个Token，接着把JWT放到响应头里发送给Browser，这时候Browser通常会把这个JWT存储（查阅相关资料做了些研究后，个人推荐是放到localStorage里面）<br>在下次（有效期内）试图登录时，Browser从localStorage里拿出这个JWT放到请求头里一并发送到Server，Server会解析JWT然后提取其中的Token迅速给出响应<br>这样就实现了和第一种方法一样的效果</p></blockquote><p><strong>为什么需要这些技术?</strong></p><blockquote><p>从根本上说还是因为HTTP协议是无状态的，一个用户访问一次之后，下一次在访问，浏览器也不会发觉这是同一个人浏览的</p></blockquote><h3 id="优劣分析"><a href="#优劣分析" class="headerlink" title="优劣分析"></a>优劣分析</h3><blockquote><p><strong>Cookie + Session的弊端</strong></p></blockquote><ol><li>Cookie不是很安全，他人可以通过揣测Cookie名称等操作来进行Cookie欺骗</li><li>Cookie容量小，一个站点在Browser最多存放3k数据</li><li>Session会保存在Server，所以会占用服务器性能</li><li>据说，在服务器集群或者跨域服务导向架构中，Session的数据就需要共享，意味着每个服务器都需要读取它，这可能会造成负责分享的这个服务器的超载；如果说为了让各个服务器共享而把Session放到数据库中，如果数据库崩溃了，那么又会有问题</li><li>最大的问题：如果浏览器设置了禁用Cookie，那么随之而来的就是Session也无法简单地被使用了，各种问题也可想而知。</li></ol><p>由于上述问题的存在，我们必须有一种新的技术思路，那就是以JWT<br>这个技术的核心思想就是</p><blockquote><p><strong>前后端分别开辟一个空间存储用户信息</strong><br>这个新的技术就是JWT，<br>其具体工作流程上面说过了，此处不再赘述</p></blockquote><blockquote><p><strong>JWT的好处</strong></p></blockquote><ol><li>无状态，可扩展<br>Browswer存储的Tokens是无状态的，且能被扩展。<br>基于这种无状态和不存储session信息，负载均衡器能将用户信息从一个服务器传到其他服务器，能够实现数据共享</li><li>安全<br>请求中发送token而不再是cookie，能够防止CSRF跨站请求伪造。即使在客户端用cookie存储token，cookie也仅仅用于存储而不是认证（个人建议还是存到localStorage或者redis里面），并且token默认是有时间限制的，一段时间后用户就需要重新认证</li><li>多平台跨域<br>每次都是携带绑定自己信息的Token访问Server，在服务器集群中，不是访问某一台指定的服务器，而是通过从缓存服务器中拿出数据，并根据负载均衡器来选择服务器</li></ol><p>对于第2点中提到的安全，可能还需要进一步解释<br>由于JWT是存储在Browser的，但是它又是比较安全的，所以我们就需要从其结构上分析推导其原理</p><h3 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h3><p>JWT由三部分组成</p><blockquote><p><strong>1.header</strong><br>声明了需要用什么算法来生成Token<br><strong>2.payload</strong><br>包含一些特定的数据，比如有效期等<br><strong>3.signature</strong><br>将header和payload中的内容进行Base64编码生成字符串,<br>再根据编码之后的两个字符串，以header中声明的算法进行加密，<br>最终得到Token，Token是一个格式为xxx.xxx.xxx的字符串<br>也就是signature这部分的内容</p></blockquote><p>这三个部分是相互关联的，只要有一个部分被修改，三个部分都会出错</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Session是被Server创建、保存，<br>而Cookie则是一种数据载体，将Session发给Browser，<br>至于Token，是被Server创建，却被Browser保存</p><h2 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h2><p>既然说了Cookie、Session、Token那么自然也得学学本地存储了<br>Cookie可以作为信息的载体，也可以存储内容，但是一般不把Cookie放在Web存储的范围内<br>（Cookie大概是94年提出的技术，而Web存储是H5更新的内容）<br>（我们还是会把它和Web存储作比较，所以这里还是写出来）</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><blockquote><p>大小：4kb<br>兼容：支持H4、H5<br>访问情况：任何同源的窗口都可以访问<br>有效期：手动设置，默认为直到结束</p></blockquote><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><blockquote><p>永久存储数据，直到手动删除，本身并不直接参与通信<br>但是是同步的，可能会影响渲染速度<br>大小：10Mb<br>兼容：H5<br>访问情况：任何同源的窗口都可以访问<br>有效期：永久，直到手动删除</p></blockquote><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><blockquote><p>会话期间存储数据，结束则删除<br>大小：5Mb<br>兼容：H5<br>访问情况：仅同一窗口可以访问（安全性高）<br>有效期：直到结束</p></blockquote><h3 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h3><blockquote><p>暂时还没研究</p></blockquote><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h3><p>其实可以直接看红宝书的，但是还是写一遍加深印象吧</p><blockquote><p>0: UNSET<br>代理已经被创建，但是尚未调用open()方法<br>1: OPENED<br>open()已经被调用<br>2: HEADERS_RECEIVED<br>send()方法已经被调用，且头部和状态已经可获取<br>3: LOADING<br>下载中，responseText属性已经包含部分数据<br>4: DONE<br>下载操作已经完成</p></blockquote><h2 id="其他通信方式"><a href="#其他通信方式" class="headerlink" title="其他通信方式"></a>其他通信方式</h2><p>没错说的就是WebSocket，它相较于HTTP的优点就是它是全双工的，适合对实时性要求比较高的场景，其URL是使用ws://或者wss://开头</p>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序开发</title>
      <link href="/2022/01/13/miniprogram/"/>
      <url>/2022/01/13/miniprogram/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>熟悉的也好，陌生的也好，方向要自己去寻找。</p><p>学做小程序，同时在学着用JS做算法，真的很想吐槽其堪称腌臜的输入方式，但是在做了一下青训的笔试题之后感到自己就像是膨胀的肥皂泡，来硬的一戳就破——还有太多路要走，还得加油！</p><p>每当我读文档、博客或者视频等各种学习资料，看到技术的发展和更迭，以及编写者、讲述人的故事和过往，我就仿佛在走近一段历史岁月，日新月异变迁中不仅是技术的进步，更有着人物的沧桑——大概真是如此，世上半数人都可谓传奇！</p><p>那么如果有一天，有人读到我这一篇博文，那么是否也会产生和我相仿的情感呢？</p><p>不论如何，计算机真是一个充满理想浪漫主义色彩的领域啊！就像是我曾看到一名物理学子高呼愿去宇宙的最深处追寻纯真的世界那般，我也希望通过二进制让世界成为我的画布——</p><p>现在，继续前行吧！</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/13</strong><br>读了些文档，看了点视频，写了点代码，先把提纲理好</p><p><strong>2022/01/14</strong><br>我敲，今天下午一点才醒，我是废物啊</p><p><strong>2022/01/15</strong><br>我…下午两点半醒的….不说的，今天的题晚上再做，先把技术学了尽快上线一个小程序</p><p><strong>2022/02/01</strong><br>更新自定义组件部分</p><p><strong>2022/02/02</strong><br>更新走近小程序、进阶开发技巧和分包</p></blockquote><h2 id="走近小程序"><a href="#走近小程序" class="headerlink" title="走近小程序"></a>走近小程序</h2><h3 id="小程序发展史"><a href="#小程序发展史" class="headerlink" title="小程序发展史"></a>小程序发展史</h3><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842ad1905841601332d64d6083a5c53612af48b74d47ac38b0a/0.png" alt="2017-2018"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842ad1905841601332d76f00e25d7460a9b56436270093eb966/0.png" alt="2018-2019"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842ad1905841601332d1664f87ee4a1f496095e2fafab3d893a/0.png" alt="2019-2020"></p><p>当然，2020-2022也有很多发展，不过这里就不一一例举了</p><h3 id="各种小程序"><a href="#各种小程序" class="headerlink" title="各种小程序"></a>各种小程序</h3><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842ad1905841601332dc4927b9e00c1352b8cdc93a072125c03/0.png" alt="各种小程序"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842ad1905841601332db1de88bebcfccd85707d59441b2c3bee/0.png"></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>众所周知，小程序开发语言的语法是参照了前端框架的，具体参照对照如下表</p><table><thead><tr><th>Vue</th><th>美团（mpvue）、网易（megalo）、京东（taro）、Hbuilder（uni-app）、腾讯（?）</th></tr></thead><tbody><tr><td><strong>React</strong></td><td><strong>蚂蚁金服（remax）、京东（taro）</strong></td></tr></tbody></table><h2 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h2><h3 id="常用基础标签"><a href="#常用基础标签" class="headerlink" title="常用基础标签"></a>常用基础标签</h3><p>标签太多了，这里只举出基础的、常见的标签的部分知识点，更多细致内容参考官方文档</p><p><strong>view</strong></p><blockquote><p>块级，可以看做div标签<br>其衍生的标签还有scroll-view，可以看做加上了滚动条的div标签</p></blockquote><p><strong>block</strong></p><blockquote><p>行内元素（就离谱，明明叫block）</p><p>相当于span标签</p></blockquote><p><strong>image</strong></p><blockquote><p>不用我说也知道是img</p><p>用法基本一致</p></blockquote><p><strong>swiper</strong></p><blockquote><p>轮播图，结合其衍生的swiper-item标签配套使用</p><p>具体使用方式和大部分组件库中的轮播图一致</p></blockquote><p><strong>text</strong></p><blockquote><p>行内元素</p><p>特点是能够长按选中复制</p><p>衍生的rich-text标签能够当做iframe使用</p></blockquote><p><strong>button</strong></p><blockquote><p>和原来一样，但是注意点击事件在这里变成了按下-抬起事件（bindtap）</p></blockquote><p><strong>全局配置</strong></p><p>在app.json中：</p><blockquote><p>pages选项里依葫芦画瓢地添加新的内容后，就添加了新页面的存放路径，并且将会自动创建其相关文件</p><p>window中可以全局设置小程序窗口的外观，包括navigationBar（指的是手机最上面显示电量的那一行），background（下拉时可见）和页面主体部分</p><p>tabBar就是设置tabBar，tabBar就是平时写的navigator那种东西，这里可以设置位置、路由等等</p><p>style中可以设置是否启用新版组件，其中v2是新版，注释这一段代码即可回到旧版</p></blockquote><p>具体配置细则可参见官方文档</p><h2 id="常用小程序API"><a href="#常用小程序API" class="headerlink" title="常用小程序API"></a>常用小程序API</h2><h3 id="事件监听API"><a href="#事件监听API" class="headerlink" title="事件监听API"></a>事件监听API</h3><h3 id="同步API"><a href="#同步API" class="headerlink" title="同步API"></a>同步API</h3><h3 id="异步API"><a href="#异步API" class="headerlink" title="异步API"></a>异步API</h3><h2 id="协同开发权限管理"><a href="#协同开发权限管理" class="headerlink" title="协同开发权限管理"></a>协同开发权限管理</h2><h2 id="全局、局部数据和方法"><a href="#全局、局部数据和方法" class="headerlink" title="全局、局部数据和方法"></a>全局、局部数据和方法</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>点进index.js一看，哎呀好家伙，这不是咱mustache吗！</p><blockquote><p>虽然知道mustache语法支持运算，但是一直没有意识到可以进行三目运算——如果可以进行三目运算的话，那么就可以配合逗号运算符做一些奇妙的操作了</p></blockquote><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>还记得事件的概念吗？不记得就倒立喝水同时大声朗读下述文字</p><blockquote><p>事件是渲染层到逻辑层的通讯方式，通过事件可以将用户在渲染层产生的行为，反馈到逻辑层进行业务的处理</p><p>可以说，事件是渲染层到逻辑层的通讯方式</p></blockquote><p><strong>独特的参数传递方式</strong></p><p>小程序的事件传参比较特殊，比如下述代码</p><p><strong>是错误的</strong><br><strong>是错误的</strong><br><strong>是错误的</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span> <span class="token attr-name">bindtap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Count(123)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>上述内容在微信小程序中是被理解为一个叫做”Count(123)”的方法，传递参数的正确形式应该是下面这样</p><p><strong>其中data-xxx=”<code>{{}}</code>“是传递参数的格式，xxx为参数的名称，而花括号内的则为参数的值</strong></p><p>（如果不使用mustache传参，那么传递的就是文本字符串）</p></blockquote><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span> <span class="token attr-name">bindtap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Count<span class="token punctuation">"</span></span> <span class="token attr-name">data-abc</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{{123}}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中的bindtap是绑定触屏事件，也可以写做bind:tap<br>类似的还有bindinput绑定输入事件，bindchange绑定状态改变事件等等（更多的事件自己查官方文档）</p><p>data-xxx=“yyy”，表示传递一个参数xxx，值为yyy，其中data-是固定写法</p><p>函数中则通过调用事件对象即可拿到参数:</p><blockquote><p>e.currentTarget.dataSet</p></blockquote><h2 id="条件渲染和列表渲染"><a href="#条件渲染和列表渲染" class="headerlink" title="条件渲染和列表渲染"></a>条件渲染和列表渲染</h2><p>其实说的就是wx:if=””和wx:for=””</p><p>同样地，要使用mustache语法，而且对于列表渲染来说，最好指定一个wx:key=””（没错就是因为diff算法）</p><h2 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h2><p>几乎完全移植了CSS的选择器和常用的样式属性（意思是也有相当一部分属性没有被移植），然后也进行了一些扩展加入了很多特有的内容（比如超强的自适应单位rpx，还有@import导入CSS）</p><h3 id="rpx"><a href="#rpx" class="headerlink" title="rpx"></a>rpx</h3><p>总是会把宽度750等分，然后根据实际尺寸做相应的适配</p><p>与px的换算就很简单了，直接750rpx == （实际尺寸大小）px就可以了</p><h3 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h3><p>在WXSS中使用，其后加上路径即可将其他文件中的WXSS导入进来</p><p>当然，如果有需要的话，可以考虑在app.wxss中写，这个就是直接对全局生效的</p><h2 id="网络数据请求"><a href="#网络数据请求" class="headerlink" title="网络数据请求"></a>网络数据请求</h2><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p><strong>和AJAX的区别</strong></p><p>微信小程序开发是基于客户端的，而AJAX的核心技术是依赖浏览器的XMLHttpRequest对象的，所以小程序中这种并不是AJAX请求，而是<strong>发起网络数据请求</strong>，而且<strong>不存在跨域问题</strong></p><p><strong>请求权限</strong></p><p>需要先登录微信开发后台，然后配置一下域名信息，只有设置了目标URL等相关信息才能进行相关URL下的网络数据请求</p><p><strong>相关使用</strong></p><p>通过配置wx.request({})发起网络数据请求，</p><p>其中的wx对象和window对象类似，可以看做是BOM的一种</p><h2 id="WXS"><a href="#WXS" class="headerlink" title="WXS"></a>WXS</h2><h3 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h3><blockquote><p>页面导航是指的页面之间的相互跳转</p></blockquote><p>在浏览器中我们一般采用两种形式实现上述功能，一种是a标签，另一种是location.href</p><p>而在小程序中，类似地，我们可以通过navigator标签，或者小程序的导航API来实现</p><p>这两个例子中，前者都可以认为是<strong>声明式导航</strong>，后者均可以认为是<strong>编程式导航</strong></p><p><strong>声明式导航</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>navigator</span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/pages/index/index<span class="token punctuation">"</span></span> <span class="token attr-name">open-type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>switchTab<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>导航1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>navigator</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>navigator</span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/pages/<span class="token punctuation">"</span></span> <span class="token attr-name">open-type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>navigate<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>导航2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>navigator</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://serio.gitee.io<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>跳转3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第一种形式是导航到tabBar页面，何为tabBar页面？即app.json中配置了路径的页面</p><p>第二种则是用于导航到非tabBar页面</p><p>第三种似乎在微信小程序中失效了？（但是标签有自动补全，具体情况有待考证）</p><p>另外，我们可以设置open-type为navigateBack使点击这个按钮的效果变为回退，并且可以设置delta为n从而实现指定回退n级页面</p><p><strong>编程式导航</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">wx<span class="token punctuation">.</span><span class="token function">switchTab</span><span class="token punctuation">(</span><span class="token punctuation">{</span>   url<span class="token operator">:</span> <span class="token string">'url'</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>wx<span class="token punctuation">.</span><span class="token function">navigateTo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>   url<span class="token operator">:</span> <span class="token string">'url'</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样，</p><p>第一种是导航到tabBar页面，</p><p>第二种是导航到非tabBar页面</p><p>并且也能设置后退，此处不再赘述，具体信息查看官方文档</p><p><strong>导航传参</strong></p><p>就是url?yyy=xxx&amp;yy=xx这样的</p><p>要知道左下角可以查看页面参数</p><p>而且，参数可以直接在生命周期函数onload的默认参数中找到</p><h3 id="下拉刷新-和-上拉触底"><a href="#下拉刷新-和-上拉触底" class="headerlink" title="下拉刷新 和 上拉触底"></a>下拉刷新 和 上拉触底</h3><blockquote><p>注意上拉和下拉，上拉是手指由下往上（下拉反之），说的是手指不是页面</p></blockquote><p><strong>下拉刷新</strong></p><p>分为全局和局部，但是都是将enablePullDownRefresh设置为true</p><p>另外，下拉刷新的loading效果不会主动消失，需要手动处理，这时候只需要调用wx.stopPullDownRefresh()就可以了</p><p>除了这种loading以外，还可以通过wx.showLoading来主动展示并且通过wx.hideLoading来隐藏 </p><p><strong>上拉触底</strong></p><blockquote><p>手指向上滑动，从而加载更多数据</p><p>大部分时候用于实现分页数据请求</p></blockquote><p>实现是在js文件中，通过onReachBottom()监听</p><p>所谓触底，也并非和底部距离为0，默认是50rpx，可以通过在配置文件中修改onReachBottomDistance属性来更改</p><p>另外，记得对上拉触底做一下节流处理，其中的一个技巧是，方法内存在生命周期函数complete，利用好这一点可以更方便地处理</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><blockquote><p>Life Cycle，和Vue差不多，具体有什么生命周期函数直接看文档，这里挑重点记一下概念</p></blockquote><p>这里的生命周期存在一个分类：</p><p><strong>应用生命周期</strong></p><p>启动-&gt;运行-&gt;销毁</p><p><strong>页面生命周期</strong></p><p>加载-&gt;渲染-&gt;销毁</p><p>其中，页面的生命周期范围较小，应用程序的生命周期范围较大，总的来看，整体的周期是：</p><p>启动-&gt;页面1的生命周期-&gt;页面2的生命周期-&gt;etc…-&gt;销毁</p><h3 id="WXS脚本"><a href="#WXS脚本" class="headerlink" title="WXS脚本"></a>WXS脚本</h3><blockquote><p>WeiXin Script，小程序独有的一套结构</p><p>和JS类似但是不一样，本质上还是两种语言，WXS有以下几个比较重要的特点：</p><p><strong>1.有自己的数据类型</strong></p><p><strong>2.不支持类似ES6及以上的语法形式</strong></p><p><strong>3.遵循CommonJS</strong></p><p>看到这些我就大胆猜测一手，一定就是你——NodeJS！</p><p><strong>4.有隔离性，一是wxs和JS不能相互使用，而是wxs不能调用小程序的API</strong></p><p><strong>5.性能更好，IOS设备上WXS会比JS快2-20倍，但是在Android上无差异</strong></p><p>我缓缓打出一个？</p></blockquote><p>wxml中无法调用页面级js文件中定义的函数，但是wxml可以调用wxs中的函数。所以小程序中的wxs应用的典型场景就是 <strong>过滤器</strong>（没错就是filter）</p><p><strong>使用</strong></p><p><strong>内嵌式</strong></p><p>在wxml文件中写一个wxs标签，并且每一个wxs标签都必须具有一个module属性用于指明当前wxs的模块名称，此后在wxml中可以将wxs当做一个对象来使用，可以通过module属性指明的名称来访问其中定义的方法和变量——没错嘛这不就是还没exports的模块的使用方法吗</p><blockquote><p>那么，这和过滤器有什么关系呢？</p><p>没错，我们这里可以处理数据，但是又不会修改js文件中的数据，这就是过滤的效果</p></blockquote><p><strong>外联式</strong></p><p>目录下创建一个文件，然后单独写，最后exports即可</p><p>但是导入不是用require，而是利用wxs中的src属性</p><h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p><strong>1.创建组件</strong><br>在项目的根目录中，鼠标右键，创建components -&gt; test文件夹<br>在新建的components -&gt; test文件夹上，鼠标右键，点击“新建Component”<br>键入组件的名称之后回车，会自动生成组件对应的4个文件，后缀名分别为.js，.json，.wxml和.wxss</p><blockquote><p>组件和页面的区别：</p><p>1.组件的配置文件中的component字段值为true</p><p>2.组件的.js中调用的是Component()函数(可能是构造函数)</p><p>3.组件的事件处理函数需要定义到methods节点中</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684297fd0d5e89c4cb6b57f9259d5e4e3809fb0e08dc7483be9c/0.png" alt="文件结构"></p><p>不同于Vue，组件的wxml文件中并不要求唯一一个标签包裹其余所有标签</p><p><strong>2.局部引入组件</strong></p><p>在配置文件中写：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token string">"usingComponents"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"a-good-component"</span><span class="token operator">:</span> <span class="token string">"/components/test/test1"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中test1是组件文件的名字</p><p>然后要使用这个组件的话，只需要在wxml中写：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a-good-component</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a-good-component</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3.全局引入组件</strong></p><p>在全局配置中新增字段</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token string">"usingComponents"</span><span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token string">"a-good-component"</span><span class="token operator">:</span> <span class="token string">"/components/test/test1"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其余一样</p><p><strong>4.区别于页面</strong></p><blockquote><ol><li>组件的.json文件中需要声明”component” : true属性</li><li>组件的.js 文件中调用的是Component()函数组件的事件</li><li>处理函数需要定义到 methods节点中，而页面则是直接放到page内</li><li>页面的自定义函数传参可以通过event.target.dataset获取，组件则有专门的properties负责接收数据</li></ol></blockquote><h3 id="样式隔离"><a href="#样式隔离" class="headerlink" title="样式隔离"></a>样式隔离</h3><p>组件之间的样式不会相互影响，也不会受到引用它的页面的样式的影响，包括全局样式也对组件无效</p><blockquote><p>一个中肯但是不知道为什么如此的建议是：<strong>在组件样式中不要使用除了class以外的选择器</strong></p></blockquote><p>如果希望破坏这种隔离性的话，可以修改其配置文件中的styleIsolation字段的值为isolated</p><p>或者在js文件中写如下代码也能达到同样的效果：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    options<span class="token operator">:</span> <span class="token punctuation">{</span>        styleIsolation<span class="token operator">:</span> <span class="token string">'isolated'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="父向子传参"><a href="#父向子传参" class="headerlink" title="父向子传参"></a>父向子传参</h3><p>是熟悉的属性绑定语法</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token comment">// 属性定义的完整方式</span>    properties<span class="token operator">:</span> <span class="token punctuation">{</span>         type<span class="token operator">:</span> Number<span class="token punctuation">,</span> <span class="token comment">// 指定类型</span>        value<span class="token operator">:</span> <span class="token number">10</span>  <span class="token comment">// 默认值</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token comment">// 属性定义的简化版</span>    name<span class="token operator">:</span> String      <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传参直接如下图所示，不需要有额外的关键字，直接写就行了</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a-good-component</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>沈俞佑<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a-good-component</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>properties中可以写一些键值对，和data类似</p><blockquote><p>1.properties和data都是可读可写的</p><p>2.data更倾向于存储私有组件的私有属性</p><p>3.properties更倾向于存储外界传递到组件中的值</p><p>4.this.data === this.properties 的结果是true，所以使用this.setData也是可以对this.properties起作用的</p></blockquote><h3 id="数据监听器"><a href="#数据监听器" class="headerlink" title="数据监听器"></a><strong>数据监听器</strong></h3><p>类似于Vue的watch，是监听数据而不是事件</p><p>在组件的methods方法列表内除了写方法之外还能写监听器等</p><p>添加以下字段对n1,n2进行监听</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">observers<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">'n1, n2'</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newN1<span class="token punctuation">,</span> newN2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842d7aa5377124ce70b8843e0e8f092ea5867dae5625a0e2058/0.png"></p><p>即使是在this.setData方法里面，后面的值也要用this.data.xxx访问</p><p>当然，也可以监听某个对象的属性——是个值都能监听</p><h3 id="纯数据字段"><a href="#纯数据字段" class="headerlink" title="纯数据字段"></a>纯数据字段</h3><p>只是一个概念性的东西，知道就行</p><blockquote><p>指不用于界面渲染的data字段，既不会展示在页面上，也不会传递给其他组件，<strong>仅在其所属组件的内部使用</strong></p></blockquote><h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p>不再赘述</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842d7aa5377124ce70be528a816990658073ed67ea9851b805d/0.png"></p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>单个slot没什么好说的，就当看一遍复习了</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrapper<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>小广告<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ad</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>image</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://p.qlogo.cn/hy_personal/3e28f14aa0516842d7aa5377124ce70be528a816990658073ed67ea9851b805d/0.png<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>image</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ad</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，如果有多个插槽，那么操作就有点不一样了</p><p>首先要在启用多slot的组件的js文件中 与 data等字段平级的位置添加一个options字段，并设置multipleSlots: true</p><p>然后又是一套基本操作了</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrapper<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>before<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>小广告<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>after<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ad</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>after<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>slot写上插槽名字就好了<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ad</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="子向父传参"><a href="#子向父传参" class="headerlink" title="子向父传参"></a>子向父传参</h3><p>是学过但是依旧不是很熟练的自定义事件</p><p>（以前每次都是去现查一遍再用…并且能不用就不用，就算用了也会因为搞不清到底有几个事件而把所有事件都命名相同）</p><p>使用步骤如下:</p><blockquote><ol><li>在父组件的js 中，定义一个函数</li><li>在父组件的wxml中，通过自定义事件的形式，将步骤1中定义的函数引用，传递给子组件</li><li>在子组件的js中，通过调用<code>this.triggerEvent('自定义事件名称'，{ /*参数对象*/ })</code>，将数据发送到父组件</li><li>在父组件的js中，通过e.detail获取到子组件传递过来的数据</li></ol></blockquote><p>简明扼要说一下就是：</p><blockquote><p>父级给个函数，子级用this.triggerEvent自定义一个事件，在父级用e.detail就能接收到数据</p></blockquote><p>绑定事件的时候需要用到<strong>关键字bind:xxx</strong>，注意这里似乎没有缩写为:xxx这样的语法糖，但是可以直接写作bindxxx(离谱吧，没错我也觉得离谱)</p><p>比如bindtap实际上也可以写作bind:tap</p><blockquote><p>知道真相的我大为震撼！</p></blockquote><h3 id="获取组件实例"><a href="#获取组件实例" class="headerlink" title="获取组件实例"></a>获取组件实例</h3><p>也可以用这种方式来进行父子间通信</p><p>在父组件中调用**this.selectComponent( id选择器/class选择器 )**来获取子组件的实例对象，这样就能够使用子组件内部的所有数据了</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ad</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ad-one<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>image</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://p.qlogo.cn/hy_personal/3e28f14aa0516842d7aa5377124ce70be528a816990658073ed67ea9851b805d/0.png<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>image</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ad</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">bindtap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getChild<span class="token punctuation">"</span></span> <span class="token attr-name">data-name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{{<span class="token punctuation">'</span>#ad-one<span class="token punctuation">'</span>}}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>获取#ad-one的信息<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">getChild</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">selectComponent</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>currentTarget<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="behaviors"><a href="#behaviors" class="headerlink" title="behaviors"></a>behaviors</h3><blockquote><p>behaviors是小程序中，用于实现<strong>组件间代码共享</strong>的一种特性，类似Vue中的mixins（mixins是啥啊）</p><p>每个behavior都可以包含一组属性、数据、生命周期函数和方法，<br>组件引用它时，属性、数据和方法等z会合并到组件中，<br>behavior也可以引用behavior</p><p><strong>总结一下</strong><br>wxml有模板可以用，那么这里就大胆地把JS也搞一个模板，这个模板就是behavior</p></blockquote><p><strong>创建一个behavior</strong></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684283b1d08f593bedd6879b1b14048319474c9836c37cc6cee9/0.png"></p><p><strong>导入一个behavior</strong></p><p>注意behavior字段的值是以数组的形式进行存储的</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684283b1d08f593bedd6d76ca82aac58e0b583467bceac458a40/0.png"></p><p><strong>使用behavior的数据</strong></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684283b1d08f593bedd6ba5f641b5df51ca7d237aa5bd6d379b8/0.png"></p><p>那么什么时候使用behavior呢？</p><p>还记得曾经苦恼过的——开发vue项目的过程中，总是感慨应该把复用多次的xxx函数先封装到一个JS文件里面的——这时候我们就该想到behavior了！</p><p>但是这时候又出现了新的问题，如果behavior中属性和调用组件已有的属性冲突，那么这些属性将会怎么被处理呢？这就是我们需要思考的新问题了</p><p><strong>同名字段的覆盖和组合规则</strong></p><blockquote><p>组件和它引用的behavior中可以包含同名的字段，此时可以参考如下3种同名时的处理规则</p><p><strong>1.同名数据字段（data)</strong></p><ol><li>如果都是对象类型，那么会发生对象合并（那么问题来了，这时候属性名有重复了咋办）</li><li>其余情况则和<strong>↓↓↓第2点↓↓↓</strong>中提到的一致</li></ol><p><strong>2.同名属性（properties和methods）</strong></p><ol><li>组件自身的优先</li><li>behavior内部出现重复属性则靠后的优先</li><li>behavior调用behavior时，父级优先</li></ol><p><strong>3.同名生命周期函数</strong></p><ol><li>不同生命周期则会依次执行</li><li>相同生命周期则和<strong>↑↑↑第2点↑↑↑</strong>中的一致</li></ol></blockquote><h2 id="进阶开发技巧"><a href="#进阶开发技巧" class="headerlink" title="进阶开发技巧"></a>进阶开发技巧</h2><h3 id="使用npm"><a href="#使用npm" class="headerlink" title="使用npm"></a>使用npm</h3><p>可以使用npm但是在小程序中多了如下三点限制：</p><blockquote><ol><li>不支持依赖于Node.js内置库的包</li><li>不支持依赖于浏览器内置对象的包</li><li>不支持依赖于C++插件的包</li></ol></blockquote><p>当时我就知道能用的没多少了</p><p>但是我们可以安装 <strong>Vant Weapp、uni-app</strong>等UI库帮助我们开发</p><p>当然，小程序里面使用npm安装也没那么方便就是了，还得手动配置一些东西…</p><blockquote><p>npm下载之后东西会放到node_module文件夹下，</p><p>但是小程序不争气啊没法直接用，还得先<strong>构建</strong>才能用</p></blockquote><p><strong>构建</strong></p><p>根目录下有个文件夹：miniprogram_npm</p><p>这之中的包可以被小程序直接使用，而要构建这个文件夹，首先需要正常npm操作一波，然后点击这里：</p><p><img src="E:/blog/blog/source/_posts/MiniProgram.assets/image-20220202145951115.png"></p><p>之后如果再添加新的包，那么再构建npm可能会不生效，这时候我们把miniprogram_npm文件夹删了重新构建就好了</p><p>当然，不同的包在安装的时候可能有不同的要求</p><p>具体安装和使用方式参考官方文档，此处不再赘述</p><h3 id="API的Promise化"><a href="#API的Promise化" class="headerlink" title="API的Promise化"></a>API的Promise化</h3><blockquote><p> Promise是为了解决回调地狱而出现的</p></blockquote><p>在小程序中要使用Promise的话需要先用npm安装一下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install --save miniprogram-api-promise<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此后构建一下miniprogram_npm，之后在app.js中书写如下代码进行全局promise化</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span>promisifyAll<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'miniprogram-api-promise'</span><span class="token keyword">const</span> wxp <span class="token operator">=</span> wx<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">promisifyAll</span><span class="token punctuation">(</span>wx<span class="token punctuation">,</span> wxp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这之后，wx对象中的所有API都会有一个pormise化的版本，而这些新版本会被放到wxp和wx.p对象上</p><p>页面的js文件中，定义对应</p><h3 id="全局数据共享"><a href="#全局数据共享" class="headerlink" title="全局数据共享"></a>全局数据共享</h3><p><strong>概念</strong></p><p>没错，可以类比Vuex、Redux、Mobx等等</p><blockquote><p>也称为状态管理</p><p>小程序的实现方式是通过<strong>mobx-miniprogram</strong>配合<strong>mobx-miniprogram-bindings</strong>实现全局数据共享</p><p>其中，<br>mobx-miniprogram用来<strong>创建</strong>Store实例对象<br>mobx-miniprogram-bindings用来把Store中的共享数据或方法<strong>绑定</strong>到组件或页面中使用</p></blockquote><p><strong>安装</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install --save mobx-miniprogram mobx-miniprogram-bindings<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后又是基本的构建操作</p><p><strong>创建store实例</strong></p><p>在根目录下创建Store文件夹，里面再新建一个store.js，我们将用这个js文件专门来创建store实例对象</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>observable<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'mobx-miniprogram'</span><span class="token keyword">export</span> <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">observable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token comment">// 数据字段</span>    num1<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    num2<span class="token operator">:</span> <span class="token number">2</span>    <span class="token comment">// get修饰符： 计算属性，类似于watch</span>    <span class="token keyword">get</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num1 <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num2<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">// actions 方法，用来修改 store 中的数据，</span>  <span class="token comment">// 外界调用updateNum即可触发内部函数</span>     updateNum1<span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">step</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>num1 <span class="token operator">+=</span> step     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     updateNum2<span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">step</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>num2 <span class="token operator">+=</span> step     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>页面绑定store</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> createStoreBindings <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'mobx-miniprogram-bindings'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> store <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../../store/store'</span><span class="token function">Page</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token comment">// 生命周期上挂一下</span>    <span class="token function-variable function">onLoad</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>storeBindings <span class="token operator">=</span> <span class="token function">createStoreBindings</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            store<span class="token punctuation">,</span><span class="token comment">// 数据源</span>            fields<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'num1'</span><span class="token punctuation">,</span> <span class="token string">'num2'</span><span class="token punctuation">,</span> <span class="token string">'sum'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 当前页面需要的数据字段</span>            actions<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'updateNum1'</span><span class="token punctuation">]</span><span class="token comment">// 当前页面需要的方法</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function-variable function">onUnLoad</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>storeBindings<span class="token punctuation">.</span><span class="token function">destoryStoreBindings</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>页面使用store</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 依旧是this访问就行了</span><span class="token function">xxxFun</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateNum1</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>step<span class="token punctuation">)</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>组件绑定store</strong></p><p>要额外给一个storeBindingsBehavior来过渡，</p><p>暂时不清楚为什么要这么设计</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> storeBindingsBehavior <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'mobx-miniprogram-bindings'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> store <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../../store/store'</span><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    behaviors<span class="token operator">:</span><span class="token punctuation">[</span>storeBindingsBehavior<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 通过storeBindingsBehavior自动绑定</span>    storeBindings<span class="token operator">:</span><span class="token punctuation">{</span>        store<span class="token punctuation">,</span>        fields<span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token function-variable function">num1</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> store<span class="token punctuation">.</span>num1<span class="token punctuation">,</span>   <span class="token comment">// 绑定字段的第1种方式</span>            <span class="token function-variable function">num2</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">store</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> store<span class="token punctuation">.</span>num2<span class="token punctuation">,</span>  <span class="token comment">// 绑定字段的第2中方式</span>            sum<span class="token operator">:</span> <span class="token string">'sum'</span><span class="token comment">// 绑定字段的第3种方式，前两者也可以这么写</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用还是那么使用</p><p>如果需要在wxml中使用，那么遵循mustache语法使用就好了</p><h2 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>把一个完整的小程序分为不同的子包，用户使用时可以按需进行加载</p></blockquote><p>好处就是优化了小程序首次启动的下载时间，在多团队合作的之后有更好的解耦协作</p><p><strong>分包前后对比</strong></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842f31e86df92f8a1ffe63e0933e4c70b74929a6d3fa3f9f0c6/0.png" alt="分包前"></p><p>分包之后，小程序变为由1个主包 + n个分包</p><blockquote><p><strong>主包</strong><br>一般只能包含项目的启动页面或TabBar页面、以及所有分包需要用到的一些公共资源</p><p><strong>分包</strong><br>只包含和当前分包有关的页面和私有资源</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842f31e86df92f8a1ff8cb3c4c5a6819c9942a6ce04a5d3e6db/0.png" alt="分包后"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842f31e86df92f8a1ff9b0c5d03f26d43df33acf8e712a86652/0.png" alt="分包目录结构"></p><p>可以在app.json文件中的subpackages字段里面以类似路由配置的形式进行管理</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842f31e86df92f8a1ff6162b5c95cc52e5582f9ed675cb7188b/0.png" alt="app.json内的subpackages字段"></p><p>如果编辑这一部分，那么保存后会自动创建响应的文件</p><p>subpackages之内是写的分包，之外的内容则是主包</p><p>注意分包之内不能相互嵌套</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>加载规则</strong></p><blockquote><ol><li>小程序启动时，默认会下载主包并启动主包内页面</li></ol><p>（所以tabBar放主包里面）</p><ol start="2"><li>用户访问某个分包页面的时候，客户端会把对应包下载下来</li></ol></blockquote><p>我寻思，这不就是个懒加载吗，说的这么高级….</p><p><strong>大小限制</strong></p><blockquote><p>一个包不能超过2M，所有包加起来不能超过20M</p><p>(当然这个具体数值是随着技术发展不断增加的，但是一定要知道每个包大小是需要控制的)</p></blockquote><p>我寻思着公共资源文件夹里面塞个图片那不是直接爆炸吗…</p><h3 id="独立分包"><a href="#独立分包" class="headerlink" title="独立分包"></a>独立分包</h3><blockquote><p>一种特殊的分包，可以不依赖主包独立运行</p><p>独立分包与其他分包之间<strong>相互隔绝</strong>，不能相互引用资源</p></blockquote><p>这种设计应该应用于什么样的场景呢？</p><p>有的功能不依赖主包即可运行，但是进入小程序时却需要默认下载主包——这时候就该独立分包了</p><p>而设置独立分包的操作也非常容易实现，只需要在app.json对每个包的设置中加上<strong>independent</strong>字段并设置为true</p><h3 id="预下载"><a href="#预下载" class="headerlink" title="预下载"></a>预下载</h3><blockquote><p>在进入某个页面时，由框架自动预先下载好之后可能需要的分包，从而优化进入后续分包页面的速度</p></blockquote><p>在app.json中使用preloadRule字段配置预下载：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842729a2b71db44bd900d2fcb03d310c45999cb144a0ec6e9fc/0.png"></p><p>一个分包的预下载大小限额：2M，超出的部分会下载失败</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>（这部分后面再更）</p>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/01/10/internet/"/>
      <url>/2022/01/10/internet/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>计算机网络可以说是我第二重视的专业基础课了，因为网络这个概念早已深入千家万户，在我没有正式进入计算机这个专业之前，就已经有了对网络的体会——网络为生活提供了不少便利，所以我对网络有一种亲切和敬仰的感觉</p></blockquote><blockquote><p>嗯？你问我为什么是第二重视的？因为第一是数据结构和算法啊——虽然我学的很烂就是了，不过我会努力补上的！</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/04</strong><br>1月10号考试，现在基本上还算是零基础（<del>对计网极其重视</del> ），教务处老师给个机会，我真的很热爱计网啊！<br><strong>2022/01/04</strong><br>真不错，明天下午考试，今天刚把视频粗略地刷了一遍，常考的大题看了一遍，笔记肯定是没时间写得非常细致了，这里先把重要的内容记下来吧！</p></blockquote><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p><strong>概念</strong></p><blockquote><p>计算机网络:是一个将<strong>分散</strong>的、具有<strong>独立功能</strong>的<strong>计算机系统</strong>，通过通信设备与线路连接起来，由功能完善的软件实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统。<br>分散是指地理位置分散<br>独立功能是指组成计算机网络的各个计算机功能不同</p></blockquote><p>上述内容可以简单总结为：</p><blockquote><p>计算机网络是互连的、自治的计算机集合<br>互连 即 互联互通<br>自治 即 无主次关系</p></blockquote><p><strong>功能</strong></p><blockquote><p>1.<strong>数据通信</strong><br>2.<strong>资源共享</strong><br>3.分布式处理<br>4.提高可靠性<br>5.负载均衡</p></blockquote><p><strong>结构组成</strong></p><blockquote><p>硬件 软件 协议 三个部分</p></blockquote><p><strong>工作方式组成</strong></p><blockquote><p><strong>1.边缘部分（用户直接使用）</strong><br>C/S方式<br>P2P方式<br><strong>2.核心部分（为边缘部分服务）</strong><br>相当于是边缘部分包裹的（用户与用户之间的）路由等等 </p></blockquote><p><strong>功能组成</strong></p><blockquote><p>1.通信组成——实现数据通信<br>2.资源子网——实现<strong>资源共享</strong>（数据处理）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/3217747256c245c08e181c31e2f645c8.png" alt="七层模型"><br><strong>分类</strong><br><img src="https://img-blog.csdnimg.cn/d0e8bbf02c464e5ebe159454ff798f85.png" alt="计算机网络分类"></p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>这里我用尽最大努力<strong>通俗易懂并且精简</strong>而非官方（至少自认为是这样）的语言进行解释</p><p><strong>速率</strong></p><blockquote><p>也称为数据率，数据传输率，比特率等<br>即<strong>比特位的传输快慢</strong><br>单位是kb/s, Mb/s, Gb/s等，需要注意，<strong>速率单位之间相差1000倍</strong>（存储空间单位之间才是1024倍）</p></blockquote><p><strong>带宽</strong></p><blockquote><p>比特位传输的<strong>最大速率</strong></p></blockquote><p><strong>吞吐量</strong></p><blockquote><p>单位时间通过某特定位置的比特数目<br>（注意在全双工信道上要取来往比特数目之和</p></blockquote><p><strong>时延</strong><br>注意，以下言论不区分信道和链路两个名词（虽然实际上有一定的区别）</p><blockquote><p>俗称延迟<br>包括四类：<br><strong>1.发送时延（传输时延）</strong><br>注意传输时延这个别称，千万别和传播时延搞混了！<br>就是从主机或者路由器内部离开，来到信道上的用时<br>（具体就是从第一位离开，到最后一位离开的用时）<br><strong>2.传播时延</strong><br>就是在信道上传播的用时<br><strong>3.排队时延</strong><br>到达目的后，可能目的主机已经在处理其他信息，需要等待一段时间才能轮到自己<br><strong>4.处理时延</strong><br>处理这段信息所需要的时间</p></blockquote><p><strong>时延带宽积</strong></p><blockquote><p><strong>这里的时延指的是传播时延</strong>，即传播时延 * 带宽<br>代表发送一条信息在信道上传播的时间，而带宽是单位时间内最大的比特传输速率<br>所以时延带宽积的意义就是<br><strong>信道中能够同时容纳的比特数目的最大值</strong><br>说白了就是和导线中电子和电流的关系一样，比特看做电子，时延带宽积就看做电流</p></blockquote><p><strong>往返时延</strong></p><blockquote><p>Round-Trip Time，简称RTT<br><strong>不包括发送时延（传输时延）</strong>，而是 传播时延 * 2 + 排队时延 + 处理时延<br>但是大部分时候，只考虑 传播时延 * 2</p></blockquote><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><strong>概念</strong></p><blockquote><p>一般是指网络协议（因为“协议”不仅是计算机的专业术语），业内交流一般简称为协议<br>是<strong>为了进行网络中数据交换而建立的规则标准</strong>，比如HTTP、DCHP、ICMP等</p></blockquote><p><strong>构成</strong></p><blockquote><p>由三个部分构成：<br><strong>1.语法</strong>：数据和控制信息的结构或者格式<br><strong>2.语义</strong>：具体的需要做的事情，比如发出某种信息<br><strong>3.同步（时序）</strong>：定义做事的先后顺序</p></blockquote><p><strong>协议和服务</strong></p><blockquote><p><strong>协议是水平的</strong><br>协议是作用于对等实体（即同一层）之间的，比如HTTP只能做用于两个应用层之间<br><strong>服务是垂直的</strong><br>服务是指下层向上层提供能够实现某种特定功能的接口<br>（上层调用下层的接口是通过服务原语实现的）</p></blockquote><p><strong>三种模型</strong><br>七层，四层，五层模型</p><p><strong>OSI七层模型</strong></p><blockquote><p>Open System Interconnect 开放式系统互联，是一种<strong>理想化</strong>的模型</p></blockquote><p><strong>TCP/IP四层模型</strong></p><blockquote><p>Transmission Control Protocal / Internet Protocal， 传输控制协议/网际协议，实用性强，是如今普遍使用的模型</p></blockquote><p><img src="https://img-blog.csdnimg.cn/00137d6804964767955e745a310934f4.png" alt="TCP/IP四层模型和OSI七层模型"><br>国内为了方便教学，结合了二者的特点，产生了一个五层协议：<br><img src="https://img-blog.csdnimg.cn/150a8e76ad3843f2a62b6569235576b8.png" alt="五层模型"></p><p>学校的考试一般是基于五层模型的，<strong>所以我接下来以五层模型为标准，且自底向上地进行讨论</strong></p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>可以理解为，包含了一大堆关于各种硬件方面标准的一层，比如规定了接口电缆上电压的范围</p><blockquote><p>由于学校期末考试不考这个，而且找工作面试也不怎么问这块，如果不打算深入研究计算机科学的话那这块相对次要，所以只挑出相对重要的概念说一说</p></blockquote><h3 id="重要的硬件"><a href="#重要的硬件" class="headerlink" title="重要的硬件"></a>重要的硬件</h3><p><strong>中继器、集线器</strong></p><p><strong>二者关系</strong></p><blockquote><p>中继器只有两端，一端进来一端出去，<strong>集线器则是有多个端口的中继器</strong></p></blockquote><p><strong>功能</strong></p><blockquote><p>放大衰减的信号，增加信号传输距离<br>放大信号后会将其<strong>广播（发送给其他所有端口）</strong>，不具备顶线传输</p></blockquote><p> <strong>特点</strong></p><blockquote><p>通过同一个集线器连接的主机属于同一个<strong>冲突域（这个区域内，同一时刻只能有一个主机收或者发信息，否则冲突）</strong>，冲突域内工作的主机会<strong>平分带宽</strong><br>当然，如果不连接的话，每个主机自身就是一个冲突域</p></blockquote><h3 id="重要的概念"><a href="#重要的概念" class="headerlink" title="重要的概念"></a>重要的概念</h3><p><strong>数据和信号</strong></p><blockquote><p><strong>数据</strong><br>要传送的内容，分为数字数据（离散的，方格）和模拟数据（连续的，平滑）<br><strong>信号</strong><br>数据的电气/电磁表现，一般是波，也分为数字信号和模拟信号</p></blockquote><h3 id="重要的单位"><a href="#重要的单位" class="headerlink" title="重要的单位"></a>重要的单位</h3><p><strong>带宽、速率</strong></p><blockquote><p>上面说过了</p></blockquote><p><strong>码元</strong></p><blockquote><p>比如有00 01 10 11四种状态，那码元有四个，每个包括2个比特<br>所以n进制马元包括log2n个比特</p></blockquote><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="三类服务"><a href="#三类服务" class="headerlink" title="三类服务"></a>三类服务</h3><blockquote><p>有三类：<br><strong>无确认无连接服务</strong><br>广播，收到数据不返回确认信息<br><strong>有确认无连接服务</strong><br>广播，收到数据返回确认信息<br><strong>有确认面向连接服务</strong><br>建立连接定向传输，收到数据返回确认信息</p></blockquote><h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><blockquote><p>在收到上层，即网络层来的IP数据报后，数据链路层为其添加<strong>帧首部</strong>和<strong>帧尾部</strong>，构成一个<strong>帧</strong>，而构成帧的这个过程，就叫<strong>组帧</strong><br>其中，来自网络层的<strong>IP数据报</strong>的最大长度即为<strong>MTU</strong>（Max Transmission Unit 最大传输单元）</p></blockquote><p>其中，添加帧首部和帧尾部（即组帧）的方式有四种</p><p><strong>1.字符计数法</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/81b6508debd34fb09bb7e5ec870426cb.png" alt="字符计数法组帧"><br>在<strong>帧首部</strong>添加一个计数的字段，表示包括这个字段在内这个帧的长度</p></blockquote><p><strong>2.字符填充法</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/ffca1aecbb464097bc706f39c175a37e.png" alt="字符填充法组帧"><br>SOH即帧的开始，EOT是帧结束，一对SOH和EOT则确定一帧<br>但是为了防止与帧内部数据内容出现二义性，可以在特殊的内容前加上ESC作为转义标识</p></blockquote><p><strong>3.零比特填充法</strong></p><blockquote><p>如果规定帧首部尾部的特殊标志是01111110（中间是6个1）<br>那么我们组帧的时候，在IP数据报，即帧的数据部分中，扫描到5个连续的1时，就在其后插入一个0，这样就避免出现6个1，也就避免数据部分和内容部分出现二义性<br><img src="https://img-blog.csdnimg.cn/fa7bc13c5d024ac09d3ebdb898f1cedb.png" alt="零比特填充法组帧"><br>可以看做<strong>更好地解决了二义性的优化版字符填充法</strong>，因为为了避免出现二义性，字符填充法每次填充一个转义字符是8位，而零比特填充法每次只需要填充1位</p></blockquote><p><strong>4.违规编码法</strong></p><blockquote><p>从物理层入手，对信号进行处理，不在话下</p></blockquote><h3 id="差错和差错控制"><a href="#差错和差错控制" class="headerlink" title="差错和差错控制"></a>差错和差错控制</h3><p><strong>类型</strong><br>一共四种，和高中生物学的那个碱基对出错很像<br><img src="https://img-blog.csdnimg.cn/363dfb29f3c74b9d9d797098c5819896.png" alt="帧的错误类型"></p><p><strong>差错控制</strong></p><blockquote><p>差错控制两种方式是<br><strong>1.检错编码</strong><br>常见的方式是通过<strong>奇/偶校验码 或 CRC循环冗余码</strong>检错<br><strong>2.纠错编码</strong><br>常见的方式是通过<strong>海明码</strong>纠错</p><p>共同之处都是通过添加<strong>冗余编码</strong>来检验，冗余编码可以理解为一些附加的信息</p></blockquote><p><strong>检错编码——奇/偶校验码</strong></p><blockquote><p><strong>添加冗余编码</strong><br><img src="https://img-blog.csdnimg.cn/beeafa33e66d4362aa64ddfce2c43a9c.png" alt="奇偶校验码"><br>比如，对101和001采用分别奇校验，就是要在首部添加一位，使得1的个数为奇数<br>所以，处理结果分别是0101, 1001<br>偶校验同理，不再赘述<br><br><br><strong>检验</strong><br>（以奇校验为例）接收方拿到数据后开始检测1的个数，如果为1的个数变成偶数了，那么即可判定数据发送变化<br>（没错，这个方法<strong>并不能100%地检测错误</strong>，只能筛掉一部分错误数据）</p></blockquote><p><strong>检错编码——CRC循环冗余码</strong></p><blockquote><p>题目至少会给发送的数据，比如11010 11011， 还有生成多项式，比如10011（即x^4^+x + 1）<br><strong>添加冗余编码</strong><br>那么我们取发送数据的前5位（11010）与生成多项式<strong>异或</strong>，结果为01001，放回原位删去前驱零得到新的数据1001 11011，然后再取前5位与生成多项式异或…重复上述过程直到最终结果不足5位（即不能再进行异或）<br>由于生成多项式最高阶是4，若不足4位通过补前驱零补满4位，即得到<strong>CRC循环冗余</strong><br>将FCS放到接收端尾部，即得到最终要发送的数据<br><br><br><strong>检验</strong><br>和上面进行一样的异或操作，如果最终结果为0，则帧没出错，否则出错</p></blockquote><p><strong>纠错编码——海明码</strong></p><blockquote><p><strong>添加冗余编码</strong><br><img src="https://img-blog.csdnimg.cn/a037b3c6dce34ebeb753f5b8dbc12699.png" alt="确定海明码校验位位数r"></p><p><img src="https://img-blog.csdnimg.cn/178dd5dba68441e998d6c3b4a1c5ad61.png" alt="确定海明码中校验码和数据的位置"><br><img src="https://img-blog.csdnimg.cn/aa903abe2aad4d1097e8fe4e863dfc28.png" alt="求海明码中校验码的值"><br>对于P1则看二进制的倒数第一位，看看Dx（x为1,2,3….）对应的二进制的倒数一位是否也是1，如果是，那么这个Dx将参与接下来的一次异或运算，该次异或运算是P1与所有满足条件的Dx异或且结果为0，这样就能求得P1的值<br>（这些满足条件的Dx即在P1纠错能力范围内）<br>同理，<strong>对于Pi则看二进制的倒数第i位，看看Dx对应的二进制的倒数第i位是否为1</strong>…..<br>这样我们就求得了所有Pi的值，最终合在一起就是<strong>海明码</strong><br><br><br><strong>纠错</strong><br><img src="https://img-blog.csdnimg.cn/636b50cd87bf448196ef0e9e1c94852a.png" alt="海明码纠错原理"><br>这里我们进行和刚才类似的异或操作，Pi和自己纠错能力范围内的Dx异或，<br>如图，结果依次是1010，但是要注意，我们之前总是提到Pi的二进制倒数第i位，所以这里是反着的，最终结果需要颠倒一下，即0101，也就是5<br>这表示第五位出错了，即D2出错，我们直接取反，D2由1变0，完成纠错</p></blockquote><h3 id="停止-等待协议-和-滑动窗口协议"><a href="#停止-等待协议-和-滑动窗口协议" class="headerlink" title="停止-等待协议 和 滑动窗口协议"></a>停止-等待协议 和 滑动窗口协议</h3><p><img src="https://img-blog.csdnimg.cn/a22812bdafca402b81aa55ef5c4bfaea.png" alt="停止-等待协议和滑动窗口协议GBN和SR"></p><p><strong>停止-等待协议</strong><br>如图，每传一帧之后都要等到收到确认帧（ACK）后才传下一帧<br>如果确认帧丢失或者出错，那么发送方可能就会一直等待——为了避免这种情况，<br>引入了</p><blockquote><p><strong>超时重传方法</strong><br>每当发送一个帧，就启动一个计时器，如果在一定时间内没有收到正确的确认帧，那么就会重新发送<br>另外，如果确认帧迟到了，那么它将会作废处理直接被抛弃</p></blockquote><p><strong>滑动窗口协议</strong><br>联想到同名的一个算法<br><img src="https://img-blog.csdnimg.cn/d0d8853d64dd49d48297aa0fe6aa83b6.png" alt="后退N帧协议GBN和选择重传协议SR"></p><blockquote><p>相当于是停止-等待协议的改进，由一次发一个帧变为<strong>可以连续发多个帧</strong><br>无论是GBN还是SR，滑动窗口都有<br>发送窗口和接受窗口<br><img src="https://img-blog.csdnimg.cn/005adf3e01fa41c8a463907ca5519dc0.png" alt="发送窗口接收窗口"><br>其中的<strong>数字是编号</strong>而非数据，<br>接收窗口收到0后，往后移动一位，并返回一个确认帧——发送窗口收到确认帧后，也往后移动一位<br>注意，只有第一位完成了上述过程窗口才发生移动</p></blockquote><blockquote><p>停止-等待协议可以看做发送窗口和接受窗口大小都是1<br>而GBN和SR的区别主要是在于<strong>处理确认帧和错误的方式</strong></p></blockquote><p><strong>GBN后退N帧协议</strong></p><blockquote><p>Go Back N-Frames，也叫回退N步协议</p></blockquote><blockquote><p><strong>接收窗口处理确认帧ACK</strong><br>这里ACK采用<strong>累积确认</strong>，即ACK的值(此处记为x)代表<strong>已经收到 x及其前面的所有帧</strong><br><br><br><strong>发送帧丢失或出错</strong><br>比如发送窗口连发了0 1 2 3 4，2在过程中丢失了，接收方就会回传一个ACK 1 代表已经收到了0 1号（当然，也可能会回传ACK 0），虽然3 4成功到达，但是接收窗口不接收…<br>在超时后，发送方只接收到了ACK 1，所以它知道从2开始就有帧丢失了，于是<strong>将 2 3 4全部重新发送</strong>——可以看做是后退了3帧这里，所以叫才后退N帧吧..</p></blockquote><p>来看看一个例题<br><img src="https://img-blog.csdnimg.cn/38613d89108443fb96cc0cc518861c85.png" alt="滑动窗口例题"></p><p><strong>SR选择重传协议</strong></p><blockquote><p>没查到英文缩写是什么<br>SR可以看做<strong>改进版的GBN</strong>，因为上面GBN的例子中，有些帧明明就成功的到达了，却还要重传，这样就造成了资源浪费<br>具体改进就是，接收窗口会<strong>存下所有正确到达的帧</strong>，然后返回响应的确认帧，发送窗口收到确认帧后也会<strong>标记所有被确认帧</strong><br>这样，当某个帧没有正确到达时，就能通过这些标记来确定该重发哪个（对，超时时，SR每次只重传一个）</p></blockquote><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p><strong>以太网</strong></p><blockquote><p>以太网（Etherner）是局域网的一种<br>10BASE-T以太网指的是，10Mb/s的传送基带（BASE）的双铰链（T）以太网<br>提供<strong>无连接不可靠</strong>服务，<strong>速率范围是10Mb/s~10Gb/s，高于100Mb/s则为高速以太网</strong>——没错这个竟然考过选择题<br>以太网拓扑：逻辑上总线型，物理上星型</p></blockquote><h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><p><img src="https://img-blog.csdnimg.cn/c9847f7d967f487ba2b0b02db51b067b.png" alt="介质访问控制的分类"><br>其中静态划分信道只需要记住名字和缩写对应关系就好了<br>而动态分配信道只需要知道<strong>CSMA/CD协议</strong>即可</p><h3 id="CSMA载波监听多点接入协议"><a href="#CSMA载波监听多点接入协议" class="headerlink" title="CSMA载波监听多点接入协议"></a>CSMA载波监听多点接入协议</h3><blockquote><pre><code>    Carrier Sense Multiple Access多点接入是指接入一根总线</code></pre></blockquote><p><strong>CSMA/CD协议</strong></p><blockquote><p>其中CD是指 Collision Detection 碰撞检测<br>检测方式是<br>发送帧之前，监听信道（半双工的）——空闲则立刻发送，忙着推迟发送</p><p>但是这并不意味着不会发生碰撞，因为监听的时候信道似乎是空闲的——但是这也可能是因为距离过程，占用信道的电磁波没进入监听范围，随后发送信号即产生碰撞</p><p><strong>争用期</strong><br>如果发生碰撞，要经过2τ-σ的时间发送方才能得知此次碰撞的发生，这个时间即<strong>争用期（也叫 冲突窗口/碰撞窗口）</strong><br>σ趋向零时，争用期趋向最大值<br><img src="https://img-blog.csdnimg.cn/485ccb9fa3ac4e49a200cdf76e835892.png" alt="载波监听和碰撞"></p></blockquote><p><strong>重传时机：截断二进制指数规避算法</strong></p><blockquote><p>如果碰撞后立即重传，那么可能又会碰撞，并且无休无止，所以需要一个算法求一个适当的时机重传信号，这个算法即<strong>截断二进制指数规避算法</strong><br><img src="https://img-blog.csdnimg.cn/d301e71f48014ea88a9ce415d819ffab.png" alt="截断二进制指数规避算法"></p></blockquote><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="电路交换、报文交换、分组交换"><a href="#电路交换、报文交换、分组交换" class="headerlink" title="电路交换、报文交换、分组交换"></a>电路交换、报文交换、分组交换</h3><p><strong>电路交换</strong><br><img src="https://img-blog.csdnimg.cn/a8a5d451c1eb4757b79f89730bb43c86.png" alt="电路交换"><br>唯一要提一下就是，一条链路中一个设备崩溃那么整个链路崩溃，即缺点3.不灵活</p><p><strong>报文交换</strong><br>报文：源应用发送的信息整体<br><img src="https://img-blog.csdnimg.cn/dc29ea69820a41eda742baaad5de7358.png" alt="报文交换"><br><strong>分组交换</strong><br>就是把报文切片了再发<br><img src="https://img-blog.csdnimg.cn/fdee67f60d714ddd9232b9f231d6da84.png" alt="分组交换"><br>分组交换其实还可以细分为</p><blockquote><p><strong>数据报方式（无连接）</strong><br>无连接，不会事先确定传输路径，每个分组路径独立，彼此之间可能不通过<br><strong>虚电路方式（连接）</strong><br>实现会确定传输路径</p></blockquote><p>发送同样的数据，分组交换一般比报文交换快</p><blockquote><p>已知，链路传输速率为1000bps（bits per second，看到这个单位要知道就是b/s）<br>要发送的报文大小是10000bits，要经过的链路如上图所示，求报文交换和分组交换（假设分为1000片）的最短用时</p><p><strong>报文交换</strong><br>10000bits / 1000bps = 10s  ，即在每段链路上传播要10s<br>很容易看出是30s<br><strong>分组交换</strong><br>10000bits/1000 = 10 bits，每一片10bits<br>10bits / 1000 bps = 0.01 s,  每小片在每段链路上传播要0.01 s<br>第一片走完全程要0.03s, 第一片和最后一片相差 999 片，也就是 9.99 s, 所以，最后一片到达重点需要10.02s<br>即10.02s</p></blockquote><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><blockquote><p>Internet Protocal 网际协议</p></blockquote><p><strong>IP数据报</strong></p><blockquote><p>注意数据部分包括了TCP段和UDP段<br>IP数据报的最大长度即MTU，最大传送单元，以太网中MTU为1500Bytes<br><img src="https://img-blog.csdnimg.cn/2ae85e270df9444d89b4d7cf3ffaf343.png" alt="IP数据报格式"><br><strong>注意，片便宜的单位是8Bytes</strong>，所以记得除8<br>字段MF是More Fragments, DF是Don‘t Fragment，其值是布尔值<img src="https://img-blog.csdnimg.cn/aaeb19a9f22c4600aeca7cc058232987.png" alt="IP数据报分片"><br>注意，通常我们认为不能出现全0或全1的网络号或者主机号，所以这里还得减去那么一两个(虽然有的可以用了，但是做题的时候我们依旧认为其不可用）<img src="https://img-blog.csdnimg.cn/7d9f3f63555647879048bfcef72adec2.png" alt="最大可用主机数"></p></blockquote><h3 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h3><blockquote><p>全世界唯一的 32位/4字节 标识符，标识路由器主机的接口<br>形如01110000 11001100 11110000 11111111，一共32位<br>也可以写作形如112.204.240.255，则称为<strong>点分十进制记法</strong><br>分为 <strong>网络号 和 主机号</strong>两部分</p></blockquote><p> <strong>分类及区别</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/6ed9bc257ab44788bb5e76ad9b483c93.png" alt="IPv4地址分类"></p></blockquote><h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p> <strong>私有IP地址</strong></p><blockquote><p>对于私有IP地址，路由器是不会转发的<br><img src="https://img-blog.csdnimg.cn/ee8b7b61096e4237847c4affbecc95b3.png" alt="IPv4的私有IP地址"></p></blockquote><p>如果想要用私有IP地址和外部网络通信的话，就需要用到NAT了·<br><strong>NAT网络地址转换器</strong></p><blockquote><p>Network Address Translation<br>在专用网连接因特网的<strong>路由器上安装NAT软件</strong>，这个路由器就变成了NAT路由器，它至少拥有一个外部全球IP地址<br>能把LAN局域网IP转换为WAN广域网IP：<br><img src="https://img-blog.csdnimg.cn/d74834af11124292bbd3a6ad30e43721.png" alt="NAT网络地址转换"></p></blockquote><h3 id="子网划分-和-子网掩码"><a href="#子网划分-和-子网掩码" class="headerlink" title="子网划分 和 子网掩码"></a>子网划分 和 子网掩码</h3><p><strong>子网划分</strong></p><blockquote><p>在主机号里抽一部分作为子网<br><img src="https://img-blog.csdnimg.cn/445a24f6df0c44b58bd4349ad89df324.png" alt="子网划分"><br><img src="https://img-blog.csdnimg.cn/aad62d4830df4217885c7dbbc74b784b.png" alt="子网划分"><br><img src="https://img-blog.csdnimg.cn/c76357d59c2c4dffbc8bb03ffe2481a4.png" alt="子网划分"></p></blockquote><h3 id="CIDR无分类编址"><a href="#CIDR无分类编址" class="headerlink" title="CIDR无分类编址"></a>CIDR无分类编址</h3><blockquote><p>CIDR，读作sider<br>能够延缓IPv4用尽的危机，作用机制如下：<br><strong>以128.233.233.233/16的形式表示IP</strong><br>其中末尾的**/16代表前16位是网络号**，这样一来就拜托了ABCDE类的束缚，更加灵活，更便于按需供给减少浪费<br><strong>需要注意，在CIDR中，网络号也称前缀号</strong></p></blockquote><p><strong>构成超网</strong></p><blockquote><p>也叫路由聚合<br>即多个子网聚合为一个大的子网，方法是缩短网络前缀</p></blockquote><p>来个例题<br><img src="https://img-blog.csdnimg.cn/2ee2c5bb25c84078aadbf31918119595.png" alt="CIDER路由转发"></p><h2 id="运输层-待更新"><a href="#运输层-待更新" class="headerlink" title="运输层(待更新)"></a>运输层(待更新)</h2><h2 id="应用层-待更新"><a href="#应用层-待更新" class="headerlink" title="应用层(待更新)"></a>应用层(待更新)</h2>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE</title>
      <link href="/2022/01/08/vue/"/>
      <url>/2022/01/08/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>这是个人的学习笔记，用于自己复习的同时也希望能帮助到有需要的人<br>由于是初学，加上Vue的知识也不少，难免有错误和不足，希望大家谅解，也欢迎批评指正</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/08</strong></p><p>本博客最初于2021/08/20发布在我的C站博客，现在做了微小的调整后搬运到此处</p></blockquote><h2 id="完善的准备"><a href="#完善的准备" class="headerlink" title="完善的准备"></a>完善的准备</h2><h3 id="认识Vue框架"><a href="#认识Vue框架" class="headerlink" title="认识Vue框架"></a>认识Vue框架</h3><p>为了便于理解，我将Vue概括为：<br>1.Vue是一个<strong>主要关注视图层</strong>的渐进式框架，即Vue可以只运用到局部代码。</p><p>2.并且Vue实现了<strong>MVVM双向绑定</strong>模式<br>M：模型层，指js对象<br>V：视图层，指DOM<br>VM：链接视图和数据的中间件</p><p>3.而且兼顾了React的<strong>虚拟DOM</strong>和Angular的<strong>模块化开发</strong></p><p>至于什么是框架，我的理解是：<br><strong>自动生成</strong>各种文件配置及相关代码的，并且提供了许多更<strong>简洁高效</strong>的开发方式的东西</p><p>另外，Vue读作view，而不是   微优易<br>================================================</p><p>需要安装下载的东西都写在这里了，根据需要自行节选阅读</p><h3 id="Vue-引入"><a href="#Vue-引入" class="headerlink" title="Vue 引入"></a>Vue 引入</h3><p>两种引入方式：<br>本地引入：去官网复制一份代码到本地然后js引入即可<br>CDN引入：加上以下代码</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><em><strong>接下来的内容是暂时不会用到的，不过提前准备好呢也没有坏处（要是觉得麻烦就先跳过）</strong></em></p><h3 id="npm-安装"><a href="#npm-安装" class="headerlink" title="npm 安装"></a>npm 安装</h3><p>Node.js的包管理工具,经常用到</p><p>1.搜索Node.js去它的官网下载，然后安装即可（自动配置环境变量）</p><p>2.win+r输入cmd打开命令提示符(或者打开编译器终端）输入：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></tbody></table></figure><p>检测版本号<br>如果出现版本号则说明安装成功</p><h3 id="cnpm镜像加速器-安装"><a href="#cnpm镜像加速器-安装" class="headerlink" title="cnpm镜像加速器 安装"></a>cnpm镜像加速器 安装</h3><p>由于npm下载国外资源的时候可能会比较慢，所以我们还得专门弄一个“中国版”（<strong>镜像加速器</strong>）的：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cnpm -g</span><br></pre></td></tr></tbody></table></figure><p>以后每当遇到npm下载卡顿的时候，就可以用<strong>ctrl+c</strong>终止下载，然后用<strong>cnpm替代npm</strong>即可体验极速下载</p><h3 id="Vue-Cli脚手架-安装"><a href="#Vue-Cli脚手架-安装" class="headerlink" title="Vue-Cli脚手架 安装"></a>Vue-Cli脚手架 安装</h3><p>Vue-Cli才是真正开始Vue，新建项目自动配置上万个文件让萌新感受一下什么才叫大前端</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install vue-cli -g</span><br></pre></td></tr></tbody></table></figure><h3 id="webpack-安装"><a href="#webpack-安装" class="headerlink" title="webpack 安装"></a>webpack 安装</h3><p>代码打包工具，自动将工程代码转为ES5并且压成一行代码</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install webpack -g</span><br></pre></td></tr></tbody></table></figure><h3 id="webpack-cli-安装"><a href="#webpack-cli-安装" class="headerlink" title="webpack-cli 安装"></a>webpack-cli 安装</h3><p>webpack都装了，那webpack顺便一起吧</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-cli -g</span><br></pre></td></tr></tbody></table></figure><h3 id="axios-安装"><a href="#axios-安装" class="headerlink" title="axios 安装"></a>axios 安装</h3><p>其实也就是Vue版的ajax</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></tbody></table></figure><h3 id="vue-router-安装"><a href="#vue-router-安装" class="headerlink" title="vue-router 安装"></a>vue-router 安装</h3><p>路由<br>这个要在<strong>项目目录下</strong>安装<br>进入项目目录下，输入</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save-dev</span><br></pre></td></tr></tbody></table></figure><h3 id="devtools-安装"><a href="#devtools-安装" class="headerlink" title="devtools 安装"></a>devtools 安装</h3><p>这是一个浏览器插件，用于vue代码的调试，只需要在浏览器上安装就行了</p><h2 id="开始使用Vue"><a href="#开始使用Vue" class="headerlink" title="开始使用Vue"></a>开始使用Vue</h2><h3 id="创建Vue对象-以及-mustache语法"><a href="#创建Vue对象-以及-mustache语法" class="headerlink" title="创建Vue对象 以及 mustache语法"></a>创建Vue对象 以及 mustache语法</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"> <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="comment">//绑定id为app的DOM元素,这也确定了Vue对象的作用范围</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">"#app"</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">//以键值对的形式存放数据</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="attr">mes</span>:<span class="string">"HelloWorld!"</span></span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="comment">//类似的，存放方法</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">     <span class="attr">helloWorld</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">     <span class="comment">//访问对象的属性</span></span></span><br><span class="line"><span class="javascript">                alert(<span class="built_in">this</span>.mes);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>相应的html部分为：<br>其中嵌套的大括号就是mustache语法,括号里面可以写多个变量，也可以填表达式(不推荐这么做)<br>mustache语法不能用于标签的内部！<br><strong>(不能出现&lt;div <code>{{name}}</code>&gt;&lt;/div&gt;这种或者其他类似的形式)</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- {{}}会动态的去接收值</span></span><br><span class="line"><span class="comment">这就是mustache语法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>{{mes}}<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用v-on:绑定事件，也可以简写为@ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">"helloWorld"</span>&gt;</span>点击我试试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></tbody></table></figure><p>运行效果：</p><p><img src="https://img-blog.csdnimg.cn/62d58f8e5fe344829912e8ee7422b55b.png" alt="在这里插入图片描述"><br>另外，vue3.0之后，建议将Vue对象中的data写为函数的形式：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">return</span>{</span><br><span class="line">    <span class="attr">mes</span>:<span class="string">"HelloWorld!"</span></span><br><span class="line">}</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>这样写的话，多个与之关联的html元素都会有自己独立的作用域，避免了污染</p><h3 id="循环v-for"><a href="#循环v-for" class="headerlink" title="循环v-for"></a>循环v-for</h3><p><strong>记得每次都要引入Vue的js文件<br>为了方便阅读，后面就不再提醒了</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm2 = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">"#app2"</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">items</span>: [<span class="string">"牛逼"</span>,<span class="string">"天秀"</span>,<span class="string">"妙绝"</span>]</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"app2"</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"i in items"</span>&gt;</span>{{i}}<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></tbody></table></figure><p>运行结果，可以看到动态的创建了三个<br><img src="https://img-blog.csdnimg.cn/7d275a5d45fc42698dd64fa38ae65e88.png" alt="在这里插入图片描述"><br>v-for还可以支持多个参数</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(i, index) in arr"</span>&gt;</span>{{index}}----{{i}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(i, index, key) in arr"</span>&gt;</span>{{index}}----{{i}}----{{key}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(i, index, key) in obj"</span>&gt;</span>{{index}}----{{i}}----{{key}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/b3d133b02d3b4eceb2a7f9d6af58e76d.png" alt="在这里插入图片描述"><br><strong>从结果上看，第一个参数是值，第二个参数是键，在对象中还会有第三个参数是下标</strong></p><h3 id="分支v-if"><a href="#分支v-if" class="headerlink" title="分支v-if"></a>分支v-if</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm1 = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">"#app1"</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="attr">num</span>: <span class="number">3</span></span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"num == 1"</span>&gt;</span>num是1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"num === 2"</span>&gt;</span>num是2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>num为其他值{{num}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>运行结果<br><img src="https://img-blog.csdnimg.cn/d2bfdca36e524429872374decee4d3b7.png" alt="在这里插入图片描述"></p><h3 id="单次变化v-once"><a href="#单次变化v-once" class="headerlink" title="单次变化v-once"></a>单次变化v-once</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">msg</span>: <span class="string">"hhhh"</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {}</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>变化：{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span>不会变化：{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>什么叫做单次变化呢？<br>首先来看看结果<br><img src="https://img-blog.csdnimg.cn/514089cec1e744ac8f40b9665ead23c9.png" alt="在这里插入图片描述"><br>我们在浏览器的控制台上对值进行一个修改，此时我们就发现：<br><img src="https://img-blog.csdnimg.cn/7c9a55b5acf44193a42c7b6d50386531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="v-text和v-html"><a href="#v-text和v-html" class="headerlink" title="v-text和v-html"></a>v-text和v-html</h3><p>v-text其实还没有mustache语法<code>{{}}`好用...但是还是要了解相比之下，v-html就显得有用多了</code></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">msg</span>:<span class="string">"&lt;div style=\"color: red;\"&gt;123&lt;/div&gt;"</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><code><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>运行结果也可想而知![在这里插入图片描述](https://img-blog.csdnimg.cn/ffcc95d216da40198a47ec82ab3dde81.png)### 预设v-pre这个说实话应该猜都能猜到作用了，其实就是\<pre>\</pre>的vue版本这里我也不给vue对象的代码了（因为给了也没用）<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-pre</span>&gt;</span>预设不处理：{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>![在这里插入图片描述](https://img-blog.csdnimg.cn/4b025bb7343b47fe9ac67190ae2df55c.png)有什么用呢？大概就是...基本上没什么用....### 解析判定v-cloakvue对象的data数据可能会来自服务器，那么网络不畅的时候就可能导致数据没有及时渲染到页面，就会出现满屏的`{{}}</code>这种mustache语法，让用户看了觉得十分诡异，为了<strong>判定Vue对象到底有没有解析完毕</strong>，就出现了v-cloak<p></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span><br><span class="line">        <span class="attr">el</span>: <span class="string">'app'</span>,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span><br><span class="line">            <span class="keyword">return</span>{</span><br><span class="line">                <span class="attr">msg</span>:<span class="string">"hhhh"</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span>啊哈！{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>请求成功和请求失败的状态:<br><img src="https://img-blog.csdnimg.cn/8aa3458d0255449fbc57451cff090d9d.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/9c3d3e32b7184e0ba04ef23c084ca8ab.png" alt="在这里插入图片描述"><br>没错，v-cloak就是在成功时消失，失败时保留<br>那么我们就可以利用css的属性选择器搞一手操作了</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-attr">[v-cloak]</span>{</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="css">    }</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样一来，失败时就不会显示mustache语法了</p><h3 id="动态绑定v-bind"><a href="#动态绑定v-bind" class="headerlink" title="动态绑定v-bind"></a>动态绑定v-bind</h3><p>之前说过了，mustache不能用在标签的内部，也就是不能用在左右箭头的里面，那么问题来了：<br>对于这样的vue对象</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">myColor</span>: <span class="string">"color:red;"</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">someOnesColor</span>: <span class="string">"blue"</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>我却偏要这么写html（甚至还报错了）：<br><img src="https://img-blog.csdnimg.cn/c40060eac0254d60a6e250b739d4d45c.png" alt="在这里插入图片描述"><br>很明显这个mycolor是没有解析成color：red；的（被当作了css)<br>此时我们就需要用到v-bind了（第二种写法是个语法糖)</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"myColor"</span>&gt;</span>啊哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"myColor"</span>&gt;</span>啊哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"{color: someOnesColor,}"</span>&gt;</span>啊哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/748291b1825e436ab21e6ec651e2658f.png" alt="在这里插入图片描述"></p><p>这里提一句，<strong>如果返回多个值，也可以考虑用数组或者对象的形式发送/接受</strong>,</p><p>中间可以利用函数进行处理（当然不用也行)</p><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p>另外，vue或react中，一个dom对象默认有一个key值，需要用v-bind绑定一个唯一标志（不要用下标，因为下标会在排序等变化值发生改变），<br>这样一来在基于<strong>diff算法</strong>的动态变化（增删改排序）时，能够做到正确匹配每个元素</p><h3 id="事件绑定v-on"><a href="#事件绑定v-on" class="headerlink" title="事件绑定v-on"></a>事件绑定v-on</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">sayhi</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">"好啊你真敢点我"</span>);</span></span><br><span class="line"><span class="javascript">            },</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">saywow</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">"这么说你很勇哦"</span>);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>其中@是一个语法糖</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">"sayhi"</span>&gt;</span>点我一下你试试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"saywow"</span>&gt;</span>这个彬彬就是逊啦<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>运行结果<br><img src="https://img-blog.csdnimg.cn/94654a883bda47ca908f401f65fdcaa5.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/27d40b49e67f4bad86fa7303092e9977.png" alt="在这里插入图片描述"></p><h3 id="事件对象参数"><a href="#事件对象参数" class="headerlink" title="事件对象参数"></a>事件对象参数</h3><p>另外，涉及到参数的一种情况</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">clickEvent1</span>(<span class="params">args</span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(args);</span></span><br><span class="line"><span class="javascript">            },</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">clickEvent2</span>(<span class="params">args</span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(args);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>注意绑定的事件，都不传参数，但是一个加了括号一个没加括号</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickEvent1()"</span>&gt;</span>按钮1号<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickEvent2"</span>&gt;</span>按钮2号<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>可见分别输出<strong>undefined</strong>和<strong>事件对象</strong><br>所以如果<strong>不加括号时会自动传一个事件对象</strong><br><img src="https://img-blog.csdnimg.cn/37f33bb47e284b2b80d5203dcf7f592f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么问题来了，如果需要传参数的同时有需要事件对象该如何操作呢?</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">clickEvent3</span>(<span class="params">num1, num2, event</span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(num1);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(num2);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(event);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>注意，第三个参数前面加了一个$符号，表示传递事件对象，这样一来我们就可以在传递其他参数的通时传递事件对象了</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickEvent3(123, 456, $event)"</span>&gt;</span>按钮3号<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>当然，事件对象参数的位置可以随意，但是约定俗成还是放末尾比较好</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>还记得<strong>事件冒泡</strong>和<strong>事件捕获</strong>吧</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">fatherClick</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"我是父元素"</span>);</span></span><br><span class="line"><span class="javascript">            },</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">sonClick</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"我是子元素"</span>);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>写了点style方便观察（懒得写class）</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"fatherClick"</span> <span class="attr">style</span>=<span class="string">"background-color: red;height: 300px;text-align: center;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"sonClick"</span> <span class="attr">style</span>=<span class="string">"margin-top:150px;"</span>&gt;</span>冒泡：OoOoOooOOOo<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>当我们点击子元素时，<strong>触发子元素事件之后会触发父元素事件</strong><br>这是因为子元素时父元素的一部分，所以点击子元素也相当于点击了父元素的一部分，也就触发了事件冒泡（<strong>事件触发自底向上</strong>）<br><img src="https://img-blog.csdnimg.cn/787c14666cb74214a9985edcd968f0a5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在以前我们会采用在子元素的函数中利用事件对象的内置函数<strong>stopPropagation</strong>来阻止冒泡</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sonClick</span>(<span class="params">event</span>)</span>{</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是子元素"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是现在我们有了修饰符,允许我们在标签中写：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"sonClick"</span> <span class="attr">style</span>=<span class="string">"margin-top:150px;"</span>&gt;</span>冒泡：OoOoOooOOOo<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>另外，不只有事件绑定v-on才有修饰符，其他vue关键词也有</p><p>懂了概念和作用，那么使用修饰符也是得心应手，下面是一些常用的事件修饰符，这里不再赘述：</p><table><thead><tr><th>修饰符</th><th>作用</th></tr></thead><tbody><tr><td>.trim</td><td>清除首尾空格</td></tr><tr><td>.stop</td><td>阻止事件冒泡</td></tr><tr><td>.prevent</td><td>阻止默认行为</td></tr><tr><td>.self</td><td>只有元素本身能触发自己的事件</td></tr><tr><td>.once</td><td>只能触发一次</td></tr><tr><td>.capture</td><td>将事件冒泡调整为事件捕获（自顶向下触发）</td></tr><tr><td>.keycode:</td><td>监听键盘</td></tr><tr><td>.enter</td><td>监听键盘是否按下enter键</td></tr><tr><td>.up(上下左右空格之类依葫芦画瓢)</td><td>监听键盘是否按下↑</td></tr></tbody></table><h3 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h3><p>虽然说mustache语法中的<code>{{}}</code>内可以进行一些如同字符串拼接的简单操作，但是遇到更多的计算时，不仅是视觉上会显得不美观，而且还存在无法正确运算的可能。<br>我们可以通过methods来解决这些问题，不过methods内的方法是动态的从而很容易被修改，存在被意外地污染的风险<br>这时候，为了防止这种事情发生，就出现了computed计算属性</p><p>最简单的使用大概就像以下这样</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">msg1</span>: <span class="string">"hello"</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">msg2</span>: <span class="string">"world"</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">computed</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">msgStrcat</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">this</span>.msg1 + <span class="string">" "</span> + <span class="built_in">this</span>.msg2</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }  </span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    {{msgStrcat}}</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>和函数有什么区别？<br>在mustache语法调用的时候<strong>不加（）</strong>,因为这是一个属性而不是函数——这是形式上的区别，<br>那还有更多本质上的区别吗？<br>各位看官莫急，且看以下分析：<br><strong>1.computed内的实际形式：</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed:{</span><br><span class="line">    <span class="attr">msgStrcat</span>:{</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params"></span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"这是computed的set函数"</span>);</span><br><span class="line">        },</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"这是computed的get函数"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure><p>其中get和set也就是ES6中增加的内容，可以参考我的ES6学习笔记<br><strong>2.被调用的时候：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">strcat</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"这是methods的方法"</span>);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">computed</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="attr">msgStrcat</span>:{</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"这是computed的set"</span>);</span></span><br><span class="line"><span class="javascript">                },</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"这是computed的get函数"</span>);</span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }  </span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后是三次同时调用computed和methods</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{msgStrcat}}{{strcat()}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{msgStrcat}}{{strcat()}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{msgStrcat}}{{strcat()}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>可以看见的是，<strong>computed只被触发了一次</strong>，这源于set的性质<br><img src="https://img-blog.csdnimg.cn/1faafaacff364b36982d82c0659f6cc0.png" alt="在这里插入图片描述"><br>没错！<strong>computed计算后的结果是放在缓存里面的</strong>，这样一来不仅避免了大量重复计算从而大大地提高了页面响应式加载的效率！<br>所以以后遇到那种几乎不变的值时，就可以考虑computed了（由于几乎不变，set也没什么用了…）<br>当然也别管那么多，以后遇到属性直接先莽computed！</p><h3 id="显示v-show"><a href="#显示v-show" class="headerlink" title="显示v-show"></a>显示v-show</h3><p>本质是修改css中display的值</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">isShowed</span>:<span class="literal">true</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"isShowed"</span>&gt;</span>显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"!isShowed"</span>&gt;</span>没有显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/a3231fcea02c4c51ac10833fee9f17fd.png" alt="在这里插入图片描述"><br><strong>和v-if的区别</strong><br><strong>v-show纵使不显示，那么标签也还在，只不过隐藏了</strong><br><img src="https://img-blog.csdnimg.cn/8826972873194b70b653b1dff58212f8.png" alt="在这里插入图片描述"><br><strong>但是v-if是 移除或创建 标签</strong><br>想一下vue为什么出现，不就是为了响应式动态加载避免频繁操作DOM吗，所以这里也是一个道理——在涉及到频繁切换的时候，我们就优先考虑v-show而不是v-if</p><h3 id="双向绑定v-model"><a href="#双向绑定v-model" class="headerlink" title="双向绑定v-model"></a>双向绑定v-model</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">inputStr</span>:<span class="string">""</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"inputStr"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>您输入的是:{{inputStr}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>双向绑定之后，两边就可以同步变化了<br><img src="https://img-blog.csdnimg.cn/0a8d0fe6575148ddb4edbc177f097d4e.png" alt="在这里插入图片描述"></p><p> <strong>v-model的底层实现</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                <span class="attr">msg</span>: <span class="number">666</span>,</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">valueChanged</span>(<span class="params">event</span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.msg = event.target.value;</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"msg"</span> @<span class="attr">input</span>=<span class="string">"valueChanged"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>您输入的是：{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>通过<strong>v-bind动态绑定</strong>和<strong>methods方法</strong>完成双向绑定<br>懂了这个原理，你就可以这么写：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"msg"</span> @<span class="attr">input</span>=<span class="string">"msg = $event.target.value"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>您输入的是：{{msg}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="组件化component"><a href="#组件化component" class="headerlink" title="组件化component"></a>组件化component</h2><h3 id="开始组件化开发"><a href="#开始组件化开发" class="headerlink" title="开始组件化开发"></a>开始组件化开发</h3><p>低耦合高内聚嘛<br>先来看看最简单的使用方式</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义全局组件</span></span></span><br><span class="line"><span class="javascript">    vm.component(<span class="string">'button-count'</span>,{</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                <span class="attr">count</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;button @click="count ++;"&gt;你点击了这个按钮{{count}}次&lt;/button&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 绑定</span></span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这里我们不再采用Vue2中使用new来创建Vue对象的形式，而是采用了Vue3中的createApp方法。<br><strong>这里需要注意的是，引入的文件需要更改为：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue@next"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>接下来我们就可以这样写了<br>(组件化中标签的写法有一定的讲究)<br>组件命名要么像buttonCount，要么像button-count</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button-count</span>&gt;</span><span class="tag">&lt;/<span class="name">button-count</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button-count</span>&gt;</span><span class="tag">&lt;/<span class="name">button-count</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button-count</span>&gt;</span><span class="tag">&lt;/<span class="name">button-count</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/3d5e4eae6c6143729703ab02611e13ed.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于data部分我们使用的函数形式，所以能够返回独立的函数作用域，因此每个点击按钮的数值可以<strong>相互独立</strong>；<br>反之，如果不采用函数形式的data，那么所有值都会同步。</p><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p>我们之前使用的都是全局组件<br>在介绍它有什么特点之前，先来看看以下代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义全局组件</span></span></span><br><span class="line"><span class="javascript">    vm.component(<span class="string">'cool-title'</span>,{</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;h1 style="color:red;background-color:pink;"&gt;炫酷的标题&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript">    vm.component(<span class="string">'button-count'</span>,{</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;cool-title&gt;&lt;/cool-title&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;button&gt;嘿，兄贵快来点我&lt;/button&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 绑定</span></span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>在一个Vue对象内定义多个组件的时候，它们之间可以相互调用</strong><br>上述代码中，第二个组件内就调用了第一个组件<br>效果如下：<br><img src="https://img-blog.csdnimg.cn/8c974d88cbd34b768e122ecf58d05a61.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><p>先看代码</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义局部组件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> title = {</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                <span class="attr">title</span>: <span class="string">"炫酷的标题"</span> </span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;h1 style="color:red;background-color:pink;"&gt;{{title}}&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> button = {</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;cool-title&gt;&lt;/cool-title&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;button&gt;嘿，兄贵快来点我&lt;/button&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="string">"cool-title"</span>:title,</span></span><br><span class="line"><span class="javascript">            <span class="string">"button-count"</span>:button</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>没错，是声明一个类似于对象的东西，最后在创建Vue对象实例的时候才塞到components内，<br>这个时候我们还要给他们自定义一个名字构成键值对</p><p>效果如下<br><img src="https://img-blog.csdnimg.cn/b634ea4481f1448e82d24dee3ef40f98.png" alt="在这里插入图片描述"><br>没错，如果你仔细看了代码，你会发现第<strong>二个组件内调用了第一个组件，但是从效果上来看并没有起到作用。</strong></p><p>这就是局部组件，<strong>只能在components中引入后才能使用</strong></p><p>所以如果硬要使用，就得像这样写：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = {</span><br><span class="line">    <span class="attr">components</span>:{</span><br><span class="line">        <span class="string">"niubi-title"</span>:title</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;niubi-title&gt;&lt;/niubi-title&gt;</span></span><br><span class="line"><span class="string">        &lt;button&gt;嘿，兄贵快来点我&lt;/button&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> <strong>其他形式</strong>：<br>这两种形式都是可以的，引入方式都一样</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/template"</span> <span class="attr">id</span>=<span class="string">"coolTitle"</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color:red;background-color:pink;"</span>&gt;</span>酷炫的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>嘿，兄贵快来点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"goodTitle"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color:red;background-color:pink;"</span>&gt;</span>酷炫的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>嘿，兄贵快来点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>使用：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = {</span><br><span class="line">    <span class="attr">components</span>: {</span><br><span class="line">    },</span><br><span class="line"></span><br><span class="line">    <span class="attr">template</span>:<span class="string">`#coolTitle</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意这时候对象中的template中就不能再书写其他东西了（包括前置空格）,不然总是会出一些稀奇古怪的问题</p><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="父组件向子组件传递props"><a href="#父组件向子组件传递props" class="headerlink" title="父组件向子组件传递props"></a>父组件向子组件传递props</h3><p>props其实就是参数</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> box = {</span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>: [<span class="string">'p'</span>],</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;h1 style="color:red;"&gt;{{p}}&lt;/h1&gt; `</span></span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="string">"great-box"</span>:box,</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">great-box</span> <span class="attr">:p</span>=<span class="string">"6666"</span>&gt;</span><span class="tag">&lt;/<span class="name">great-box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果如下<br><img src="https://img-blog.csdnimg.cn/890f5ac691f04f1fbbb87864d6228c29.png" alt="在这里插入图片描述"><br><strong>约束</strong><br>可以通过如下形式对参数传递的内容进行约束，<br>当内容不符合约束时，控制台会给出相应的警告</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box = {</span><br><span class="line">    <span class="attr">props</span>: {</span><br><span class="line">        <span class="attr">p</span>: <span class="built_in">String</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1 style="color:red;"&gt;{{p}}&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当然，也有更完善的约束形式：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box = {</span><br><span class="line">    <span class="attr">props</span>: {</span><br><span class="line">        <span class="attr">p</span>: {<span class="attr">type</span>:<span class="built_in">String</span>, <span class="attr">required</span>:<span class="literal">true</span>, <span class="attr">default</span>:<span class="string">'哈哈哈哈'</span>}</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1 style="color:red;"&gt;{{p}}&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>props命名规范</strong><br>props中比如写一个</p><p><strong>coolBrand，那么在html部分进行绑定时就要写成cool-brand，原因是html不区分大小写</strong></p><h3 id="no-props"><a href="#no-props" class="headerlink" title="no-props"></a>no-props</h3><p>不使用props传递内容</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="attr">price</span>: <span class="number">5</span></span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            },</span></span><br><span class="line"><span class="javascript">            <span class="attr">components</span>: {</span></span><br><span class="line"><span class="javascript">                <span class="string">"box"</span>: {</span></span><br><span class="line"><span class="javascript">                    <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">                    &lt;h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                        &lt;div&gt;吴彦祖？哦，是镜子啊&lt;/div&gt;    </span></span></span><br><span class="line"><span class="string"><span class="javascript">                    &lt;/h1&gt;`</span></span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }).mount(<span class="string">"#app"</span>);     </span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>当前的价格是{{price}}<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span> <span class="attr">ababa</span>=<span class="string">"阿巴阿巴"</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 200px;background-color: #faa;"</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/529ddf638633455687e0add94926579c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>课件，最外层的h1继承了模板标签的各项属性</p><p><strong>需要注意的是，在以下两种情况中，继承无法完成：</strong><br><strong>第一种：inheritAttrs:false</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">components: {</span><br><span class="line">    <span class="string">"box"</span>: {</span><br><span class="line">        <span class="attr">inheritAttrs</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;吴彦祖？哦，是镜子啊&lt;/div&gt;    </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;`</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>第二种：模板内最大父级元素不唯一 （并且不做处理时）</strong><br>此处指的两个h1标签，都是最大的父级元素</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">components: {</span><br><span class="line">    <span class="string">"box"</span>: {</span><br><span class="line">        <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;吴彦祖？哦，是镜子啊&lt;/div&gt;   </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;古尔丹？哦，是镜子啊&lt;/div&gt;   </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>在第二种情况中，如果还是想要继承</strong>，<br>可以使用用 <strong>v-bind:=”$attrs”</strong> ：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">components: {</span><br><span class="line">    <span class="string">"box"</span>: {</span><br><span class="line">        <span class="comment">// inheritAttrs:false,</span></span><br><span class="line">        <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1 :="$attrs"&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;吴彦祖？哦，是镜子啊&lt;/div&gt;   </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;h1 :="$attrs"&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;古尔丹？哦，是镜子啊&lt;/div&gt;   </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另外，我们还可以选择其中一部分属性继承</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">components: {</span><br><span class="line">    <span class="string">"box"</span>: {</span><br><span class="line">        <span class="comment">// inheritAttrs:false,</span></span><br><span class="line">        <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1 :a="$attrs.ababa"&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;吴彦祖？哦，是镜子啊&lt;/div&gt;   </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;h1 :style="$attrs.style"&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;古尔丹？哦，是镜子啊&lt;/div&gt;   </span></span><br><span class="line"><span class="string">        &lt;/h1&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是，这样具体到某一个属性的时候，v-bind需要加上一个名字（<strong>盲猜之前没加的时候都是自动把$attrs解构了</strong>）</p><h3 id="子组件向父组件传递"><a href="#子组件向父组件传递" class="headerlink" title="子组件向父组件传递"></a>子组件向父组件传递</h3><p>子组件向父组件传递的方式是通过自定义事件</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> box = {</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;button style="color:red;" @click="boxClick"&gt;我是子组件，快来点我&lt;/button&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">boxClick</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"子组件发出了信息"</span>);</span></span><br><span class="line"><span class="javascript">                <span class="comment">//1.this.$emit使得boxClick方法可以作为事件触发</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//（注意当做事件使用时，命名规则形如box-click）</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$emit(<span class="string">'boxClick'</span>);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="string">"great-box"</span>:box,</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">response</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"父组件表示收到"</span>);</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 200px;background-color: #faa;"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2.把方法当事件用，绑定父组件中的一个方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">great-box</span> @<span class="attr">box-click</span>=<span class="string">"response"</span>&gt;</span><span class="tag">&lt;/<span class="name">great-box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>来一步一步分析：<br>1.子组件自定义一个方法，这个方法内部有一个this.$emit()是用于触发自定义事件的，<strong>它的存在使得这个函数可以作为一个事件来使用</strong>。<strong>其中值是作为事件时的名称</strong>，可以随意。<br>2.在模板标签上用1中所构成的自定义事件来绑定一个父组件的方法<br>3.触发子组件的自定义事件，则父组件的函数也会触发</p><p>效果：<br><img src="https://img-blog.csdnimg.cn/3655a43a56a14988a27cf2c61816a542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="refs-parent和-root"><a href="#refs-parent和-root" class="headerlink" title="$refs,$parent和$root"></a>$refs,$parent和$root</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//这个box就是子组件对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> box = {</span></span><br><span class="line"><span class="javascript">            <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div style="background-color: #faa;width:200px;height:200px"&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">            `</span></span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">            <span class="attr">components</span>:{</span></span><br><span class="line"><span class="javascript">                <span class="string">"box"</span>:box</span></span><br><span class="line"><span class="javascript">            },</span></span><br><span class="line"><span class="javascript">            <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">getChildComponent</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="comment">//this.$refs访问到所有具有ref属性的子组件对象</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'啊哈'</span>,<span class="built_in">this</span>.$refs);</span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        })</span></span><br><span class="line"><span class="javascript">        vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>给父组件下的元素添加一个ref属性，就是给个名字<br>点击button调用方法，通过this.$refs访问到父组件下的具有ref属性的子组件对象</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span> <span class="attr">ref</span>=<span class="string">"牛蛙牛蛙"</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span> <span class="attr">ref</span>=<span class="string">"牛蛙牛蛙2"</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getChildComponent"</span>&gt;</span>别来点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果：<br><img src="https://img-blog.csdnimg.cn/188f686bf7b74679b53bfc397823efcc.png" alt="在这里插入图片描述"><br>由于是对象，所以也可以通过这样的语句去进一步地访问:</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.牛蛙牛蛙);</span><br></pre></td></tr></tbody></table></figure><p><strong>至于$parent和$root，前者是访问最近的父级，后者是访问最远的父级，用法同上，不再赘述</strong></p><h2 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>一个组件在一个项目中可能会被反复用。但是问题是，我们可能会根据使用该组件的环境来对其进行一个调整，可是组件无法更改，我们也不想重新再写一个组件。就这样，插槽出现了。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    let box = {</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        template: `</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color: #faa;width: 250px;height: 250px;float:left"</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>好消息好消息!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>机会有限<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">           <span class="tag">&lt;<span class="name">p</span>&gt;</span>先到先得<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        `</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    }</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    let vm = Vue.createApp({</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        data(){</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            return{}</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        },</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        methods: {},</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        components: {</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            'box': box</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        }</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    });</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">vm.mount('#app');</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/db1d0d337f6d49cf9c93ee6c89d7b9fd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果我们要对其进行修改，那么就在组件标签中填入相应的内容，这些内容会依次匹配slot</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 50px;background-color: #fff;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hhhhh<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span></span><br><span class="line">        牛逼</span><br><span class="line">    <span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 32px;color: #fff;"</span>&gt;</span>6666<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>插入之后就是这样了<br><img src="https://img-blog.csdnimg.cn/a4ad142f6c824cffac7ef386b9044256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果需要默认内容的话，只要在slot标签里面写好就行了</p><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>也就是具有名字的插槽的意思。前面提到的都是匿名插槽，内容会自动匹配模板中的slot标签，这也意味着可能出现匹配错误的情况。为了准确的引导匹配，我们可以在slot标签中加上一个name属性，然后在插入的标签上加上v-slot。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box = {</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div style="background-color: #faa;width: 250px;height: 250px;float:left"&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;好消息好消息!&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name="dalao"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;机会有限&lt;/p&gt;</span></span><br><span class="line"><span class="string">       &lt;p&gt;先到先得&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意v-slot只能运用在template标签或者components中</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:dalao</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">box</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 32px;color: #fff;"</span>&gt;</span>6666<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意v-slot的值不加引号。另外，和v-on一样，v-slot可以简写为#</strong></p><h3 id="渲染作用域"><a href="#渲染作用域" class="headerlink" title="渲染作用域"></a>渲染作用域</h3><p>什么是渲染作用域？看看下面的代码就知道了：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">     <span class="keyword">let</span> box = {</span></span><br><span class="line"><span class="javascript">         <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">             <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                 <span class="attr">flag</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">             }</span></span><br><span class="line"><span class="javascript">         },</span></span><br><span class="line"><span class="javascript">         <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">             &lt;div style="background-color:green;width:200px;height:200px"&gt;&lt;/div&gt; </span></span></span><br><span class="line"><span class="string"><span class="javascript">         `</span></span></span><br><span class="line"><span class="javascript">     }</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">     <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">         <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">             <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                 <span class="attr">flag</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">             }</span></span><br><span class="line"><span class="javascript">         },</span></span><br><span class="line"><span class="javascript">         <span class="attr">components</span>: {</span></span><br><span class="line"><span class="javascript">             <span class="string">'box'</span>: box</span></span><br><span class="line"><span class="javascript">         }</span></span><br><span class="line"><span class="javascript">     })</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">     vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>上图中，子组件和父组件都有一个值为flag，但是分别为false和true。<br>那么假如像下图这样访问flag值，究竟会不会显示呢？</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span> <span class="attr">v-show</span>=<span class="string">"flag"</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>竟然是会显示的，解释是，在<strong>模板外访问flag值时</strong>，优先使用父级组件的值。<br><img src="https://img-blog.csdnimg.cn/3da22cd8a89c4322914f1b0e16c04c72.png" alt="在这里插入图片描述"><br>那么，什么又是在<strong>模板内访问flag值</strong>呢？</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box = {</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">            <span class="attr">flag</span>: <span class="literal">false</span></span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">//template里面使用就是模板内使用</span></span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div v-show="flag" style="background-color:green;width:200px;height:200px"&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就会<strong>只访问组件自身的值</strong><br>（如果自身没有，并不会向上访问父组件，反而会给出警告）<br><img src="https://img-blog.csdnimg.cn/557475ff8e804b5c8ae8c6f39670288e.png" alt="在这里插入图片描述"><br>总结起来就是，在模板外使用访问父组件的值，内部访问子组件自身的值</p><p><strong>那问题来了，如果要在模板外使用，却依旧需要子组件的值呢？</strong></p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽就是为了解决上述问题而诞生的<br>实际上就是一个v-bind与slot结合使用的产物，如果想通了v-bind的作用的话可以不用刻意去学作用域插槽</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> box = {</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                <span class="attr">datas</span>: [<span class="string">'123'</span>,<span class="string">'456'</span>,<span class="string">'789'</span>]</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="comment">//slot标签通过v-bind绑定data属性,并把datas赋值给data</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//后面通过v-slot:dalao1=""来接收</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div style="background-color:green;width:300px;height:300px"&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;h1&gt;广告位招商啦~&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                </span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;slot name="dalao1" :data="datas"&gt;&lt;/slot&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                </span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;h1&gt;买得早的都抱富(婆)了&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;/div&gt; </span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="string">'box'</span>: box,</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这里dataReceiver类似于一个参数，可以自由命名，其data属性(<strong>就是在模板里面绑定那个data</strong>)保存了传递的值<br>(#dalao1是v-slot:的简写)</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> #<span class="attr">dalao1</span>=<span class="string">"dataReceiver"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 32px;color: #fff;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"i in dataReceiver.data"</span>&gt;</span>{{i}}<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果如下<br><img src="https://img-blog.csdnimg.cn/787ebbfdeac24e498aa60f86af3e823b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>另外，如果不给slot一个name值，那么在使用v-slot时，写成v-slot:default=””就好了，这样就会自动匹配</p><h2 id="组件进阶"><a href="#组件进阶" class="headerlink" title="组件进阶"></a>组件进阶</h2><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>嘛…也没啥好说的，还是类似于一个模板</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">     <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">         <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">             <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                 <span class="attr">boxOne</span>: <span class="string">'cool-box'</span>,</span></span><br><span class="line"><span class="javascript">                 <span class="attr">boxTwo</span>: <span class="string">'handsome-box'</span></span></span><br><span class="line"><span class="javascript">             }</span></span><br><span class="line"><span class="javascript">         },</span></span><br><span class="line"><span class="javascript">         <span class="comment">//就是一个组件，名字都写明白了，然后替换掉is属性绑定的那个组件</span></span></span><br><span class="line"><span class="javascript">         <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript"> </span></span></span><br><span class="line"><span class="string"><span class="javascript">             &lt;component :is="boxOne"&gt;&lt;/component&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">         `</span></span></span><br><span class="line"><span class="javascript">     })</span></span><br><span class="line"><span class="javascript">     vm.component(<span class="string">'cool-box'</span>,{</span></span><br><span class="line"><span class="javascript">         <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">             &lt;h1&gt;很炫酷的box&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">         `</span></span></span><br><span class="line"><span class="javascript">     })</span></span><br><span class="line"><span class="javascript">     vm.component(<span class="string">'handsome-box'</span>,{</span></span><br><span class="line"><span class="javascript">         <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">             &lt;h1&gt;十分帅气的box&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">         `</span></span></span><br><span class="line"><span class="javascript">     })</span></span><br><span class="line"><span class="javascript">     vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>异步组件实际上也就是大家所想的那样<br>只是语法上要注意一下就是了</p><p>实现方式很多，只要保证结果是“在需要的时候才加载”就行了</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {}</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript">    vm.component(<span class="string">'box'</span>,Vue.defineAsyncComponent(<span class="function">()=&gt;</span>{</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>{</span></span><br><span class="line"><span class="javascript">            resolve({</span></span><br><span class="line"><span class="javascript">                <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">                    &lt;div&gt;hhhh&lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                `</span></span></span><br><span class="line"><span class="javascript">            })</span></span><br><span class="line"><span class="javascript">        })</span></span><br><span class="line"><span class="javascript">    }));</span></span><br><span class="line"><span class="javascript">    vm.mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/cd217f0e0d66440289d5d6eae62f26f4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当然还有其他实现的形式:</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.component(<span class="string">'box2'</span>,</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">''</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>这种方法简洁一些，但实际上还是一个意思</p><h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p> <strong>钩子函数</strong><br>为什么叫钩子函数？大概就是说，钩在某个组件上的函数，这个函数会在组件创建到销毁过程中的<strong>某个阶段触发</strong><br>使用方式类似于下面这样：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'beforeCreate!!!!'</span>);</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    });</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>beforeCreate顾名思义就是创建之前执行的函数。<br>其他常用的生命周期钩子函数还有：<br>| 阶段   | 名称          | 作用                                   |<br>| —— | ————- | ————————————– |<br>| 初始化 | beforeCreate  | 创建之前执行                           |<br>| 初始化 | created       | 创建之后执行                           |<br>| 初始化 | beforeMount   | 渲染（挂载）之前执行                   |<br>| 初始化 | mounted       | 渲染（挂载）之后执行                   |<br>| 更新   | beforeUpdate  | 数据更新之前执行                       |<br>| 更新   | updated       | 数据更新之后执行                       |<br>| 销毁   | beforeUnMount | app.unmount(‘#app’)（DOM销毁）之前执行 |<br>| 销毁   | unMounted     | app.unmount(‘#app’)（DOM销毁）之前执行 |</p><p>(unmount方法可以手动结束组件的生命周期，但是不建议操作组建的生命周期)</p><h3 id="侦听器watch"><a href="#侦听器watch" class="headerlink" title="侦听器watch"></a>侦听器watch</h3><p><strong>侦听数据，当其发生变化时，触发相应的操作</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="attr">price</span>: <span class="number">5</span></span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            },</span></span><br><span class="line"><span class="javascript">            <span class="attr">watch</span>:{</span></span><br><span class="line"><span class="javascript">            <span class="comment">//第一个参数是当前的值，第二个参数是之前的值</span></span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">price</span>(<span class="params">cur, pre</span>)</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"price变化了"</span>)</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"现在的值是"</span>,cur)</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"以前的值是"</span>,pre)</span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }).mount(<span class="string">"#app"</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">//注意，这里的挂载！</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//之前都是单独写一个vm.mount("#app")</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//只有这样写才能用vm.price访问</span></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/ab57a0a72504417b9d8fbbe6676eb63d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么问题来了，这个和computed有什么区别呢?<br>通俗地说，区别在于：<br><strong>watch支持异步，不缓存，并且可以接受两个参数；<br>computed不支持异步，默认缓存；</strong><br>更多的区别在于：<br>watch默认为浅度观测（对多层嵌套，只观测其最外层）….<br>computed在调用时需要在模板中渲染，且默认为深度依赖（对多层嵌套，观测所有）….<br><strong>分别什么时候用？</strong><br>计算属性就用computed；<br>异步、复杂的操作 或者 一个值得变化会引起一堆值变化的情况 就用 watch</p><h2 id="特效动画"><a href="#特效动画" class="headerlink" title="特效动画"></a>特效动画</h2><p>（略）<br>两种使用特效动画的方式，<br>一种是通过动态修改class等来添加动画，这个就是css3的内容，不在话下；<br>另一种就是Vue封装的特效动画。<br>不过这个东西个人感觉相对次要，这里先不做笔记，以后再说</p><h2 id="Vue高阶API"><a href="#Vue高阶API" class="headerlink" title="Vue高阶API"></a>Vue高阶API</h2><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>前面我们用到了v-if等指令，现在我们来自定义指令<br>比如我们来自定义一个叫做v-tianxiu的指令</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">              <span class="keyword">return</span>{}</span></span><br><span class="line"><span class="javascript">          },</span></span><br><span class="line"><span class="javascript">          <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">          },</span></span><br><span class="line"><span class="javascript">          <span class="attr">directives</span>:{</span></span><br><span class="line"><span class="javascript">              <span class="attr">tianxiu</span>: {</span></span><br><span class="line"><span class="javascript">                  <span class="comment">// 里面写生命周期钩子</span></span></span><br><span class="line"><span class="javascript">                  <span class="function"><span class="title">mounted</span>(<span class="params">el</span>)</span>{</span></span><br><span class="line"><span class="javascript">                      el.focus();</span></span><br><span class="line"><span class="javascript">                      <span class="built_in">console</span>.log(<span class="string">'执行成功了'</span>);</span></span><br><span class="line"><span class="javascript">                  }</span></span><br><span class="line"><span class="javascript">              }</span></span><br><span class="line"><span class="javascript">          }</span></span><br><span class="line"><span class="javascript">      })</span></span><br><span class="line"><span class="javascript"><span class="comment">//这样写也可以</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//也可以写个局部的然后挂载到组件上</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// vm.directive('tianxiu',{</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//     mounted(el){</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//         el.focus()</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//         console.log('执行成功')</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//     }</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// }</span></span></span><br><span class="line"><span class="javascript">      vm.mount(<span class="string">"#app"</span>)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样一来，在组件挂载后就会执行这个v-tianxiu<br>也就是 自动聚焦+输出“执行成功了”</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入一点东西"</span> <span class="attr">v-tianxiu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>自定义事件最多可以有四个参数<br><img src="https://img-blog.csdnimg.cn/746670b5723846ea80aea9977c194572.png" alt="在这里插入图片描述"></p><h3 id="传送门teleport"><a href="#传送门teleport" class="headerlink" title="传送门teleport"></a>传送门teleport</h3><p>就和c/c++的goto差不多一个意思</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">components: {</span><br><span class="line">    <span class="string">'box'</span>: {</span><br><span class="line">        <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;div class="box"&gt;这是box&lt;/div&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    },</span><br><span class="line">    <span class="string">'container'</span>: {</span><br><span class="line">        <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;teleport to=".box"&gt;</span></span><br><span class="line"><span class="string">                &lt;div class="mask"&gt;是container组件的部分&lt;/div&gt;    </span></span><br><span class="line"><span class="string">            &lt;/teleport&gt;</span></span><br><span class="line"><span class="string">            &lt;div class="container"&gt;这是container&lt;/div&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里box和container是两个不相干的标签</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span>&gt;</span><span class="tag">&lt;/<span class="name">box</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container</span>&gt;</span><span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>但是通过teleport传送，让container的部分传送到了box内<br>并且是放到box内<strong>原有的DOM元素之后</strong><br><img src="https://img-blog.csdnimg.cn/ff8bd21695c34f658f5531386ec2be41.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="组件式API"><a href="#组件式API" class="headerlink" title="组件式API"></a>组件式API</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>本来应该放到Vue高阶API中的，但是由于过于重要，所以单独提出来<br>之前我们在Vue2.x中的写法:</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{},</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {},</span></span><br><span class="line"><span class="javascript">        <span class="attr">computed</span>: {},</span></span><br><span class="line"><span class="javascript">        <span class="attr">watch</span>: {},</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: {},</span></span><br><span class="line"><span class="javascript">        <span class="attr">directives</span>: {}</span></span><br><span class="line"><span class="javascript">    })</span></span><br><span class="line"><span class="javascript">vm.mount()</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样把，不同的内容分类放到不同的选项里面就是<strong>选项式API</strong><br>但是如果后期业务量庞大起来，一个功能的相关内容会分布到各个位置，维护起来就十分麻烦。<br>所以Vue3.x推出了组件化API，把一个业务的内容放到一个地方</p><p>（以下图片来自网络）<br>这是选项式API<br><img src="https://img-blog.csdnimg.cn/8c951f4fca6d4e1ba2f080f170ec8cbf.png" alt="请添加图片描述"><br>这是组件式API<br><img src="https://img-blog.csdnimg.cn/c26eedba3dc943928a81ff6432523cb0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>接下来我们开始使用组件式API<br>其中，改动了不少生命周期函数（删了一些又增了一些）</p><h3 id="新的生命周期钩子"><a href="#新的生命周期钩子" class="headerlink" title="新的生命周期钩子"></a>新的生命周期钩子</h3><p> setup()<br>取代了beforeCreate()和created()，<br>并且不建议再使用data()等（虽然可以并存）</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                <span class="attr">msg</span>: <span class="string">'hello compositionAPI'</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">sayHi</span>: <span class="function">()=&gt;</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="built_in">this</span>,<span class="string">'hhh'</span>);</span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;h1&gt;{{msg}}&lt;/h1&gt;  </span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;button @click="sayHi"&gt;点击一下&lt;/button&gt;  </span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }).mount(<span class="string">"#app"</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/e8f67afc3f9849228c875f9a83781374.png" alt="在这里插入图片描述"><br>这里注意setup是创建之前触发，此时this指向的是window<br>更多生命周期钩子变化如下：<br>| 选项式API                                                    | 组件式API         |<br>| ———————————————————— | —————– |<br>| beforeCreate                                                 | setup             |<br>| created                                                      | setup             |<br>| beforeMount                                                  | onBeforeMount     |<br>| mounted                                                      | onMounted         |<br>| beforeUpdate                                                 | onBeforeUpdate    |<br>| updated                                                      | onUpdated         |<br>| beforeUnmount                                                | onBeforeUnmount   |<br>| unmounted                                                    | onUnmounted       |<br>| errorCaptured                                                | onErrorCaptured   |<br>| renderTracked                                                | onRenderTracked   |<br>| renderTriggered                                              | onRenderTriggered |<br>| 其中onRenderTracked是每次<strong>页面刷新后重新收集响应式依赖时</strong>， |                   |<br>| 然后onRenderTriggered是每次<strong>页面重新渲染时</strong>                |                   |</p><p>需要注意，除了setup之外，其余的都要写到setup里面，比如：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp({</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span><br><span class="line">        <span class="keyword">let</span> name = <span class="string">'张三丰'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> {onMounted} = Vue</span><br><span class="line">        onMounted(<span class="function">()=&gt;</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'挂载成功'</span>)</span><br><span class="line">        })</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">            name</span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">}).mount(<span class="string">"#app"</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>在过去选项式API里面，data()中的数据会被处理从而能达到响应式的效果,<br>但是组件式API里面就不会自动处理<br><img src="https://img-blog.csdnimg.cn/bf5c5fd4430e4a9eaf1c59de699986ab.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>要是没了方便的响应式效果，那么框架也失去了一大亮点<br>所以我们需要一个东西来实现基础数据的响应式，于是乎ref就诞生了</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span></span><br><span class="line"><span class="javascript">        <span class="comment">//解构赋值，从Vue对象里拿到ref</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> {ref} = Vue</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">            <span class="comment">//像这样处理基础数据</span></span></span><br><span class="line"><span class="javascript">                <span class="attr">msg</span>: ref(<span class="string">'hello compositionAPI'</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">sayHi</span>: <span class="function">()=&gt;</span>{</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="built_in">this</span>,<span class="string">'hhh'</span>);</span></span><br><span class="line"><span class="javascript">                }</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;h1&gt;{{msg}}&lt;/h1&gt;  </span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;button @click="sayHi"&gt;点击一下&lt;/button&gt;  </span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }).mount(<span class="string">"#app"</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/cdff4dc28fdd47d0810fcb6b0ffbed90.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>原理是通过proxy代理，<strong>包装成proxy（{value:….}）</strong>的形式<br>至于多次提到的proxy代理到底是什么，后面再细嗦</p><p>另外，需要注意，<strong>如果在代码中对msg的值进行修改，需要写成msg.value的形式</strong><br><strong>（在页面上不用这么写是因为底层会自动帮你转化为msg.value）</strong></p><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>其实作用和ref差不多，就是约定俗成地，<strong>在对 数组对象等引用类数据 进行响应式处理地时候，我们不使用ref，而使用reactive</strong><br>（其实ref也可以，处理引用类数据地时候，ref底层还是会自动使用reactive，不过这样一来效率就低多了，所以不推荐）</p><p>唯一需要注意的是，reactive没有value属性，访问值的时候需要这样写:</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> {computed, ref, reactive} = Vue</span><br><span class="line"><span class="keyword">let</span> num1 = reactive({<span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span>})</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> show = <span class="function">()=&gt;</span>{</span><br><span class="line"><span class="built_in">console</span>.log(num1)<span class="comment">//proxy代理</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num1.value)<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把num1作为了一个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(num1.one,num1.two)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/86729232441f411ab43a5d64b918910f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>用法都一样，这里就不再赘述了</p><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>顾名思义咯，只读<br>防止数据传递传着传着就变了</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> {readonly} = Vue</span><br><span class="line"><span class="keyword">const</span> myName = readonly(ref(<span class="string">'吴彦祖'</span>))</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/7d454f9f2694420a8fc4f691586b9717.png" alt="在这里插入图片描述"></p><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>在解构赋值的时候比较常用<br>比如，解构赋值一个具有响应式能力的对象时，<br>解构后的数据就成为了普通的数据而不再具有响应式能力<br><strong>如果我们希望其继续拥有响应式能力，那么就要使用到toRefs()</strong><br><img src="https://img-blog.csdnimg.cn/f9c1b3eafb08491c98a30f698d004030.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了方便阅读，往后尽量只给出关键的代码</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> {ref, toRefs, reactive} = Vue</span><br><span class="line"><span class="keyword">let</span> person = reactive({<span class="attr">name</span>:<span class="string">"古尔丹"</span>, <span class="attr">job</span>:<span class="string">"大酋长"</span>})</span><br><span class="line"><span class="comment">//解构赋值后的name和job也会拥有响应式的能力</span></span><br><span class="line"><span class="keyword">let</span> {name, job} = toRefs(person)</span><br></pre></td></tr></tbody></table></figure><p>原理还是proxy代理，把代理的对象拆开，给属性代理</p><h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><p>本质还是把里面的东西丢给代理<br>相关语法如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> {ref, toRefs, reactive,toRef} = Vue</span><br><span class="line"><span class="keyword">let</span> age = toRef(person, <span class="string">'age'</span>).value = <span class="number">233</span></span><br></pre></td></tr></tbody></table></figure><p>这里需要两个参数，第一个是对象名称，第二个是该对象的属性名称<br>toref返回一个proxy代理,也就有value值<br>和toRefs的差异大概也就和名字意义的差异一般</p><p>这里不得不说一下<strong>ref(),reactive(),toRef(),toRefs()的区别</strong><br>ref()深拷贝，获取数据时需要加上.value<br>reactive()深拷贝，不需要加.value（ref是在reactive的基础上实现的）<br>toRef()浅拷贝，获取数据时需要加上.value<br>toRefs()浅拷贝，获取数据时需要加上.value</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>context上下文<br>就是setup的参数</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span><br><span class="line"><span class="keyword">const</span> {ref, toRefs, reactive,toRef} = Vue</span><br><span class="line"><span class="keyword">let</span> {attrs, slots, emit} = context</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"这是attrs:"</span>,attrs)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"这是slots:"</span>, slots)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"这是emit:"</span>, emit)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"props:"</span>,props)</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>attrs在前面no-props提到过，也就是继承的属性，<br>slots是插槽<br>emit在前面组件通信提到过，是发射的事件<br>props是v-bind绑定传过来的参数<br><img src="https://img-blog.csdnimg.cn/713e6e13cd8544259be9e83f9580eb92.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>没错就是那个computed，现在又来了<br>不过这里需要引入一下<br>作用也没变，都是把东西放到缓存</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> {computed, ref} = Vue</span><br><span class="line"><span class="keyword">let</span> num1 = ref(<span class="number">233</span>)</span><br><span class="line"><span class="keyword">let</span> num2 = computed(<span class="function">()=&gt;</span>{</span><br><span class="line">     <span class="keyword">return</span> num1.value * <span class="number">10</span>;</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>还是侦听器，和以前一样</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = Vue.createApp({</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span><br><span class="line">        <span class="keyword">let</span> {computed, ref, reactive,watch} = Vue</span><br><span class="line">        <span class="keyword">let</span> myName= ref(<span class="string">''</span>)</span><br><span class="line">        <span class="comment">//监听myName</span></span><br><span class="line">        watch(myName,<span class="function">(<span class="params">cur, pre</span>)=&gt;</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"现在的值："</span>, cur)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"过去的值："</span>,pre)</span><br><span class="line">        })</span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">            myName</span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;input type="text" placeholder="请输入你的姓名" v-model="myName"&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;我的名字是：{{myName}}&lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">}).mount(<span class="string">"#app"</span>)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/871b2d0879614779972f96345d22dc9b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果监听多个值的话，写成如下形式即可</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watch([myName,myAge],<span class="function">(<span class="params">[curName, curAge], [preName, preAge]</span>)=&gt;</span>{</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"现在的值："</span>, curName, <span class="string">"和"</span>, curAge)</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"过去的值："</span>,preName, <span class="string">"和"</span>, preAge)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>另外，由于<strong>监听的对象不能是一个对象的属性</strong>，那么如果要监听对象的属性的话，需要这么写：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(<span class="function">()=&gt;</span>person.name,<span class="function">(<span class="params">cur,pre</span>)=&gt;</span>{</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">""</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>用一个函数返回一手，就可以变成一般的数据类型了（当然你可以解构之类的）</p><p>watch还有第三个参数，再说这个之前先了解<strong>watch的性质</strong>：</p><p>1.默认<strong>惰性</strong>（浏览器打开不会自动触发，要等到相关组件开始活动才触发，比如输入框要输入后才触发）</p><p>2.可调度（可以选择是否有惰性以及是否深度监视）<br>（tip：<strong>浅度监视</strong>是只监视如一个对象Obj1，发生如同Obj1 = Obj2这种操作Obj1本身发生的变化，会<strong>忽视对象内部的变化</strong>；相反地，<strong>深度监视</strong>就是会<strong>监视对象的所有变化</strong>）</p><p>具体语法：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch(<span class="function">()=&gt;</span>person.name, <span class="function">(<span class="params">cur, pre</span>)=&gt;</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"现在的值："</span>, cur)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"过去的值："</span>, pre)</span><br><span class="line">},{</span><br><span class="line">    <span class="comment">//是否立即执行（是否取消惰性）</span></span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//是否深度监视</span></span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">false</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>还是侦听器，不过默认深度监视，没有惰性，并且不能查询变化以前的值</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="function">()=&gt;</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'watchEffect开始监听:'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'myName:'</span>, myName.value)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'myAge'</span>, myAge.value)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/a1d8d165dfee4e678bbe7b4525286e03.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="provide与inject"><a href="#provide与inject" class="headerlink" title="provide与inject"></a>provide与inject</h3><p>由于<strong>Vue是单向数据流</strong>，孙组件要用父组件内的数据的话，得先经过子组件，也就是：<br>父组件—&gt;子组件—–&gt;孙组件<br>如果嵌套层级过多，那么数据传递效率就会相当慢<br>或者，两个毫不相干的组件之间传递数据的…</p><p>除了组件通信中提到的方法，这里还可以使用provide和inject</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> grandson = {</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div style="background-color:red;"&gt;我是孙组件&lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> son = {</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="string">'grandson'</span>: grandson </span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div style="background-color:orange"&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                我是子组件</span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;grandson&gt;&lt;/grandson&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;/div&gt;      </span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> father = Vue.createApp({</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">                <span class="attr">fatherMsg</span>: <span class="string">'我是father'</span></span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="string">'son'</span>: son</span></span><br><span class="line"><span class="javascript">        },</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;div style="background-color:yellow"&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">                我是父组件</span></span></span><br><span class="line"><span class="string"><span class="javascript">                &lt;son&gt;&lt;/son&gt;    </span></span></span><br><span class="line"><span class="string"><span class="javascript">            &lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">        `</span></span></span><br><span class="line"><span class="javascript">    }).mount(<span class="string">"#app"</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/d263b927a6a148ab89ce2593de647e1d.png" alt="在这里插入图片描述"></p><p>如果需要跨越性传递数据：</p><p>使用provide向所有内部组件提供数据</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span><br><span class="line">    <span class="keyword">const</span> {ref, provide} = Vue</span><br><span class="line">    <span class="comment">//注意这里是value</span></span><br><span class="line">    <span class="keyword">let</span> fatherMsg = ref(<span class="string">'我是father'</span>).value</span><br><span class="line">    provide(<span class="string">'fatherMsg'</span>, fatherMsg)</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        fatherMsg</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>使用inject接收数据</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span><br><span class="line">    <span class="keyword">const</span> {inject} = Vue</span><br><span class="line">    <span class="keyword">let</span> grapaMsg = inject(<span class="string">'fatherMsg'</span>, <span class="string">'第二个参数:默认值'</span>)</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        grapaMsg</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/0bbf25548a8f4c4696796036e2adfe0d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4497a2b2d63c47209083a0d85aca566b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="ref获取真实DOM"><a href="#ref获取真实DOM" class="headerlink" title="ref获取真实DOM"></a>ref获取真实DOM</h3><p>注意这个ref不是之前的ref，而是写在标签里面作为属性的ref</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">"mark"</span>&gt;</span>我被ref标记了！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp({</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span>{</span><br><span class="line">        <span class="keyword">const</span> {ref, onMounted} = Vue</span><br><span class="line">       <span class="comment">//这样一来，mark在app被挂载之后就会获得真实DOM</span></span><br><span class="line">       <span class="comment">//下面这个ref纯属是为了让mark获得响应式</span></span><br><span class="line">        <span class="keyword">let</span> mark = ref(<span class="string">''</span>)</span><br><span class="line">        onMounted(<span class="function">()=&gt;</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(mark.value)</span><br><span class="line">        })             </span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">            mark</span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">}).mount(<span class="string">"#app"</span>)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/0cddca315821403a8da792d9223b9aeb.png" alt="在这里插入图片描述"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>到这里Vue篇大概也算完结了，不过我也会继续修改补充完善内容。<br>考虑到使用频率，部分没有提及的Vue知识点会在后续的<strong>Vue-Cli篇</strong>中补充。<br>感谢各位的阅读。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础</title>
      <link href="/2022/01/07/javabasic/"/>
      <url>/2022/01/07/javabasic/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>本来以前是学过Java的（指2021年1月左右）…但是..但是主要是使用前端的知识，久了没碰Java就快忘完了…<br>这也不是第一次把本就没学多少的Java知识忘得一干二净了，<br>这边正好赶上学校要开Java课程了，所以这次痛定思痛决定写个学习笔记，希望能帮助自己的同时也能帮助到大家。<br>本来想用IDEA的（毕竟方便又好看）,但是为了适应学校的安排，还是用上了eclipse..</p><p>因为是前端的，这篇笔记主要是为了速通，所以很多知识点不会说太细<br><del>学什么前端，爷要全栈！</del> </p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2022/01/07</strong></p><p>这篇博文是我在2021/08/23日在CSDN上发布的</p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/119833436?spm=1001.2014.3001.5501"><font color="aa6633">点击这里跳转</font></a></p><p>现在做了一些小的调整后，将其搬至当前位置</p></blockquote><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><h3 id="选择Java版本"><a href="#选择Java版本" class="headerlink" title="选择Java版本"></a>选择Java版本</h3><p>先要熟悉版本<br>三大版本：<br>JavaSE： 标准版<br>JavaME：嵌入式开发<br>JavaEE：企业级开发</p><p>我们这里使用JavaSE</p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>java development kit <strong>java开发工具包</strong>，安装完成之后配置环境变量即可<br><strong>JDK包括了JRE（java运行环境），而JRE又包括了JVM（java虚拟机，java虚拟机的存在使得程序能够忽略系统的差异）</strong><br>（具体操作自行查阅，不再赘述)</p><h3 id="安装编译器"><a href="#安装编译器" class="headerlink" title="安装编译器"></a>安装编译器</h3><p>Eclipse，intelligent IDEA等都可以（记事本也行）</p><h2 id="正式操作"><a href="#正式操作" class="headerlink" title="正式操作"></a>正式操作</h2><h3 id="新建内容"><a href="#新建内容" class="headerlink" title="新建内容"></a>新建内容</h3><p>第一步：先新建一个项目<br><img src="https://img-blog.csdnimg.cn/805e84fdaec7499d901c4a20eead4135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>随便给个名字，这里叫EclipseNewbee（意思是Eclipse新手，不是牛逼..）<br><img src="https://img-blog.csdnimg.cn/7b8e608381794bdc97904a4986f63584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>弹出一个窗口，内容不用修改。<br>不用细究，直接Create<br><img src="https://img-blog.csdnimg.cn/a894c845065e4f03b8fb2a75535210d4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第二步：新建一个包（可省略）<br>然后右键src新建一个Package，<br><strong>Package相当于一个文件夹</strong>，不用想太多<br><strong>（如果不建包的话也可以直接建一个Class然后写代码）</strong><br><img src="https://img-blog.csdnimg.cn/95cc831353ce4a14ae125479a7c27e5d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>随便给一个名字，这里叫JavaLearner好了<br><img src="https://img-blog.csdnimg.cn/cb3df5148e5d426689e808c4eadc6927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第三步：新建一个类<br><img src="https://img-blog.csdnimg.cn/f940bc1a982a4385ad31780ec2352bc3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里要做的依旧是给个名字，其余的不用管<br><img src="https://img-blog.csdnimg.cn/d0bc3551f33945c98d8d3e927f6e24ee.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Finish后得到一个这样的</p><p><img src="https://img-blog.csdnimg.cn/708537c8dde2415dadf819c840df3331.png" alt="在这里插入图片描述"><br>右边的两个对应左边的两个，不相同的话会报错，所以不要去修改</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>这里默认为有 C语言 和 面向对象 语言的基础<br>（初学的话压力可能有点大)</p><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaLearner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"><span class="comment">//别问，问就是 “这么写就对了”</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>后面默认给出代码和图片两种格式，分别方便 复制粘贴 和 阅读 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaLearner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="comment">//两种写法都可以</span></span><br><span class="line"><span class="comment">//Scanner scanner = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//String s = scanner.next();</span></span><br><span class="line">String s = <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">System.out.printf(<span class="string">"Hello "</span> + s);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>导入Scanner对象，然后实例化，<strong>next()是获取下一次输入的字符串</strong>并返回给 s<br>然后在输出的时候进行一个字符串拼接<br><img src="https://img-blog.csdnimg.cn/c7d2b1b14fe4439786e2c293b25da751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>运行效果：<br><img src="https://img-blog.csdnimg.cn/18b0a9ce97fe476b90720f75d8e9e6b5.png" alt="在这里插入图片描述"></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>其实还是if和switch那些<br>基本上所有语言都差不多，大概看看就行</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="keyword">new</span> Scanner(System.in).nextInt();</span><br><span class="line"><span class="comment">//分支</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">1000</span>) {</span><br><span class="line">System.out.printf(<span class="string">"这是%d\n"</span>,a);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &gt; <span class="number">800</span>){</span><br><span class="line">System.out.println(<span class="string">"没错，这是我了"</span> + a + <span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">System.out.print(<span class="string">"hhh\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>依旧是差不多，所有语言基本一个样</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i ++) {</span><br><span class="line">System.out.printf(<span class="string">"%d "</span>,arr1[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>增强for循环</strong><br>也就是迭代器，遍历数组或许看不出来什么区别，但是遍历其他数据结构或者对象就很好用了<br><strong>注意i取的是内容，不是下标</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : arr1 ) {</span><br><span class="line">System.out.printf(<span class="string">"增强for循环(迭代器):%d "</span>, i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = {<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>};</span><br><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="keyword">int</span>[] arr2 = arr1;</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">6666</span>;</span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length];</span><br><span class="line">System.arraycopy(arr1, <span class="number">0</span>, arr3, <span class="number">0</span>, arr1.length);</span><br><span class="line">arr3[<span class="number">2</span>] = <span class="number">2333</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>深拷贝就是复制一个和原来一模一样的；<br>浅拷贝就是直接指向原来那个；</strong></p><p>上述代码在遍历之后的结果是：<br><img src="https://img-blog.csdnimg.cn/2a7fdb4954fa43709f20fa81d94d6866.png" alt="在这里插入图片描述"><br>注意，我们只修改过arr2和arr3，但是修改arr2的时候arr1也发生了同步变化，这是因为arr1和arr2本来就是一个东西的两个名字罢了</p><p>但是修改arr3却不会对另外两个有影响，因为它是完全独立的复制品</p><p><strong>增强for循环遍历二维数组</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int[][] arr4 = new int[3][];</span></span><br><span class="line"><span class="comment">//上述写法也可以，注意至少要明确行数</span></span><br><span class="line"><span class="keyword">int</span>[][] arr4 = {</span><br><span class="line">{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>},</span><br><span class="line">{<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>},</span><br><span class="line">{<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] i : arr4 ) {</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j : i) {</span><br><span class="line">System.out.printf(<span class="string">"%d "</span>, j);</span><br><span class="line">}</span><br><span class="line">System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>其实可以近似地理解为函数<br>和函数的区别大概是：<br><strong>函数是相对独立的，方法是附在对象上的</strong><br>所以c只有函数，java只有方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> n + fib(n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个写在class里面，main外面（如果有main的话）</p><h2 id="面向对象进行开发"><a href="#面向对象进行开发" class="headerlink" title="面向对象进行开发"></a>面向对象进行开发</h2><p>什么是面向对象？<br>首先就得说一下什么是面向过程。<br>C语言就是面向过程的，它的每一步操作都要自己做，包括内存的分配释放等等；<br>Java等就是面向对象的，它的许多操作是已经被封装好了，我们使用的时候直接调用就好了；</p><p><strong>比喻一下就是：<br>面向过程（POP）：自己买菜一步一步做菜<br>面向对象（OOP）：直接点个外卖</strong></p><h3 id="初识类与对象"><a href="#初识类与对象" class="headerlink" title="初识类与对象"></a>初识类与对象</h3><p>class本意就是类<br>这里新建一个类，内容如图<br><img src="https://img-blog.csdnimg.cn/421e33720c0c48988e58655960690592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaLearner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{</span><br><span class="line">String type;</span><br><span class="line">String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">System.out.printf(<span class="string">"吃东西"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>接下来到之前的文件内<br><img src="https://img-blog.csdnimg.cn/965bd943eaf74b8da669b12696a18579.png" alt="在这里插入图片描述"><br>在main中运行以下代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal lion = <span class="keyword">new</span> Animal();</span><br><span class="line">Animal tigger = <span class="keyword">new</span> Animal();</span><br><span class="line">lion.eat();</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/57c25c14a9794ae88512684a20b55eb1.png" alt="在这里插入图片描述"><br><strong>其中，Animal就是一个类，lion和tigger是对象</strong><br>世界上的任何东西都可以作为一个类，<br>对象就是具体化的类（准确地说叫<strong>实例化</strong>）</p><p><strong>比如我们常说的人类就是一个类，<br>我们可以将其不同程度地实体化为年轻人、工程师、张三李四</strong></p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>在刚才，你会发现，type和name这两个值没有赋值，这时候他们的值默认null<br>如果我们再去主函数里面赋值，那感觉好low逼啊<br>所以这里出现了构造器</p><hr><p>也叫构造方法（C++里面叫构造函数）<br>满足以下两个特点：<br><strong>1.名称与所在类的名称相同<br>2.不写任何返回类型，包括void<br>3.在new实例化对象的时候触发</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaLearner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{</span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String type, String name)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">System.out.println(name + <span class="string">"被初始化了！"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">String type;</span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">System.out.printf(<span class="string">"吃东西"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>这里涉及到了this指针，this指针就是字面意思，指代当前所处的类或对象；<br>this.name指的是类或对象的属性；<br>name这里指的是参数；</strong><br>’<br><img src="https://img-blog.csdnimg.cn/d07f0fd3a9104ae59541982c39998b2f.png" alt="在这里插入图片描述"><br>main里面运行结果<br><img src="https://img-blog.csdnimg.cn/b90ab87c07ee44ed9308bbb499d1dba5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>另外，如果是一个没有写入构造方法的类，那么默认自动生成一个空的构造方法</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>问题来了，加了构造器之后可是要传递参数的，那假如用户不穿怎么办？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaLearner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{</span><br><span class="line"><span class="comment">//第一种情况，两个参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String type, String name)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">System.out.println(name + <span class="string">"被初始化了！"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//第二种情况，一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String type)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"莫得名字"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//第三种情况，没有参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"莫得名字"</span>;</span><br><span class="line"><span class="keyword">this</span>.type = <span class="string">"某种动物"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">String type;</span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">System.out.printf(<span class="string">"吃东西"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>这样一来就能根据用户传入的参数来自动选择执行哪个构造方法<br>（注意，重载方法是根据参数的个数和类型来区分的，不是参数名称！）</strong></p><p>重载不仅可以用于构造方法，只要是方法，那么都可以重载。</p><p>接下来说面向对象三大特征</p><hr><h3 id="面向对象三大特征：-封装"><a href="#面向对象三大特征：-封装" class="headerlink" title="面向对象三大特征： 封装"></a>面向对象三大特征： 封装</h3><p>就是把对象包裹起来，并且控制对象内容的访问权限<br>大概就是为了所谓的高内聚低耦合<br><strong>高内聚：类的内部数据操作细节不由外部干涉<br>低耦合：仅暴露少量的方法给外部使用</strong></p><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p><img src="https://img-blog.csdnimg.cn/9512a8c669aa4af88ffc4b1994ae1b9f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>内容访问权限的控制是通过修饰符来完成的<br>类的属性通常用private修饰，这样可以避免误操作修改，避免了不可预测得混乱</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过getName()和setName()操作，保证了 <strong>访问的时候不会被误操作修改</strong> 和 <strong>修改的内容一定是字符串</strong><br>并且你还可以通过if判断等方式进一步地规避误操作</p><p>这样一来安全性高多了</p><h3 id="面向对象三大特征：-继承"><a href="#面向对象三大特征：-继承" class="headerlink" title="面向对象三大特征： 继承"></a>面向对象三大特征： 继承</h3><p>继承就是将已有的类进行<strong>修改和拓展</strong>形成的新的类<br>（其实就是字面意思</p><p>先新建一个Pet类，使用extends关键字继承Animal类<br><img src="https://img-blog.csdnimg.cn/2aee83e94bf74c15a4e1e0b6e54aa91c.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaLearner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String toy)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.toy = toy;</span><br><span class="line">System.out.printf(<span class="string">"他喜欢玩"</span> + <span class="keyword">this</span>.toy);</span><br><span class="line">}</span><br><span class="line">String toy;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>main里实例化一下，<br><strong>调用自身构造函数之外，还会调用父类的无参构造</strong><br><img src="https://img-blog.csdnimg.cn/1554b715876b4f50b927eb809b92bc91.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果父级的属性是public修饰的，那么子级就会直接继承并且可以直接访问；如果不能直接访问，那么可以用封装里面提到过的方法来给子级传递数据；</p><p>这里我们用protected修饰，给父类Animal添加一个属性:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String size;</span><br></pre></td></tr></tbody></table></figure><p>然后在子类Pet里面用<strong>super关键字</strong>向上访问父类：<br>（父级，也可以叫超级，超类，就是因为其关键字是super，<br>super会向上查找，直到查找到符合条件的父类）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaLearner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String toy, String size)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.toy = toy;</span><br><span class="line"><span class="comment">//访问到父级的size属性</span></span><br><span class="line"><span class="comment">//由于继承的存在，这个属性在实例化后将变成自己的</span></span><br><span class="line"><span class="keyword">super</span>.size = size;</span><br><span class="line">System.out.println(<span class="string">"他喜欢玩"</span> + <span class="keyword">this</span>.toy);</span><br><span class="line">}</span><br><span class="line">String toy;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>回到main函数里面：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pet cat = <span class="keyword">new</span> Pet(<span class="string">"锤子"</span>,<span class="string">"big"</span>);</span><br><span class="line">Pet dog = <span class="keyword">new</span> Pet(<span class="string">"球"</span>,<span class="string">"huge"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"这是继承的父类的属性: "</span> + dog.size);</span><br><span class="line">System.out.println(<span class="string">"这是继承的父类的属性: "</span> + cat.size);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/0627e0f2f16843339e3b26959fe2b24e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以发现，这里我们先实例化cat对象，后实例化dog对象，<br>但是先输出dog对象，后输出cat对象<br>我们发现，虽然是一个父类的两个子类，但是<strong>继承一般数据类型（非引用类型）属性是通过深拷贝实现的</strong>，他们的属性没有发生覆盖，不会相互干扰</p><p>另外，super和this，可以通过形如super()或this()的操作调用构造函数，但是注意两点：<br><strong>1.super只能出现在子类的方法中<br>2.super()或this()需要放在构造函数的第一行（由于这个性质，他们两个不能同时存在）</strong></p><p><strong>继承的其他注意事项</strong><br>注意java只有单继承，意思是一个子类只能有一个直接父级，<br>可以<strong>多重（单）继承（子类–父类–爷爷类（间接父级）–）</strong><br><strong>不是多继承（多个直接父级）<br>不是多继承！！！<br>不是多继承！！！</strong></p><p><strong>所有类的最终父级是Object类，这种终极父类被称为“基类”（基岩基石那个意思，别多想啊）</strong></p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写全称是方法重写，为了更好地和重载区分，我们先分析一下两者地字面意思<br>重载：多重挂载<br>重写：重新写一遍<br>比如在父类Animal中有一个方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>{</span><br><span class="line">System.out.printf(<span class="string">"捕猎"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>子类中也有一个同名的方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>{</span><br><span class="line">System.out.printf(<span class="string">"吃饭喝水睡觉"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这就构成了重写，<br>不过这还不够规范，为了提醒代码的阅读者，我们还会在重写的方法上加上@Override</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>{</span><br><span class="line">System.out.printf(<span class="string">"吃饭喝水睡觉"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实也就是一个从自身出发向上寻找指定内容的过程，优先使用最先找到的指定内容（也就是JavaScript中的作用域链）<br><img src="https://img-blog.csdnimg.cn/0c804ad13e384374af1939db0a20c17e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当然，如果不希望一个方法被重写，可以给它加上<strong>final</strong>关键字进行修饰，有了final修饰的类，不能被继承</p><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>什么是抽象？就是没有具体内容<br>比如一个抽象类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">xxx</span></span>{</span><br><span class="line"><span class="comment">//.....(当然也可以什么都不写)</span></span><br><span class="line"><span class="comment">//要写的话可以写抽象方法等</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不能直接实例化一个抽象的对象，因为其没有具体内容！<br>它存在的目的就是为了适应不同情况，举个例子，<br>生物这个类里面有个方法是输出生物的日常活动，<br>但是生物很多，要执行这个方法的话，固定的代码可能不能很好地适应每一种情况<br>所以就需要被重写——既然会被重写，那一开始我们就没必要给它具体内容，只需要在这里放一个名称提醒我们还有这个方法就好了。<br>注意事项：</p><p><strong>1.抽象类不能创建对象（不能new）,并且有抽象方法的类一定要是抽象类。<br>2.抽象类只能通过儿子继承然后覆盖重写所有的抽象类方法进行使用。抽象类可以有构造方法，是供子类创建对象时，初始化父类成员使用的。<br>3.抽象类中不一定有抽象方法，但有抽象方法一定是抽象类。<br>4.抽象类的子类除非也是抽象类，否则就要重写所有父类方法。<br>(如果子类也是抽象类，那么可以选择不重写或重写一部分)<br>5….中的抽象方法，没有方法体！！！</strong><br> <strong>父类的引用指向子类</strong><br>新建两个类，分别是A，B</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaLearner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">System.out.println(<span class="string">"这是B"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaLearner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">System.out.println(<span class="string">"这是A"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>主函数内：</p><p><img src="https://img-blog.csdnimg.cn/b20a8940987a4fee9dfefd939383416c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>至于为什么执行A的方法，是因为，优先在自身寻找，自身没有才找父类。<br>这里自身有test()方法，所以调用A的test方法</p><p><strong>其实上面的内容就是多态</strong></p><h3 id="面向对象三大特征：-多态"><a href="#面向对象三大特征：-多态" class="headerlink" title="面向对象三大特征： 多态"></a>面向对象三大特征： 多态</h3><p>一个对象的多种形态，比如Kitty是cat类也是animal类。<br>或者说，一个人的父亲，必定也是一个人的儿子。<br>这就是多态的字面意思。</p><p><strong>概括为父类引用指向子类对象。</strong><br>比如原来是Zi zi = new Zi(),<br><strong>多态的写法就是 Fu zi = new Zi();</strong><br>（即“左父右子”。同时，这种操作叫做<strong>向上转型</strong>，这种操作一定是安全的）<br>说明：<br>1.直接通过对象名称访问成员变量，优先访问<strong>等号左边</strong>，没有就向上找<br>（<strong>编译看左边，运行也看左边</strong>）<br>2.间接通过成员方法访问（调用方法的话），优先访问<strong>等号右边</strong>（new的对象），没有就向上找。<br>（<strong>编译看左边，运行看右边</strong>）</p><p>第二种说明：<br>（如果前一种不是那么好理解的话）<br>记住编译看等号左边就行，别管右边new的是什么，左边怎么声明的就是声明。</p><p><strong>解释：<br>编译看左，运行看右。<br>假设Fu中有方法A,B子类有方法A,C，<br>现在我们Fu zi = new Zi();那么：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fu zi = <span class="keyword">new</span> Zi();</span><br><span class="line">zi.A();<span class="comment">//父子都有，优先用子</span></span><br><span class="line">zi.B();<span class="comment">//子没有，向上找到父</span></span><br><span class="line"></span><br><span class="line">zi.C();</span><br><span class="line"><span class="comment">//编译报错，编译看左(Fu)，Fu是没有C的</span></span><br></pre></td></tr></tbody></table></figure><p>为什么使用多态<br>比如</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CAT cat = <span class="keyword">new</span> CAT();</span><br><span class="line">DOG dog = <span class="keyword">new</span> DOG();</span><br><span class="line">DUCK duck = <span class="keyword">new</span> DUCK();</span><br></pre></td></tr></tbody></table></figure><p>…….<br>这样一来东西一多，就很难知道他们的继承关系了</p><p>所以我们可以：<br>ANIMAL cat = new CAT();<br>…….<br>继承关系一目了然！</p><h4 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h4><p>还是用比喻来说吧..<br><strong>向上转型：</strong><br>比如猫转为动物，即左父右子的多态（FU zi = new Zi），一定是安全的<br><strong>向下转型：</strong><br>比如动物转为猫，类似强制类型转换，如（Fu zi = (Zi)fu）<br>这样是有风险的，可能导致未知错误发生。所以动物向下转为猫的前提是原先是从猫向上转来的，这个例子可以推广到一般情况。</p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>instanceof关键字：<br>由于存在多态这种操作，有时候我们难免会忘记ANIMAL到底是DOG，CAT还是PIG什么的…所以我们就有了instanceof！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断 一个对象 是不是 一个类的 子类 的实例</span></span><br><span class="line"><span class="comment">//A是B的子类，a是A的实例</span></span><br><span class="line">B a = <span class="keyword">new</span> A();</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">System.out.println(a <span class="keyword">instanceof</span> B);</span><br></pre></td></tr></tbody></table></figure><p>由于返回值是布尔类型，还可以利用这个关键字做很多事情！（不在话下）</p><h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>从public static void main开始就在用了<br>static修饰的变量和普通变量区别在于，<del>进厂时机不同</del><br>好吧，是分配内存空间的时机和位置不同<br><strong>有static修饰的内容，在写下之后就分配进了方法区，而且还是多线程的<br>没有static的内容，要等到类加载之后才会存在（这个学到代理和反射再说）</strong></p><p>所以对于static修饰的内容，可以直接这么访问而不需要实例化：<br>类中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">233</span>;<span class="comment">//静态变量</span></span><br></pre></td></tr></tbody></table></figure><p>主函数中：</p><p><img src="https://img-blog.csdnimg.cn/599540b0db0b425995dab02c69fb8061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的内容再口语一点就是，static约束的内容会“直接出生”，早于其他非static的内容</p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在类里写一个：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> {</span><br><span class="line">System.out.println(<span class="string">"这是Animal的一个静态代码块"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>主函数里：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal pig = <span class="keyword">new</span> Animal();</span><br><span class="line">Animal frog = <span class="keyword">new</span> Animal();</span><br><span class="line">Animal seal = <span class="keyword">new</span> Animal();</span><br></pre></td></tr></tbody></table></figure><p>运行结果是:<br><img src="https://img-blog.csdnimg.cn/1d13e39418a24619a83df9d3422ed7ff.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可见，执行了一次静态代码块的函数，三次构造函数<br>这说明，静态的优先执行，并且一个类的静态内容只会执行一次</p><p>那么这和静态方法有什么关系呢？<br>静态方法写法上的区别就是多个名字之类的嘛…..</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hhh</span><span class="params">()</span></span>{</span><br><span class="line">System.out.println(<span class="string">"这是Animal的一个静态代码块"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当然，静态方法需要自己调用才会执行。</p><h4 id="静态导入包"><a href="#静态导入包" class="headerlink" title="静态导入包"></a>静态导入包</h4><p>导入包在输入输出就提过了<br>不过静态地导入包是什么鬼？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规导包</span></span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="comment">//静态导包（只能导入包内的一个方法）</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.random;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般的操作</span></span><br><span class="line">System.out.println(Math.random());</span><br><span class="line"><span class="comment">//静态导包后直接用</span></span><br><span class="line">System.out.println(random());</span><br></pre></td></tr></tbody></table></figure><p>大概就是这样，当做语法糖看看就好</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h4><p>接口是为了使约束和实现相分离：“面向接口进行编程”<br>接口是建立在抽象上的，说白了就是一个<strong>抽象的集合</strong>（意思是里面不能有具体的方法）。<br>另外，<strong>接口是可以多继承的，弥补了类的不足</strong></p><p>接口创建是建立一个interface<br><img src="https://img-blog.csdnimg.cn/b7335b4d65af4632b72c1f4894065c85.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaLearner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMethods</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//不写约束的话，默认为public abstract</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String name, String newName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(String name)</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>接口是抽象的集合，那么我们就需要一个类来实现这些抽象</p><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>新建一个类来重写接口中的抽象方法，这个类就叫做<strong>接口的实现类</strong>，其命名规范是 <strong>人类看得懂的名字 + Impl</strong></p><p>这里要使用<strong>关键字implements</strong>进行实现</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaLearner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMethodsImpl</span> <span class="keyword">implements</span> <span class="title">UserMethods</span></span>{</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String name)</span></span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String name)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String name, String newName)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(String name)</span></span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于接口可以多继承（准确地说是“多实现”，但是这样说很奇怪不是吗）<br>所以允许存在以下写法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Impl</span> <span class="keyword">implements</span> <span class="title">In1</span>，<span class="title">In2</span>,<span class="title">In3</span></span>{</span><br><span class="line"><span class="comment">//当然还是需要重写，不然会报错</span></span><br><span class="line"><span class="comment">//三个接口的内容直接在这里重写就行</span></span><br><span class="line"><span class="comment">//不过这里我就不写了，大家懂这个意思就行</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>啥是异常就不多解释了吧，就是用户或者程序员或者系统造成的各种未知的bug</p><p>Java把异常当成对象进行处理，<br>并且定义了一个基类<strong>java.lang.Throwable</strong>作为所有异常的终极父类，其下有两个直接子类，分别是Error和Exception</p><p>Error是JVM抛出的，大多数时候和代码语法关系不大（比如内存溢出，这只能怪内存太小了？），但是导致的错误往往是致命的，JVM往往会因此终止线程；</p><p>Exception则一般是有程序本身的逻辑引起的，可以被程序处理；</p><h4 id="抛出和捕获异常"><a href="#抛出和捕获异常" class="headerlink" title="抛出和捕获异常"></a>抛出和捕获异常</h4><p>try是指要检测的部分<br>catch参数要写错误的类型对象（这个得去查一下有哪些，实在不行Throwable吧）<br>如果触发了这个类型的错误，那么就会执行其中的代码<br>finally是检测完毕时执行（无论如何都会执行，可以不写这一部分）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">System.out.println(a/b);</span><br><span class="line">}<span class="keyword">catch</span>(ArithmeticException e) {</span><br><span class="line">System.out.println(e);</span><br><span class="line">System.out.println(<span class="string">"太强了这就是抛出和捕获异常吗"</span>);</span><br><span class="line">}<span class="keyword">finally</span> {</span><br><span class="line">System.out.println(<span class="string">"检测完毕"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>比如，0作为除数<br><img src="https://img-blog.csdnimg.cn/a0183bb4620940999d619f472825cd54.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注意事项：</strong><br>如果要捕获多种异常的话，可以用使用多个if else那种格式来书写多个catch达到目的<br>catch中的参数是一个对象，其中内置了很多处理错误的方法可以了解一下</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>JavaSE基础部分大概到这里就结束了，如果内容上还有不足或疏漏之处，欢迎指正。<br>后面我会继续做JavaWeb相关的学习笔记（Vue-Cli的就先缓一缓吧….东西太多了学不过来…）</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.JS后端开发</title>
      <link href="/2021/12/30/node.js-be/"/>
      <url>/2021/12/30/node.js-be/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><blockquote><p>2021-12-30，23:23，很冷，有点困，但是据刚回到寝室的一位室友所说，寝室竟然只有他一人——太卷了，太卷了，我真的好爱他们啊！</p><p><font color="#ff3700">哦对了，本篇博文还有一篇前置博文哦（Node.JS基础），零基础的朋友可以先通过简单阅读那篇文章快速上手哦</font></p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2021/12/30</strong><br>开始写吧，希望接下来的学习能够顺利！<br><strong>2021/12/31</strong><br>说好一起通宵写代码，结果好家伙拉着我打金铲铲之战打到凌晨五点就为了进一次前四..<br><strong>2022/1/1</strong><br>争取今天能够写完吧<br><strong>2022/1/2</strong><br>本来还想写实际开发过程中遇到的一些问题，不过3号的下午六点作业提交就要截止了，接口那些都还没开始动，可能就没时间写这部分了，以后有机会再补上</p></blockquote><h3 id="浅谈Node-JS"><a href="#浅谈Node-JS" class="headerlink" title="浅谈Node.JS"></a>浅谈Node.JS</h3><p>众所周知，计算机执行代码之前，会先把高级语言/汇编语言编译成机器代码，<br>但是JS啊，能被我们浏览器的引擎（说的就是你，ChromeV8）编译，但是却不能直接被计算机编译，</p><blockquote><p>这个脚本，就是逊啦！</p></blockquote><p>但是现在好啦，Node出现了，它是一个V8的容器，只需要装上Node，我们就能利用这个V8引擎脱离浏览器运行我们的脚本语言——哦不，此时已经飞升成面向对象语言的JS！</p><blockquote><p>Node究竟是何方神圣能够把JS带出浏览器的小圈子呢？<br>因为它底层是C++写的，本身就能在浏览器外跑…</p></blockquote><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>要学计网了，这块也得学着走了</p><blockquote><p>什么？你问我为什么这学期计网都结课了还说这话？<br>我能咋整嘛，太菜了跟不上，还不是只能自己下来补呜呜呜~</p></blockquote><h3 id="HTTP请求的过程"><a href="#HTTP请求的过程" class="headerlink" title="HTTP请求的过程"></a>HTTP请求的过程</h3><p>也没啥好说的，这小节不重要（但是还是写下来了，问就是强迫症）</p><p>主要分为三步：</p><p><strong>1.发送请求</strong></p><blockquote><p>DNS解析，建立TCP连接，发起HTTP请求<br>（TCP啊，以后学计网再写一篇细说这些）</p></blockquote><p><strong>2.处理请求</strong></p><blockquote><p>服务端接收HTTP请求，进行处理</p></blockquote><p><strong>3.响应数据</strong></p><blockquote><p>服务端发送数据给客户端，客户端接收数据</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token comment">// 创建服务器对象，处理 请求 和 响应</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">// 响应</span>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello Server'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">// 监听2333端口，成功监听则执行回调函数</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">2333</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器已在2333端口开启！'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/0ffc8f3a6dd94fb7b93296c5e3ac5924.png" alt="开启成功"></p><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><p>其实上一节中的代码就处理了一个GET请求<br><img src="https://img-blog.csdnimg.cn/2d9afcd5708748e1ab21958608ec8cc9.png" alt="GET来的html文件"><br>我们现在来试着处理一下GET请求<br>先看一下URL，大概长这样</p><blockquote><p><a href="http://localhost:2333/?name=syy&amp;&amp;password=123456/">http://localhost:2333/?name=syy&amp;&amp;password=123456/</a></p></blockquote><p>我们可以如下书写代码，来基本地处理请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> qs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'querystring'</span><span class="token punctuation">)</span><span class="token comment">// 服务端，处理 请求 和 响应</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">// 处理GET</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是method'</span><span class="token punctuation">,</span> req<span class="token punctuation">.</span>method<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是url'</span><span class="token punctuation">,</span> req<span class="token punctuation">.</span>url<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是首个参数'</span><span class="token punctuation">,</span> qs<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'/?'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello Server'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">2333</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器已在2333端口开启！'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>哦，需要注意，这里的<strong>querystrig包已经被弃用</strong>了，但是问题不大，<br>我们只需要ctrl + 鼠标左键点击方法名称，就可以观察其源码</p><p>可以看到这里有个注解<br><img src="https://img-blog.csdnimg.cn/b3cf4d88fb63444eaa845e835d36ed22.png" alt="querystring方法的源码"><br>这里我们只需要<strong>删掉这一行就可以继续用</strong>了<br>（当然，也可以自己在通过cv大法把这段代码封装，避免以后真的被删除了没方法可以用了）</p><p>进行URL带参数的GET请求，可以在终端看到如下结果</p><p><img src="https://img-blog.csdnimg.cn/075c19f0bf3049b29a6b542912ee8620.png" alt="两个GET请求"><br>至于第二个GET请求，也就是这个favicon.ico，它是网页标题前的一个小图标，比如下面这样</p><p><img src="https://img-blog.csdnimg.cn/daab103539ca43adabe7425f9446babd.png" alt="favicon.ico"></p><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>再说POST请求之间，先写一个index.html作为前端页面，然后手写一个简单的AJAX请求</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token constant">AJAX</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>发送POST请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token constant">AJAX</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>发送GET请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">function</span> <span class="token constant">AJAX</span><span class="token punctuation">(</span><span class="token parameter">model</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        xhr<span class="token punctuation">.</span>withCredentials<span class="token operator">=</span><span class="token boolean">true</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>xhr<span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'XMLHttpRequest对象创建失败'</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>model <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span><span class="token string">'http://localhost:2333/index.html'</span><span class="token punctuation">)</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>model <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>            xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'http://localhost:2333/index.html'</span><span class="token punctuation">)</span>            xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是响应的数据'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'没有正确地响应！'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>            <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原生Node解决跨域</strong><br>之后，我们还需要注意，这里由于端口号不同，所以会有跨域问题出现</p><blockquote><p>这里就要给广大的前端学习者们说明一下，跨域就该由后端来解决，所以很多时候，当后端甩锅给前端让前端配置反向代理什么之类的都是后端懒！</p></blockquote><p>后端大概写成这样</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token comment">// 服务端，处理 请求 和 响应</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span> <span class="token string">'http://localhost:5500'</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Methods"</span><span class="token punctuation">,</span> <span class="token string">"PUT,POST,DELETE"</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Headers"</span><span class="token punctuation">,</span> <span class="token string">"Content-Type,token"</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Credentials'</span><span class="token punctuation">,</span> <span class="token string">'true'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'application/json;charset=utf-8;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringfy</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        msg<span class="token operator">:</span><span class="token string">'成功辣兄弟们！！！'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">2333</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器已在2333端口开启！'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们采用的是CORS解决跨域<br><img src="https://img-blog.csdnimg.cn/eaa1b22dd0554c84ab38a65f65948c6f.png" alt="请求成功"><br><img src="https://img-blog.csdnimg.cn/69cd371bc8f2453db5b9d0815e4372e2.png" alt="请求头"></p><p>对了，还要很多简单的小框架可以使用，这样用起来更方便<br>安装express模块：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install express --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>别和我说你看到这里的时候还不会用npm</p></blockquote><h3 id="混合请求方式实战"><a href="#混合请求方式实战" class="headerlink" title="混合请求方式实战"></a>混合请求方式实战</h3><p>之前简单了解了两种请求，现在来写一写：<br>首先我们先小小地调整一下AJAX</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token constant">AJAX</span><span class="token punctuation">(</span><span class="token parameter">model</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    xhr<span class="token punctuation">.</span>withCredentials<span class="token operator">=</span><span class="token boolean">true</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>xhr<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'XMLHttpRequest对象创建失败'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>model <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span><span class="token string">'http://localhost:2333/index.html?user=碳苯&amp;age=19'</span><span class="token punctuation">)</span>        xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{</span>time<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>model <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'http://localhost:2333/index.html'</span><span class="token punctuation">)</span>        xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>                    xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是响应的数据'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'没有正确地响应！'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务端也相应地来一点小小的改动</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span> <span class="token string">'http://localhost:5500'</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Methods"</span><span class="token punctuation">,</span> <span class="token string">"PUT,POST,DELETE"</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Headers"</span><span class="token punctuation">,</span> <span class="token string">"Content-Type,token"</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Credentials'</span><span class="token punctuation">,</span> <span class="token string">'true'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'application/json;charset=utf-8;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> method <span class="token operator">=</span> req<span class="token punctuation">.</span>method    <span class="token keyword">const</span> url <span class="token operator">=</span> req<span class="token punctuation">.</span>url    <span class="token keyword">const</span> path <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">const</span> query <span class="token operator">=</span> qs<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> resData <span class="token operator">=</span> <span class="token punctuation">{</span>        method<span class="token punctuation">,</span>        url<span class="token punctuation">,</span>        path<span class="token punctuation">,</span>        query    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">'GET'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            msg<span class="token operator">:</span><span class="token string">'GET成功辣兄弟们！！！'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">'POST'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> postData <span class="token operator">=</span> <span class="token string">''</span>        req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token parameter">chunk</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>            postData <span class="token operator">+=</span> chunk<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>            resData<span class="token punctuation">.</span>postData <span class="token operator">=</span> postData            res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>                <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>resData<span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过阅读以上代码，我们可以看到，我们通过数据流的形式来处理POST请求<br><img src="https://img-blog.csdnimg.cn/a8c4101f8f52467db0ae6fcbf7e4b6ec.png" alt="响应的数据"></p><blockquote><p>虽然有一点中文乱码，不过问题不大，应该设置一下请求头就好了<br>另外postData没有展开，这个问题不大，实在不行利用深拷贝重新写一个对象传回去</p></blockquote><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>在学会请求之后，咱们也得准备正式开发了<br>为了熟悉每一个文件和相关配置的具体作用，我们就不新建项目了直接在这几个文件的基础上进行改动吧</p><blockquote><p>其实就是懒</p></blockquote><h3 id="基本文件"><a href="#基本文件" class="headerlink" title="基本文件"></a>基本文件</h3><blockquote><p>这里大概是遵循了什么三层架构什么的，但是由于我没有过相关知识的学习经历，所以对这一块的内容还是感到生疏，做的笔记也只能说是照猫画虎有样学样，还不能系统地总结。</p></blockquote><p><strong>1.创建<a href="http://www.js/">www.js</a></strong><br>我们建一个文件叫做<a href="http://www.js,先写个板子/">www.js，先写个板子</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'WWW.JS'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server running at port 6666'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了方便维护，我们把createServer里面的回调提出来单独写一个文件叫做app.js<br><strong>2.创建app.js</strong><br>先写个基础的板子</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">serverHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span> <span class="token string">'http://127.0.0.1:5500'</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Methods"</span><span class="token punctuation">,</span> <span class="token string">"PUT,POST,DELETE"</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Headers"</span><span class="token punctuation">,</span> <span class="token string">"Content-Type,token"</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Credentials'</span><span class="token punctuation">,</span> <span class="token string">'true'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'application/json;charset=utf-8;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> resData <span class="token operator">=</span> <span class="token punctuation">{</span>        name<span class="token operator">:</span> <span class="token string">'SYY'</span><span class="token punctuation">,</span>        nickName<span class="token operator">:</span> <span class="token string">'碳苯Carbon'</span><span class="token punctuation">,</span>        id<span class="token operator">:</span> <span class="token number">1024</span>    <span class="token punctuation">}</span>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>        <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>resData<span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">}</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> serverHandler<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>记得exports导出之后，还要回到<a href="http://www.js里面require引入一下/">www.js里面require引入一下</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./app.js'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3.设置入口文件</strong><br>在package.json中修改一下这一行<br><strong>修改成<a href="http://www.js/">www.js</a></strong><br><img src="https://img-blog.csdnimg.cn/bcf40e36a52141cdb6720766d4424e58.png" alt="package.json文件"></p><h3 id="开发依赖"><a href="#开发依赖" class="headerlink" title="开发依赖"></a>开发依赖</h3><p>开发依赖和依赖的区别就是顾名思义<br>开发依赖在普通用户使用的时候实际上是不需要的，但是在开发的过程中可能会有比较重要的作用，比如辅助调试之类的</p><p>这里要安装的nodemon就是一个做<strong>热重载</strong>的开发依赖nodemon</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 注意这里要一定写大写Dnpm i nodemon -D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后我们到package.json中康康<br><img src="https://img-blog.csdnimg.cn/91e959961a7d4d3d9331a5bcdd6eda29.png" alt="package.json"><br>之后我们顺便在package.json添加一个命令dev<br><img src="https://img-blog.csdnimg.cn/a3be08cd81ab4ebca53bc0ff4a5f64ad.png" alt="添加一个命令"></p><p>之后我们就可以用npm run dev来执行nodemon ./<a href="http://www.js了,/">www.js了，</a><br>这样就可以有一个具有热重载的后端了</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm run dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/7f4356b1e3e44b3e839700e7145bf515.png" alt="nodemon启动"></p><p>淦，这里我的6666端口被占用了，网页打不开，所以只好换了个端口4567<br>（记得把所有该端口响应地修改一下）</p><blockquote><p>修改的时候就体现出全局变量的好处了啊</p></blockquote><p><img src="https://img-blog.csdnimg.cn/f103be5587974cd7a5f96e1b50f8d081.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/9c06ede65e5242fb9de6a9f7a5a96e0c.png" alt="在这里插入图片描述"><br>利用刚才的index.html（记得修改AJAX中的URL）<br><img src="https://img-blog.csdnimg.cn/6a12f5324eb74532af628f43848dd571.png" alt="AJAX请求成功"></p><p>就很棒</p><h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><p>由于是原生，所以定义接口的方式很原始，真的很原始啊</p><p><strong>1.创建一个文件夹放各个路由</strong></p><p><img src="https://img-blog.csdnimg.cn/cde2c93417b44b77b6bedc14b98d816f.png" alt="路由测试"><br><strong>2.创建一个路由</strong><br>先来随便写一个试试手</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">handelTestRoute</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> method <span class="token operator">=</span> req<span class="token punctuation">.</span>method    <span class="token keyword">const</span> url <span class="token operator">=</span> req<span class="token punctuation">.</span>url    <span class="token keyword">const</span> path <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>method <span class="token operator">==</span> <span class="token string">'GET'</span> <span class="token operator">&amp;&amp;</span> path <span class="token operator">==</span> <span class="token string">'/test_route'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            msg<span class="token operator">:</span> <span class="token string">'这是测试用的接口'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            msg<span class="token operator">:</span> <span class="token string">'阿巴阿巴'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们有返回值，所以还需要在某个地方接收这个返回值，而这个地方正是我们的app.js<br><img src="https://img-blog.csdnimg.cn/53184e3db87349a4a6db819716f8adaa.png" alt="红框中是新增的内容"><br>输入URL测试一下<br><img src="https://img-blog.csdnimg.cn/acfa5a515f244e929739afe716a11e5f.png" alt="非常巧妙啊"><br><strong>3.加大难度</strong><br>首先改一下app.js</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">}</span><span class="token keyword">const</span> testRouteData <span class="token operator">=</span> <span class="token function">handleTestRoute</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>testRouteData<span class="token punctuation">)</span> <span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>        <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>testRouteData<span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">'Content-Type'</span><span class="token operator">:</span><span class="token string">'text/plain'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'404 Not Found!!!!'</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是路由本身再改改</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">handleTestRoute</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> method <span class="token operator">=</span> req<span class="token punctuation">.</span>method    <span class="token keyword">const</span> url <span class="token operator">=</span> req<span class="token punctuation">.</span>url    <span class="token keyword">const</span> path <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>method <span class="token operator">==</span> <span class="token string">'GET'</span> <span class="token operator">&amp;&amp;</span> path <span class="token operator">==</span> <span class="token string">'/test_route'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            msg<span class="token operator">:</span> <span class="token string">'这是测试用的接口'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> handleTestRoute<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有ajax的url<br>（略）</p><p>好了测试一下<br><img src="https://img-blog.csdnimg.cn/75544a78b1f940f3bac2db00aa1ebbd7.png" alt="成功"><br><img src="https://img-blog.csdnimg.cn/bfe25ab374174f91b9f27cc98702896d.png" alt="失败"></p><blockquote><p>404——这就对了！</p></blockquote><h3 id="规范化类"><a href="#规范化类" class="headerlink" title="规范化类"></a>规范化类</h3><blockquote><p>终于，自从ES6有了class之后，现在才是第一次用</p></blockquote><p><strong>1.新建文件夹和文件</strong><br><img src="https://img-blog.csdnimg.cn/378ed98755604b94b08db342dc71764c.png" alt="新建model文件夹，放resModel"><br>新建这个文件主要是为了统一各种数据的格式，以达到一种规范化的效果</p><p><strong>2.书写如下代码</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//  基类</span><span class="token keyword">class</span> <span class="token class-name">BaseModel</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 理想的参数类型是对象，但是如果传进来的是字符串也需要处理一下</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> data <span class="token operator">==</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> data            <span class="token comment">// null，接下来就可以视为对象</span>            data <span class="token operator">=</span> <span class="token keyword">null</span>            <span class="token comment">// 同上</span>            msg <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 成功模型</span><span class="token keyword">class</span> <span class="token class-name">SuccessModel</span> <span class="token keyword">extends</span> <span class="token class-name">BaseModel</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>err <span class="token operator">=</span> <span class="token number">0</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 失败模型</span><span class="token keyword">class</span> <span class="token class-name">ErrorModel</span> <span class="token keyword">extends</span> <span class="token class-name">BaseModel</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>err <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    SuccessModel<span class="token punctuation">,</span>    ErrorModel<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，其中基类的代码，<br>因为理想的参数是对象，但是如果强行传进一个字符串作为参数，那么就需要特殊处理一下方便后续流程的进行</p><blockquote><p>这里所谓的后续流程，看似只有后面两个if，感觉改为else就足够了，但考虑到后续的维护，我们还是有必要做这种处理<br>这种处理在开发中很常见</p></blockquote><p>把字符串信息保存进this.msg，然后把msg和data置为null，这样就能够看做一个为空的对象了</p><p><strong>相关方法</strong></p><p><strong>1.创建Controller文件夹和文件</strong><br><img src="https://img-blog.csdnimg.cn/b7a1df3586f6466d80048239bfda20ea.png" alt="在这里插入图片描述"><br>因为书写过程中会使用到一些自定义的方法，为了方便维护我们把它们放到一起</p><p>即这里创建的controllers文件夹</p><p><strong>2.书写如下代码</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">getData</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>            name<span class="token operator">:</span> <span class="token string">'香甜的甲基橙'</span><span class="token punctuation">,</span>            appearance<span class="token operator">:</span> <span class="token string">'(owo)'</span><span class="token punctuation">,</span>            motto<span class="token operator">:</span> <span class="token string">'爱自己，更要爱别人'</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>               id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>            name<span class="token operator">:</span> <span class="token string">'碳苯'</span><span class="token punctuation">,</span>            appearance<span class="token operator">:</span> <span class="token string">'(nvn)'</span><span class="token punctuation">,</span>            motto<span class="token operator">:</span> <span class="token string">'胸怀明月，目蕴骄阳'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    getData<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>由于改动太大了，比如上面改个端口都要到各个文件里面相应地改一下，或者说写完方法之后在某个文件中添加调用的语句…这样的一些改动我就不演示了，不然篇幅实在是太过于冗余，还望海涵</p></blockquote><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><blockquote><p>本来是想用MySQL,结果期末作业要求SQLServer我人麻了，试着连SQLServer整了一晚上还是没有成功</p><p>所以我放弃了，还是用MySQL</p><p>（MySQL对应的包是mysql，SQLserver对应的包是mssql）</p></blockquote><p>还是先新建文件啦<br><img src="https://img-blog.csdnimg.cn/205b70e95ae845db8aab9fd8f0f333ae.png" alt="在这里插入图片描述"></p><p>这里用的是mysql，代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// const { connect } = require('mssql')</span><span class="token comment">// 垃圾mssql给爷爬，还得是我mysql啊</span><span class="token keyword">const</span> mysql <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mysql'</span><span class="token punctuation">)</span><span class="token comment">// 连接</span><span class="token keyword">const</span> connection <span class="token operator">=</span> mysql<span class="token punctuation">.</span><span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    host<span class="token operator">:</span> <span class="token string">'localhost'</span><span class="token punctuation">,</span>    user<span class="token operator">:</span> <span class="token string">'root'</span><span class="token punctuation">,</span>    password<span class="token operator">:</span> <span class="token string">'root'</span><span class="token punctuation">,</span>    port<span class="token operator">:</span> <span class="token number">3306</span><span class="token punctuation">,</span>    database<span class="token operator">:</span> <span class="token string">'syyselectcourse'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>connection<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 执行sql</span><span class="token keyword">const</span> sql <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">select * from syystudent</span><span class="token template-punctuation string">`</span></span>connection<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>sql<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">// 关闭连接</span>connection<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果<br><img src="https://img-blog.csdnimg.cn/e6c5ac1484944c25aa017cb42eda2389.png" alt="数据库连上啦！！！"><br>这里为了演示，就把执行sql和关闭连接写到一个文件里面了，后面记得要拆出来单独写</p><p>这里先改成这样：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// const { connect } = require('mssql')</span><span class="token keyword">const</span> mysql <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mysql'</span><span class="token punctuation">)</span><span class="token comment">// 连接</span><span class="token keyword">const</span> connection <span class="token operator">=</span> mysql<span class="token punctuation">.</span><span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    host<span class="token operator">:</span> <span class="token string">'localhost'</span><span class="token punctuation">,</span>    user<span class="token operator">:</span> <span class="token string">'root'</span><span class="token punctuation">,</span>    password<span class="token operator">:</span> <span class="token string">'root'</span><span class="token punctuation">,</span>    port<span class="token operator">:</span> <span class="token number">3306</span><span class="token punctuation">,</span>    database<span class="token operator">:</span> <span class="token string">'syyselectcourse'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>connection<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 执行sql</span><span class="token comment">// const sql = `select * from syystudent`</span><span class="token comment">// connection.query(sql, (err, result) =&gt; {</span><span class="token comment">//     if(err) {</span><span class="token comment">//         console.log(err)</span><span class="token comment">//         return</span><span class="token comment">//     }</span><span class="token comment">//     console.log('result', result)</span><span class="token comment">// })</span><span class="token comment">// function executeSQL(sql, callback) {</span><span class="token comment">//     connection(query, callback)</span><span class="token comment">// }</span><span class="token comment">// 还可以进一步优化，用promise来做这个</span><span class="token keyword">function</span> <span class="token function">executeSQL</span><span class="token punctuation">(</span><span class="token parameter">sql</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        connection<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>sql<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token punctuation">}</span>            <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> promise<span class="token punctuation">}</span><span class="token comment">// 关闭连接</span><span class="token comment">// connection.end()</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    executeSQL<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后如果要执行SQL语句，我们放到路由这里做<br>比如这样</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>path <span class="token operator">===</span> <span class="token string">'/student'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> sql <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">SELECT * FROM syystudent</span><span class="token template-punctuation string">`</span></span>    <span class="token function">executeSQL</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'~~~~~SQL执行成功~~~~~'</span><span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发一下ajax请求，果然如我所料，稳得一批<br>那么</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>大概，就这样了？</p><blockquote><p>当然不是，时间是有限的，但是知识可是无限的！<br>Node.JS的学习只是告一段落了，但是我并不会停下学习的脚步，在完成作业项目的开发之后，我会把相关内容上传到我的Gitee仓库，并且把更多更详细的内容放到我的个人博客。<br><font color="aa3322">我的仓库</font><br><a href="https://gitee.com/Serio">Serio的Gitee仓库希望能得到更多星星哦！</a><br><font color="aa3322">我的博客</font><br><a href="https://serio.gitee.io/">Serio的个人博客！访问获得更多学习资料！</a></p></blockquote><p>之后，咱先去复习计网了，再过几天又是要考试考试考试了哈哈哈~~<br>2022新的一年，大家继续加油啊！</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transact-SQL</title>
      <link href="/2021/12/25/tsql/"/>
      <url>/2021/12/25/tsql/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>由于考试在即，本文只写一些与MySQL不太一样的内容，（也可能是一样的但是某佑根本不会的内容）</p><p>并且只是很粗略地过一遍，很多细致的地方还得进一步研究！</p></blockquote><blockquote><p>其他未提到的语法可参考本站的<strong>MySQL学习笔记</strong>。</p></blockquote><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>接下来涉及到的操作中，数据库名尽可能采用SelectCourse，DB等</p><h3 id="数据库创建"><a href="#数据库创建" class="headerlink" title="数据库创建"></a>数据库创建</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> SelectCourse <span class="token comment">-- 创建数据库</span><span class="token keyword">ON</span> <span class="token keyword">PRIMARY</span> <span class="token punctuation">(</span>NAME <span class="token operator">=</span> <span class="token string">'data'</span><span class="token punctuation">,</span>               <span class="token comment">-- 主数据文件的逻辑名</span>FILENAME <span class="token operator">=</span> <span class="token string">'E：\data'</span><span class="token punctuation">,</span>    <span class="token comment">-- 主数据文件的物理名</span>SIZE <span class="token operator">=</span> <span class="token number">10</span>MB<span class="token punctuation">,</span>                  <span class="token comment">-- 初始大小</span>FILEGROWTH <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">%</span>             <span class="token comment">-- 增长率</span><span class="token punctuation">)</span>LOG <span class="token keyword">ON</span> <span class="token punctuation">(</span>NAME <span class="token operator">=</span> <span class="token string">'log'</span><span class="token punctuation">,</span>             <span class="token comment">-- 日志文件逻辑名</span>    FILENAME <span class="token operator">=</span> <span class="token string">'E:\log'</span><span class="token punctuation">,</span> <span class="token comment">-- 日志文件物理名</span>    SZIE <span class="token operator">=</span> <span class="token number">1</span>MB<span class="token punctuation">,</span>                    MAXSIZE <span class="token operator">=</span> <span class="token number">20</span>MB<span class="token punctuation">,</span>    FILEGROWTH <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">%</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BACKUP</span> <span class="token keyword">DATABASE</span> SelectCourse<span class="token keyword">TO</span> <span class="token string">'E:\bk_SelectCourse'</span> <span class="token keyword">WITH</span> DIFFERENTIAL<span class="token punctuation">,</span> <span class="token keyword">INT</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中<strong>DIFFERENTIAL</strong>关键字是可以去掉的，其意义是保留设备上已有的内容，去掉的话则是覆盖</p><p>好吧，其实整个WITH都是可以省略的，INT参数意义不详（暂时也没找到参考资料）</p><h3 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h3><p>既然有备份，那自然有恢复啊</p><p>（诶，这个备份模式好像在哪里学过来着，究竟是哪里啊）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">RESTORE</span> <span class="token keyword">DATABASE</span> SelectCourse<span class="token keyword">FROM</span> <span class="token string">'E:\bk_SelectCourse'</span><span class="token keyword">WITH</span> <span class="token keyword">FILE</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">REPLACE</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>只知道REPLACE大概是强制替换，FILE参数意义不详</p><p>同样，WITH整个都可以省略</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>当发现有变量这种东西的时候，我还是小为震惊了一下——这可太不得了了！</p><p>有了变量之后，意味着很多逻辑处理能够在数据库内部完成了！</p><p>这种其妙发现带来的兴奋毫不次于发现CSS中可以使用变量时的惊喜！</p><p>这种设定对于我来说还算比较新颖，所以这一章稍微详细一点，咱先来看看T-SQL的发展背景。</p><blockquote><p>Transact-SQL，即事务SQL，简称为T-SQL，是微软大爹开发的，是<strong>SQL的超集</strong>。</p></blockquote><p>好了，我们已经详细地了解了T-SQL的背景（MS的黑科技，知道牛逼就行了）</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>这里的变量也有<strong>局部和全局</strong>之分。</p><p>一开始我还挺迷惑的，SQL语句不是选中之后再执行的吗，那这个局部和全局是按我选中的区域来动态划分作用域的吗？</p><p>试了一下结果并不是我想的这样。</p><blockquote><p>由<strong>用户自定义的变量</strong>，可以存储数值，字符串等类型，作用范围仅在某个程序内部。</p><p>语法如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@name</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">-- 声明局部变量name，类型是变长数组，长度上限是10</span><span class="token keyword">set</span> <span class="token variable">@name</span> <span class="token operator">=</span> <span class="token string">'沈某人'</span>       <span class="token comment">-- 赋值</span><span class="token keyword">print</span> <span class="token variable">@name</span>  <span class="token comment">-- 打印</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也就是局部变量名称前面需要带有@字符</p></blockquote><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><blockquote><p>由系统提供的，用于存储一些系统信息，不能由用户定义。</p><p>全局变量的作用域并不局限于某个程序，而是任何程序随时可以调用。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">@<span class="token variable">@ERROR</span>  <span class="token comment">-- 最后一个T-SQL错误的错误号</span>@<span class="token variable">@IDENTITY</span> <span class="token comment">-- 最后一次插入的标记值</span>@<span class="token variable">@LANGUAGE</span> <span class="token comment">-- 当前使用语言的名称</span>@<span class="token variable">@MAX_CONNECTIONS</span> <span class="token comment">-- 可以创建同时连接的最大数目</span>@<span class="token variable">@ROWCOUNT</span> <span class="token comment">-- 受上一个SQL语言影响的行数</span>@<span class="token variable">@SERVERNAME</span> <span class="token comment">-- 本地服务器的名称</span>@<span class="token variable">@TRANSCOUT</span> <span class="token comment">-- 当前连接打开的事务数目</span>@<span class="token variable">@VERSION</span> <span class="token comment">-- SQL SERVER的版本信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没错，全局变量的标志是前置两个@字符</p></blockquote><p>tip:局部变量名称支持中文</p><h2 id="选择分支"><a href="#选择分支" class="headerlink" title="选择分支"></a>选择分支</h2><p>几乎所有语言的分支都长一个样</p><p>但是这里竟然不太一样！！！</p><h3 id="IF语句"><a href="#IF语句" class="headerlink" title="IF语句"></a>IF语句</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span> @院系 <span class="token operator">=</span> <span class="token string">'计科院'</span><span class="token keyword">BEGIN</span><span class="token keyword">PRINT</span> <span class="token string">'壮哉我计科院！'</span><span class="token keyword">END</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中BEGIN和END就是起到类似于{}花括号划定作用域的效果</p><p>当然，在其中只有一条语句时，依旧存在语法糖</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span> @院系 <span class="token operator">=</span> <span class="token string">'计科院'</span><span class="token keyword">PRINT</span> <span class="token string">'壮哉我计科院'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同样地，也有ELSE和ELSE IF语句，此处不再赘述</p><p>（应该有ELSE IF吧？没试过，不过我想应该是有的。有空试一试）</p><h3 id="CASE语句"><a href="#CASE语句" class="headerlink" title="CASE语句"></a>CASE语句</h3><p>什么，竟然不是switch，爷青结！</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Sname<span class="token punctuation">,</span> location <span class="token operator">=</span><span class="token keyword">CASE</span> Sdept <span class="token keyword">WHEN</span> <span class="token string">'计科院'</span> <span class="token keyword">THEN</span> <span class="token string">'明理楼'</span>，<span class="token keyword">WHEN</span> <span class="token string">'机电院'</span> <span class="token keyword">THEN</span> <span class="token string">'明志楼'</span><span class="token punctuation">,</span><span class="token keyword">WHEN</span> <span class="token string">'化工院'</span> <span class="token keyword">THEN</span> <span class="token string">'明德楼'</span><span class="token punctuation">,</span><span class="token keyword">WHEN</span> <span class="token string">'石工院'</span> <span class="token keyword">THEN</span> <span class="token string">'明德楼'</span><span class="token punctuation">,</span><span class="token keyword">ELSE</span> <span class="token string">'思学楼'</span><span class="token keyword">END</span><span class="token keyword">FROM</span> Student<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>所有语言的循环都差不多</p><p>啊，什么？没有FOR循环？爷二度青结！</p><h3 id="WHILE语句"><a href="#WHILE语句" class="headerlink" title="WHILE语句"></a>WHILE语句</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">WHILE</span> <span class="token punctuation">(</span>SELCT <span class="token function">AVG</span><span class="token punctuation">(</span>Ccredit<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Course <span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token comment">-- 注意这个括号不是WHILE语句的，只是为了改变SELECT语句和小于比较的运算优先级</span><span class="token keyword">BEGIN</span><span class="token keyword">UPDATE</span> Course <span class="token keyword">SET</span> Ccredit <span class="token operator">=</span> Credit <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">-- 没有 ++ 这样的一目运算符</span>    <span class="token keyword">IF</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>Ccredit<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Course<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token comment">-- 同样地， 这个括号也只是为了改变运算优先级</span>    <span class="token keyword">BREAK</span>   <span class="token comment">-- 是经典的BREAK语句</span>    <span class="token keyword">ELSE</span>    <span class="token keyword">CONTINUE</span> <span class="token comment">-- 应该不写也一样 </span><span class="token keyword">END</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述WHILE中SELECT语句的执行过程并不是一步到位的，而是一个元组一个元组地查询，每次查询都会用AVG函数计算平均值，一旦这个平均值不再满足&lt;5这个条件，WHILE循环结束</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>一开始我还以为是什么理论性的东西（望文生义</p><p>结果这东西还挺实在的哈</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>存储过程（Strored Procedure）是<strong>一组</strong>为了完成特定功能的<strong>SQL语句集合</strong></p><p>用户通过制定存储过程的名字，并且给出参数（如果需要参数的话）即可执行它。</p></blockquote><p>看完上述概念想到什么啊？</p><p>这不就和C语言中的函数这一概念类似吗？</p><p>那么我们暂时吧存储过程看做函数吧（当然也注意区别，因为T-SQL中也有函数这一概念，这个我们后面再提）</p><p>那为什么要有这样一个设定呢？当然是为了懒啊！</p><h3 id="存储过程的简单操作"><a href="#存储过程的简单操作" class="headerlink" title="存储过程的简单操作"></a>存储过程的简单操作</h3><p><strong>创建存储过程</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> proc_name<span class="token keyword">AS</span><span class="token keyword">BEGIN</span> <span class="token comment">-- 里面写SELECT语句等各种T-SQL语句，此处不再赘述</span><span class="token keyword">END</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用存储过程</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXECUTE</span> proc_name <span class="token comment">-- 熟悉的语句，有了Minecraft的感觉了</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>修改存储过程</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">PROCEDURE</span> proc_name<span class="token keyword">AS</span><span class="token keyword">BEGIN</span> <span class="token comment">-- 新的内容</span><span class="token keyword">END</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除存储过程</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> proc_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>我还以为触发器是单独的一章，结果和我说是<strong>一种特殊的存储过程</strong></p><p>也叫 <strong>自执行存储过程</strong>，在满足特定条件的时候执行，而不用EXECUTE执行</p><p>简单使用过程如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> tri_name<span class="token keyword">ON</span> Student <span class="token comment">-- 这是针对的表</span><span class="token keyword">AFTER</span> <span class="token keyword">UPDATE</span> <span class="token comment">-- 这是触发事件，可以有多个触发事件.此处为在更新之后.</span><span class="token keyword">AS</span>  <span class="token keyword">BEGIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student<span class="token keyword">END</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<strong>AFTER可以替换为FOR或者INSTEAD OF</strong>，作用也就是顾名思义</p><p>另外<strong>UPDATE也可以替换为INSERT或者DELETE</strong>，作用依旧是顾名思义</p><h2 id="登录、用户、角色管理"><a href="#登录、用户、角色管理" class="headerlink" title="登录、用户、角色管理"></a>登录、用户、角色管理</h2><p><strong>登录名、用户、角色的区分</strong>：</p><ol><li>登录名：数据库访问者需要登录到数据库服务器中，因此需要有一个登录号来通过安全控制的SQL Server验证的过程。</li><li>用户：是指对某个数据库具有访问和操作权限的访问者，这个用户身份需要被授予给登录名。</li><li>角色：特指具有一系列权限的身份，这个角色身份可以赋予给用户，此时这个用户就具有了该角色所有的权限。</li></ol><p><strong>登录名管理</strong>：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> LOGIN login_name <span class="token keyword">WITH</span> PASSWORD <span class="token operator">=</span> <span class="token string">'...'</span><span class="token keyword">DROP</span> LOGIN login_name<span class="token punctuation">`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>用户管理</strong>：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> user_name <span class="token keyword">FOR</span> LOGIN login_name<span class="token punctuation">`</span><span class="token keyword">DROP</span> <span class="token keyword">USER</span> user_name<span class="token punctuation">`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>角色管理</strong>：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> ROLE role_name<span class="token keyword">CREATE</span> ROLE role_name <span class="token keyword">AUTHORIZATION</span> owner_name<span class="token keyword">EXEC</span> sp_addrolemember <span class="token string">'role_name'</span><span class="token punctuation">,</span> <span class="token string">'user_name'</span><span class="token keyword">EXEC</span> sp_droprolemember <span class="token string">'role_name'</span><span class="token punctuation">,</span> <span class="token string">'user_name'</span><span class="token keyword">DROP</span> ROLE role_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote><p>总的来说T-SQL是相当的厉害啊，对于只有半吊子MySQL学习经验的我来说可谓是<strong>惊艳</strong>，</p><p>但是可惜我几门考试接踵而至也腾不出多余的时间来系统地学习这门技术了，不过我想总有一天我还会再学习更多数据库相关知识的。</p><p>当然了，如果我发现本篇疏漏的较大的知识点，我也会找个时间添加上的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库理论知识</title>
      <link href="/2021/12/24/databasetheory/"/>
      <url>/2021/12/24/databasetheory/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>写在开篇</strong></p><blockquote><p>本篇只讲述数据库相关的各种概念理论，具体代码实践不在本篇讨论范围之内，此后会另起一篇写代码和例题</p></blockquote><blockquote><p>由于是还有几天就要考试了，所以本篇内容尽量<strong>精简</strong>，采用的语言也<strong>并不官方，尽可能通俗易懂</strong>。</p></blockquote><p><strong>更新日志</strong></p><blockquote><p><strong>2021/12/28</strong></p><p>看了下佳豪兄的笔记，简直是自愧不如，于是乎借鉴其笔记补充一些必要的内容</p></blockquote><h2 id="数据库发展史"><a href="#数据库发展史" class="headerlink" title="数据库发展史"></a>数据库发展史</h2><p>什么，竟然要考这个？</p><h3 id="数据和数据库"><a href="#数据和数据库" class="headerlink" title="数据和数据库"></a>数据和数据库</h3><p><strong>数据</strong></p><blockquote><p>数据是信息的载体，信息是数据的内涵。统一信息可以有不同的数据表现形式，而统一数据也可能有不同的解释。</p></blockquote><p><strong>数据库</strong></p><blockquote><p>存放数据的仓库，是长期存储在计算机内有组织额度、可共享的大量数据集合。其中的数据按照一定的数据模型组织、描述和存储。</p><p>具有<strong>永久存储、有组织、可共享</strong>三个特点</p></blockquote><p><strong>数据库系统</strong></p><blockquote><p>包括<strong>数据库、数据库管理系统、应用系统、数据库管理员</strong>四个部分</p></blockquote><p><strong>数据库管理系统</strong></p><blockquote><p>是一种位于用户和操作系统之间的数据管理软件，用于管理、控制和维护数据库</p></blockquote><p>注意，数据库系统，即DBS，包括了数据库操作系统DBMS和数据库DB，在不引起混淆的情况下，口语上可以混用DBS和DB</p><p> 数据库发展经过了四个阶段：</p><table><thead><tr><th>时间</th><th>内容</th><th>特点</th></tr></thead><tbody><tr><td>人工管理阶段</td><td>20世纪40年代中–50年代中</td><td>1.不保存数据<br>2.不共享数据<br>3.应用程序管理数据<br>4.程序与数据不具有独立性</td></tr><tr><td>文件系统阶段</td><td>20世纪50年代末–60年代中</td><td>1.数据共享性差，冗余度大<br>2.数据独立性差</td></tr><tr><td>数据库系统阶段</td><td>20世纪60年代末–现在</td><td>1.具有统一管理数据的专门的软件系统，即数据库管理系统</td></tr><tr><td>新一代数据库（此处以NoSQL非结构化数据库为例）</td><td>20世纪90年代–未来</td><td></td></tr></tbody></table><p>（看到最后这里的年代我迷惑了一下，但是咱也不敢问啊）</p><h3 id="人工管理阶段"><a href="#人工管理阶段" class="headerlink" title="人工管理阶段"></a>人工管理阶段</h3><p><strong>背景</strong></p><blockquote><p>硬件上没有直接存取的设备，软件上没有操作系统，处理方式为批处理</p></blockquote><p><strong>应用程序和数据的对应关系</strong></p><blockquote><p>应用程序和数据集一一对应</p></blockquote><p><strong>特点</strong></p><blockquote><p>数据仅面向某一个应用程序，<strong>不保存不共享</strong>，内容冗余度高，且<strong>不独立无结构</strong>，完全被程序控制</p></blockquote><h3 id="文件管理阶段"><a href="#文件管理阶段" class="headerlink" title="文件管理阶段"></a>文件管理阶段</h3><p><strong>背景</strong></p><blockquote><p>硬件上有了磁盘和磁鼓（？什么鬼），软件上有了操作系统，处理方式上有了联机实时处理</p></blockquote><p><strong>应用程序和数据的对应关系</strong></p><blockquote><p>允许一个应用程序对应一个数据文件，<br>也可以多个应用程序对应一个文件管理系统，再对应多个文件</p></blockquote><p><strong>特点</strong></p><blockquote><p>数据依旧面向某一程序，可以长期保存，<strong>共享性较差且冗余度大</strong>，<strong>记录有结构整体无结构</strong>，独立性差，依旧是应用程序控制数据</p></blockquote><h3 id="数据库系统阶段"><a href="#数据库系统阶段" class="headerlink" title="数据库系统阶段"></a>数据库系统阶段</h3><p>这里更多的是指传统的<strong>文件系数据库</strong><br><strong>背景</strong></p><blockquote><p>出现了大规模管理的需求，硬件上有了更大容量的磁盘和磁盘阵列，软件上有了数据库管理系统，处理方式有了分布式处理</p></blockquote><p><strong>应用程序和数据的对应关系</strong></p><blockquote><p>（此处主要指的是<strong>文件系数据库阶段</strong>）多个应用程序对应一个数据库操作系统，这个数据库操作系统对应一个数据库</p></blockquote><h3 id="新一代数据库管理系统"><a href="#新一代数据库管理系统" class="headerlink" title="新一代数据库管理系统"></a>新一代数据库管理系统</h3><blockquote><p>比如<br>分布式数据库: 数据分布在网络上，但是逻辑上属于一个系统，<br>空间数据库：主要描述、存储和处理空间数据及其属性，<br>NoSQL数据库…，<br>面向对象数据库…，<br>….</p></blockquote><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><blockquote><p><strong>简介</strong><br>数据模型是对现实世界的模拟和抽象，用来描述数据如何组织、操作和存储的。</p><p><strong>分类</strong></p><p>分为三类：<strong>概念模型、逻辑模型、物理模型</strong><br>分别对应</p><p><strong>现实世界，信息世界（第一层抽象），机器世界（第二层抽象）</strong></p><p><strong>组成</strong><br>分为三部分：  <strong>数据结构、数据操作、数据完整性约束条件</strong></p></blockquote><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><blockquote><p>现实世界到机器世界的一个中间层次（<strong>信息世界，第一层抽象</strong>）<br>主要描述有哪些<strong>实体和关系</strong><br>简单说就是描述<strong>是什么</strong>，</p><p><strong>简单理解为E-R图</strong></p></blockquote><p>涉及一些前置的概念：</p><blockquote><p><strong>实体Entity</strong><br>客观存在并且相互区别的事物称为实体，包括事物和概念<br>比如张三、汽车、运动、喜好这些名词都是实体<br><strong>属性Attribute</strong><br>实体所具有的某一特性<br><strong>码Key</strong><br>唯一标识实体的属性<br><strong>域Domain</strong><br>属性的取值范围称<br><strong>实体集Entity Set</strong><br>同一类型实体的集合称为实体集<br><strong>实体型Entity Type</strong><br>用实体名及其属性名集合来抽象和刻画同类实体</p></blockquote><p>比如学生(学号，姓名，性别，院系，专业)，表示学生实体，<br>全体学生则是实体集<br><strong>实体集之间的联系</strong></p><blockquote><p><strong>联系</strong><br>实体内部的联系通常是指的组成实体的各属性之间的联系<br>实体之间的联系通常是指的不同实体集之间的联系<br>联系分为一对一，一对多，多对多</p></blockquote><p><strong>E-R图</strong></p><blockquote><p><strong>矩形</strong><br>表示实体<br><strong>椭圆</strong><br>表示属性<br><strong>菱形</strong><br>表示联系</p></blockquote><p>比如这样<br><img src="https://img-blog.csdnimg.cn/00ae9e1eccaf4c0da2061d942de2f2d4.png" alt="在这里插入图片描述"><br>有时候，联系本身也是一种实体，可以有属性<br><img src="https://img-blog.csdnimg.cn/7da1868fbc3342c09174e142fc63ce42.png" alt="在这里插入图片描述"><br>存在多个实体间多对多联系的时候<br><img src="https://img-blog.csdnimg.cn/61b67c604fd143eea140a82d150489b1.png" alt="在这里插入图片描述"><br>单个实体型内的联系<br><img src="https://img-blog.csdnimg.cn/d2e1d26882864aaa95074f6627efe2ab.png" alt="在这里插入图片描述"></p><h3 id="逻辑模型"><a href="#逻辑模型" class="headerlink" title="逻辑模型"></a>逻辑模型</h3><blockquote><p>从数据的组织方式来描述数据，即用什么样的数据结构来组织<br>简单说就是<strong>在概念模型基础上</strong>，进一步考虑实体的属性<br>也就是定义<strong>做什么</strong></p><p>简单看做<strong>表</strong></p></blockquote><p><strong>常见的逻辑数据模型</strong></p><blockquote><p><strong>1.层次模型</strong></p><p>优点：实现简单，结构清晰，数据表现完整</p><p>缺点：不能表示两种以上实体的联系和多对多联系、插入删除复杂、查询孩子节点必须经过双亲节点</p><p><strong>2.网状模型</strong></p><p>优点：直观表示现实世界中的复杂关系，有良好的性能和存储效率</p><p>缺点：结构复杂，数据独立性差</p><p><strong>3.关系模型</strong></p><p>也就是常常提到的表结构</p><p>优点：数据理论根据强，结构清晰简单，数据有更高的独立性和安全性（关系之间的存取关系对用户不可见）</p><p>缺点：（由于存取关系不可见）数据查询效率低，且关系必须规范化（比如<strong>属性是不能再分的数据项，不允许表中有表</strong>等等）</p></blockquote><p>如果要对逻辑数据模型做一个分类，那么</p><p>逻辑模型可以分为三类：</p><blockquote><p><strong>1.非关系模型</strong></p><p>主要是指层次模型和网状模型</p><p><strong>2.关系模型</strong></p><p>以严格的数学理论为基础：谓词逻辑、集合论<br>（什么？竟然是离散数学）</p><p>关系型数据库则采用关系模型<br>其中，<strong>关系</strong>通常对应一张表，该表包含数个<strong>属性</strong>和数个<strong>元组</strong>，而<strong>关系模式</strong>则是对关系的一种描述，格式为</p><p><strong>关系名字（属性1，属性2，属性3…）</strong></p><p>当然，也可以用E-R图描述，此处不再赘述</p><p><strong>3.面向对象模型</strong></p><p>未来的方向，不知道是什么意思，或许是以能够存对象为基础吧</p></blockquote><h3 id="物理模型"><a href="#物理模型" class="headerlink" title="物理模型"></a>物理模型</h3><blockquote><p>在逻辑模型的基础上，考虑存储空间等问题，即数据类型，长度大小等等<br>也就是<strong>怎么做</strong></p><p>简单看做<strong>机器存储表</strong></p></blockquote><h3 id="三级模式"><a href="#三级模式" class="headerlink" title="三级模式"></a>三级模式</h3><blockquote><p>由<strong>概念模式、外模式、内模式</strong></p></blockquote><blockquote><p><strong>1.外模式</strong></p><p>也称<strong>子模式</strong>或者<strong>用户模式</strong></p><p>数据库用户看见和使用的局部数据的逻辑结构和特征，是用户能看到的一部分数据的逻辑结构和特征描述</p><p>描述一个数据库<strong>可以有多个外模式</strong><br>外模式是保证数据库安全性的一个有力措施</p><p><strong>2.概念模式</strong></p><p>介于外模式和内模式之间</p><p>数据库用户看见和使用的局部数据的逻辑结构和特征的描述<br>所有用户的公共数据视图，综合所有用户的需求</p><p>一个数据库只有一个模式</p><p><strong>3.内模式</strong></p><p>也称<strong>存储模式</strong></p><p>是数据结构和存储方式的描述<br>是数据在数据库内部的表示方式</p></blockquote><p><strong>具体示例</strong><br><img src="https://img-blog.csdnimg.cn/f55af2ccff6e42a1836b617e1e947fa2.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/d7a3ea58b13a4abebcdb2dbc6402615b.png" alt="在这里插入图片描述"></p><h3 id="二级映像"><a href="#二级映像" class="headerlink" title="二级映像"></a>二级映像</h3><blockquote><p>二级映像的目的是<strong>为了实现三级模式之间的转换和联系</strong></p><p><strong>外模式/概念模式映像</strong><br>保障了数据的逻辑独立性<br>对每一个外模式，数据库都有一个外模式/概念模式映像<br><strong>概念模式/内模式映像</strong><br>保障了数据的物理独立性<br>对于每一个概念模式，数据库都有一个概念模式/内模式映像</p></blockquote><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>数据依赖的主要类型有<strong>函数依赖</strong>，<strong>多值依赖</strong>, <strong>连接依赖</strong>等<br>这里主要讨论<strong>函数依赖</strong></p><blockquote><p>在属性（或属性组）X的值确定的情况下，必定能够确定属性Y的值<br>记为    X-&gt;Y<br>例如：学号-&gt;学生姓名，代表<strong>学生姓名函数依赖于学号</strong></p><p>可以细分为<strong>部分函数依赖</strong>、<strong>完全函数依赖</strong>、<strong>传递函数依赖</strong></p></blockquote><h3 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a><strong>部分函数依赖</strong></h3><blockquote><p>比如， 存在一个属性组{学号，年龄}，其中有学号满足学号-&gt;姓名，即可称姓名部分函数依赖于{学号， 年龄}<br>即属性组（集合）存在真子集满足一个函数依赖时，就称为部分函数依赖。<br><strong>严格地说应该记为A-P-&gt;B，P表示Part部分</strong></p></blockquote><h3 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a><strong>完全函数依赖</strong></h3><blockquote><p>类似于部分函数依赖，但是要求是该属性组没有多余的属性，<br>也就是说，<br>比如存在一个属性组{a, b, c}, 要求a-&gt;x, b-&gt;x, c-&gt;x，{a, b}-&gt;x, {a, c}-&gt;x,{b, c}-&gt;x也就是x函数依赖于其中所有真子集<br><strong>严格地说应该记为A-F-&gt;B，Full表示Full全部</strong></p></blockquote><h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a><strong>传递函数依赖</strong></h3><blockquote><p>比如， a-&gt;b, b-&gt;c, 可以间接推导出a-&gt;c，这就称为c传递函数依赖于a<br><strong>严格地说应该记为A-T-&gt;B，T表示Transition传递</strong></p></blockquote><h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当问起一张表有没有码的时候，这并不是骂它</p><blockquote><p><strong>码是可以确定一个元组所有信息的属性或者属性组</strong></p></blockquote><p>其中，<strong>元组</strong>是指一个表里面的某一行，而属性其实就是一个表里的某一列</p><blockquote><p>比如，存在一个属性组{学号，姓名，年龄，专业}，那么其他所有属性都可以函数依赖于学号，那么就可以把学号称为<strong>主码</strong>或者<strong>主键</strong>，不能为空<br>如果不考虑重名，那么姓名也能推出其他信息，但是由于<strong>只能有一个主码</strong>，所以姓名只能做<strong>候选码</strong>，当然主码被看做是特殊的<strong>候选码</strong><br>如果某个属性<strong>部分函数依赖</strong>于某个属性组，那么这个属性组就是<strong>超码</strong><br>注意，<strong>候选码是最小的码（最小的超码）</strong>，即<strong>候选码的真子集不能有码</strong></p></blockquote><h3 id="主属性和非主属性"><a href="#主属性和非主属性" class="headerlink" title="主属性和非主属性"></a>主属性和非主属性</h3><blockquote><p>包含在任何一个候选码中的属性，称为<strong>主属性</strong><br>不包含在任何码中的属性称为<strong>非主属性</strong><br>如果整个属性组都是码，那么成为<strong>全码</strong></p></blockquote><p>举个全码的例子：</p><blockquote><p>关系模式R（P,W,A）,P是演奏者，W是作品，A是听众<br>一个演奏者-&gt;多个作品  一个作品-&gt;多个演奏者  多个听众-&gt;多个演奏者、多个作品<br>需要同时确定三者才能推导出整行的信息，码表示为（P,W,A），即为全码</p></blockquote><p>上述内容提到的<strong>关系模式</strong>可以看做是一张表，包含了PWA三个属性</p><h3 id="外部码（外码）"><a href="#外部码（外码）" class="headerlink" title="外部码（外码）"></a>外部码（外码）</h3><p>举个例子</p><blockquote><p>两个关系模式中，<br>学生选课表(学号，课程号，成绩)，以下称为表A<br>学生信息表(学号，专业，年龄), 以下称为表B<br>表A中，需要同时确定学号和课程号才能确定一个元组，所以<strong>候选码是（学号，课程号）</strong><br>表B中，只需要确定学号就能确定一个元组，所以<strong>候选码是（学号）</strong><br>可以看到，学号不是A的码，但是是B的码，那么把学号称为A的外码</p></blockquote><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>不仅是生活中的关系，也指离散数学中集合间的关系，更指关系型数据库中的关系</p><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p><strong>关系模式</strong></p><blockquote><p>对关系的描述即为关系模式，表示为<br><strong>关系名（属性1， 属性2 …..）</strong></p></blockquote><p>关系型数据库则是建立在关系模型上的数据库，在关系数据库中面实体和实体间以<strong>关系的形式</strong>进行描述</p><p><strong>关系的形式</strong>具体指的是以表格的形式</p><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><blockquote><p>完整性约束时为了保证数据库中数据的正确性和相容性，对关系模型提出的某种<strong>约束条件或规则</strong><br>其中，<strong>完整性</strong>包括了四个部分：<br>1.<strong>域完整性</strong><br>2.<strong>实体完整性</strong><br>3.<strong>参照完整性</strong><br>4.用户定义完整性<br>其中，<strong>123是关系模型必须满足的完整性约束条件</strong></p></blockquote><p><strong>1.域完整性</strong></p><blockquote><p>指约束数据类型、格式、取值范围、是否允许空值等。</p></blockquote><p><strong>2.实体完整性</strong></p><blockquote><p>指关系型数据库中所有表都必须有主码，且不允许存在与其他记录的主码相同的记录（主码是唯一的标识）</p></blockquote><p><strong>3.参照完整性</strong></p><blockquote><p>指的是外码的值必须参考主码的值，关系中不能引用不存在的记录<br>比如存在两个关系（也就是表），A和B，A中的a属性参照B中的b属性（参照，大概就是类似于平时说的左外/右外连接那样）<br>则对于a的值，必须为<strong>空</strong>或者<strong>B中某个元组中属性b的取值</strong></p></blockquote><p><strong>4.用户自定义完整性</strong></p><blockquote><p>指的是针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求<br>可以看做是一种随机应变的规范，比如银行卡取款金额不能超过余额</p></blockquote><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p><strong>符号</strong></p><table><thead><tr><th>运算</th><th>符号</th></tr></thead><tbody><tr><td>并 交 差 笛卡尔积</td><td>∪   ∩   -   ×</td></tr><tr><td>选择 投影 连接 自然连接 除</td><td>σ   ∏   ∞   *   ÷</td></tr><tr><td>算是比较（大于小于等于）</td><td>（略）</td></tr><tr><td>或 且（与） 非</td><td>∨  ∧  ¬</td></tr></tbody></table><p><strong>运算分类</strong></p><blockquote><p><strong>集合运算符（4）</strong><br>交   并  差  笛卡尔积<br><strong>专门关系运算符（5）</strong><br>选择 投影 连接 自然连接  除<br><strong>算术比较符（6）</strong><br>大于 大于等于 小于 小于等于 等于 不等于<br><strong>逻辑运算符（3）</strong><br>或  且(与)  非<br><strong>其他运算符（2）</strong><br>更名运算符 赋值运算符</p></blockquote><p>tip:有时也把自然连接视为特殊的连接</p><p>其中这些又构成</p><blockquote><p><strong>基本运算符(5)</strong><br>并 差 笛卡尔积 投影 选择</p><p><strong>组合操作(4)</strong> </p><p>交 连接 自然连接 除</p></blockquote><p>关系代数操作的是一个序列形成的关系代数表达式，运算对象是关系，运算结果也是一个关系</p><p>下文节选部分关系代数运算提供示例</p><p><strong>集合运算：并</strong><br>具有<strong>相容性</strong></p><blockquote><p>并运算的关系必须有相同的属性个数，并且每个相对应的属性都有相同的域<br>对应的属性名称不一定一致，在不一致的时候会取参与运算前者的属性名。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/265a28152c514b8cb6ed4bffe8ab2582.png" alt="在这里插入图片描述"><br><strong>集合运算：差</strong></p><p><img src="https://img-blog.csdnimg.cn/9b0c255840e8403bbf75d2b6bc133d59.png" alt="在这里插入图片描述"></p><p><strong>集合运算：笛卡尔积</strong></p><blockquote><p>运算的结果是具有n+m个属性，r * s个元组</p></blockquote><p>（图没截全）<br><img src="https://img-blog.csdnimg.cn/08f395e65eb54500b84e3c94fd9ff0d3.png" alt="在这里插入图片描述"></p><p><strong>专门关系运算：选择</strong><br>看做SELECT语句就好，针对的是元组<br><img src="https://img-blog.csdnimg.cn/406a74ed3b7a46238536fdcd1789ad05.png" alt="在这里插入图片描述"><br><strong>专门关系运算：投影</strong><br>和选择类似，但是针对的是列<br>具有<strong>重复消除性</strong></p><blockquote><p>如果投影运算的属性列表中<strong>只包含关系的非键属性</strong>，那么结果关系中就有可能出现重复的元组（如下图，是因为必须要有新的主键产生，但是又不能和主键的定义矛盾）<br>这时候，就会消除重复的元组，所以投影运算得到的关系的元组数量小于等于关系的元组个数</p></blockquote><p><img src="https://img-blog.csdnimg.cn/f8323a87140642318744cae14a5a6fc3.png" alt="在这里插入图片描述"><br><strong>专门关系运算：连接</strong><br><strong>连接运算</strong>根据情况分为<strong>θ连接</strong>或<strong>自然连接</strong></p><blockquote><p><strong>θ连接</strong><br>当连接运算的条件是形如AθB的时候，就称为<strong>θ连接</strong><br>当θ为=时，则该连接称为<strong>等值连接</strong><br>当有连接的关系存在共同的属性时，可以简化为<strong>自然连接</strong>，即以共同的属性进行自动匹配</p></blockquote><p><img src="https://img-blog.csdnimg.cn/badd53a9d5824dd2a4473c69572cd3ae.png" alt="在这里插入图片描述"></p><blockquote><p><strong>与笛卡尔积的区别</strong><br>主要区别是运算结果的元组数目不同：<br>对于笛卡尔积，两个关系所有元组的组合都会出现在笛卡尔积的结果中，而只有符合连接条件额度元组才会出现在连接结果中</p></blockquote><p><strong>专门关系运算：除</strong></p><blockquote><p>这里有两个关系R(A1…An, B1…Bm), S(B1…Bm,C1…Ck)<br>其中存在共同的属性：（B1…Bm）<br>在R中取(A1…An)取值相同的<strong>所有元组</strong>中的(B1…Bm)属性的值作为一个集合RB<br>在S这边取(B1…Bm)上所有取值作为一个集合SB<br>如果有SB是RB的子集，则R中(A1…An)的取值便构成了R÷S的一个元组</p></blockquote><p>上面的描述挺复杂的，记起来也很麻烦，还是看个例子吧<br><img src="https://img-blog.csdnimg.cn/3b85febe52fe400e8d0921e6eabc8fce.png" alt="在这里插入图片描述"><br>首先表R和S都有的属性是C和D<br>那么把R中A和B属性中值相等的C和D属性的值作为一个集合，得到这个集合并记为</p><blockquote><p>RS = { {(c, d), (e, f), (h, k)}，{(e, f), (d, l)}，{(c,d),(e,f)} }</p></blockquote><p>而S这边得把C和D作为一个集合，记为</p><blockquote><p>SS = { {(c,d),(e,f)} }</p></blockquote><p>很显然，SS是RS的子集，所以满足这个关系的RS的C和D属性对应的<strong>A和B属性</strong>即成为该运算结果的属性</p><p><strong>其他运算：赋值</strong><br>其实就是修改关系名以便引用，当然也可以修改属性名</p><p><strong>其他运算：更名</strong><br>给关系代数的运算结果命名，也可以修改运算结果的属性名<br><strong>注意，别被运算的名字误导了！</strong></p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><blockquote><p>定义为<br>符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度。一般我们用NF代表范式。<br>（很晦涩…）</p></blockquote><p>数据库范式有1NF，2NF，3NF，BCNF，4NF，5NF<br>但是一般我们只需要考虑到BCNF就够了</p><h3 id="第一范式1NF"><a href="#第一范式1NF" class="headerlink" title="第一范式1NF"></a>第一范式1NF</h3><blockquote><p>关系中的属性不可再分</p><p><strong>即属性不能具有属性</strong></p></blockquote><p>1NF是对所有关系型数据库的<strong>最基本要求</strong></p><p>但是仅仅符合1NF的设计可能会存在数据冗余过大，插入异常，删除异常，修改异常等问题</p><h3 id="第二范式2NF"><a href="#第二范式2NF" class="headerlink" title="第二范式2NF"></a>第二范式2NF</h3><blockquote><p>消除了非主属性对于码的部分函数依赖<br>要求每个实例或者行必须唯一地被区分，每一行数据只能与其中一列相关，如果出现重复的数据，那么就要把它拆分开来</p><p><strong>每个非主属性（主码，主键）都完全依赖于主属性，即主属性可以推出所有属性</strong></p></blockquote><h3 id="第三范式3NF"><a href="#第三范式3NF" class="headerlink" title="第三范式3NF"></a>第三范式3NF</h3><blockquote><p>3NF在2NF基础上，消除了主属性对于码的传递函数依赖</p><p><strong>属性不依赖于非主属性</strong></p></blockquote><blockquote><p>3NF <strong>基本</strong> 解决了数据冗余过大，插入异常，删除异常的问题 </p></blockquote><h3 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h3><blockquote><p>在3NF的基础上，消除主属性对于码的部分函数依赖和传递函数依赖</p></blockquote><p><strong>例题</strong><br><img src="https://img-blog.csdnimg.cn/fe635fa51b3a4475b06e52084c33b3f0.png" alt="在这里插入图片描述"></p><h3 id="其他范式"><a href="#其他范式" class="headerlink" title="其他范式"></a>其他范式</h3><p>4NF，5NF暂不讨论</p><p>总结一下大概就是这样<br><img src="https://img-blog.csdnimg.cn/9991dda3f2504261a7b271ea93deba9a.png" alt="在这里插入图片描述"></p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="备份的分类"><a href="#备份的分类" class="headerlink" title="备份的分类"></a>备份的分类</h3><ol><li>完整备份：将所有数据库信息都进行备份，备份下来的时一个完整的数据库。数据库的备份需要时间，在备份中用户同样可以进行操作，且备份会将备份过程中执行的操作记录下来。</li><li>差异备份：是对最近一次<strong>完整备份</strong>以来发生的数据变化进行备份，它的特点是速度快体积小，通过增加差异备份的次数，可以有效减少数据丢失的风险。</li><li>事务日志备份：仅对事务日志进行备份，事务日志中包含了从上一次<strong>完整备份</strong>以来所有已经完成的事务。事务日志备份由于只备份事务日志，所以速度更快、占据磁盘空间更小。</li><li>需要注意的是，差异备份和事务日志备份尽管都只备份一部分数据加快了备份速度，但是差异备份只保留最近一次修改，事务日志保留了从上一次备份以来的所有事务。</li></ol><p><strong>备份内容</strong>：</p><ol><li>系统数据库：记录了重要的系统信息，必须<strong>完整备份</strong>。一旦进行修改，最好立刻备份。</li><li>用户数据库：记录了重要的用户数据，必须<strong>完整备份</strong>。可以进行周期性的备份。</li><li>事务日志：事务日志体积小，备份时间短，但是<strong>恢复需要的时间长</strong>。</li></ol><h3 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h3><p><strong>策略一：完整备份</strong></p><p>适合于数据量不大，或者不平凡修改的数据库。</p><p><strong>策略二：完整备份+日志备份</strong></p><p>适用于用户不允许丢失太多数据，但又不想经常完整备份的情况。</p><p><strong>策略三：完整备份+差异备份+日志备份</strong></p><p>适用于用户不允许丢失太多数据，但又不想经常完整备份的情况，而且恢复速度比较块的情况。</p><p><strong>恢复顺序</strong>：</p><ol><li>恢复最近的完整数据库备份。</li><li>恢复完整备份之后的最近的差异数据库备份。</li><li>按事务日志的备份的先后顺序回资完整备份的所有日志备份。</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>事务是用户定义的一个数据操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单元。</p><p><strong>操作</strong></p><p>事务可以由用户开启，也可以让DBMS自动决定事务是否开启。事务相关的操作：</p><ol><li>BEGIN TRANSACTION：开启事务。</li><li>COMMIT：提交事务。</li><li>ROLLBACK：回滚事务。</li></ol><p><strong>特征（ACID特性）</strong>：</p><ol><li>原子性（Atomicity）：指事务的操作要么全部做要么都不做，<strong>不可分割</strong>。</li><li>一致性（Consistency）：是指数据库必须从一个一致性转为另一个一致性，不允许部分改变。一致性和原子性紧密相关。</li><li>隔离性（Isolation）：指事务不能受到其他事务的干扰，事务之间必须是相互隔离互不干扰的。</li><li>持久性（Durability）：也称永久性，事务一旦提交，对数据库的修改就是永久性的。</li></ol><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>让事务串行执行虽然可以有效保持数据库的一致性，但是效率颇低，于是<strong>为了提高数据库的并行度，避免数据库资源的闲置浪费</strong>，可以让多个事务同时执行，即并发执行。</p><p>而在这个过程中，可能存在多个事务同时对一段数据进行读取或改写，出现各种各样的错误，破坏数据库的一致性，因此<strong>保护数据库一致性的这个过程就是并发控制</strong>。</p><p><strong>并发操作引起的问题</strong>：</p><ol><li>丢失更新问题：两个事务<strong>同时读取并修改同一段数据</strong>，事务2的提交<strong>覆盖</strong>了事务1的提交，导致事务1的更新丢失。</li><li>读“脏”数据问题：事务1对一段数据进行修改后，事务2读取了该段数据，但是由于某种原因，事务1<strong>撤销</strong>了自己的修改操作，导致事务2<strong>之前读取到的数据与现在数据库中的数据不同</strong>，称之为读脏数据。读到脏数据的原因就是读取了未提交事务的数据（或称未提交数据）。</li><li>不可重复读问题：事务1读取一段数据后，事务2<strong>修改</strong>了该段数据，此时事务1再读取该段数据却<strong>得到了不同的数据</strong>，读取数据被称为检索，所有又称检索不一致。</li></ol><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>并发控制的手段——封锁技术（或简称锁）</strong>：</p><ol><li>封锁（Locking）：就是事务T在操作某一个数据对象之前，向DBMS发送一段请求对操作对象上锁，被上锁的数据对象不能被除事务T以外的事务修改，确保了数据库的一致性。</li><li>锁的分类：<ol><li>排他锁（简称X锁）：又称写锁，事务T对数据对象上了X锁之后，<strong>只有事务T能够读取和更新该数据对象，其他事务就不能再对该对象上任何锁，也不能读取和更新该数据对象</strong>，直到事务T释放X锁。</li><li>共享锁（简称S锁）：又称读锁，事务T对数据对象上了S锁之后，事务T只能读取该数据对象而不能更新，其他事务<strong>只能对该数据对象上S锁而不能加X锁</strong>，直到事务T释放S锁。注意<strong>上了S锁之后，所有事务都只能读而不能修改</strong>。</li></ol></li><li>封锁协议：<ol><li>封锁协议规定了何时上锁，何时释放锁和封锁的时间等，不同等级的封锁协议在一定程度上保证了数据库的一致性避免并发操作引起问题。</li><li>一级封锁协议：在需要<strong>修改数据之前</strong>，必须对数据上<strong>X锁</strong>，<strong>直到事务完成</strong>（事务完成包括commit提交和roolback回滚）。一级协议保证了<strong>不会出现丢失更新的问题</strong>，但是读事务不考虑数据是否上锁，因此还是可能出现脏数据和不可重复读问题。</li><li>二级封锁协议：在一级封锁协议的基础上，事务在<strong>读取数据之前</strong>，必须对数据上<strong>S锁</strong>，<strong>直到数据读取完成就释放S锁</strong>。二级协议除了保证了不会出现丢失更新问题，还保证<strong>避免了读脏数据的问题</strong>。但是由于数据在读取完成后就释放S锁，这时其他事务就可以修改数据了，所以还是会存在不可重复读的问题。</li><li>三级封锁协议：在一级封锁协议的基础上，事务在<strong>读取数据之前</strong>，必须对数据上<strong>S锁</strong>，<strong>直到事务完成后才释放S锁</strong>。这样就可以保证在事务完成之前，无论读多少次数据都能得到相同的结果，因此<strong>避免了不可重复读的问题</strong>。</li><li>死锁：同操作系统的死锁，两个事务都在等待对方释放上锁的数据，导致两个事务都不能完成。</li></ol></li></ol><p><strong>串行调度</strong>：</p><p>即每个事务都顺序执行，这种情况下虽然串行的顺序不一定相同，但<strong>执行结果总是正确的</strong>；</p><p><strong>并发调度</strong>：</p><p>区别于串行调度，时刻可以同时执行，这时并行的顺序就可能影响执行结果的正确性。</p><p><strong>并发调度的可串行性</strong>：</p><p>指找到并行执行的某个顺序下的结果，与某一串行执行的结果相同，就可以说这个并行执行是正确的。</p><p><strong>二段锁协议</strong>：</p><p>是DBMS确保并发调度可串行性的手段，其含义是：将事务分为两个阶段，第一阶段只允许申请封锁，第二阶段只允许释放封锁。</p><p>实现了二段锁协议的事务只是具备了可串行化的充分条件而不是必要条件，意思是可串行化的事务同样可以不遵守二段锁协议。</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><blockquote><p>按照功能可以分为三部分</p><p><strong>数据定义语言DDL</strong></p><p><strong>数据操纵语言DML</strong></p><p><strong>数据控制语言DCL</strong></p><p>有的还可以分出第四类</p><p><strong>数据查询语言DQL</strong></p></blockquote><h2 id="数据库新技术"><a href="#数据库新技术" class="headerlink" title="数据库新技术"></a>数据库新技术</h2><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><blockquote><p>全称其实是Not Only SQL</p><p>是一类范围非常广泛的数据持久化解决方案，不遵循关系数据库模型，也不使用SQL作为查询语言</p><p>传统关系型数据库的主要缺点：<strong>扩展性差</strong></p><p>目前的主要解决思路有两个，</p><p><strong>1.水平分区（数据分片 sharing）</strong></p><p>举个例子，比如一个服务器十年的用户数据本来放到一张表里面，现在我们按年来分别建立十张表</p><p><strong>2.垂直分区（功能业务分区）</strong></p><p>没看懂，啥子主从方式，复制阿巴阿巴….</p></blockquote><p>NoSQL的分类可以分为四类</p><blockquote><p>1.键值存储库 （MongoDB）</p><p>2.文档库（CouchDB）</p><p>3.图形数据库（Neo4j）</p><p>4.列存储库（Hadoop）</p></blockquote><p>但是普遍地具有这些结构：</p><blockquote><p><strong>1.数据持久层</strong> </p><p><strong>2.数据分布层</strong></p><p><strong>3.数据逻辑模型层</strong></p><p><strong>4.接口层</strong></p></blockquote><p>这学了个寂寞….</p><p>其他的数据库类型暂时不学了，因为NoSQL应该比较重要，但是依旧被学校的课程一笔带过，所以我想其他的新型数据库应该不是考试的重点，为了节约时间我们也先不复习这块了！</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote><p>今天计算机类2020级13班吃了散伙饭，大家分流到各自的专业去了，希望班导和各位同学们都能够学业有成啊！</p><p>数据库理论的学习就告一段落了，接下来我会再写一篇T-SQL具体代码的文档。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.JS</title>
      <link href="/2021/12/15/node.js/"/>
      <url>/2021/12/15/node.js/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2021/12/15：</strong><br>虽然说还有N个项目没有写完，考试也迫在眉睫，但是我啊依旧不慌，还是学技术最令人心情愉悦了！</p><p>当然，话是这么说，后面该复习还是得复习啊，哦——是预习。总之在学习考试科目的同时，我也会抽空持续学习技术的！</p><p><strong>2021/12/16</strong><br>明天还要做数据库的上机实验，但是我还是选择通宵了，没错，现在是凌晨四点，说实话感觉有点累，但是还是再学会儿吧，</p><p>四点半就回寝室…</p><p><strong>2021/12/17</strong><br>爆肝三日终于Node入门，学到FS文件操作的时候当时我就意识到了，或许项目中前后端传递图片的技术已经近在眼前！真的太强了，伟哉JS！</p><p><strong>2022/02/07</strong><br>补充关于AMD和CMD的少量知识点</p><p><strong>2022/02/25</strong><br>补充Node常用模块及其API</p></blockquote><h3 id="多余的话"><a href="#多余的话" class="headerlink" title="多余的话"></a>多余的话</h3><blockquote><p>Node.JS真是了不起啊，想想就觉得刺激！</p><p>这里只是皮毛，学完了最多算是入门的入门~~</p></blockquote><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><blockquote><p>小黑窗、命令行窗口、命令提示符、DOS窗口、shell、CMD窗口、终端说的都是一个东西啊…</p></blockquote><p>这个东西过于基础，放在这里只是为了让大家知道要学这个，此处就不再赘述</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>格式是键值对。</p><p>以path变量为例，其值是多个路径，路径间以分号隔开</p><p>这些路径，能够在任意目录下访问</p><blockquote><p>比如配置一个D:/hello</p><p>这里的hello是一个txt文件</p><p>我们在终端里执行如下内容：</p><p>C:\User&gt;hello.txt</p><p>系统会先到User目录下寻找hello.txt，如果没找到，那么就会去环境变量path中寻找，这样就访问到了hello.txt</p></blockquote><p>环境变量可以分为两类</p><blockquote><p><strong>用户变量</strong></p><p>当前用户能够使用</p><p><strong>系统变量</strong></p><p>这台计算机上的所有用户都能够使用</p></blockquote><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>概念不再赘述，详见<strong>操作系统</strong>笔记</p><p>简单提下为什么浏览器主进程（渲染进程）是单线程</p><blockquote><p>如果原生变为多线程，那么渲染页面和JS解析同时进行，</p><p>由于并发和异步可能会导致最终页面出现和预期不符的结果</p></blockquote><h2 id="Node-JS基础"><a href="#Node-JS基础" class="headerlink" title="Node.JS基础"></a>Node.JS基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Node.JS还没有诞生的时候，JS顶天就是操作浏览器.</p><blockquote><p>Node.JS是一个能够在服务器端运行JavaScript的开源跨平台JavaScript运行环境。</p><p>Node采用Google开发额度V8引擎运行JS代码，使用事件驱动、非阻塞、异步I/O等技术提高性能。</p><p>Node大部分内容都用JS编写。</p></blockquote><p>但是Node.JS诞生了，JS能够撼动整个计算机的世界.</p><h3 id="性能提升的原理"><a href="#性能提升的原理" class="headerlink" title="性能提升的原理"></a>性能提升的原理</h3><blockquote><p>浏览器作为客户端，和服务端交互存在两个过程：请求和响应。而服务端和数据库之间存在I/O操作。</p><p>客户端对于硬件层面的I/O操作就是无能为力，但是可以优化请求和响应相关的逻辑代码可以提升程序的性能。</p></blockquote><p>客户端（此处指传统浏览器）每发出一个请求，客户端都会为之创建一个线程，而在其I/O完成之前，该线程会一直等待，即<strong>阻塞</strong></p><p>当有大量请求时，会出现大量请求阻塞，内存资源会被极大的消耗</p><p>Node.JS的解决方案就是<strong>Node模式</strong></p><blockquote><p>避免一个线程忙等待，当请求执行到I/O操作时，该线程不会阻塞而是选择<strong>去服务其他请求</strong>，从而避免了大量线程白白浪费资源。</p><p>当然，要注意<strong>Node服务器单线程</strong>，意思是只有一个线程忙活，所以它需要超高速地服务不同的请求。</p><p>如果有做多线程的需求，可以考虑<strong>分布式</strong>，但这个概念不在话下。</p></blockquote><h3 id="为什么是JavaScript"><a href="#为什么是JavaScript" class="headerlink" title="为什么是JavaScript"></a>为什么是JavaScript</h3><blockquote><p>有如此多的语言，但是为什么Ryan Dahl选择在JavaScript的基础上进行改动，这是因为C/C++，Java等传统服务端语言的模式已经根深蒂固，</p><p>想要进行大刀阔斧的改革变得尤其困难，而JavaScript在这方面还像是一片从未开发的沃土，而且正值Google推出V8引擎，这使得JavaScript变成了最好的选择。</p><p>也正是从此开始，JavaScript从一个需要浏览器支撑的脚本语言变成了独立自主的面向对象语言，也就是说，JavaScript从此站了起来！</p></blockquote><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>Node.JS虽然能够做服务端，但是大数据的能力依旧不如Java。</p><p>淘宝的后台服务器采用Java服务器，但是会在客户端和后台服务器之间加一层Node.JS服务器，因为Node.JS解析渲染页面的能力要更强一些，</p><p>这样的结构可以加速页面的解析和渲染。</p><h3 id="Node-JS发展史"><a href="#Node-JS发展史" class="headerlink" title="Node.JS发展史"></a>Node.JS发展史</h3><table><thead><tr><th align="center">时间</th><th align="center">事件</th></tr></thead><tbody><tr><td align="center">2009</td><td align="center">瑞安·达尔发布Node.JS的最初版本</td></tr><tr><td align="center">2011</td><td align="center">npm诞生 <br>Node.JS发布Windows版本<br>Node超越Ruby on Rails（一个Web框架）</td></tr><tr><td align="center">2012</td><td align="center">瑞安·达尔离开Node项目</td></tr><tr><td align="center">2014</td><td align="center">Node的分支IO.JS诞生</td></tr><tr><td align="center">2015</td><td align="center">Node.JS基金会成立<br>Node.JS合并IO.JS成为Node 4.0(合并后凭空出现的版本号)</td></tr><tr><td align="center">2016</td><td align="center">Node 6.0发布</td></tr><tr><td align="center">2017</td><td align="center">Node 8.0发布</td></tr><tr><td align="center">2021</td><td align="center">某佑开始学习Node.JS</td></tr></tbody></table><p>朝着前辈们的背影，踏上这伟大的道路！！！</p><h2 id="简单使用Node-JS"><a href="#简单使用Node-JS" class="headerlink" title="简单使用Node.JS"></a>简单使用Node.JS</h2><h3 id="终端运行Node-JS"><a href="#终端运行Node-JS" class="headerlink" title="终端运行Node.JS"></a>终端运行Node.JS</h3><p>win + r打开命令提示符终端，输入node后回车开启，此后便可以开始输入JS代码</p><p><img src="https://img-blog.csdnimg.cn/3bcc1d6d42394088b9493b42c0c0f076.png" alt="在这里插入图片描述"></p><p>输入.exit或ctrl + c两次后退出</p><p>当然，这样写十分不方便，所以我们还可以使用下面这种形式来用node执行JS代码</p><p><img src="https://img-blog.csdnimg.cn/8fb195cc312048db8107a88903498353.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/c54711c7cd5043bdae84fba9a62b4a2a.png" alt="在这里插入图片描述"></p><h3 id="集成环境运行Node-JS"><a href="#集成环境运行Node-JS" class="headerlink" title="集成环境运行Node.JS"></a>集成环境运行Node.JS</h3><p>当然，也可以在webstorm或者vscode提供的终端执行以上操作</p><p><img src="https://img-blog.csdnimg.cn/6c705062c26f45439167e89cc8dbedb7.png" alt="在这里插入图片描述"></p><h2 id="COMMONJS规范"><a href="#COMMONJS规范" class="headerlink" title="COMMONJS规范"></a>COMMONJS规范</h2><p>啊不是吧，这几天才知道TypeScript还有几个稀奇古怪的Script，这里又来个COMMONJS…</p><p><strong>注意，现在已经采用ES6标准了，但COMMONJS还是要会</strong></p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>ECMAScript5的缺陷</strong></p><p>COMMONJS提出时，还没有ES6，所以下述内容是针对ES5的</p><blockquote><p>1.没有模块系统（ES6有了，现在可以忽略这一条）</p><p>2.标准库较少</p><p>3.没有标准接口</p><p>4.缺乏管理系统</p></blockquote><p><strong>COMMONJS的提出</strong></p><p>最开始是用于服务端的标准而不是浏览器环境</p><p><strong>这个规范希望JS能够在任何地方运行</strong></p><p>它也提出了JS模块化早期的一些内容，这些内容在Node中有较为广泛的应用</p><blockquote><p><strong>1.模块引用</strong></p><p>通过require()来引用模块，参数是一个路径，<strong>返回值是引入的对象</strong></p><p>这里需要注意，当参数为相对路径时，必须以.或者..开头</p><p><strong>2.模块定义</strong></p><p>在Node中，一个JS文件就是一个模块，<strong>并且每一个JS文件中的代码都是独立运行在一个函数中的</strong>，所以一个模块中的变量和函数在其他模块中无法访问（除非exports）</p><p><strong>3.模块标识</strong></p><p>通过exports.v这种形式来暴露内容，exports相当于该模块暴露出去的部分</p><p>能够通过模块标识找到该模块，具体模块标识参见下述内容</p></blockquote><p>模块分为两个大类：</p><blockquote><p><strong>核心模块</strong></p><p>由node引擎提供的模块，其标识是模块的名字</p><p>（意味着不需要使用相对路径，直接把模块名字作为require的参数即可）</p><p><strong>文件模块</strong></p><p>由用户自己创建的模块，其标识是文件的路径</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>建立这样一个目录结构</p><p>暴露test2中的内容</p><p><img src="https://img-blog.csdnimg.cn/e5804265e8a74740844c0337c8b34e42.png" alt="在这里插入图片描述"></p><p>test引入</p><p><img src="https://img-blog.csdnimg.cn/b338ffd0591742faa652c66b24f0b72d.png" alt="在这里插入图片描述"></p><p>运行结果</p><p><img src="https://img-blog.csdnimg.cn/3d69ffb803894c1ebb56d5ba1b51cdf4.png" alt="在这里插入图片描述"></p><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>在COMMONJS之后呢，还出现了一种叫做<strong>AMD</strong>（Asynchronous Module Definition，异步模块定义）的规范，形如：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'getSum'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'math'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">math</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'sum: '</span> <span class="token operator">+</span> math<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">var</span> exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     exports<span class="token punctuation">.</span><span class="token function-variable function">method</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> exports<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它只有一个接口，那就是<code>define</code>，把要模块化的内容包起来，Node就可以看做是做了隐式的define包装</p><p><strong>RequireJS</strong>就是实现了AMD的著名例子（注意AMD只是规范，Require.JS是其实现）</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>提到了AMD就顺带一提CMD，CMD很多地方和AMD类似</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span>exports<span class="token punctuation">,</span>module</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而<strong>Sea.JS</strong>就是实现了CMD的著名例子</p><h2 id="模块的函数本质"><a href="#模块的函数本质" class="headerlink" title="模块的函数本质"></a>模块的函数本质</h2><h3 id="global全局对象"><a href="#global全局对象" class="headerlink" title="global全局对象"></a>global全局对象</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">a <span class="token operator">=</span> <span class="token number">5</span><span class="token comment">// 记住这种声明是直接变成全局变量</span><span class="token comment">// 全局变量保存在global中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/e0887ebae6cf4949af6c5cf57aefe687.png" alt="在这里插入图片描述"></p><h3 id="证明模块的函数本质"><a href="#证明模块的函数本质" class="headerlink" title="证明模块的函数本质"></a>证明模块的函数本质</h3><p>上面的内容有提到过，模块内的变量和函数相当于是放到一个函数中的，那么如何证明呢？</p><p>答案是函数特有的<strong>伪数组对象arguments</strong></p><p><img src="https://img-blog.csdnimg.cn/ffc860c0d7a0456d84c70f36bb1c218f.png" alt="在这里插入图片描述"></p><p>那么我们能不能瞅瞅这个函数呢？</p><p>当然可以，<strong>arguments里有一个叫callee的方法</strong>，查看当前执行的函数对象</p><p><img src="https://img-blog.csdnimg.cn/587f1cdae0e546a0aa2501bf99d303bd.png" alt="在这里插入图片描述"></p><p>橙色的部分是通过字符串拼接，让对象调用了toString方法变成字符串达到展开的效果，也就是说效果和下面这段代码等价</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>callee<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>总结一下就是，模块会把内容（包括注释）装进一个这样的函数里面</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">exports<span class="token punctuation">,</span> require<span class="token punctuation">,</span> module<span class="token punctuation">,</span> __filename<span class="token punctuation">,</span> __dirname</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//这是模块的内容 </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以除了隐式声明之外，模块中写的内容都是局部的。</p><h3 id="五个参数"><a href="#五个参数" class="headerlink" title="五个参数"></a>五个参数</h3><p>通过观察参数，我们发现exports，require是通过参数传递进来的，而剩下三个参数则是</p><p><img src="https://img-blog.csdnimg.cn/b98f8f43973c4aeead9a13fd79058e0c.png" alt="在这里插入图片描述"></p><p>总结就是</p><table><thead><tr><th align="left">名称</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">exports</td><td align="left">用来将变量或函数暴露到外部的对象</td></tr><tr><td align="left">requires</td><td align="left">用来引入外部模块的函数</td></tr><tr><td align="left">module</td><td align="left">代表当前模块本身的对象，<strong>exports是其属性</strong></td></tr><tr><td align="left">__filename</td><td align="left">当前模块的完整路径</td></tr><tr><td align="left">__dirname</td><td align="left">当前模块所在的目录文件的完整路径</td></tr></tbody></table><p>上面提到了，exports是module的一个属性，那么我们就要讨论一下<strong>module.exports和直接exports</strong></p><h3 id="比较两种导出方式"><a href="#比较两种导出方式" class="headerlink" title="比较两种导出方式"></a>比较两种导出方式</h3><p>首先复习一下<strong>栈内存</strong>和<strong>堆内存</strong></p><blockquote><p><strong>栈内存</strong></p><p>以键值对的形式存放变量名和变量值</p><p><strong>堆内存</strong></p><p>存放引用数据类型的内容，比如对象的内容和对象的地址</p><p>（栈内存中存放对象名和对象的地址）</p></blockquote><p>那么，以下代码的执行结果是？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> obj2 <span class="token operator">=</span> objobj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'帅'</span>obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'俊'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">,</span> obj2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/0dc7b1368ee74ce998f6c8e0632d4604.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> obj2 <span class="token operator">=</span> objobj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'帅'</span>obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'俊'</span>obj2 <span class="token operator">=</span> <span class="token keyword">null</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/b86e862380924e879241a1da4cfb1747.png" alt="在这里插入图片描述"></p><p>总结就是修改obj.name是修改的对象，修改obj只是修改指向</p><p>那么同样的，对于exports和module.exports也是一样</p><p>首先在test3.js里写下如下代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">exports<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'试图导出一条信息a'</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    b<span class="token operator">:</span> <span class="token string">'module.exports修改的是导出对象本身'</span><span class="token punctuation">}</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    c<span class="token operator">:</span> <span class="token string">'直接exports修改的是exports的指向'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/b628b84dc37c4a97abcb6c0d14bfd6c5.png" alt="在这里插入图片描述"></p><p>在test.js中则写下如下代码:</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> test3 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./test3.js'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test3<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/1c8ea9f8b94a4e129f837221c00c1bc1.png" alt="在这里插入图片描述"></p><p>我们先来分析一下，</p><p>之前我们可以通过exports.v这种形式添加暴露的内容，是因为exports指向了module.exports，require返回的是module.exports，所以我们的结果是</p><p><img src="https://img-blog.csdnimg.cn/125dd864a33847dd9783acf9244ce118.png" alt="在这里插入图片描述"></p><p>但是如果我们把test3.js中的代码顺序调整为</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token string">'module.exports修改的是导出对象本身'</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    c<span class="token operator">:</span> <span class="token string">'直接exports修改的是exports的指向'</span><span class="token punctuation">}</span>exports<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'试图导出一条信息a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/886ed2fd0c6647a895190d56957bc3cf.png" alt="在这里插入图片描述"></p><p>运行结果则是</p><p><img src="https://img-blog.csdnimg.cn/b8421e380f0f47af8fca910a0464467a.png" alt="在这里插入图片描述"></p><p>所以建议都使用对象调用内部成员的方式来暴露信息</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><blockquote><p>COMMONJS的包规范由<strong>包结构</strong>和<strong>包描述文件</strong>两个部分组成</p><p><strong>包结构</strong></p><p>用于组织包中的各种文件</p><p><strong>包描述文件</strong></p><p>描述包的相关信息，以供外部读取分析</p><p>包规范允许我们将一组先关的模块组合到一起，形成一组完整的工具</p></blockquote><h3 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h3><blockquote><p>包实际上就是一个压缩文件，解压后应该还原为目录。</p><p>一个标准的目录应该包含如下文件：</p><p><strong>1.package.json 描述文件（必有）</strong></p><p>2.bin 可执行二进制文件</p><p>3.lib js代码</p><p>4.doc 文档</p><p>5.test 单元测试</p></blockquote><h3 id="包描述文件"><a href="#包描述文件" class="headerlink" title="包描述文件"></a>包描述文件</h3><blockquote><p>包描述文件用于表达非代码相关的信息，</p><p>它是一个JSON文件，<strong>也就是package.json</strong>，这是包的标志。</p><p>位于包的根目录下，是包的重要的组成部分。</p></blockquote><p>举个例子，打开一个vue项目就能发现package.json</p><p><img src="https://img-blog.csdnimg.cn/e4f7e6e0918840088cd25479c3e74bee.png" alt="在这里插入图片描述"></p><p>其中，会发现版本号前面可能有~或者^符号，这是<strong>版本号的语义化</strong>（虽然我没看出来哪里语义化）</p><blockquote><p><strong>~<strong>代表强调小版本，指的是形如</strong>x.y.z</strong>的版本号上的z这一位，更新时会尽可能增大z来更新</p><p><strong>^</strong>同理，代表中版本，指的是y这一位，</p></blockquote><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><blockquote><p>Node Package Manager,Node包管理工具，</p><p>COMMONJS包规范是理论，NPM是一种实践，</p><p>对于Node而言，NPM帮助其完成了第三方模块的发布、安装和依赖等。</p><p>借助NPM，Node与第三方模块之间形成了很好的一个生态系统</p></blockquote><p>由于经常使用NPM，所以这部分稍微讲其他生疏一些的内容</p><h3 id="初始化包"><a href="#初始化包" class="headerlink" title="初始化包"></a>初始化包</h3><p>执行下面这行shell指令开启初始化流程</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/61c55926ced143229f53f3e01e49ca02.png" alt="在这里插入图片描述"></p><p>经过上述的一番操作之后，就会产生一个package.json文件，之后Node就会把当前文件夹视为一个包</p><p><img src="https://img-blog.csdnimg.cn/bc26e1ed1aa544599bfe81bdaf48bbc9.png" alt="在这里插入图片描述"></p><h3 id="下载包"><a href="#下载包" class="headerlink" title="下载包"></a>下载包</h3><p>其中的xxx是具体的包名</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里以math为例</p><p><img src="https://img-blog.csdnimg.cn/f7333ad07c874c86a2aaf57c04ab93cc.png" alt="在这里插入图片描述"></p><p>此后新增内容：</p><blockquote><p><strong>1.node_modules文件夹</strong></p><p>其中包括了下载的包，比如这里下载的math。</p><p><strong>2.package-lock.json</strong></p><p>锁定安装时的版本号，并上传到git，保证其他用户在npm install下载的时候依赖保持一致。</p><p>package.json文件只能锁定大版本，也就是版本号的第一位，并不能锁定小版本，每次npm install就会拉取该大版本下最新的小版本。</p><p>package-lock.json则是在每次安装一个依赖的时候就锁定在安装这个版本。</p></blockquote><h3 id="使用包"><a href="#使用包" class="headerlink" title="使用包"></a>使用包</h3><p>在初始化的时候，我们设置了entry point为main.js，这就要求我们在根目录下新建一个main.js作为主函数（不知道该怎么称呼，暂时称为主函数好了）</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 因为是从NPM下载的，可以视为Node提供的，即核心模块，所以可以直接写名字引入</span><span class="token keyword">let</span> math <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'math'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是math:'</span><span class="token punctuation">,</span> math<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'===================================='</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'调用math的add方法：'</span><span class="token punctuation">,</span> math<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'===================================='</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'调用math的sum方法：'</span><span class="token punctuation">,</span> math<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意Node搜索包的过程是，首先搜索当前目录下的node_modules，在其中搜到了目标内容则直接使用；</p><p>否则进入上一级目录重复上述过程，递归直至搜索成功或搜索完根目录。</p><h3 id="常用操作指令"><a href="#常用操作指令" class="headerlink" title="常用操作指令"></a>常用操作指令</h3><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td>npm -v</td><td>查看npm的版本</td></tr><tr><td>npm version</td><td>查看所有模块的版本</td></tr><tr><td>npm search [包名]</td><td>搜索包</td></tr><tr><td>npm install [?包名]</td><td>安装包，不加参数则安装所有依赖的包<br>如果在指令末尾加上–save<br>那么会把该包添加进package.json的依赖<br>如果在指令末尾加上 -g<br>那么会全局安装包（一般是全局安装工具）</td></tr><tr><td>npm remove [包名]</td><td>删除包</td></tr><tr><td>npm init</td><td>初始化包</td></tr></tbody></table><h3 id="CNPM"><a href="#CNPM" class="headerlink" title="CNPM"></a>CNPM</h3><blockquote><p>NPM的服务器是在国外，下载速度有时比较慢。</p><p>CNPM则是在国内的镜像服务器，相对更稳定。</p></blockquote><p>cnpm下载的内容不会覆盖npm下载的内容，其名称会有相应的标识。</p><h2 id="Buffer缓冲区"><a href="#Buffer缓冲区" class="headerlink" title="Buffer缓冲区"></a>Buffer缓冲区</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><blockquote><p>从结构上来看，Buffer和数组很像。但是相较于数组，Buffer性能更好，而且能够存储图片音频等<strong>二进制文件</strong>数据。</p></blockquote><p>使用Buffer不需要引入模块，直接使用即可：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'Hello World'</span><span class="token keyword">let</span> buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/90e6854a9ce24577a2b04c9d00fee6b6.png" alt="在这里插入图片描述"></p><p><strong>数值对应的是unicode编码而不是ascii编码</strong></p><p>存储的是二进制，但是打印出来的时候是十六进制，（因为二进制太长可读性太差），由于是两位数，所以取值范围是00-ff，即00-255，分别<strong>对应8位二进制0和1，即一个字节</strong></p><h3 id="缓冲区的长度计算"><a href="#缓冲区的长度计算" class="headerlink" title="缓冲区的长度计算"></a>缓冲区的长度计算</h3><p>结合上面的内容，我们来分析下述代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'你好,世界'</span><span class="token keyword">let</span> buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'缓冲区大小'</span><span class="token punctuation">,</span>buf<span class="token punctuation">.</span>length<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'字符串大小'</span><span class="token punctuation">,</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>str的长度肯定是5，但是buf的长度又如何呢？</p><p>其中逗号采用的是英文逗号，而buf存储的又是字节，<strong>读入字符串时，默认采用UTF-8</strong>，而<strong>在UTF-8，汉字占3个字节</strong>，所以结果应该是4*3+1 = 13</p><p><img src="https://img-blog.csdnimg.cn/c4014e150bdc4fca8ca88b8069e59472.png" alt="在这里插入图片描述"></p><p>当然，我们可以创建指定长度的buffer</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// let buf2 = new Buffer(10) // 这种写法已经被删除</span><span class="token keyword">let</span> buf3 <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment">// 推荐使用这种写法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意，Buffer的构造方法都已经废除了（就是别new了）</p><h3 id="缓冲区的内容"><a href="#缓冲区的内容" class="headerlink" title="缓冲区的内容"></a>缓冲区的内容</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> buf3 <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment">// 推荐使用这种写法</span>buf3<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">15</span>buf3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x15</span>buf3<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">,</span> buf3<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">256</span><span class="token punctuation">,</span> buf3<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">257</span>buf3<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x11</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf3<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf3<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/ba5b7b449d0c401cb523320f1fb148c3.png" alt="在这里插入图片描述"></p><p>观察结果，我们可以发现</p><blockquote><p>1.支持下标访问，自动转化为十六进制</p><p>2.静态且连续，不会动态扩容，越界非法访问无效</p><p>3.值会对最大值（255）进行取模运算（只保留二进制后八位）</p></blockquote><p>并且在单独打印某个值时，它一定是十进制</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">buf3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x15</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出结果是1 * 16 + 5，即 21</p><p>那么，要怎么指定进制输出呢？</p><p>（竟然是toString方法，完了忘完了）</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是十进制:'</span><span class="token punctuation">,</span> buf3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是二进制:'</span><span class="token punctuation">,</span> buf3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是十六进制:'</span><span class="token punctuation">,</span> buf3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出结果分别是：21,10101,15</p><p>接下来，我们来看看Buffer的不安全分配：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> buf4 <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">let</span> buf5 <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">allocUnsafe</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'安全分配:'</span><span class="token punctuation">,</span> buf4<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'不安全分配:'</span><span class="token punctuation">,</span> buf5<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果是：</p><blockquote><p>安全分配: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;<br>不安全分配: &lt;Buffer 20 91 0b d1 46 02 00 00 60 92&gt;</p></blockquote><p>安全分配会将内容全部清空（归零）</p><p>不安全分配则会保留该部分内存的内容，省略一步操作其实性能还会好些（但是确实不安全啊）</p><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>太多了懒得写，直接看官方文档</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>服务器接收用户的二进制数据都先存到缓冲区等待处理</p><p>其余内容参见操作系统部分</p><h2 id="FS文件系统"><a href="#FS文件系统" class="headerlink" title="FS文件系统"></a>FS文件系统</h2><p>终于，要操作文件了</p><blockquote><p>file system文件系统</p><p>所有操作都会有两种形式可供选择：同步和异步</p><p>之后的方法都会有两种形式：</p><p>一种名为xxxSync（同步），则一定有另一种名为xxx（异步）</p></blockquote><h3 id="同步写入"><a href="#同步写入" class="headerlink" title="同步写入"></a>同步写入</h3><p>首先想一下文件写入的步骤：</p><blockquote><p><strong>1.打开文件</strong></p><p>openSync(path，flags [, mode])</p><ul><li>path 文件路径</li><li>flags 操作的类型： r读； w写；</li><li>mode 可选参数，设置文件权限，一般不写</li></ul><p>没有该文件则会创建该文件。</p><p>返回值是一个该文件的描述符，可以通过该描述符操作对应文件。<strong>通常是一个数字</strong>。</p><p><strong>2.向文件中写入内容</strong></p><p>writeSync(fd, string [,position [, encoding]])</p><ul><li>fd 文件描述符</li><li>string 写入内容</li><li>position 写入起始位置，一般不写</li><li>encoding 编码格式，默认utf-8</li></ul><p><strong>3.保存并关闭文件</strong></p><p>fs.closeSync(fd)</p><ul><li>fd  同上，文件描述符</li></ul></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> fd <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">openSync</span><span class="token punctuation">(</span><span class="token string">'text.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span>fs<span class="token punctuation">.</span><span class="token function">writeSync</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token string">'今天天气真不戳'</span><span class="token punctuation">)</span>fs<span class="token punctuation">.</span><span class="token function">writeSync</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token string">'我要从第五十格开始写'</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token comment">// 其实是从五十一格开始写</span>fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/5f6e6027b4f04872ac9cb9fbbe6d2be0.png" alt="在这里插入图片描述"></p><p>如果不指定位置，那么会直接清空原内容，写入新内容</p><p>当然有时候会发生两部分内容重叠导致的乱码…</p><h3 id="异步写入"><a href="#异步写入" class="headerlink" title="异步写入"></a>异步写入</h3><blockquote><p><strong>1.打开文件</strong></p><p>open(path，flags [, mode]，callback)</p><ul><li>path 文件路径</li><li>flags 操作的类型： r读； w写；</li><li>mode 可选参数，设置文件权限，一般不写</li><li><strong>callback 回调函数：两个参数，第一个为err（错误优先思想），没有错误则为null；第二个为fd，文件描述符</strong>，</li></ul><p>没有该文件则会创建该文件。</p><p>没有返回值。</p><p><strong>2.向文件中写入内容</strong></p><p>writeSync(fd, string [,position [, encoding]])</p><ul><li>fd 文件描述符</li><li>string 写入内容</li><li>position 写入起始位置，一般不写</li><li>encoding 编码格式，默认utf-8</li></ul><p><strong>3.保存并关闭文件</strong></p><p>closeSync(fd)</p><ul><li>fd  同上，文件描述符</li></ul></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>fs<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'text2.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> fd</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        fs<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token string">'啊，这个兽偶好好看的哇~'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'文件写入成功'</span><span class="token punctuation">)</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'文件写入出错'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>            <span class="token punctuation">}</span>            fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'文件关闭成功'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'文件关闭出错'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'文件打开出错'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>学到这里才意识到，一般而言异步函数是没有返回值的，多半是把结果放到参数里面来保存的</p><p>上面这个结构也让我更好的认识到了<strong>回调地狱</strong></p><h3 id="简单写入（异步封装）"><a href="#简单写入（异步封装）" class="headerlink" title="简单写入（异步封装）"></a>简单写入（异步封装）</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">writeFile</span><span class="token punctuation">(</span><span class="token string">'text3.txt'</span><span class="token punctuation">,</span> <span class="token string">'来啊放纵啊，反正有——大把时光~~'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'成功写入，稳如老狗'</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个对异步写入的封装</p><p>当然，简单文件写入方法还有其更多参数，比如可以传一个options对象，包括encoding编码格式，mode权限以及flag操作模式等等（可以通过修改flag为r来把方法变为读）</p><p>这个方法似乎没法指定从某一个位置开始写</p><p><img src="https://img-blog.csdnimg.cn/4991b8d7c3e54e679742abc3d407c82d.png" alt="在这里插入图片描述"></p><p>那如何追加而不是替换内容，我们参考上表，将flag操作模式的值设置为a再次尝试</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">writeFile</span><span class="token punctuation">(</span><span class="token string">'text3.txt'</span><span class="token punctuation">,</span> <span class="token string">'来啊，快活啊~~'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>flag<span class="token operator">:</span><span class="token string">'a'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'成功写入，稳如老狗'</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/26adef648984481a9881f1f1e821e64f.png" alt="在这里插入图片描述"></p><h3 id="流式写入"><a href="#流式写入" class="headerlink" title="流式写入"></a>流式写入</h3><blockquote><p>同步、异步、简单写入都不适合大文件的写入，性能都比较差，容易导致内存溢出</p><p>流式写入则可以持续的、一部分一部分地写入文件</p><p>比喻就是，从水池A向水池B引水，流式输入就是两个水池间连接的管道——<strong>请记住这个比喻</strong></p></blockquote><p>最简单步骤是</p><blockquote><p><strong>1.创建一个可写流</strong></p><p>createWriteStream(path [,options])</p><p>返回一个可写流对象</p><p><strong>2.写入</strong></p><p>write(string)</p><p><strong>3.关闭可写流</strong></p><p>close() 或者 end（）</p><p>这里比喻一下：两个方法都是把管道拔掉，但是close是拔掉对面那头，end是拔掉我们这头。</p><p>区别在于，当我们把水都引入管道后，我们并不知道水是否已经进入对面的水池，拔掉对面那头的话可能导致还在管道中的水丢失；所以我们一般是先拔掉我们这边这头。</p><p>但是随着版本更迭，close可能出现的弊端似乎也得到了很好的修正（？管他的反正先end吧）</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token keyword">let</span> ws <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">'text3.txt'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是可写流对象'</span><span class="token punctuation">,</span>ws<span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>ws<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">' '</span><span class="token punctuation">)</span>ws<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/3118d3a8dd164cd58a15e7dab3699731.png" alt="在这里插入图片描述"></p><p>默认的操作模式是w，也是对内容进行覆盖</p><p><img src="https://img-blog.csdnimg.cn/d5ec5b69d0db4c63a2e825f3a5d3cc9c.png" alt="在这里插入图片描述"></p><p>我们还可有更多操作</p><p><strong>监听</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token keyword">let</span> ws <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">'text3.txt'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>flag<span class="token operator">:</span><span class="token string">'a'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>ws<span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">'open'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'流打开了'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">// console.log('这是可写流对象',ws)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>ws<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">' '</span><span class="token punctuation">)</span>ws<span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'流关闭了'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>ws<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>once和on一样，能够添加时间，但是once是只能触发一次的</p><h3 id="简单读取（异步封装）"><a href="#简单读取（异步封装）" class="headerlink" title="简单读取（异步封装）"></a>简单读取（异步封装）</h3><p>文件读取和写入也是一一对应的，也分为四种：同步异步简单流式，前两种几乎和写入没有区别，所以不再赘述</p><p>流程也不再赘述，直接上代码</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'text2.txt'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">//才想起来啊，throw直接抛出错误啊</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>         <span class="token keyword">throw</span> err    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是数据'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果如下</p><blockquote><p>这是数据 &lt;Buffer e5 a4 a9 e6 b0 94 e7 9c 9f e4 b8 8d e6 88 b3&gt;</p></blockquote><p>是十六进制的嘛，这咋看哦——这个时候就得归功于我们万能的toString了，原来它不只是能够转进制，还能直接给翻译回去，是真滴牛啤啊</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'text2.txt'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>         <span class="token keyword">throw</span> err    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是数据:'</span><span class="token punctuation">,</span> <span class="token operator">...</span>data<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'处理一手:'</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而且我还发现，可以对buffer用展开运算符，展开之后直接变十进制，简直帅死了</p><p>输出结果如下：</p><blockquote><p>这是数据: 229 164 169 230 176 148 231 156 159 228 184 141 230 136 179<br>处理一手: 天气真不戳</p></blockquote><p>注意，这里可不只是能够读文本，还可以读图片等超文本</p><p>比如像下面这样</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'pic.png'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token keyword">throw</span> err    <span class="token keyword">let</span> biPic <span class="token operator">=</span> data      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>biPic<span class="token punctuation">)</span>       fs<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'pic2.png'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> fd</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>            <span class="token keyword">throw</span> err        fs<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> biPic<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>                <span class="token keyword">throw</span> err            fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="流式读取"><a href="#流式读取" class="headerlink" title="流式读取"></a>流式读取</h3><blockquote><p>大家或许会觉得依葫芦画瓢，写是怎么样读就怎么样，但是流式读取还真不是那样的。</p><p><strong>监听data事件</strong></p><p>监听可读流访问数据</p><p>懒得多说了直接上代码</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> rs <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token string">'video.mp4'</span><span class="token punctuation">)</span>rs<span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">'open'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'开启流'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>rs<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>rs<span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'关闭流'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可读流似乎不用手动关闭，一旦读取完毕自动关闭</p><p><img src="https://img-blog.csdnimg.cn/5c968742b0e34c0ab8f73acf06da8c6a.png" alt="在这里插入图片描述"></p><p>总之就是非常大的数据啦</p><p>结合可写流，我们能够实现视频的复制：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token keyword">let</span> rs <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token string">'video.mp4'</span><span class="token punctuation">)</span><span class="token keyword">let</span> ws <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">'video2.mp4'</span><span class="token punctuation">)</span>rs<span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">'open'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'可读流---开启'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>rs<span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'可读流---关闭'</span><span class="token punctuation">)</span>    <span class="token comment">// 可读流关闭，那么可写流也可以关闭了</span>    ws<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>ws<span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">'open'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'可写流---开启'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>ws<span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'可写流---关闭'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>rs<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就实现了一个文件的复制</p><p>当然上述内容太麻烦了，这里还有一种更为简单的方法<strong>管道</strong></p><p>管道的具体概念参见操作系统，使用方式如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">rs<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>ws<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就建立起了rs和ws之间的管道，将可读流的内容输出到可写流中，是对之前的代码的一次封装</p><h3 id="其他操作-1"><a href="#其他操作-1" class="headerlink" title="其他操作"></a>其他操作</h3><p><strong>验证路径是否存在</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token comment">//已经废止,用fs.stat替代</span>fs<span class="token punctuation">.</span><span class="token function">existsSync</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>获取文件信息</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">stat</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> fs<span class="token punctuation">.</span><span class="token function">statSync</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>删除文件</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">unlink</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>fs<span class="token punctuation">.</span><span class="token function">unlinkSync</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然还有更多方法，具体使用参阅<a href="http://nodejs.cn/api/fs.html">官方文档</a></p><h2 id="常用核心模块及其API"><a href="#常用核心模块及其API" class="headerlink" title="常用核心模块及其API"></a>常用核心模块及其API</h2><h3 id="url模块"><a href="#url模块" class="headerlink" title="url模块"></a>url模块</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> url <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>url.parse()</strong></p><p>第一个参数是url字符串，返回一个<strong>URL对象</strong>，具有protocol、hostname、query、path等属性</p><p>第二个参数如果为true，则会将query再解析为对象</p><p><strong>url.format()</strong></p><p>将URL对象转为URL字符串</p><p><strong>url.resolve()</strong></p><p>用于URL拼接，能够识别相对路径等</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'/one/two/three'</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">)</span> <span class="token keyword">var</span> b <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'http://example.com/'</span><span class="token punctuation">,</span> <span class="token string">'/one'</span><span class="token punctuation">)</span><span class="token keyword">var</span> c <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'http://example.com/one'</span><span class="token punctuation">,</span> <span class="token string">'/two'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> d <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'http://example.com/one/ddd/ddd/ddd'</span><span class="token punctuation">,</span> <span class="token string">'./two'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> e <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'http://example.com/one/ddd/ddd/ddd'</span><span class="token punctuation">,</span> <span class="token string">'../two'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> f <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'http://example.com/one/ddd/ddd/ddd'</span><span class="token punctuation">,</span> <span class="token string">'.../two'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span> b <span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span> c<span class="token operator">+</span><span class="token string">','</span><span class="token operator">+</span>d<span class="token operator">+</span><span class="token string">','</span><span class="token operator">+</span>e<span class="token operator">+</span><span class="token string">','</span><span class="token operator">+</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>//输出结果：<br>/one/two/four,<br><a href="http://example.com/one">http://example.com/one</a>,<br><a href="http://example.com/two">http://example.com/two</a>,<br><a href="http://example.com/one/ddd/ddd/two">http://example.com/one/ddd/ddd/two</a>,<br><a href="http://example.com/one/ddd/two">http://example.com/one/ddd/two</a><br><a href="http://example.com/one/ddd/ddd/.../two">http://example.com/one/ddd/ddd/.../two</a></p></blockquote><h3 id="querystring模块"><a href="#querystring模块" class="headerlink" title="querystring模块"></a>querystring模块</h3><p><strong>querystring.escape()</strong></p><p>编码，在接下来的stringify等方法中会自动调用这个方法</p><p>作用是将中文转化为编码字符</p><p><strong>querystring.unescape()</strong></p><p>解码，能够将编码的字符还原为原本的文字</p><p><strong>querystring.parse()</strong></p><p>反序列化，将query字符串转化为Query对象</p><p><strong>querystring.stringify()</strong></p><p>序列化，将Query对象转化为query字符串</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">querystring<span class="token punctuation">.</span><span class="token function">stringify</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">"a"</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个参数是操作的对象，<br>第二个参数是指定键值对间分隔方式，<br>第三个参数可省略，默认值为:，指定键值间分隔方式</p><p>第四个参数可省略，用于配置，详情查阅官方文档</p><p>结果</p><blockquote><p>“name:a，age:1”</p></blockquote><h3 id="https模块"><a href="#https模块" class="headerlink" title="https模块"></a>https模块</h3><p>和http的方法基本上都一样</p><p><strong>https爬虫</strong></p><p>非常容易，代码如下</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> https <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">'https'</span><span class="token punctuation">)</span><span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token string">'https://uland.taobao.com/sem/tbsearch'</span>https<span class="token punctuation">.</span><span class="token function">get</span> <span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> html <span class="token operator">=</span> <span class="token string">''</span>    res<span class="token punctuation">.</span><span class="token function">on</span> <span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        html <span class="token operator">+=</span> chunk    <span class="token punctuation">}</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">on</span> <span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">on</span> <span class="token punctuation">(</span><span class="token string">'err'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>cheerio</strong></p><p>用于内容筛选，是第三方包，需要先npm安装</p><p>其语法类似JQ，筛选方式是用CSS选择器的形式筛选：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> cheerio <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">'cheerio'</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">filter</span> <span class="token punctuation">(</span><span class="token parameter">html</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> $ <span class="token operator">=</span> cheerio<span class="token punctuation">.</span><span class="token function">load</span> <span class="token punctuation">(</span>html<span class="token punctuation">)</span>    <span class="token keyword">const</span> footer <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#alimama-footer'</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment">// console.log(footer)</span>    footer<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">index<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        text<span class="token punctuation">.</span><span class="token function">push</span> <span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> text<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842551f8a2363614ee4b3de5ee3f73f426846700acfef20a07e/0.png" alt="部分运行结果"></p><p><strong>request</strong></p><p>可以看做封装的AJAX，能发起请求，也能拿到响应</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> https <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">'https'</span><span class="token punctuation">)</span><span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>    hostname<span class="token operator">:</span> <span class="token string">'api.douban.com'</span><span class="token punctuation">,</span>    port<span class="token operator">:</span> <span class="token number">443</span><span class="token punctuation">,</span>    method<span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span>    path<span class="token operator">:</span> <span class="token string">'v2/movie/top250'</span><span class="token punctuation">}</span><span class="token keyword">const</span> request <span class="token operator">=</span> https<span class="token punctuation">.</span><span class="token function">request</span> <span class="token punctuation">(</span>options<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span> <span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>request<span class="token punctuation">.</span><span class="token function">on</span> <span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">error</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>request<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842551f8a2363614ee43b912b2805ca3113d2007e4f73c06a45/0.png" alt="拿到了response的所有信息"></p><p>当然也可以这样拿</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> request <span class="token operator">=</span> https<span class="token punctuation">.</span><span class="token function">request</span> <span class="token punctuation">(</span>options<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">// console.log (response) </span>    response<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span>    <span class="token comment">// 不设置编码格式的话默认是buffer</span>    <span class="token comment">// 设置为utf8之后返回的是JSON</span>    response<span class="token punctuation">.</span><span class="token function">on</span> <span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们要发起post请求，那么需要像下面这样</p><p>这是一个自动评论b站视频的脚本，这里由于个人隐私，部分数据以xxx代替</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> https <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">'https'</span><span class="token punctuation">)</span><span class="token keyword">const</span> qs <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">'querystring'</span><span class="token punctuation">)</span><span class="token keyword">const</span> postData <span class="token operator">=</span> qs<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token string">'oid'</span><span class="token operator">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span>    <span class="token string">'type'</span><span class="token operator">:</span><span class="token string">'1'</span><span class="token punctuation">,</span>    <span class="token string">'message'</span><span class="token operator">:</span><span class="token string">'发个评论测试一下'</span><span class="token punctuation">,</span>    <span class="token string">'plat'</span><span class="token operator">:</span><span class="token string">' 1'</span><span class="token punctuation">,</span>    <span class="token string">'ordering'</span><span class="token operator">:</span><span class="token string">'heat'</span><span class="token punctuation">,</span>    <span class="token string">'jsonp'</span><span class="token operator">:</span><span class="token string">'jsonp'</span><span class="token punctuation">,</span>    <span class="token string">'csrf'</span><span class="token operator">:</span><span class="token string">'xxx'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>    hostname<span class="token operator">:</span> <span class="token string">'api.bilibili.com'</span><span class="token punctuation">,</span>    port<span class="token operator">:</span> <span class="token string">'443'</span><span class="token punctuation">,</span>    method<span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>    path<span class="token operator">:</span> <span class="token string">'/x/v2/reply/add'</span><span class="token punctuation">,</span>    header<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token comment">// xxx</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> request <span class="token operator">=</span> https<span class="token punctuation">.</span><span class="token function">request</span> <span class="token punctuation">(</span>options<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span> <span class="token punctuation">(</span><span class="token string">'请求结果'</span><span class="token punctuation">,</span> response<span class="token punctuation">.</span>statusCode<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>request<span class="token punctuation">.</span><span class="token function">on</span> <span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">error</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>request<span class="token punctuation">.</span><span class="token function">write</span> <span class="token punctuation">(</span>postData<span class="token punctuation">)</span>request<span class="token punctuation">.</span><span class="token function">end</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="事件模块"><a href="#事件模块" class="headerlink" title="事件模块"></a>事件模块</h3><p><strong>Events类</strong></p><p>注意这个是一个类，所以我们继承一下方便扩展</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> Events <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">'events'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Player</span> <span class="token keyword">extends</span> <span class="token class-name">Events</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">const</span> player <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Player</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>emit()</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">player<span class="token punctuation">.</span><span class="token function">on</span> <span class="token punctuation">(</span><span class="token string">'play'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">title</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">正在播放:《</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>title<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">》</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>player<span class="token punctuation">.</span><span class="token function">emit</span> <span class="token punctuation">(</span><span class="token string">'play'</span><span class="token punctuation">,</span> <span class="token string">'JAVA零基础到入坟'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>emit就是触发事件，第二个参数是作为事件的参数，可以考虑封装成对象然后传多个参数</p><p>这里用on的话，那么通过emit能够多次触发；</p><p>如果用once的话，那么就只能触发一次；</p><h3 id="文件模块（待补充）"><a href="#文件模块（待补充）" class="headerlink" title="文件模块（待补充）"></a>文件模块（待补充）</h3><p>也就是fs模块，我们在之前的<strong>FS</strong>文件系统章节已经说过了</p><p>这里再做一点补充，内容比较多，建议参考官方文档</p><table><thead><tr><th>关键词</th><th>名称</th></tr></thead><tbody><tr><td>stat</td><td>得到文件与目录的信息</td></tr><tr><td>mkdir</td><td>创建一个目录</td></tr><tr><td>writeFile <br>appendFile</td><td>创建文件并写入内容</td></tr><tr><td>readFile</td><td>读取文件的内容</td></tr><tr><td>readdir</td><td>列出目录的东西</td></tr><tr><td>rename</td><td>重命名目录</td></tr><tr><td>rmdir<br>unlink</td><td>删除目录与文件</td></tr></tbody></table><p><strong>常用操作</strong></p><p>(以后补充)</p><h3 id="stream模块"><a href="#stream模块" class="headerlink" title="stream模块"></a>stream模块</h3><p>在之前的章节已经提到过了(FS文件系统的流式写入)</p><p>这里（暂时）不做讨论</p><p><strong>pipe</strong></p><p>管道，也提过了</p><h3 id="async模块（待补充）"><a href="#async模块（待补充）" class="headerlink" title="async模块（待补充）"></a>async模块（待补充）</h3><p>需要npm安装</p><p><strong>串行无关联</strong></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote><p>前方是星辰大海，寻找知识，让世界成为你的画布！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对齐方式与幽灵节点</title>
      <link href="/2021/12/12/ghostnode/"/>
      <url>/2021/12/12/ghostnode/</url>
      
        <content type="html"><![CDATA[<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.box</span>{</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        }</span></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> {</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: lightskyblue;</span></span><br><span class="line"><span class="css">            </span></span><br><span class="line"><span class="css">        }</span></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> {</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">200px</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: blueviolet;</span></span><br><span class="line"><span class="css">        }</span></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> <span class="selector-tag">img</span> {</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">        }</span></span><br><span class="line"><span class="css">    </span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果如下</p><p><img src="https://img-blog.csdnimg.cn/c9358de6756540d9bda2ce2f874e2a35.png" alt="在这里插入图片描述"></p><h3 id="问题一：为什么出现了换行"><a href="#问题一：为什么出现了换行" class="headerlink" title="问题一：为什么出现了换行"></a>问题一：为什么出现了换行</h3><p><img src="https://img-blog.csdnimg.cn/9654e3ddaa4748d297e9a94c698f187a.png" alt="在这里插入图片描述"></p><p>照理来说，这个应该是恰好占满一行才对，但是从结果来看并没有。</p><p>经过和大佬的交流才知道，这是因为inline-block会产生空白间隙，所以需要再额外增加一些才能并列</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">210px</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="问题二：添加图片导致左右两部分错位"><a href="#问题二：添加图片导致左右两部分错位" class="headerlink" title="问题二：添加图片导致左右两部分错位"></a>问题二：添加图片导致左右两部分错位</h3><p><img src="https://img-blog.csdnimg.cn/2d47e4a414e642088ed4bcca6325e433.png" alt="在这里插入图片描述"></p><p>在解决了问题一之后，还有如上图所示的问题二</p><p><img src="https://img-blog.csdnimg.cn/504bfd394c384b49a129e668bd9597cb.png" alt="在这里插入图片描述"></p><p>我们先指明宽高，再看看结果</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> <span class="selector-tag">img</span> {</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/59b9d1ad2f1442e783b5e5f59657fd05.png" alt="在这里插入图片描述"></p><p>不断修改宽高（这里主要考虑高度对布局的影响）观察结果</p><p><img src="https://img-blog.csdnimg.cn/f0a412ae9a08467fa089d10f4cbe643e.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/f4eca0ec90e2470fbc40d32ecf6be793.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/63581c07c4354134bcdcfd964510899d.png" alt="在这里插入图片描述"></p><p>我们观察上图规律，可以看到图片放大，蓝色块反而偏移更少，而当height正好等于蓝色块高度时，偏移量刚好消失</p><p><img src="https://img-blog.csdnimg.cn/21f70ad1106642aea83d7b3f2e40138c.png" alt="在这里插入图片描述"></p><p>而超出这个值时，紫色块发生偏移</p><p>(经过和大佬的有效交流讨论后)</p><p>我们发现上述几个样例都有一个共同点，那就是图片底部始终和紫色块<strong>底部对齐</strong></p><p>这我们就联想到了对齐方式方面的因素，这可能是图片默认对齐方式为底部对齐导致的</p><p>所以我们给蓝色块添加如下样式:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vertical-align</span>: top;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/198af3fc6b464c3a8a39615d16faf602.png" alt="在这里插入图片描述"></p><p>果然，效果就很棒</p><p>经过大佬的推理和测试，上述情况不仅会由img标签产生，<strong>也会对文字生效</strong>，</p><p>因为文字也是有类似的对齐特性</p><p>（这也大概就是为什么vertical-align和text-align既对图片生效，又对文字生效的缘故了吧)</p><p>通过以上问题，我们应该更进一步地了解到一些东西：</p><h2 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们常用的几种对齐方式有</p><blockquote><p>1.顶线对齐 top</p><p>2.中线对齐 middle</p><p>3.基线对齐 baseline</p><p>4.底线对齐 bottom</p></blockquote><p>顶线中线这个还好理解，那么基线和底线又有什么区别呢？</p><p>还记得中学写英语作文的时候那个四线格吗？不记得也没关系，看看下图应该就知道了：</p><p><img src="https://img-blog.csdnimg.cn/d4cf1d0c6472440491ca93ef3e91be92.png" alt="在这里插入图片描述"></p><p>没错，我们可以认为，上述的四根线和图上的四线格由上自下一一对应</p><p><img src="https://img-blog.csdnimg.cn/3be31e8b7c5c4a3683996beb9e4d75d4.png"></p><p>需要复习的是，英文大多以基线（baseline）为底书写，</p><p>这就意味着我们在选择对齐方式的时候也要用这样的标准进行参考</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>基线对齐</strong></p><p>这是文字的默认对齐方式</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="selector-class">.left</span> {</span><br><span class="line">            <span class="attribute">display</span>: inline-block;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">            </span><br><span class="line">            <span class="attribute">font-size</span>: <span class="number">64px</span>;</span><br><span class="line">            <span class="attribute">vertical-align</span>: baseline;</span><br><span class="line">        }</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">            <span class="attribute">display</span>: inline-block;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">            <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">230px</span>);</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">140</span>, <span class="number">58</span>, <span class="number">211</span>);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">            哇偶fg</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">            哇偶fg</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/c906c3e678964dd09c9099dab58b8a92.png" alt="image-20211212150936358"></p><p>而且是对齐最后一行</p><p><img src="https://img-blog.csdnimg.cn/33934b3c3e1e4601b35986d6ada23a0e.png" alt="在这里插入图片描述"></p><h3 id="其他对齐方式"><a href="#其他对齐方式" class="headerlink" title="其他对齐方式"></a>其他对齐方式</h3><p><img src="https://img-blog.csdnimg.cn/1689e553d96f4b9bb44ddd193c30614f.png" alt="在这里插入图片描述"></p><h2 id="幽灵节点"><a href="#幽灵节点" class="headerlink" title="幽灵节点"></a>幽灵节点</h2><p>一开始我都以为问题解决了，结果龚老师又抛出这个概念叫我去学…</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">div</span>{</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: yellow;</span></span><br><span class="line"><span class="css">  }</span></span><br><span class="line"><span class="css">  <span class="selector-tag">span</span>{</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">  }</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>我们这里可没有给span和div任何高度啊</p><p><img src="https://img-blog.csdnimg.cn/159d9bf51e1c449f93b2fbe4daddc1c6.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/7fbb79966f8b4524a167add6485a0040.png" alt="在这里插入图片描述"></p><p>span宽高为0，这没有问题，那么这div是怎么回事，它的高度从何而来？</p><p>我们就将撑开div高的这个“看不见的节点”称为 <strong>幽灵节点</strong></p><blockquote><p>此处是是因为行级块（这里的span设置成了inline-block）渲染时，先会在这个行级块前面生成一个空白节点，宽度为0，并且 <strong>继承font-size，line-height属性，这里的font-size是16px，line-height是font-size + 行距，也就是此处的20.667px</strong></p></blockquote><p><strong>注意，这里的20.667px会因缩放而发生变化，所以对以下内容的数值计算不构成参考</strong></p><h3 id="分析一"><a href="#分析一" class="headerlink" title="分析一"></a>分析一</h3><p>我们进行如下修改，观察结果</p><p><strong>设置line-height为0</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"line-height: 0;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/a5b3c53df4d04ada8d6aa7a73f324bde.png" alt="在这里插入图片描述"></p><p><strong>设置font-size为0</strong></p><p>这里我的理解是，如果一行字的高度为0，那么行与行之间的距离也是0，</p><p>由于line-height = font-size + 行距，那么line-height也为0</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 0;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/b8fd975364f24a06b6fc237040829795.png" alt="在这里插入图片描述"></p><h3 id="分析二"><a href="#分析二" class="headerlink" title="分析二"></a>分析二</h3><p>当然，幽灵节点还有其他体现形式，比如：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">div</span>{</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: yellow;</span></span><br><span class="line"><span class="css">  }</span></span><br><span class="line"><span class="css">  <span class="selector-tag">img</span> {</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  }</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://xxx.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/ca801f364d0349e09c946ee99feba544.png" alt="在这里插入图片描述"></p><p>下方又出现了奇怪的空隙，这也是 <strong>幽灵节点的体现</strong>（因为img是内联块，所以也存在这种现象）</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>{</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ff3700</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">span</span>{</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/0c1f7635a4584ee5a715a6e676cbd5e6.png" alt="在这里插入图片描述"></p><blockquote><p>上一个例子中，还没有考虑vertical-align的影响，这里则是因为vertical-align和line-height一起作用的结果，</p><p>添加一点文字后我们发现，图片的默认对齐方式是基线对齐，所以和底部的间距其实是和底线的距离</p><p>（这里没有padding，文字的背景色大小是line-height决定的，这里</p></blockquote><p>让我们试着修改一下vertical-align</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/99429cceccb2455e8826f82a2652cd3d.png" alt="在这里插入图片描述"></p><p>简直妙不可言</p><p>根据龚老师的提示，还可以修改dispaly，因为只有inline-block或者inline才会出现这种现象</p><p>我们只需要将其修改为block就可以了</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> {</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>确实管用</p><p><img src="https://img-blog.csdnimg.cn/5212b9736ac84a6fb3d5bf70d8a7878c.png" alt="在这里插入图片描述"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>查资料的过程中，也是发现了大量重复的文段，感觉应该都是出自一位叫做 <strong>张鑫旭</strong>的大佬之手，下面这篇文章提供了相当全面的分析，甚至让我重新审视HTML和CSS——<a href="https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/">大佬的博文</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript6</title>
      <link href="/2021/12/10/es6/"/>
      <url>/2021/12/10/es6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>大概是半年前学的，当时放到CSDN上的，现在搬到自己博客上</p></blockquote><p>这是我学习ES6的笔记，语言偏向口语化，主要是个人觉得这样会比较亲切…</p><p>由于是学习笔记，内容可能会有不够详实，存在瑕疵等诸多问题，欢迎大家在评论区批评指正</p><p>希望接下来的内容能够在大家学习ES6的过程中给予一点帮助</p><p><strong>ES的定义</strong><br>即ECMAScript，脚本语言的规范</p><p>其中的ECMA的全称是全称：<em>European computer manufacturers association欧洲计算机制造联合会，后改名为ECMA国际</em>。</p><p>ES新特性指的是JavaScript的新特性.</p><p><strong>为什么学ES</strong><br>概括为—-更方便更高能</p><p>接下来进入正题：</p><h2 id="1-let声明"><a href="#1-let声明" class="headerlink" title="1.let声明"></a>1.let声明</h2><p><em>let a = 233，翻译就是让a等于233，简直语义化啊！</em></p><p><strong>使用方式（就是变量声明啦）</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">let</span> b, c;</span><br><span class="line"><span class="keyword">let</span> d = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> e = <span class="number">666</span>, f = <span class="string">'hhh'</span>, g = [];</span><br></pre></td></tr></tbody></table></figure><p>  <strong>特性</strong></p><ol><li>变量不能重复声明，否则报错<br>(没错，var是可以重复的)</li><li>增加块级作用域<br>（ES5中有三种作用域：全局、函数、严格模式中的eval）<br><del>C/C++转过来的简直感动</del> </li></ol><p>举个栗子:</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'我在一个块里面'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'这是第1个:'</span> + a);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上图的运行结果：<br><img src="https://img-blog.csdnimg.cn/20210622105508307.png" alt="这是第1个：我在一个块里面"></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'我在一个块里面'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'这是第2个:'</span> + a);</span><br></pre></td></tr></tbody></table></figure><p>上图的运行结果<br> <img src="https://img-blog.csdnimg.cn/20210622105645594.png" alt="报错：a没有定义"><br> 补充一点，if、else、while、for等也可以形成块级作用域</p><ol start="3"><li>取消变量提升</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'我是'</span> + Var);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'我是'</span> + Let);</span><br><span class="line"><span class="keyword">var</span> Var = <span class="string">'var'</span>;</span><br><span class="line"><span class="keyword">let</span> Let = <span class="string">'let'</span>;</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果：<br><img src="https://img-blog.csdnimg.cn/20210622110344712.png" alt="一个报错一个undefined"><br>（undefined是声明提升但是赋值不提升导致的）</p><ol start="4"><li>依旧有作用域链<h2 id="2-const声明"><a href="#2-const声明" class="headerlink" title="2.const声明"></a>2.const声明</h2></li></ol><p><em>就是常量啦</em></p><p><strong>使用方式</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="string">"必须要初始化（赋值）"</span>;</span><br><span class="line"><span class="comment">//常量命名规范是：大写大写大写！！！</span></span><br></pre></td></tr></tbody></table></figure><p><strong>特性</strong></p><ol><li>一定要赋初始值</li><li>赋值完成后不可修改（毕竟声明的是常量）</li><li>也有块级作用域</li><li>对于用const声明的数组和对象，可以修改其元素</li></ol><h2 id="3-新特性：解构赋值"><a href="#3-新特性：解构赋值" class="headerlink" title="3.新特性：解构赋值"></a>3.新特性：解构赋值</h2><p><del>字面意思就是把结构拆解然后赋值？</del><br>关于这个东西呢直接举例子比较好<br><strong>数组的解构赋值</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ARRAY = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> array = [a,b,c,d] = ARRAY;</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c,d);</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果：<br><img src="https://img-blog.csdnimg.cn/20210622112351347.png" alt="1 2 3 4"><br>awsl！！！！怎么样，是不是爽的不要不要的?!<br><strong>对象的解构赋值</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyInfo = {</span><br><span class="line">    <span class="attr">name</span>:<span class="string">'Serio'</span>,</span><br><span class="line">    <span class="attr">ablity</span>:<span class="string">'TouchFish'</span>,</span><br><span class="line">    <span class="attr">TouchFish</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'没人比我更懂摸鱼'</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> InfoOfMine = {name,ablity,TouchFish} = MyInfo;</span><br><span class="line"><span class="built_in">console</span>.log(name,ablity);</span><br><span class="line">TouchFish();</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果：<br><img src="https://img-blog.csdnimg.cn/20210622132115428.png" alt="Serio TouchFish 没人比我更懂摸鱼"><br>其中对 对象的方法 进行解构是最常用的，为了<del>偷懒</del> 方便<br>需要注意的是，各个元素的名字需要一致，否则报错。</p><h2 id="4-新特性：模板字符串"><a href="#4-新特性：模板字符串" class="headerlink" title="4.新特性：模板字符串"></a>4.新特性：模板字符串</h2><p>孔丙己便涨红了脸，额上的青筋条条绽出，争辩道，“<strong>ES5不能……换行！……ES6的事，还用换行吗？</strong>”接连便是难懂的话，什么“作用域链”，什么“闭包”之类，引得众人都哄笑起来：店内外充满了快活的空气</p><p><strong>使用方式</strong></p><p>新旧对比</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'换行昂昂昂\</span></span><br><span class="line"><span class="string">           要加上斜杠，或者加号连接'</span></span><br><span class="line">          + <span class="string">'不然会报错的'</span>;</span><br><span class="line"><span class="keyword">let</span> strES6 = <span class="string">`没错，现在我们用\`（反引号，就是键盘上和~一个位置那个）</span></span><br><span class="line"><span class="string">            表示字符串惹~</span></span><br><span class="line"><span class="string">            换行很方便的~~~`</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>特性</strong></p><ol><li>可以直接换行了</li><li>可以直接拼接变量</li></ol><p><em>（配合高贵的${}）</em></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`我要给这篇文章一个<span class="subst">${a}</span>连`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210622135125533.png" alt="提前感谢"><br>感谢各位读者，感谢一路走来给予我支持和帮助的老师和前辈….阿巴阿巴（手动狗头）</p><h2 id="5-新特性：对象属性声明简化"><a href="#5-新特性：对象属性声明简化" class="headerlink" title="5.新特性：对象属性声明简化"></a>5.新特性：对象属性声明简化</h2><p><strong>使用方式</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">let</span> name = <span class="string">'Serio'</span>, </span><br><span class="line">         level = <span class="string">'蒟蒻'</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">showAbility</span>(<span class="params"></span>)</span>{</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'BUG + 1'</span>);</span><br><span class="line">     }</span><br><span class="line"><span class="comment">//没错，直接将变量作为自身属性</span></span><br><span class="line">     <span class="keyword">const</span> FEIWU = {</span><br><span class="line">         name,</span><br><span class="line">         level,</span><br><span class="line">         showAbility,</span><br><span class="line"><span class="comment">//函数的声明也可以不用写function了</span></span><br><span class="line">         <span class="function"><span class="title">checkMoney</span>(<span class="params"></span>)</span>{</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">`果然没钱`</span>);</span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line">     FEIWU.showAbility();</span><br><span class="line">     FEIWU.checkMoney();</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果：<br><img src="https://img-blog.csdnimg.cn/20210622140629477.png" alt="在这里插入图片描述"></p><p><strong>特性</strong><br>似乎…没啥特性</p><h2 id="6-新特性：箭头函数"><a href="#6-新特性：箭头函数" class="headerlink" title="6.新特性：箭头函数"></a>6.新特性：箭头函数</h2><p>“你知道吗，箭头函数的语法糖，有四种写法”</p><p> <strong>使用方式</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种：()=&gt;{}</span></span><br><span class="line">        <span class="keyword">let</span> fn = <span class="function">(<span class="params">a, b</span>)=&gt;</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(a + b);</span><br><span class="line">        }</span><br><span class="line">        fn(<span class="string">'啊'</span>,<span class="string">'是箭头函数'</span>);</span><br><span class="line"><span class="comment">//第二种：只有一个参数，省略() </span></span><br><span class="line">        fn = <span class="function"><span class="params">a</span> =&gt;</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`笑死我<span class="subst">${a}</span>`</span>);</span><br><span class="line">        }</span><br><span class="line">        fn(<span class="number">2333</span>);</span><br><span class="line"><span class="comment">//第三种：方法体只有一条语句，省略{}</span></span><br><span class="line">        fn = <span class="function">(<span class="params">a,b</span>)=&gt;</span><span class="built_in">console</span>.log(a + b);</span><br><span class="line">        fn(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//第四种：方法体只有一条语句且为return，直接写return的内容</span></span><br><span class="line">        fn = <span class="function">(<span class="params">a</span>)=&gt;</span>a + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(fn(<span class="number">9</span>));</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210622141902613.png" alt="在这里插入图片描述"></p><p><strong>特性</strong></p><ol><li>静态this<br>对于function声明的函数，谁调用this就指向谁；<br>但是对于箭头函数来说，其this永远指向函数声明时的作用域下的this，并且不能被call，bind等方法改变</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写成这样方便复习上一个知识点</span></span><br><span class="line">        <span class="keyword">let</span> whereIsThis1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"1普通函数"</span> + <span class="built_in">this</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> whereIsThis2 = <span class="function">()=&gt;</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"2箭头函数"</span> + <span class="built_in">this</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">const</span> WhereRU = {</span><br><span class="line">            whereIsThis1,</span><br><span class="line">            whereIsThis2</span><br><span class="line">        }</span><br><span class="line">        WhereRU.whereIsThis1();</span><br><span class="line">        WhereRU.whereIsThis2();</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210622143057708.png" alt="普通函数---this指向对象，箭头函数---this指向window"><br>所以箭头函数适用于与this无关的情况</p><ol start="2"><li>不能实例化对象（就是不能作为构造函数，也就是不能new）</li><li>没有arguments了（悲伤）</li><li>多种省略形式（没错就是开头的几种形式）</li></ol><h2 id="7-函数参数默认值"><a href="#7-函数参数默认值" class="headerlink" title="7.函数参数默认值"></a>7.函数参数默认值</h2><p> 说实话看到这个新特性的时候我第一也是唯一的反应就是————<br> 原来以前没有吗？？？<br> <strong>使用方式</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//好了，现在c有默认值了</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">a,b,c = <span class="number">220</span></span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(a + b + c);</span><br><span class="line">        };</span><br><span class="line">        calc(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">        calc(<span class="number">100</span>,<span class="number">200</span>,<span class="number">1014</span>);</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210622145131822.png" alt="520 1314"></p><h2 id="8-rest参数"><a href="#8-rest参数" class="headerlink" title="8.rest参数"></a>8.rest参数</h2><p>“arguments的离去，是rest的要求，还是es6的不挽留”<br>（其实arguments不仅还能用，还挺好用的）<br><strong>使用方法</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...是扩展运算符 不可以省略</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">UltramanBros</span>(<span class="params">a,b,...args</span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(a,b,args);</span><br><span class="line">        }</span><br><span class="line">        show(<span class="string">"佐菲"</span>,<span class="string">"初代"</span>,<span class="string">"赛文"</span>,<span class="string">"艾斯"</span>,<span class="string">"泰罗"</span>,<span class="string">"雷欧"</span>);</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210622150523576.png" alt="超出的四个会以数组形式保存"><br>…是<strong>扩展运算符</strong>，能将数组展开成参数序列，<br>所以传入…args相当于传入了n个参数，<br>超出的四个参数依次对应，然后存入args中</p><h2 id="9-Symbol类型"><a href="#9-Symbol类型" class="headerlink" title="9.Symbol类型"></a>9.Symbol类型</h2><p>JS的第七种数据类型（话说前六种是啥来着）<br>这次我们先说特性<br><strong>特性</strong></p><ol><li>值唯一，解决了命名冲突问题</li><li>不能与其他类型的数据进行运算</li><li>Symbol类的对象不能用加强for循环（for in），但是可以用Reflect.ownKeys</li></ol><p>我对Symbol的理解：<br>就是根据你传入的内容产生一个（伪）随机的、不重复的值，感觉原理就是<strong>哈希表（散列表）</strong><br>（如果没错的话，那么理解哈希表会帮助理解Symbol）</p><p><strong>使用方式</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种声明方式</span></span><br><span class="line">        <span class="keyword">let</span> s1_1 = <span class="built_in">Symbol</span>(<span class="string">'第一类'</span>);</span><br><span class="line">        <span class="keyword">let</span> s1_2 = <span class="built_in">Symbol</span>(<span class="string">'第一类'</span>);</span><br><span class="line"><span class="comment">//s1_1和s1_2依旧是不同的值</span></span><br><span class="line"><span class="comment">//keyFor()方法就是根据值反过来找下标        </span></span><br><span class="line">        <span class="built_in">console</span>.log(s1_1 === s1_2);<span class="comment">//false</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'第一类声明的索引'</span> + <span class="built_in">Symbol</span>.keyFor(s1_1));<span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//第二种声明方式</span></span><br><span class="line">        <span class="keyword">let</span> s2_1 = <span class="built_in">Symbol</span>.for(<span class="string">'第二类'</span>);</span><br><span class="line">        <span class="keyword">let</span> s2_2 = <span class="built_in">Symbol</span>.for(<span class="string">'第二类'</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">console</span>.log(s2_1 === s2_2);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'第二类声明的索引'</span> + <span class="built_in">Symbol</span>.keyFor(s2_1));</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210622160216887.png" alt="在这里插入图片描述"><br>第一类声明没有“记录机制”，同样的内容是不同的值，而且不能根据值反过来找索引</p><p>第二类则有“记录机制”，与第一类相反</p><p><strong>运用</strong><br>有什么用？<br>参考一下哈希表，至少能够用来安全、随机、可查询地在数组中存储数据….（啊，我也不知道）<br><del>（哦哦我是蒟蒻，所以我也不该知道—-骄傲！）</del> </p><p><strong>Symbol内置值</strong><br>这个对于我来说有点晦涩，而且看上去用处不是很大，<br>这里先暂时跳过，等我学懂了再补上….</p><h2 id="10-迭代器"><a href="#10-迭代器" class="headerlink" title="10.迭代器"></a>10.迭代器</h2><p>ES6中新增<strong>for-of</strong>遍历<br>迭代器是用来做什么的呢？就是用来遍历的，为不同的数据结构提供了同样的访问方式：<br><strong>只要某种数据结构中具备iterator的接口，就可以使用迭代器遍历</strong></p><p>首先我们来说一下两种迭代遍历：<br>for-in和 for-of</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">const</span> SZ3L = [<span class="string">'woc'</span>,<span class="string">'NB'</span>,<span class="string">'666'</span>];</span><br><span class="line"><span class="comment">//普通for不用let就只能用立即执行函数了      </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; SZ3L.length; i ++){</span><br><span class="line">            (<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>{</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'普通for循环'</span>,a);</span><br><span class="line">            })(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> SZ3L){</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'for-in循环：'</span> + i);</span><br><span class="line">        }</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> SZ3L){</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'for-of循环：'</span> + i);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210622190802126.png" alt="在这里插入图片描述"><br>可以看到，<br>for-in是遍历数组的下标（键），<br>for-of则是遍历数组的值</p><p><strong>浅析原理</strong><br><del>（我是废物，说不清楚）</del><br>（还得再研究一下，主要还是Symbol没学懂）<br><img src="https://img-blog.csdnimg.cn/20210622192347416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="迭代器接口"><br>迭代器工作过程简单概括为以下3步：<br>1.创建一个指针对象，指向当前数据结构起始位置<br>2.调用对象的<strong>next方法</strong>，指向下一个成员并返回一个包括value和done属性的对象<br><strong>（注意是next方法返回对象）</strong>，<br>重复这个过程，直到指向最后一个成员<br>3.修改done属性为true，遍历完成，停止调用next</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator = SZ3L[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210622193626257.png" alt="在这里插入图片描述"><br>其中，done属性是表示是否遍历完成，当访问到<strong>最后一个数据</strong>时，done的属性从false变为true，迭代器停止遍历</p><p><strong>现在来手写一个迭代器</strong><br>经过多年的研究之后，我为各位读者量身定义了reader对象，<br>并手写一个迭代器遍历appearance属性数组</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reader = {</span><br><span class="line">            <span class="attr">salary</span>:<span class="string">"月薪10k起步"</span>,</span><br><span class="line">            <span class="attr">appearance</span>:[</span><br><span class="line">                <span class="string">'女美男帅'</span>,</span><br><span class="line">                <span class="string">'墨发雪肌'</span>,</span><br><span class="line">                <span class="string">'壮得一批'</span></span><br><span class="line">            ],</span><br><span class="line">         <span class="comment">//迭代器</span></span><br><span class="line">            [<span class="built_in">Symbol</span>.iterator](){</span><br><span class="line">                <span class="comment">//先初始化一个索引</span></span><br><span class="line">                <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//要返回一个类</span></span><br><span class="line">                <span class="keyword">return</span>{</span><br><span class="line">                    <span class="comment">//类里有next方法</span></span><br><span class="line">                    <span class="comment">//这里利用了箭头函数指针是静态的这一特性</span></span><br><span class="line">                    <span class="attr">next</span>:<span class="function">()=&gt;</span>{</span><br><span class="line">                        <span class="keyword">if</span>(index &lt; <span class="built_in">this</span>.appearance.length){</span><br><span class="line">                            index ++;</span><br><span class="line">                            <span class="keyword">return</span> {<span class="attr">value</span>:<span class="built_in">this</span>.appearance[index], <span class="attr">done</span>:<span class="literal">false</span>};</span><br><span class="line">                        }<span class="keyword">else</span>{</span><br><span class="line">                            <span class="keyword">return</span> {<span class="attr">value</span>:<span class="literal">undefined</span>, <span class="attr">done</span>:<span class="literal">true</span>};</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> reader.appearance){</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210622201139642.png" alt="女美男帅 墨发雪肌 壮的一批"></p><h2 id="11-生成器"><a href="#11-生成器" class="headerlink" title="11.生成器"></a>11.生成器</h2><p>生成器是一个特殊的函数，用于更好地解决异步编程<br><em>（虽然还是已经被更更更好的方法替代了，不过还是得学）</em><br><strong>使用方式</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记得加星号;这不是指针;</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> * <span class="title">myFriends</span>(<span class="params"></span>)</span>{</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'后端学习打卡时长排名的人数显示器'</span>);</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">'阿波'</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'明明是嵌入式的实验室却专攻后端'</span>);</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">'陈大爷'</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'算法很强的后端并且还在学Unity做游戏'</span>);</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">'豪老板'</span>;</span><br><span class="line">        } </span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> iterator = myFriends();</span><br><span class="line">        <span class="built_in">console</span>.log(iterator.next());</span><br><span class="line">        <span class="built_in">console</span>.log(iterator.next());</span><br><span class="line">        <span class="built_in">console</span>.log(iterator.next());</span><br><span class="line">        <span class="built_in">console</span>.log(iterator.next());</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br>（为什么都是后端？巧合吧）<br><img src="https://img-blog.csdnimg.cn/20210623095242910.png" alt="在这里插入图片描述"><br><strong>解析</strong><br><strong>yield相当于一条有名字的分界线</strong>，我们可以通过迭代器的next方法执行每一部分的内容</p><p>第一次调用next时，执行第一条分界线以上的内容<br>第二次调用next时，执行第二条以上，第一条以下的内容<br>以此类推…</p><p><strong>使用方式2</strong><br>生成器 和 next方法 都可以传参数</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params">a</span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是分界线1里的'</span> + a);</span><br><span class="line">    <span class="keyword">let</span> one = <span class="keyword">yield</span> <span class="string">'分界线1'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'分界线1的返回值'</span> + one);</span><br><span class="line">    <span class="keyword">let</span> two = <span class="keyword">yield</span> <span class="string">'分界线2'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'分界线2的返回值'</span> + two);</span><br><span class="line">    <span class="keyword">let</span> three = <span class="keyword">yield</span> <span class="string">'分界线3'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = gen(<span class="string">'一个参数'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); </span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">233</span>));</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210623101919531.png" alt="在这里插入图片描述"><br>生成器gen传参和普通方法一样</p><p>next方法的参数，是作为<strong>上一条分界线的返回值</strong></p><p>比如，第二次调用next，其参数作为 yield ‘分界线1’ 的返回值<br>要是没有传递参数，那么yield的返回值为undefined</p><p><strong>特性</strong></p><ol><li>关键字function与函数名称中间有个 *</li><li>使用了yield表达式</li><li>直接调用会返回一个迭代器对象</li></ol><p><strong>运用</strong><br>说是优化异步编程的，那么我们来看看没有生成器的时候存在的问题：<strong>回调地狱</strong></p><p><strong>回调函数</strong>：将一个函数作为参数传递，但是这个函数不会立刻执行，而是会等待某个条件触发才执行<br><strong>回调地狱</strong>：异步明明是没有固定执行顺序的，那么如果我们偏要它有顺序，就会出现下图这样的结构</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3s时执行第一层'</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5s时执行第二层'</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{   </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'6s时执行第三层'</span>);</span><br><span class="line">            <span class="comment">//扶我起来，我还能继续嵌套</span></span><br><span class="line">        }, <span class="number">1000</span>)</span><br><span class="line">    }, <span class="number">2000</span>)</span><br><span class="line">}, <span class="number">3000</span>)</span><br></pre></td></tr></tbody></table></figure><p><em>如果代码量少还好受，要是多了就不好说了</em><br>这种<strong>回调函数的嵌套就是回调地狱</strong><br>所以我们可以通过一些方式改善这种情况，比如用生成器：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3s时执行第一层'</span>);</span><br><span class="line">        g.next();</span><br><span class="line">    },<span class="number">3000</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5s时执行第二层'</span>);</span><br><span class="line">        g.next();</span><br><span class="line">    },<span class="number">1000</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">three</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'6s时执行第三层'</span>);</span><br><span class="line">        g.next();</span><br><span class="line">    },<span class="number">1000</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">yield</span> one();</span><br><span class="line">    <span class="keyword">yield</span> two();</span><br><span class="line">    <span class="keyword">yield</span> three();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line">g.next();</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210623111416462.png" alt="在这里插入图片描述"><br>其实上面还有个一个点可以提一下，就是let明明没有了提升，g却依旧能被上面的函数访问，<br>和别人讨论了一下觉得应该是由于function声明的时候函数体不会展开，此时g也就没有被访问；等到g.next执行，one，two，three依次执行的时候，才依次展开，此时就可以通过作用域链向上访问到g从而能再次调用g.next…阿巴阿巴（反正大概就是那个意思）</p><h2 id="12-Promise"><a href="#12-Promise" class="headerlink" title="12.Promise"></a>12.Promise</h2><p>promise是一个构造函数，可以用来封装异步操作，并获取到其成功和失败的结果然后据此作出反应<br><strong>使用方法</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个promise对象有三种状态：初始化状态、成功状态、失败状态</span></span><br><span class="line">        <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>{</span><br><span class="line">            <span class="comment">//里面要封装一个的操作</span></span><br><span class="line">            <span class="comment">//（大多数是异步，大多数是异步，但是你要同步也可以）</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{            </span><br><span class="line"><span class="comment">//执行resolve方法之后，p变为‘成功’状态</span></span><br><span class="line">                <span class="keyword">let</span> data1 = <span class="string">'成功了!'</span>;</span><br><span class="line">                resolve(data1);<span class="comment">//promise实例化对象的状态就会变成成功</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">//执行reject方法之后，p变为‘失败’状态</span></span><br><span class="line">                <span class="keyword">let</span> data2 = <span class="string">'失败了!'</span>;                </span><br><span class="line">                reject(data2);</span><br><span class="line">            },<span class="number">1000</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//成功的话执行第一个函数，失败的话执行第二个函数</span></span><br><span class="line">        p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'这是成功了：'</span> + value);</span><br><span class="line">        }, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'这是失败了：'</span> + reason);</span><br><span class="line">        })</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210624102353283.png" alt="在这里插入图片描述"><br>从结果来看，似乎在遇到resolve方法之后就结束了而不是继续往下执行<br>（Promise的状态一旦变化，就不会再改变了）<br>另外介绍一下<strong>catch方法</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//catch方法大体上就相当于只写then方法的后半部分</span></span><br><span class="line">p.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这也是失败了，不过语法糖比较甜对吧'</span> + reason);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>运用</strong><br>首先我们来回忆一下原生JS的AJAX<br>现在准备一个这样的JSON文件</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="string">"key"</span>:<span class="string">"NB"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后（这里是同一目录下）写AJAX</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">httpRequest = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">if</span> (!httpRequest) {</span><br><span class="line">    alert(<span class="string">"创建请求失败"</span>);</span><br><span class="line">}</span><br><span class="line">httpRequest.open(<span class="string">"GET"</span>, <span class="string">"./JSONtest.json"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//莫得后端，孤寡前端人只能本地玩单机</span></span><br><span class="line"></span><br><span class="line">httpRequest.send();</span><br><span class="line">httpRequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (httpRequest.readyState === <span class="number">4</span>) {</span><br><span class="line">        <span class="keyword">if</span> (httpRequest.status === <span class="number">200</span>) {</span><br><span class="line">            <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(httpRequest.responseText);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'AJAX'</span> + data[<span class="string">'key'</span>]);</span><br><span class="line">            <span class="comment">//别忘了和data.key的区别</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">'请求失败'</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210624103245847.png" alt="AJAXNB"></p><p>接下来我们来演示一次传说中的<strong>封装</strong>！！！</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  P = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>{</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">    <span class="keyword">if</span>(!xhr){</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'创建请求失败'</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    xhr.open(<span class="string">"GET"</span>,<span class="string">"./JSONtest.json"</span>);</span><br><span class="line">    </span><br><span class="line">    xhr.send();</span><br><span class="line">    </span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>){</span><br><span class="line">            <span class="keyword">if</span>(xhr.status === <span class="number">200</span>){</span><br><span class="line">                <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(xhr.responseText)[<span class="string">'key'</span>];</span><br><span class="line">                resolve(data);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                reject(xhr.status);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">);</span><br><span class="line">P.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你的AJAX生了，是个'</span> + data);</span><br><span class="line">},<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你的AJAX是个男的'</span> + reason);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>“就这？就这？这不就是把ajax装进Promise里面吗？我人傻了”<br>“大家懂的都懂,<del>这种博主老水怪了</del> ”<br><strong>上图运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210624154933271.png" alt="本地运行，请求失败"><br><img src="https://img-blog.csdnimg.cn/20210624155033970.png" alt="服务器上运行，请求成功"></p><p><strong>特性</strong>（写这个的时候有点困，估计很多问题，后面再改改，现在大家看看就行）</p><ol><li>Promise.then方法的返回值:<strong>不写return默认返回一个Promise对象（是被处理之前的Promise）</strong></li></ol><p> <strong>第一种：内部 回调函数 返回非Promise类型</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> P = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> {</span><br><span class="line">        resolve(<span class="string">'abab'</span>);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = P.then(<span class="function"><span class="params">value</span> =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'我是第一种返回值（非Promise类型）'</span>;</span><br><span class="line">    },<span class="function"><span class="params">reason</span> =&gt;</span> {</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210624163124394.png" alt="在这里插入图片描述"><br><strong>第二种：内部 回调函数 返回Promise类型</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> P = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> {</span><br><span class="line">    resolve(<span class="string">'abab'</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = P.then(<span class="function"><span class="params">value</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="comment">//套娃，返回一个Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">//reject使返回的这个Promise的状态为‘失败’</span></span><br><span class="line">        reject(<span class="string">'第二种类型：最内部promise的状态决定最终的状态'</span>)</span><br><span class="line">    })</span><br><span class="line">},<span class="function"><span class="params">reason</span> =&gt;</span> {</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210624164713193.png" alt="在这里插入图片描述"><br>第三种：throw</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> P = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> {</span><br><span class="line">    resolve(<span class="string">'abab'</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = P.then(<span class="function"><span class="params">value</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">        reject(<span class="string">'第三种类型：抛出错误'</span>);</span><br><span class="line">    })</span><br><span class="line">},<span class="function"><span class="params">reason</span> =&gt;</span> {</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210624165751201.png" alt="在这里插入图片描述"><br>通过观察以上三种情况，我们发现：这形成了一个链…也就避免了回调地狱的情况……..</p><p>（今天写不动了…好困…团队的人还在商量着今晚去吃自助的事情…又困又饿…以后找个时间一定把这里补起来）</p><p>(时隔几天，考完了高数….promise剩下的内容以后补充）</p><h2 id="13-Set对象"><a href="#13-Set对象" class="headerlink" title="13.Set对象"></a>13.Set对象</h2><p><em>那个橘子味的夏天，少年回忆起了蝉鸣和STL类库…</em></p><p><strong>特性</strong></p><ol><li>拥有iterator接口，可以使用迭代器和扩展运算符（…）</li><li>类似于数组，但是具有<strong>唯一性</strong>，即元素不重复</li></ol><p> <strong>属性/方法</strong></p><ol><li>size 返回元素个数</li><li>add 增加一个新元素，返回增加元素后的集合  </li><li>delete 删除元素，返回一个布尔值 </li><li>has 查询是否包含某个元素，返回一个布尔值</li><li>clear 清空，没有返回值(或者说返回undefined)</li></ol><p><strong>代码实例</strong><br>先单独说一下add</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="comment">//可以传入一个可迭代对象作为参数，参数用于初始化这个集合</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'甲'</span>, <span class="string">'乙'</span>,  <span class="string">'丙'</span>, <span class="string">'乙'</span>, <span class="string">'甲'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s2);</span><br><span class="line"><span class="comment">//add方法</span></span><br><span class="line">s2.add(<span class="string">'one'</span>,<span class="string">'two'</span>);</span><br><span class="line">s2.add([<span class="string">'a'</span>,<span class="string">'b'</span>]);</span><br><span class="line">s2.add(...[<span class="string">'1'</span>,<span class="string">'2'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s2);</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210630140148740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>都没什么特别的，<br>需要提一下的就是如果传入多个参数，只有第一个有效<strong>（不仅局限于add，delete，has等也是如此)</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="comment">//可以传入一个可迭代对象作为参数，参数用于构造这个集合</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'甲'</span>, <span class="string">'乙'</span>,  <span class="string">'丙'</span>, <span class="string">'乙'</span>, <span class="string">'甲'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(s2);</span></span><br><span class="line">s2.add(<span class="string">'one'</span>,<span class="string">'two'</span>);</span><br><span class="line">s2.add([<span class="string">'a'</span>,<span class="string">'b'</span>]);</span><br><span class="line">s2.add(...[<span class="string">'1'</span>,<span class="string">'2'</span>]);</span><br><span class="line"><span class="comment">// console.log(s2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数 乙 无效</span></span><br><span class="line"><span class="built_in">console</span>.log(s2.delete(<span class="string">'甲'</span>,<span class="string">'乙'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(s2.delete(<span class="string">'不存在的元素'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(s2.add(<span class="string">'520'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(s2.size);</span><br><span class="line"><span class="comment">//参数666无效</span></span><br><span class="line"><span class="built_in">console</span>.log(s2.has(<span class="string">'丙'</span>,<span class="string">'666'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s2.clear(),s2);</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210630141320394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>运用</strong><br><strong>1.数组去重</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="comment">//用arr创建一个集合，然后展开得到1，2，3再放进数组</span></span><br><span class="line"><span class="keyword">let</span> s = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果<br><img src="https://img-blog.csdnimg.cn/20210630141903251.png" alt="1 2 3"><br><strong>2.求交集</strong><br>这里顺便介绍：</p><h2 id="14-filter"><a href="#14-filter" class="headerlink" title="14.filter"></a>14.filter</h2><p>过滤器，<strong>遍历每个元素</strong>进行筛选<br><strong>代码实例</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="comment">//可以传三个参数，</span></span><br><span class="line"><span class="comment">//顾名思义，结合输出结果不难理解</span></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.filter(<span class="function">(<span class="params">value,key,arr</span>)=&gt;</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是value'</span>,value);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是key'</span>,key);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是arr'</span>,arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">2</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'这是过滤之后的结果'</span>,arr2);</span><br></pre></td></tr></tbody></table></figure><p>数组长度是5，函数执行了5次遍历了每个元素，筛选出了大于2元素<br><img src="https://img-blog.csdnimg.cn/20210630144501974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="遍历5次，结果只剩一个3"></p><p>好了我们继续看我们的<strong>求交集</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr.filter(<span class="function">(<span class="params">value</span>)=&gt;</span>{</span><br><span class="line">    <span class="keyword">return</span> s2.has(value) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">}));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210630151543379.png" alt="1 2"><br><strong>3.求并集</strong><br>这个就没啥说的了</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([...arr,...arr2]);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210630152022168.png" alt="在这里插入图片描述"><br><strong>4.求补集</strong><br>其实也就和求交集一个意思</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(arr.filter(<span class="function">(<span class="params">value</span>)=&gt;</span>{</span><br><span class="line">    <span class="keyword">return</span> s2.has(value) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">}));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></tbody></table></figure><p>不过这里有八十岁老爷爷看了都说牛逼的简化：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(arr.filter(<span class="function">(<span class="params">value</span>)=&gt;</span>{</span><br><span class="line">    <span class="keyword">return</span> !<span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(value);</span><br><span class="line">}));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210630152901249.png" alt="2 3 4"></p><h2 id="15-map对象"><a href="#15-map对象" class="headerlink" title="15.map对象"></a>15.map对象</h2><p>其实就是键值对<br><strong>特性</strong></p><ol><li>又是一个自带iterator接口的</li><li></li></ol><p><strong>属性/方法</strong></p><ol><li>size 长度 </li><li>set 添加元素</li><li>has 查询是否存在</li><li>clear 清空</li><li>get 通过键传入值</li><li>delete 通过键删除元素</li></ol><p><strong>代码实例</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="number">233</span>,<span class="string">'键233的值'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = {<span class="attr">name</span>:<span class="string">'一个对象'</span>};</span><br><span class="line">m.set(obj,<span class="string">'键对象的值'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'m.get(233):'</span>, m.get(<span class="number">233</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'m.get(obj):'</span>, m.get(obj));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'m.has(obj)'</span>,m.has(obj));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'m.size:'</span>,m.size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'clear之前:'</span>,m);</span><br><span class="line">m.clear();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'clear之后:'</span>,m);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210630162847473.png" alt="在这里插入图片描述"></p><h2 id="16-class类"><a href="#16-class类" class="headerlink" title="16.class类"></a>16.class类</h2><p>先回顾一下<strong>构造函数实例化对象</strong>：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person1</span>(<span class="params">name, age</span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Person1.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I\'m the '</span> + <span class="built_in">this</span>.name +<span class="string">' DEEP! DARK! FANTASY♂!'</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> somebody1 = <span class="keyword">new</span> Person1(<span class="string">'黑暗之王'</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">somebody1.speak();</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210630174350744.png" alt="在这里插入图片描述"></p><p><strong>class类实例化对象</strong>（javar狂喜）</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span>{</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span>{</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">       <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我是'</span> + <span class="built_in">this</span>.name + <span class="string">',我是不朽的'</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> somebody2 = <span class="keyword">new</span> Person2(<span class="string">'玛尔加尼斯'</span>,<span class="number">5</span>);</span><br><span class="line">somebody2.speak();</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210630210315995.png" alt="在这里插入图片描述"><br><strong>static静态</strong><br>不论新旧，都有这样一手操作：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder1</span></span>{</span><br><span class="line">    <span class="comment">//什么都没有哦</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Coder2</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="comment">//意思是程序员一无所有[bushi</span></span><br><span class="line">}</span><br><span class="line">Coder1.name = <span class="string">'知鑫'</span>;</span><br><span class="line">Coder2.name = <span class="string">'雨溪'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coder1 = <span class="keyword">new</span> Coder1();</span><br><span class="line"><span class="keyword">let</span> coder2 = <span class="keyword">new</span> Coder2();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'红尘作伴，代码潇潇洒洒~'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(coder1.name,coder2.name);</span><br></pre></td></tr></tbody></table></figure><p><em>快快乐乐，昂第佛爱德~</em><br><img src="https://img-blog.csdnimg.cn/20210630212908786.png" alt="两个undefined"><br>通过上述方式添加的成员，只属于构造函数而不属于实例化对象.</p><p>上述写法相当于<br><strong>(static只能在class类里面合法)</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder3</span></span>{</span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">'日娃'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> coder3 = <span class="keyword">new</span> Coder3();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'无名英雄，程序员:'</span> + coder3.name);</span><br></pre></td></tr></tbody></table></figure><p><em>无名英雄的名字当然是undefined啊！</em><br><img src="https://img-blog.csdnimg.cn/20210630213651447.png" alt="undefined"><br><strong>继承</strong><br>又让我们先回顾构造函数如何继承吧<br><em>(JS高级的原型链…说实话我也快忘完了)</em></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Win10</span>(<span class="params">info, bugs</span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.info = info;</span><br><span class="line">    <span class="built_in">this</span>.bugs = bugs;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Win11</span>(<span class="params">info, bugs, moreBugs</span>)</span>{</span><br><span class="line">    Win10.call(<span class="built_in">this</span>,info,bugs);</span><br><span class="line">    <span class="built_in">this</span>.moreBugs = moreBugs;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Win11.prototype = <span class="keyword">new</span> Win10;</span><br><span class="line">Win11.prototype.constructor = Win11;<span class="comment">//纠正Win11的构造函数 </span></span><br><span class="line"></span><br><span class="line">Win11.prototype.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'绿屏了'</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newSystem = <span class="keyword">new</span> Win11(<span class="string">'最后一代？从来没说过'</span>,<span class="string">'挺多'</span>,<span class="string">'更多了'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newSystem);</span><br><span class="line">newSystem.start();</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/2021063022112453.png" alt="在这里插入图片描述"><br>啥？为啥方法要写到prototype里面而不是直接写到对象里面？（上一节<strong>static静态</strong>才说了</p><p><strong>class继承</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Win10</span></span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">info,bugs</span>)</span>{</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">        <span class="built_in">this</span>.bugs = bugs;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Win11</span> <span class="keyword">extends</span> <span class="title">Win10</span></span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">info,bugs,moreBugs</span>)</span>{</span><br><span class="line">        <span class="built_in">super</span>(info,bugs);</span><br><span class="line">        moreBugs = moreBugs;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">start</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'绿屏了'</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySystem = <span class="keyword">new</span> Win11(<span class="string">'谁说win10是最后一代了？'</span>,<span class="string">'有bug'</span>,<span class="string">'更多bug!'</span>);</span><br><span class="line">mySystem.start();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'mySystem:'</span>,mySystem);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210701100648888.png" alt="运行结果"><br>虽然看上去和JAVA差不多了，但是实际上还是原型链的封装<br>子类对父类方法的重写也一样，其实只是原型链的知识…</p><h2 id="17-get与set"><a href="#17-get与set" class="headerlink" title="17.get与set"></a>17.get与set</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span></span>{</span><br><span class="line">    <span class="keyword">get</span> <span class="title">whyWeLive</span>(){</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'为了吃饭'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">whyWeLive</span>(<span class="params">dream</span>){</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'为了理想'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> us = <span class="keyword">new</span> Coder();</span><br><span class="line"><span class="keyword">let</span> ans = us.whyWeLive; <span class="comment">//访问，触发get部分</span></span><br><span class="line"><span class="built_in">console</span>.log(ans);</span><br><span class="line">us.whyWeLive = <span class="string">'为更多的人创造更好的世界'</span>;<span class="comment">//修改，触发set部分</span></span><br></pre></td></tr></tbody></table></figure><p>注意whyWeLive是属性不是方法，<br>get修饰是指，在该属性被访问的时候，调用后面的函数<br>set修饰是指，在该属性被修改的时候，调用后面的函数</p><p><img src="https://img-blog.csdnimg.cn/20210701103321673.png" alt="在这里插入图片描述"><br><em>人生来不是为了吃饭，我们还有理想</em></p><h2 id="18-数值扩展"><a href="#18-数值扩展" class="headerlink" title="18.数值扩展"></a>18.数值扩展</h2><p>感觉这部分也没什么好说的，了解一下就行</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.误差（最小精度）</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'0.1 + 0.2 === 0.3'</span>, <span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">equal</span>(<span class="params">a, b</span>)</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a - b) &lt; <span class="built_in">Number</span>.EPSILON ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//EPSILON是一个极其小的数字</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'equal(0.1 + 0.2, 0.3):'</span>, equal(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>));</span><br><span class="line"><span class="comment">//2.更多的进制</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0b10100</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">0o24</span>;</span><br><span class="line"><span class="keyword">let</span> d = <span class="number">0x14</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'十进制'</span>, a, <span class="string">'二进制'</span>, b, <span class="string">'八进制'</span>, c, <span class="string">'十六进制'</span>, d);</span><br><span class="line"><span class="comment">//3.更多方法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Number.isNaN(100 / 0):'</span>, <span class="built_in">Number</span>.isNaN(<span class="number">100</span> / <span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Number.isFinite(100 / 0):'</span>, <span class="built_in">Number</span>.isFinite(<span class="number">100</span> / <span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Number.isInteger(2.3):'</span>, <span class="built_in">Number</span>.isInteger(<span class="number">2.3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Number.parseInt(\'2333ababa66\'):'</span>, <span class="built_in">Number</span>.parseInt(<span class="string">'2333ababa66'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Number.parseFloat(\'1.7321abcd\'):'</span>, <span class="built_in">Number</span>.parseFloat(<span class="string">'1.7321abcd'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Math.trunc(4.33):'</span>, <span class="built_in">Math</span>.trunc(<span class="number">4.33</span>),<span class="string">'Number.parseInt(\'4.33\'):'</span>, <span class="built_in">Number</span>.parseInt(<span class="number">4.33</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Math.sign(0):'</span>,<span class="built_in">Math</span>.sign(<span class="number">0</span>),<span class="string">'Math.sign(-666):'</span>,<span class="built_in">Math</span>.sign(-<span class="number">666</span>));</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p>唯一需要注意的是这里的equal方法是用EPSILON属性实现的，不是JS自带的方法<br><img src="https://img-blog.csdnimg.cn/2021070115125938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="19-Object方法扩展"><a href="#19-Object方法扩展" class="headerlink" title="19.Object方法扩展"></a>19.Object方法扩展</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Object.is 判断两个值是否完全相等</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Object.is(NaN, NaN)'</span>,<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>),<span class="string">'NaN === NaN'</span>,<span class="literal">NaN</span> === <span class="literal">NaN</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Object.assign 合并对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name, age</span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name,sex</span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A(<span class="string">'A'</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(<span class="string">'B'</span>,<span class="string">'女'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Object.assign(a,b)'</span>,<span class="built_in">Object</span>.assign(a,b));</span><br><span class="line">  </span><br><span class="line"><span class="comment">//3.Object.setPrototypeOf 设置原型对象</span></span><br><span class="line"><span class="comment">//4.Object.getPrototypeof 获取原型对象</span></span><br><span class="line"><span class="keyword">let</span> C = {</span><br><span class="line">   <span class="attr">name</span>: <span class="string">'C'</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> D ={</span><br><span class="line">    <span class="attr">age</span>: <span class="number">33</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(C, D);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Object.setPrototypeOf(C, D):'</span> , C);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Object.getPrototypeOf(C):'</span> , <span class="built_in">Object</span>.getPrototypeOf(C));</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210701175626457.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210705121429291.png" alt="在这里插入图片描述"></p><h2 id="20-module模块化"><a href="#20-module模块化" class="headerlink" title="20.module模块化"></a>20.module模块化</h2><p><em><strong>把丑陋的代码实现包起来，只留出接口给外面看</strong><br>（比如写一个冒泡排序，接口名字叫做快速排序，别人调用的时候就会觉得————好耶）</em></p><p><em>而且模块之间的内容是互不影响的，避免了污染</em></p><p>首先在同一目录下创建一个moduleTest.js文件，内容是</p><p><strong>其中export修饰的内容会被暴露</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> date = <span class="string">'2021/07/05'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myRecentLife</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'还在进行因为疫情被推迟的军训..'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我想躺着写代码啊！！！'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我想吃肉！！！'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后另一边，我们这样写</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span>&gt;</span><br><span class="line">    <span class="comment">//模块化必须在服务器上测试</span></span><br><span class="line">    <span class="comment">//（本地折腾半天没有输出...）</span></span><br><span class="line">    <span class="keyword">import</span> {date} <span class="keyword">from</span> <span class="string">"./moduleTest.js"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(date);</span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">'./moduleTest.js'</span>;</span><br><span class="line">    <span class="comment">//这个语句很像SQL，语义化也很强</span></span><br><span class="line">    <span class="comment">//*是啥？参考一下css的*就知道了</span></span><br><span class="line">    <span class="built_in">console</span>.log(m);</span><br><span class="line">    m.myRecentLife();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>上图运行结果（<strong>一定要在服务器上运行啊！不然没有反应的</strong>）<br><img src="https://img-blog.csdnimg.cn/20210705130511467.png" alt="在这里插入图片描述"><br><strong>注意事项</strong><br>假如引入的两个模块中有重名内容，<br>比如<br><img src="https://img-blog.csdnimg.cn/20210705214428333.png" alt="在这里插入图片描述"><br>那么我们可以使用关键字as操作一手：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> {date} <span class="keyword">from</span> <span class="string">"./moduleTest.js"</span>;</span><br><span class="line"><span class="keyword">import</span> {date <span class="keyword">as</span> date2} <span class="keyword">from</span> <span class="string">"./moduleTest2.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"date:"</span>,date,<span class="string">"\ndate2:"</span>,date2);  </span><br></pre></td></tr></tbody></table></figure><p><strong>（记得要在服务器上运行啊！！！）</strong><br><img src="https://img-blog.csdnimg.cn/2021070521470085.png" alt="在这里插入图片描述"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>ES6大概就这样结束了，不过我还是想写下这多余的话</p><p>ES6更新了很多东西，这篇笔记是我一边学习一遍写代码做记录产生的，也是第一次接触到其中一些内容，所以难免有漏掉部分知识点，和理解分析不到位的情况，希望大家包涵谅解</p><p>后面如果有机会的话，我也会继续做ES相关的内容</p><p>祝大家能够不断进步</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript</title>
      <link href="/2021/12/09/typescript/"/>
      <url>/2021/12/09/typescript/</url>
      
        <content type="html"><![CDATA[<h2 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h2><h3 id="强弱类型"><a href="#强弱类型" class="headerlink" title="强弱类型"></a>强弱类型</h3><p>这是从<strong>类型安全</strong>的角度区分的</p><p>强、弱类型缺乏官方的界定标准，但是较为认可的一种说法是：</p><blockquote><p>强类型语言中不允许任意的隐式类型转换；</p><p>弱类型语言则允许。</p></blockquote><h3 id="静动态类型"><a href="#静动态类型" class="headerlink" title="静动态类型"></a>静动态类型</h3><p>这是从<strong>类型检查</strong>的角度区分的</p><p>有较为官方统一的解释：</p><blockquote><p>静态类型即，变量声明后就不允许再修改了；</p><p>动态类型则允许，并且在运行的时候才能明确一个变量的类型</p></blockquote><p>注意，<strong>并非</strong>弱类型就是静态类型，强类型就是动态类型<br><img src="https://img-blog.csdnimg.cn/a648a19d22f94d7a89d7a1e01f9df535.png" alt="在这里插入图片描述"></p><h2 id="JavaScript的系统特性"><a href="#JavaScript的系统特性" class="headerlink" title="JavaScript的系统特性"></a>JavaScript的系统特性</h2><p>弱类型 且 动态类型<br>灵活多变导致的极其不可靠</p><blockquote><p>这是因为早期开发JS的时候根本没想过JS会发展到今天这一步，所以设计得相对简单，不适合大规模的应用<br>随着时代更迭，这种“灵活”的优势，也就演变成了“混乱、不稳定”的劣势</p></blockquote><p>比如，</p><blockquote><p>语法上允许调用对象本不存在的方法（执行时才会报错）<br>函数/方法参数类型不做限制地进行运算（函数功能可能发生改变）<br><strong>对象属性名会自动转化为字符串</strong>（稀奇古怪的操作）</p></blockquote><p><strong>解决方式</strong></p><blockquote><p>一、简单的方式是通过约定，即开发者一起遵守一套规则 但是很明显，这样并没有保障，随时都可能出现不遵守规则的人</p></blockquote><blockquote><p>二、通过额外的工作去保障，如图：<br><img src="https://img-blog.csdnimg.cn/1e98aec695de4e199c9b4acc2b3f8533.png" alt="ab如果不为数字，那么抛出异常"><br>当然，也可以是借助其他工具。<br></p></blockquote><blockquote><p>三、则是想办法改变JavaScript的系统特性吗，这才是从根本上解决问题</p></blockquote><h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><p>我们先考虑一下借助其他工具，比如Flow——一款JavaScript静态资源检查器</p><blockquote><p>Flow是2014年由facebook推出的一款工具，可以弥补JS的系统特性的弊端，工作原理是通过添加类型注解的方式来解决变量类型不明确的问题，是一个成熟的技术</p></blockquote><h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p><img src="https://img-blog.csdnimg.cn/c97dcb9f8a3f485e83d49d06dcc1f6bb.png" alt="在这里插入图片描述"><br>参数后加冒号再加数据类型，以此形式来限定参数类型，即<strong>类型注解</strong></p><p><strong>需要安装相关依赖</strong>，有兴趣就学</p><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>TypeScript是JavaScript的超集，<br><img src="https://img-blog.csdnimg.cn/9d7dcebb1bf441648a9e75ee7e9af094.png" alt="TypeScript"><br><strong>缺点一</strong>：增加了如接口，泛型，枚举等的“新概念”（？迷惑，却不说）<br>但是好消息是，TypeScript是<strong>渐进式</strong>的<br>也就意味着，就算我们什么新概念都不知道，凭借JS基础我们依旧能够直接开始使用它<br><strong>缺点二</strong>：项目初期，TypeScript会增加开发成本<br>大概是需要自定义各种数据类型等等工作加大了开始的成本，不过这便于后期的维护</p></blockquote><h3 id="隐式类型推断"><a href="#隐式类型推断" class="headerlink" title="隐式类型推断"></a>隐式类型推断</h3><p>即在不明确变量类型的时候，系统根据其使用情况来判断它是什么类型</p><h3 id="类型注解-1"><a href="#类型注解-1" class="headerlink" title="类型注解"></a>类型注解</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a : <span class="built_in">number</span>, b : <span class="built_in">number</span></span>) </span>{</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>和flow的语法一样</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>用法：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = res <span class="keyword">as</span> <span class="built_in">number</span></span><br></pre></td></tr></tbody></table></figure><p>这样写就是说，res是一个数字</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num2 == &lt;<span class="built_in">number</span>&gt;res</span><br></pre></td></tr></tbody></table></figure><p>虽然上述写法也可以实现一样的效果，但是这和JSX的语法会发生冲突，<br>所以还是建议使用第一种写法</p><h3 id="更多类型"><a href="#更多类型" class="headerlink" title="更多类型"></a>更多类型</h3><h4 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h4><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><h4 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h4><h3 id="declare类型声明"><a href="#declare类型声明" class="headerlink" title="declare类型声明"></a>declare类型声明</h3><p>一开始我看到类型声明的时候还愣了一下<br>为了避免误解我还是在其前面加上一个declare吧</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { camelCase } <span class="keyword">from</span> <span class="string">'loadsh'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块中提供的这个函数并没有定义参数和返回值类型</span></span><br><span class="line"><span class="comment">// 我们用以下形式给它补上这些信息</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">camelCase</span> (<span class="params">input: <span class="built_in">string</span></span>): <span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">res</span> = <span class="title">camelCase</span>(<span class="params"><span class="string">'hellotankyoutankyouverymuch,iamok'</span></span>)</span></span><br></pre></td></tr></tbody></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>其实吧，我寻思啊，这js怎么还整接口啊…</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是接口</span></span><br><span class="line"><span class="keyword">interface</span> Post {</span><br><span class="line"><span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line"><span class="attr">content</span>: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">p: Post</span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(p.title, p.content)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">print({</span><br><span class="line"><span class="attr">title</span>: <span class="string">'Hello, Interface'</span></span><br><span class="line"><span class="attr">content</span>: <span class="string">'TypeScript is so cool'</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="成员修饰"><a href="#成员修饰" class="headerlink" title="成员修饰"></a>成员修饰</h4><p><strong>可选成员</strong><br>即可有可无的成员</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// subtitle后面加上了一个? 表示这个成员可有可无</span></span><br><span class="line"><span class="comment">// 原理是标记subtitle类型是string 或者 undefined</span></span><br><span class="line"><span class="keyword">interface</span> Post {</span><br><span class="line"><span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">subtitle?: <span class="built_in">string</span></span><br><span class="line"><span class="attr">content</span>: <span class="built_in">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>只读成员</strong><br>不可手动设置和修改</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Post {</span><br><span class="line"><span class="comment">// readonly关键字约束成员即可设置只读</span></span><br><span class="line"><span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">subtitle?: <span class="built_in">string</span></span><br><span class="line"><span class="attr">content</span>: <span class="built_in">string</span></span><br><span class="line"><span class="keyword">readonly</span> summary: <span class="built_in">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>动态成员</strong><br>有些时候一个接口该有哪些成员是不确定的</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [prop: string]设置成员名称为string</span></span><br><span class="line"><span class="comment">// 其后的string指定值为string</span></span><br><span class="line"><span class="keyword">interface</span> Cache {</span><br><span class="line">[prop: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">const</span> cache: Cache = {}</span><br><span class="line"></span><br><span class="line">cache.foo = <span class="string">'value1'</span></span><br><span class="line">cache.bar = <span class="string">'value2'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>对ES6引入的类进行了扩展</p><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span> <span class="comment">// = '赵宇'</span></span><br><span class="line"><span class="keyword">private</span> age: <span class="built_in">number</span></span><br><span class="line"><span class="title">constructor</span> (<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) {</span><br><span class="line"><span class="built_in">this</span>.name = name</span><br><span class="line"><span class="built_in">this</span>.age = age</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Y1M = <span class="keyword">new</span> Person(<span class="string">'杨二鸣'</span>, <span class="number">20</span>)</span><br></pre></td></tr></tbody></table></figure><p>注意，在TS标准中，类的成员变量要么初始化，要么用构造函数设置值<br>另外，如果不加修饰，那么<strong>默认为public，不是default</strong><br>当然还有，protected，和private区别大概是</p><blockquote><p>protected可以继承，只能在子类中访问（子类的实例对象不可访问） </p></blockquote><blockquote><p>private不可继承，只能在当前类中访问</p></blockquote><p>同样，<strong>继承extends</strong>，<strong>静态static</strong>，<strong>只读readonly</strong>， <strong>抽象abstract</strong>这些东西也被加入到了这个体系，<br>总之就是Java玩剩下的东西都被拉到了TS的体系中</p><blockquote><p>这里单独说一下readonly，<br>放到public等修饰的后面，<br>被其修饰的成员先得在声明时或构造函数中初始化，此后不能再被修改</p></blockquote><h4 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h4><p>Java的类和类之间是单继承的，类和接口之间是多继承的，<br>所以TS这里类和接口的关系还是多继承的（蜜汁逻辑）</p><blockquote><p>用法和Java一样，依旧是用implements实现<br>书写的规范是，一个接口约束一个有关功能即可</p></blockquote><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>果然，我就知道泛型也跑不掉</p><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt; (<span class="params">length: <span class="built_in">number</span>, value : T</span>): <span class="title">T</span>[] </span>{</span><br><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Array</span>&lt;T&gt;(length).fill(T)</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = createArray&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">'foo'</span>)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventLoop中同步异步和微宏任务</title>
      <link href="/2021/12/07/eventloop/"/>
      <url>/2021/12/07/eventloop/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器构成概述"><a href="#浏览器构成概述" class="headerlink" title="浏览器构成概述"></a>浏览器构成概述</h2><p>浏览器是多线程的<br>主要包括以下六个线程：</p><blockquote><p><strong>1.GUI渲染线程（DOM/BOM）<br>2.JS引擎线程（web worker）<br>3.浏览器事件线程 （onclick）</strong><br>4.定时器线程<br>5.Http网络请求线程<br>6.EventLoop线程</p></blockquote><p><strong>其中,123是常驻线程，始终存在；而456是在有需求是才会存在的线程</strong></p><h2 id="JS执行"><a href="#JS执行" class="headerlink" title="JS执行"></a>JS执行</h2><p>单线程异步（不考虑web worker）。<br>从前到后一行一行顺序执行，一行报错则就此终止执行</p><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>由<strong>调用栈</strong>和<strong>任务队列</strong>组成,<br>而消息队列又分为<strong>微任务队列</strong>和<strong>宏任务队列</strong></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>遇到同步任务，直接将其放入<strong>调用栈</strong>中执行<br>遇到异步任务，先托管到对应的<strong>线程</strong>，时机到了再放入<strong>任务队列</strong>，再排队进入<strong>调用栈</strong><br><img src="https://img-blog.csdnimg.cn/6e5e108e23574e65b0c6214187176af6.png" alt="事件轮询示意图"></p><p>即<strong>先同后异</strong><br>另外，需要注意，<strong>定时器的时间参数不能小于4ms</strong>，这一点在开发人工智能反作弊系统的时候也体会过</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>回顾一下Promise的三种状态：pending resolved rejected<br>即初始为pending，then正常执行返回resolved，报错则rejected</p><p>pending状态下是同步的，调用then方法（或者resolve、reject函数）的部分为异步</p><h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><p>本质上是Promise的语法糖<br>async修饰的函数就是以同步函数的形式表现异步函数的操作<br>但是如果async约束的函数里面没有用到await，那么<strong>async不会产生任何影响，其修饰的函数依旧是同步</strong><br>可以转化为Promise的形式，比如</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">await</span> async2()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">}</span><br><span class="line">async1()</span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">resolve()</span><br><span class="line">}).then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line">}</span><br><span class="line">async1()</span><br></pre></td></tr></tbody></table></figure><p>上述两段代码等价，结果都是1 3 2</p><h3 id="宏微任务"><a href="#宏微任务" class="headerlink" title="宏微任务"></a>宏微任务</h3><p>先微后宏和先微后宏只要解释得当都算是对的，<br>一般我们说是先微后宏，<br>但是如果硬要把主线程代码看成宏任务，那就是先执行宏<br><strong>微任务Micro-task</strong></p><blockquote><p>主线程代码（script中的代码）<br>setTimeOut<br>setInterval<br>setImmediate<br>requestAnimationFrame<br>I/O流<br>UI render<br>AJAX</p></blockquote><p><strong>宏任务Macro-task</strong></p><blockquote><p>process.nextTick<br>Promise（严格来说是new Promise().then()）<br>Async/Await（实际上和Promise一样）<br>MutationObserver（H5新特性）（这什么鬼啊）</p></blockquote><p><strong>示例图</strong><br>这里把主线程代码看做宏任务，所以是先宏后微的<br>但是记住，我们一般说是先微后宏<br><img src="https://img-blog.csdnimg.cn/075ffaf73b8b47bea6a9126ae7b772e1.png" alt="宏微任务执行流程示意图"><br>当微任务和宏任务多层嵌套时，大概过程如下：<br><img src="https://img-blog.csdnimg.cn/b648123e3587452da79503fbe96abff8.png" alt="宏微任务嵌套"></p><h3 id="完整的Event-Loop"><a href="#完整的Event-Loop" class="headerlink" title="完整的Event Loop"></a>完整的Event Loop</h3><p><img src="https://img-blog.csdnimg.cn/60a72ac05ece48c8aa764f44724ca2e3.png" alt="Event Loop完整流程"><br>总结就是<br>先同后异，先微后宏</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS</title>
      <link href="/2021/12/06/html-css/"/>
      <url>/2021/12/06/html-css/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="向无人理想处的，或多余的告白"><a href="#向无人理想处的，或多余的告白" class="headerlink" title="向无人理想处的，或多余的告白"></a>向无人理想处的，或多余的告白</h3><p>在这个如果有疾风骤雨惊雷就会非常符合我此时心情但却是无比静谧的深夜里（指0点27分），我痛定思痛，意识到如果不重新学习HTML、CSS、JS的话代价将会是巨大的——就会变得和我的算法一样，会是一种难以结痂的伤口。<br>走吧，走同一条路也会有不同的风景的。</p><p>我大概是2021/01左右学习的前端，距今是过去一年时间了。</p><p>说到我为什么要学前端——一开始是学后端的，但是那个时候啊，IDEA编译工具试用期过了我犯懒又不想去申请学生认证，eclipse看上去太老旧了我倍感排斥，这时候漂漂亮亮的VSCode就把我吸引了——但是VSCode配置Java环境又是一件麻烦事，那么好吧——不如咱学前端试试看吧！于是乎，我自此踏上了学习前端的征途。</p><p>哈，没错，没有什么别的理由，就是这么简简单单——喜欢，是不需要太多理由的。</p><p>一路上，有五彩斑斓甚至有点花里胡哨的特效给我带来的惊艳的视觉冲击，有学习资料不系统和没有正确地做笔记导致的迷茫困惑并且无从复习的雪上加霜，有对这个做起算法来让人爱恨交加的脚本小皇帝的痛斥和赞美，还有太多太多掉进时光里面的影子——一同构成了我的前端学习记忆，我从中发自心底地感到：</p><blockquote><p> 三生有幸，学计算机</p></blockquote><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2021/12/06</strong><br>首次发布这篇博文，当时是为了引领前端新人们入门</p><p><strong>2022/01/24</strong><br>一开始是为了引领新人入门，所以一些内容会细致到离谱，但是现在目标群体变成了我或者像我一样的复习者，所以一些内容对于初学者或许难以接受</p><p><strong>2022/03/11</strong><br>做了一些修正和补充</p></blockquote><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><h3 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h3><table><thead><tr><th>名称</th><th>评价</th></tr></thead><tbody><tr><td>sublime text</td><td>轻量级，适合入门</td></tr><tr><td>vscode</td><td>方便装插件，更加全面、美观，<strong>以我今天的眼光看来，他是最完美的</strong></td></tr><tr><td>intelligent idea</td><td>相当全面，写前端的同时还方便写Java代码</td></tr><tr><td>webstorm</td><td>相对更倾向前端，大家用了都说好</td></tr></tbody></table><p>其实用记事本写也可以，只需要把扩展名txt改为html，然后用浏览器打开即可</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>web前端当然要有浏览器才能运行起来，这里注意使用大牌浏览器（比如某绿色浏览器、企鹅浏览器之类的就不要用了）</p><p>这里推荐六个浏览器</p><table><thead><tr><th>浏览器</th><th>评价</th><th>内核</th></tr></thead><tbody><tr><td>IE（4-11）</td><td>万恶之源</td><td>Trident</td></tr><tr><td>Chrome</td><td>基于开源的Chromium的闭源浏览器，个人觉得必装</td><td>2013以前是Webkit，之后是Blink</td></tr><tr><td>Firefox</td><td>推荐装</td><td>Gecko</td></tr><tr><td>Opera</td><td>这个国内好像没什么人用，不太了解</td><td>最初是presto，再是Webkit，现在是Blink</td></tr><tr><td>Safari</td><td>mac的御用浏览器</td><td>Webkit</td></tr><tr><td>Microsoft Edge</td><td>相当于重生的IE，还是挺好用的</td><td>Edge</td></tr></tbody></table><p>内核诞生时间顺序：</p><blockquote><p>Gecko(1997)-&gt;Trident(1997)-&gt;KHTML(1998)-&gt;WebKit(2001)-&gt;Presto(2003)-&gt;Blink(2013)-&gt;Edge(2014)-&gt;Gonna(2016)</p></blockquote><p>上述六个浏览器中，除了IE的兼容性相对拉胯之外，其他都还行。<br>个人觉得入门至少要在Chrome、FireFox、Edge中三选一</p><p>另外，部分属性需要加上浏览器的<strong>私有前缀</strong>以兼容老版本的浏览器，对应关系如下：</p><blockquote><p>-moz- firefox系列<br>-ms- ie系列<br>-webkit- safari、chrome系列<br>-o- opera系列</p></blockquote><h3 id="资料参考（待补充）"><a href="#资料参考（待补充）" class="headerlink" title="资料参考（待补充）"></a>资料参考（待补充）</h3><blockquote><p>Zeal 自行下载</p><p>W3CSchool 自行搜索</p><p>MDN 自行搜索</p><p>Font Awesome</p><p>CodePen<br><a href="https://codepen.io/">https://codepen.io/</a></p><p>HTML5 ROCKS<br><a href="https://www.html5rocks.com/">https://www.html5rocks.com/</a></p><p>ICON FONT<br><a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p></blockquote><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><blockquote><p>全称是Hyper Text Market Language（超文本标记语言），用来写超文本。<br>规范是由W3C指定的，大家都会遵循这个标准（除了IE）。</p></blockquote><p>什么是<strong>超文本</strong>?</p><blockquote><p>普通文本就是文字，超文本指的是流媒体、图片、声音、视频等等</p></blockquote><h3 id="HTML基本结构"><a href="#HTML基本结构" class="headerlink" title="HTML基本结构"></a>HTML基本结构</h3><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码就是一个最基本的HTML文件结构，我们一步一步分析</p><p><strong>标签</strong><br>这是构成HTML代码的基本单位<br><img src="https://img-blog.csdnimg.cn/82717e4b7ba44df384bb5285b94ce9fa.png" alt="在这里插入图片描述"><br>从图中我们可以得知：</p><blockquote><p>1.形如&lt;…&gt;的就叫标签<br>2.由&lt;…&gt;&lt;/…&gt;构成的叫双标签，前者为头标签，后者为尾标签，二者之间可以写东西<br>3.只有一个&lt;…&gt;的叫单标签<br>4.标签可以嵌套</p></blockquote><hr><p><strong>文档声明</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!</span> <span class="token attr-name">DOCTYPE</span> <span class="token attr-name">html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这其实不是HTML的标签，它是为了告诉浏览器用什么模式标准进行<strong>渲染</strong>（可以类比编译，把代码变成图形）<br>这样写就是希望浏览器采用<strong>HTML5</strong>进行渲染（但是实际上是否这样做完全取决于浏览器）</p><p>我们也可以看一下其他模式的写法<br><strong>HTML 4.01 Strict</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">HTML</span> <span class="token name">PUBLIC</span> <span class="token string">"-//W3C//DTD HTML 4.01//EN"</span> <span class="token string">"http://www.w3.org/TR/html4/strict.dtd"</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>HTML 4.01 Frameset</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">HTML</span> <span class="token name">PUBLIC</span> <span class="token string">"-//W3C//DTD HTML 4.01 Frameset//EN"</span> <span class="token string">"http://www.w3.org/TR/html4/frameset.dtd"</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，我们现在都采用HTML5</p><hr><p><strong>HTML文档</strong></p><p><img src="https://img-blog.csdnimg.cn/640c746ca690422593bd68c1cf094d98.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="HTML基本结构"></p><blockquote><p><strong>根标签</strong>，也叫html标签是一个双标签，之后我们所有内容将写在其头标签和尾标签之间；<br><strong>文档头</strong>也叫head标签，之间用于书写一些配置类的东西（正如其名，head，头部，作用和大脑一样）<br><strong>文档体</strong>也叫body标签，之间书写页面的主体内容（正如其名，body，身体，决定了整个页面的结构）</p></blockquote><h3 id="使用HTML"><a href="#使用HTML" class="headerlink" title="使用HTML"></a>使用HTML</h3><p>新建一个文件，将扩展名（后缀名）改为html，用编译工具打开即可<br><img src="https://img-blog.csdnimg.cn/31e67237428b476bb092a05c67bc7e6b.png" alt="在这里插入图片描述"><br>书写如下内容</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>你好，HTML<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用的是sublime text，那么直接按下F12即可渲染<br>如果是vscode，那么按下alt+b即可（需要安装插件）<br>如果是idea或者webstorm，那么点击右上角的浏览器图标即可<br>（不管用什么，鼠标右键之后应该都有“在浏览器打开的选项”）</p><p>我们这里采用sublime + chrome<br><img src="https://img-blog.csdnimg.cn/089fa3bdbd1b46c0a13245ca36961a76.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="你好HTML"></p><p>HTML准确地说并不算是编程语言，它最多是个脚本语言，因为它不具备逻辑运算等能力</p><h3 id="两类标签"><a href="#两类标签" class="headerlink" title="两类标签"></a>两类标签</h3><p>就好像水，如果要控制水，那么首先得想办法把它装起来，这时候我们就需要容器<br><strong>div标签</strong></p><blockquote><p>区隔标签（应该是divide的缩写），双标签</p></blockquote><p>先别问有什么用，后面再说用处</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>你好，HTML<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了容器之后，我们就能修改其内容的<strong>属性</strong><br>这里我们来修改一下style属性</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>你好，HTML<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/87cf53e2254e4c70a1f20ec63888b799.png" alt="背景色为红色"></p><p>同样的还有<br><strong>span标签</strong></p><blockquote><p>意义不详（大雾）</p></blockquote><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>你好，HTML<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>你好，HTML<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>你好，HTML<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>hhh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>hhh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>hhh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/95fd2c6d07c64f57ab232354634de082.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="行级元素和块级元素"></p><p>上述两种标签默认的布局是有区别的</p><table><thead><tr><th>类型</th><th>效果</th><th>例子</th></tr></thead><tbody><tr><td>块级元素（block）</td><td>独占一行，可以修改大小</td><td>div，h1，p，ul，table</td></tr><tr><td>行级元素（内联元素，inline）</td><td>只占据内容的大小，在挤满一行之后才换行，无法修改大小</td><td>span,  td, a, img</td></tr></tbody></table><p><strong>tips：元素指的就是标签</strong></p><p>至于修改大小，举个例子：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 100px</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>你好，HTML<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 100px</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>hhh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>style属性的不同内容之间用分号隔开，末尾可以省略空格<br>其中px是一个单位，即<strong>像素</strong><br><img src="https://img-blog.csdnimg.cn/4078b9f2338c43a480271ae299e84d72.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="常见的基础标签"><a href="#常见的基础标签" class="headerlink" title="常见的基础标签"></a>常见的基础标签</h3><p><strong>img标签</strong></p><p>首先找个图<br><img src="https://img-blog.csdnimg.cn/078f5bfc66ec4dbb9318c7742f61d3c8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_19,color_FFFFFF,t_70,g_se,x_16" alt="香甜的甲基橙？"></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://i2.hdslb.com/bfs/face/18b1c56221b25b1ed47543c6574a9562beb195f0.jpg@160w_160h_1c_1s.webp<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/62400a1152504bf495066ae7799af891.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img标签示例"></p><hr><p><strong>title标签</strong><br>这个写在head里面</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>网页hhh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/416e317030e34504a61f8e219ecb607b.png" alt="网页标题"></p><hr><p><strong>a标签</strong></p><p>可以理解为超链接</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://www.baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>比例比例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/49c29061cce540ec949ce278e74a508f.png" alt="点击就能跳转到百度页面"><br>点击就可以实现跳转，访问到百度的首页</p><hr><p><strong>input标签</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>登录<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>前者是输入框，后者是提交按钮（不过目前这样是没法提交的）</p><p>注意“输入”这个概念，对于计算机来说，不仅是键盘输入，鼠标点击等一系列产生了信息的事件都可以是输入</p><p><img src="https://img-blog.csdnimg.cn/236e9e24be114f7bbdc3016fbb9f241b.png" alt="输入框和输入按钮"></p><hr><p><strong>ul标签和ol标签</strong><br>ul是unordered list，ol是ordered list<br>它们都有二级标签li标签</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>芒果<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>香蕉<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>猕猴桃<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>铅笔<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>直尺<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>橡皮擦<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/3fae9fbf3fb4415cae92a91ab4fe6ad2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="无序列表和有序列表"><br>其实没有大家想的那么高级，什么有序无序，不过是有无序号的区别</p><hr><p><strong>table标签</strong></p><table><thead><tr><th>名字</th><th>内容</th></tr></thead><tbody><tr><td>a</td><td>1</td></tr><tr><td>b</td><td>2</td></tr><tr><td>c</td><td>3</td></tr></tbody></table><p>像上面这种表格，我们可以可以用代码实现：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>名字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>a<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>b<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>c<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实标题那里应该使用th标签，这样更规范，不过呢也不强求了</p><p>这里介绍一下emmet语法，我们可以输入上面的内容后按下tab，自动生成上述代码</p><p><img src="https://img-blog.csdnimg.cn/8cfc85f9326c4602926f7400dbc0f414.png" alt="emmet语法示例"></p><p><img src="https://img-blog.csdnimg.cn/b97ba4136e6c4f529132d8d0b0ed47b3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="一个表格"></p><hr><p><strong>注释标签</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 这是注释 --&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于这个符号手写很难打，所以我们一般都用ctrl+？的快捷键</p><p><strong>br标签</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就是换行</p><h3 id="实体符号"><a href="#实体符号" class="headerlink" title="实体符号"></a>实体符号</h3><p>其实就是转义字符，比如我想在浏览器中展现&lt;或者&gt;符号，却与原有的语句冲突时，直接写会被解析为标签，所以需要有转义符号</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token entity named-entity" title="<">&amp;lt;</span><span class="token entity named-entity" title=">">&amp;gt;</span><span class="token comment">&lt;!--对比一下，其中lt是less than的简写，gt是greater than的简写--&gt;</span>&lt;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/ef644451812146c8b187c729bcd45ebb.png" alt="大于小于符号"><br>还有空格<br>直接写多个空格会被解析为一个空格</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">1               2          3 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>1<span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span>2<span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span>3<span class="token comment">&lt;!--nbsp是new break-space--&gt;</span><span class="token comment">&lt;!--nbsp是new break-space--&gt;</span><span class="token comment">&lt;!--nbsp是new break-space--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/e2587207d30e416e83929fa3e9e23ffd.png" alt="记住啊，直接多个空格会被压缩为一个空格"></p><h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><blockquote><p>meta标签表示的是<strong>元数据</strong>，是head标签中的base，link，script，style，title等标签无法表示的数据</p><p>meta是单标签，并且由于内容是空的，不能用单标签的形式表示</p><p>但是meta可以设置多种属性，比如charset，content，http-equiv，name等</p></blockquote><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>charset</td><td>character_set</td><td>定义文档的字符编码</td></tr><tr><td>content</td><td>text</td><td>定义与 http-equiv 或 name 属性相关的元信息</td></tr><tr><td>http-equiv</td><td>content-type<br>default-style<br>refresh<br>Expires<br>Set-Cookie<br>Pragma<br>Window-target<br>…..</td><td>把 content 属性关联到 HTTP 头部</td></tr><tr><td>name</td><td>application-name<br>author<br>description<br>generator<br>keywords<br>robots<br>copyright<br>revisit-after<br>viewport<br>renderer<br>…….</td><td>把 content 属性关联到一个名称<br>比如将“前端开发”关联到keywords，那么就可以做到SEO优化——搜索前端开发然后发现该网页的概率更大</td></tr></tbody></table><p>总结一下稍微常用的：</p><h4 id="一、name"><a href="#一、name" class="headerlink" title="一、name"></a>一、name</h4><p>name属性主要用于描述网页，对应属性是 content ，以便于搜索引擎机器人查找、分类（目前几乎所有的搜索引擎都使用网上机器人自动查找meta值来给网页分类）。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>参数<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>参数值<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>1.Keywords（关键字）</strong></p><p>为搜索引擎提供的关键字列表</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>keywords<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>程序员<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2.Description（简介）</strong></p><p>Description用来告诉搜索引擎你的网站主要内容。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>description<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>meta标签是HTML中的一个重要标签，它位于HTML文档头部的&lt;HEAD&gt;标签和&lt;TITL&gt;标签之间。<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3.robots（机器人向导）</strong></p><p>robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>robots<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>content的参数值有all,none,index,noindex,follow,nofollow，默认值是all。</p><p>参数说明：</p><p>参数为 all ：文件将被检索，且页面上的链接可以被查询； </p><p>参数为 none ：文件将不被检索，且页面上的链接不可以被查询； </p><p>参数为 index ：文件将被检索； </p><p>参数为 follow ：页面上的链接可以被查询； </p><p>参数为 noindex ：文件将不被检索，但页面上的链接可以被查询；</p><p> 参数为 nofollow ：文件将被检索，但页面上的链接不可以被查询；</p><p><strong>4.author（作者）</strong></p><p>标注网页的作者</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>author<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TG,TG@qq.com<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5.copyright（版权）</strong></p><p>标注版权</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>copyright<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>本网站版权归TG所有<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>6.generator</strong></p><p>说明网站采用什么编辑器制作。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>generator<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>你所用的编辑器<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>7.revisit-after（重访）</strong></p><p>网站重访</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>revisit-after<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>7days<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>HTML5更新部分</p></blockquote><p><strong>1.viewport</strong></p><p>能优化移动浏览器的显示（屏幕的缩放）</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数值：</p><p>width viewport的宽度[device-width | pixel_value]width如果直接设置pixel_value数值，大部分的安卓手机不支持，但是ios支持；   </p><p>height – viewport 的高度 （范围从 223 到 10,000 ）   </p><p>user-scalable [yes | no]是否允许缩放   </p><p>initial-scale [数值] 初始化比例（范围从 &gt; 0 到 10）   </p><p>minimum-scale [数值] 允许缩放的最小比例   </p><p>maximum-scale [数值] 允许缩放的最大比例   </p><p><strong>2.format-detection（忽略电话号码和邮箱）</strong></p><p>忽略电话号码和邮箱</p><p>//忽略页面中的数字识别为电话号码</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>format-detection<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>telephone=no<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>//忽略页面中的邮箱格式识别为邮箱</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>format-detection<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email=no<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以写成：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>format-detection<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>telphone=no, email=no<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3、浏览器内核控制</strong>：国内浏览器很多都是双内核（webkit和Trident），webkit内核高速浏览，IE内核兼容网页和旧版网站。而添加meta标签的网站可以控制浏览器选择何种内核渲染。（仅限360浏览器）</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>renderer<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>webkit|ie-comp|ie-stand<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若页面需默认用极速核，增加标签：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>renderer<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>webkit<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>若页面需默认用ie兼容内核，增加标签：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>renderer<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie-comp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>若页面需默认用ie标准内核，增加标签：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>renderer<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie-stand<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>各渲染内核的技术细节</code></pre><p>内核    Webkit    IE兼容    IE标准<br>内核版本    Chrome 45    IE6/7    IE9/IE10/IE11(取决于用户的IE)<br>HTML5支持    YES    NO    YES<br>ActiveX控件支持    NO    YES    YES<br><strong>4、WebApp全屏模式</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>apple-mobile-web-app-capable<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yes<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> <span class="token comment">&lt;!-- 启用 WebApp 全屏模式 --&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5、隐藏状态栏/设置状态栏颜色</strong>：只有在开启WebApp全屏模式时才生效。content的值为default | black | black-translucent 。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>apple-mobile-web-app-status-bar-style<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>black-translucent<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>6、不同浏览器</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HandheldFriendly<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 微软的老式浏览器 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MobileOptimized<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>320<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- uc强制竖屏 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>screen-orientation<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>portrait<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- QQ强制竖屏 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x5-orientation<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>portrait<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- UC强制全屏 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>full-screen<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yes<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- QQ强制全屏 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x5-fullscreen<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- UC应用模式 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>browsermode<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>application<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- QQ应用模式 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x5-page-mode<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- windows phone 点击无高光 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msapplication-tap-highlight<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二、http-equiv"><a href="#二、http-equiv" class="headerlink" title="二、http-equiv"></a>二、http-equiv</h4><p>http-equiv类似于HTTP的头部协议，它回应给浏览器一些有用的信息，以帮助正确和精确地显示网页内容。与之对应的属性值为content，content中的内容其实就是各个参数的变量值。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>参数<span class="token punctuation">"</span></span>  <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>参数值<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数说明：</p><p><strong>1.Expires（期限）</strong></p><p>指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新传输。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>expires<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Wed, 26 Feb 1997 08:21:57 GMT<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：必须使用GMT的时间格式，或者直接设为0（数字表示多久后过期）</p><p><strong>2.Pragma（cache模式）</strong></p><p>禁止浏览器从本地计算机的缓存中访问页面内容。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Pragma<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no-cache<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：网页不保存在缓存中，每次访问都刷新页面。这样设定，访问者将无法脱机浏览。</p><p><strong>3.Refresh（刷新）</strong></p><p>自动刷新并指向新页面。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--&lt;meta http-equiv="refresh"content="5; url=http://www.baidu.com/"/&gt;--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中的5表示5秒后自动刷新并调整到URL新页面。</p><p><strong>4.Set-Cookie（cookie设定）</strong></p><p>说明：浏览器访问某个页面时会将它存在缓存中，下次再次访问时就可从缓存中读取，以提高速度。当你希望访问者每次都刷新你广告的图标，或每次都刷新你的计数器，就要禁用缓存了。</p><p>如果网页过期，那么存盘的cookie将被删除。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Set-Cookie<span class="token punctuation">"</span></span>  <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cookievalue=xxx; expires=Wednesday, 　　　　　　 21-Oct-98 16:14:21 GMT; path=/<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：必须使用GMT的时间格式</p><p><strong>5.Window-target（显示窗口的设定）</strong></p><p>强制页面在当前窗口以独立页面显示</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Window-target<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_top<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以用来防止别人在框架里调用你的页面。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">**6.content-Type（显示字符集的设定）**<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设定页面使用的字符集/编码方式</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content-Type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/html;charset=utf-8<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他参数值：</p><p>GB2312，简体中文；</p><p>BIG5，繁体中文； </p><p>iso-2022-jp，日文；  </p><p>ks_c_5601，韩文；  </p><p>ISO-8859-1，英文；  </p><p>UTF-8，世界通用的语言编码；</p><p>在HTML5中，我们一般都是：<meta charset="utf-8"><br><strong>7.content-Language（显示语言的设定）</strong></p><p>显示语言</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Content-Language<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zh-cn<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>8.http-equiv=”imagetoolbar”</strong></p><p>指定是否显示图片工具栏，当为false代表不显示，当为true代表显示</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>imagetoolbar<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p> HTML5更新部分</p></blockquote><p><strong>1、优先使用 IE 最新版本和 Chrome</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge,chrome=1<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><!-- 关于X-UA-Compatible -->  <pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=6<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 使用IE6 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=7<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 用于在IE8版本浏览器中使用IE7渲染来避免出错 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=8<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 使用IE8 --&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、转码申明</strong>：用百度打开网页可能会对其进行转码（比如贴广告），避免转码可添加如下meta</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Cache-Control<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no-siteapp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="内联框架（待补充）"><a href="#内联框架（待补充）" class="headerlink" title="内联框架（待补充）"></a>内联框架（待补充）</h3><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>看完上述代码，我们知道标签内部还是可以写东西的，但是除了style属性之外，标签还有其他的属性</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span>  <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1px<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>名字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>a<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>b<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>c<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/49eb5d6a5e3a4d228affa53e74b21bcd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>以及行内向下合并</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span>  <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1px<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>名字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>a<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>b<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">rowspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>c<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/614c9cec752c4595a2529ad667ba8ee8.png" alt="在这里插入图片描述"><br>也可以行合并</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span>  <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1px<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>名字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>a<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>b<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">rowspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>c<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/435cfe7967f84ad3a002a88c97deac89.png" alt="在这里插入图片描述"></p><hr><p>再比如</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入密码<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/bc65c24be4774f029773b6b8c2b75722.png" alt="在这里插入图片描述"><br>不过这些可以慢慢熟悉，现在我们只需要掌握常用到的</p><hr><p><strong>颜色及其6种表示方式</strong></p><p>（rgba、HSL、HSLA写漏了，不过问题不大）</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>         <span class="token property">background-color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> #f00<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> #000<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">rgb</span><span class="token punctuation">(</span>255<span class="token punctuation">,</span>0<span class="token punctuation">,</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgb</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span>0<span class="token punctuation">,</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/d7ecbe0b3a6c482a9ea4eb61dea1cce8.png" alt="在这里插入图片描述"></p><table><thead><tr><th>方式</th><th>简述</th></tr></thead><tbody><tr><td>英文词汇</td><td>很low，但是对于美术不好的人很亲和</td></tr><tr><td>十六进制</td><td>取值范围是0~ff（ff是16*16，即256，但是从0开始数，所以最大值是255）<br>比如#ffaa33,代表红色值为ff，绿色为aa，蓝色为33，当三种颜色的两位均一样时，可以简写为#fa3这种形式</td></tr><tr><td>rgb函数</td><td>采用十进制，最大值是255，依次对应red，green，blue<br>规则和十六进制一样<br>还有rgba函数，会多一个范围是0~1的参数代表透明度</td></tr></tbody></table><hr><p><strong>宽高</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/93932ce55225493caa23942c1fdd7e08.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">这里是使用最最常见的px，像素为单位，一个像素有多大，是由个人的电脑的分辨率决定的。<br>当然还有其他单位，不过这里暂不讨论。</p><hr><p><strong>文字</strong><br>关于文字，那么属性就可多了<br>这里例举一些</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>文字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">font-weight</span><span class="token punctuation">:</span> 900</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>文字0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">font-size</span><span class="token punctuation">:</span> 14px</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>文字1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">font-family</span><span class="token punctuation">:</span><span class="token string">'宋体'</span></span><span class="token punctuation">"</span></span></span> <span class="token punctuation">&gt;</span></span>文字2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> green</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>文字3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/30b3e4380fe64ed3b15352b394a57b5e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><table><thead><tr><th>名称</th><th>介绍</th></tr></thead><tbody><tr><td>font-weight</td><td>取值是100-900，决定文字的粗细</td></tr><tr><td>font-size</td><td>文字的大小，这里的单位是用的px，即像素。当然你也可以采用其他单位。</td></tr><tr><td>font-family</td><td>字体。如果设置字体的话，可能会因为字体限定了一些样式而导致对字体粗细等设置失效</td></tr><tr><td>color</td><td>文字颜色，注意，<font color="red">没有font-color</font></td></tr></tbody></table><p>我们思考一个问题</p><p>当一个标签存在大量样式的时候，很明显是不易于阅读和后续改进</p><p><img src="https://img-blog.csdnimg.cn/4dac5cf06a604e619bc63ea45b1dcb27.png" alt="在这里插入图片描述"></p><p>但是不用紧张，CSS会为我们解决这个问题</p><h3 id="HTML5更新内容"><a href="#HTML5更新内容" class="headerlink" title="HTML5更新内容"></a>HTML5更新内容</h3><p>简单总结一下，目前来看至少更新了这些：</p><blockquote><p><strong>新的标签</strong><br>main header aside section footer canvas等等</p><p><strong>Web存储</strong><br>localStorage sessionStorage等</p><p><strong>更多特性</strong><br>meta元素有了更多的属性</p></blockquote><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><blockquote><p>CSS，Cascading Style Sheets，三个单词的意思分别是大量的，样式，表</p><p>官方给的翻译就是<strong>层叠样式表</strong>，用于存放大量的样式</p><p>(层叠有两层含义，一是“大量”，而是指“叠加”——多个样式表的效果可以叠加到一个元素上)</p><p>所以HTML是管理结构的，CSS才是管理样式的，更多的样式我们会放到CSS这里讲</p></blockquote><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><p>我们想一下一张表长什么样子</p><p><img src="https://img-blog.csdnimg.cn/e7cbb7419f3344e6bb2a82c7a77de45b.png" alt="在这里插入图片描述"></p><p>所以CSS作为一张表也该有类似上图的样子——由键值对构成</p><p><img src="https://img-blog.csdnimg.cn/7900cf33c55c4471992e6ed133a58f29.png" alt="在这里插入图片描述"></p><p>没错，CSS可以写在html文件里面，通常我们会把一个style标签写在head标签内部</p><p>（其实写哪都能生效，但是规范是写到head里面）</p><p>然后在style内写多个键值对来设置样式</p><h4 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h4><p>很明显，上述CSS影响到了所有div标签</p><p>而上述的这种用标签名字来选择样式作用的范围的方式，就叫做<strong>标签选择器</strong></p><p><img src="https://img-blog.csdnimg.cn/167c247ca6314c068923ca92f5d3c81a.png" alt="在这里插入图片描述"></p><p>假如我们想让第一个div独有这种样式，我们就给它取个名字</p><p><img src="https://img-blog.csdnimg.cn/a1c755d104ec424d81cc682eba5c1a9a.png" alt="在这里插入图片描述"></p><p>注意不要漏掉前面的点</p><p><img src="https://img-blog.csdnimg.cn/8ed6470f723b4388bd5ae6c27c571cb3.png" alt="image-20211203171156480"></p><p>注意，这里的<strong>后面覆盖前面</strong>，其前后顺序是<strong>以style标签中的内容顺序决定的而不是class名称的顺序</strong></p><p>这里的class并不是面向对象编程里面的类，不要混淆，二者没有联系。</p><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><p>和class选择器类似，但是id选择器名字前面的是#，并且<strong>id选择器不可复用，具有唯一标识性</strong></p><p><img src="https://img-blog.csdnimg.cn/58ebfc47aec14c58b1e686cfc087a9e5.png" alt="在这里插入图片描述"></p><p>比如看一个简单的例子</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#a-good-id<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>跳转<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个可以实现跳转到id为a-good-id的标签所在的位置。</p><p>那么可不可以写class呢？当然不能，因为class可能“重名”，这样就不知道到底该跳转到哪里。</p><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><p>根据标签所具有的属性来进行选择</p><p>看个例子</p><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">[type="text"]{background-color:#ff0000;}[type]{border:5px solid blue;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述两个样式都能作用于</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>意思就是用属性来选择，可以只写属性名称，也可以限制属性值</p><h4 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h4><p>选择器之间通过组合来实现更加复杂的选择</p><p><strong>交集选择器</strong></p><p>更精准地选择:</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div.good</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就选中了class值为good的div标签</p><p><strong>并集选择器</strong></p><p>多个内容具有相同的css可以像这样写成一块:</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div,p</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就同时选中了div和p标签</p><p><strong>子代选择器</strong></p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div&gt;p</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只选中div的子级p标签</p><p><strong>后代选择器</strong></p><p>又叫包含选择器，用来选择后代</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div p</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就选中了div内所有的p标签</p><p><strong>兄弟选择器</strong></p><p>对于如下HTML</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过div来选择p则可以像这样操作</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div + p</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示选中div的<strong>紧邻的 下 一 个</strong>兄弟p（如果div和p中间隔了一个其他标签，那么这将无法选中）</p><h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><p>带一个冒号，这个要注意和伪元素选择器区分</p><blockquote><p>此处的类指的是标签属性中的class，那为什么是“伪”呢？</p><p>因为伪类选择器相当于是根据情况来给元素添加了一个不存在的class名称，并且赋予了响应的样式，<strong>它是用于描述一个元素的特殊状态</strong></p></blockquote><p>比如</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div &gt; span:nth-child(2n + 1)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">/*可以选中第奇数个子元素*/</span><span class="token selector">div &gt; span:nth-of-type(n)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">/*n计数时不考虑span以外的元素（潜台词就是nth-child()是会考虑除了span以外的元素的）*/</span>div &gt; <span class="token property">span</span><span class="token punctuation">:</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token punctuation">:</span><span class="token function">nth-of-type</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">/*否定伪类，意味着除了第一个span之外*/</span><span class="token selector">a:link</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">/*未访问的链接*/</span><span class="token selector">a:visited</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">/*访问过的链接*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><p>带两个冒号（老版本允许一个冒号，但是标准还是双冒号），这个要注意和伪类选择器区分</p><blockquote><p>同理，伪元素是逻辑上有但是实际上并不存在的”元素”，<strong>它表示元素的特殊位置</strong></p></blockquote><p>比如</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">p::first-letter</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">/*元素的第一个字母*/</span><span class="token selector">p::first-line</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">/*元素的第一行    */</span><span class="token selector">p::selection</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">/*元素选中的部分  */</span><span class="token selector">p::before</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">/*元素的起始位置    */</span><span class="token selector">p::after</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">/*元素的结束位置    */</span><span class="token comment">/*before和after中总是用content属性来设置innerText，并且这样设置的innerText是无法选中的*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>后代选择器、子代选择器、交集选择器、并集选择器、伪类选择器合称<strong>复合选择器</strong></p></blockquote><h4 id="特异度"><a href="#特异度" class="headerlink" title="特异度"></a>特异度</h4><p>即选择器生效的<strong>优先级/权重</strong>，计算方法是</p><blockquote><p>先看id选择器个数，记为n个，再看伪类或类选择器个数，记为m，再看标签选择器个数l，那么特异度就是n m l  </p></blockquote><p>优先级由高到低具体地说就是：</p><blockquote><p>!important                        (永远最高)<br>内联style                          1 0 0 0<br>id选择器                            0 1 0 0<br>class、伪类选择器            0 0 1 0<br>标签选择器                        0 0 0 1<br>通配选择器                        0 0 0 0<br>继承的样式                    （永远最低）</p></blockquote><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>有的属性可以继承，有的不可以</p><p>比如字体大小，字体颜色等等是可以继承的，会和最近的拥有该属性的父级元素一样</p><p>有的属性是不可继承的，比如背景、布局、盒子模型等，但是如果我们想修改这种情况，那我们可以在某属性字段后面加上inherit，比如</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">*</span> <span class="token punctuation">{</span>    <span class="token property">box-sizing</span><span class="token punctuation">:</span> inherit<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里需要注意，默认的背景颜色是transparent透明的，所以在测试背景是否能够继承的时候需要注意别被表象误导</p><p>至于具体哪些能继承哪些不能继承，这个就需要用时间去形成记忆了</p><h4 id="CSS求值过程"><a href="#CSS求值过程" class="headerlink" title="CSS求值过程"></a>CSS求值过程</h4><blockquote><p><strong>1.确定了DOM树和样式规则</strong></p><p><strong>2.filtering: 对应用到该页面的规则用一些条件进行筛选：选择器匹配、属性有效、符合当前media等</strong></p><p>（Declared Value声明值：一个元素可能没有或者有多个值，处理声明的值）</p><p><strong>3.cascading：按照来源、!import、选择器特异性、书写顺序等选出优先级最高的一个属性值</strong></p><p>（Cascaded Value层叠值：在层叠的过程中，选出优先级最高的那个值）</p><p><strong>4.defaulting：当层叠值为空的时候，继承或初始化值</strong></p><p>（Specified Value指定值：经过cascading和defaulting之后，保证值一定不为空）</p><p><strong>5.resolving：将一些相对值或者关键字转化为绝对值，比如em转为px，相对路径转为绝对路径</strong></p><p>（Computed Value计算值：一般来说是浏览器会在不进行布局的情况下，所能得到的最具体的值，比如60%）</p><p><strong>6.formatting：将计算值进一步转换，比如关键字、百分比转为绝对值</strong></p><p>（Used Value使用值：进行实际布局的时候使用的值，均为绝对值，比如400.2px）</p><p><strong>7.constraining：将小数像素值转为整数</strong></p><p>（实际值：渲染时，实际生效的值，比如上述的400.2px实际生效的是400px）</p></blockquote><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>这里讲的是 <strong>标准盒模型</strong>，主要是了解margin padding border content 四个概念</p><p>这里我们准备两个标签：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>一号<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>二号<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>至于各种配色，我们这里是为了醒目，别说美感云云~~</p><h4 id="内容content"><a href="#内容content" class="headerlink" title="内容content"></a>内容content</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.test</span><span class="token punctuation">{</span><span class="token property">background-color</span><span class="token punctuation">:</span>#ff3700<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span>100px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span>100px<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用width和height来设置content大小</p><p><img src="https://img-blog.csdnimg.cn/cecb09a44c8d478db2fc77d16b41acd6.png" alt="橙色部分是content"></p><h4 id="边界border"><a href="#边界border" class="headerlink" title="边界border"></a>边界border</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.test</span><span class="token punctuation">{</span><span class="token property">background-color</span><span class="token punctuation">:</span>#ff3700<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span>100px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span>100px<span class="token punctuation">;</span><span class="token property">border</span><span class="token punctuation">:</span> 10px solid blue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>10px是边界宽度，</p><p>solid是边界样式，实心线，还有dashed等其他样式，</p><p>blue是边界颜色</p><p><img src="https://img-blog.csdnimg.cn/a8e348d6082d47428975c79a33cb78e8.png" alt="蓝色是边界border"></p><h4 id="内边距padding"><a href="#内边距padding" class="headerlink" title="内边距padding"></a>内边距padding</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.test</span><span class="token punctuation">{</span><span class="token property">background-color</span><span class="token punctuation">:</span>#ff3700<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span>100px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span>100px<span class="token punctuation">;</span><span class="token property">border</span><span class="token punctuation">:</span> 10px solid blue<span class="token punctuation">;</span><span class="token property">padding</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看图就知道了</p><p><img src="https://img-blog.csdnimg.cn/8079715748fb40859d55e5387b9a162d.png" alt="内容距离边界的距离就是内边距"></p><p>顾名思义，内容距离边界30px</p><h4 id="外边距margin"><a href="#外边距margin" class="headerlink" title="外边距margin"></a>外边距margin</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.test</span><span class="token punctuation">{</span><span class="token property">background-color</span><span class="token punctuation">:</span>#ff3700<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span>100px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span>100px<span class="token punctuation">;</span><span class="token property">border</span><span class="token punctuation">:</span> 10px solid blue<span class="token punctuation">;</span><span class="token property">padding</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span><span class="token property">margin</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/1554e0df41a943fcae12e0ed9e38621b.png" alt="外边距就是和其他元的距离啦"></p><p>顾名思义，和周围隔开30px</p><p>另外，我们可以打开浏览器，按下f12，点击右上角的这个图标，再用鼠标悬停在想要查看的图形上，就能查看包括盒子模型在内的相关信息</p><p><img src="https://img-blog.csdnimg.cn/039f7a232e1f460a98d36c8e1d37e338.png" alt="如图所示"></p><h4 id="怪异盒模型"><a href="#怪异盒模型" class="headerlink" title="怪异盒模型"></a>怪异盒模型</h4><p>设置box-sizing属性为border-box即可切换为怪异盒模型</p><p>在怪异盒模型中width和height指定后，设置padding或者border不会撑开容器而是向内压缩</p><h4 id="margin塌陷"><a href="#margin塌陷" class="headerlink" title="margin塌陷"></a>margin塌陷</h4><blockquote><p>即margin collapse</p><p>（也有叫外边距的重叠、折叠的说法…不过还是margin塌陷顺口些）</p><p>当元素A、B垂直分布且分别具有margin-bottom和margin-top属性时，会发生margin塌陷</p></blockquote><p>可以分为两类</p><p><strong>兄弟元素之间</strong></p><blockquote><p>竖直方向上margin不会相加，而是取二者中较大的值<br>但是注意，<strong>一正一负值则能够发生算术运算，而两者为负则取绝对值大者</strong></p></blockquote><p><strong>父子元素之间</strong></p><blockquote><p>父级元素如果没有padding-top和border-top，那么这个盒子的上边距会和其内部文档流中的第一个子元素发生上边距的重叠</p><p>（也就是说，这个子元素的margin-top要是找不到有效的border或者padding，那么就会不断向上找参照物）</p></blockquote><p><strong>历史由来</strong></p><p>这个并非是设计时考虑不周遗留下来的bug</p><p>而是有意为之，CSS1.0规范中所说：</p><blockquote><p>Two or more adjoining vertical margins (i.e., with no border, padding or content between them) are collapsed to use the maximum of the margin values. In most cases, after collapsing the vertical margins the result is visually more pleasing and closer to what the designer expects</p></blockquote><p>大意就是：<strong>margin塌陷是故意这样设计的，因为这样能够在大部分情况下符合设计师的要求</strong></p><blockquote><p>第一次听到这里，我的感受是——这怕是在扯淡吧，改个数值的事情和搞出塌陷这样的设计有什么关系？该不会是为了掩盖CSS设计的漏洞找的借口吧？</p></blockquote><p>但是后来找了一些资料看，1995提出HTML2.0才正式使用，1996才有CSS1.0，那么在1996以前，P标签这类样是固定且无法修改的（这也就是为什么一个div能解决的事情却还要提出那么多标签）</p><p>如果当时没有设计margin塌陷，那么竖直均匀分布就难以实现：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842ff58e495dc312778db23abc809657af960f2787dd1109845/0.png" alt="1996年前要是有margin塌陷"></p><h4 id="盒模型的差异"><a href="#盒模型的差异" class="headerlink" title="盒模型的差异"></a>盒模型的差异</h4><p>中所周知display有四个常用属性：block、inline、inline-block、none</p><blockquote><p><strong>block</strong></p><p>会产生一个块级盒子，内容被放到这个块级盒子中</p><p><strong>inline</strong></p><p>会生成一个行级盒子，内容分散在这个行级盒子中</p><p><strong>inline-block</strong></p><p>本身是行级，可以放到行级盒子中；作为一个整体而不会被分散</p><p><strong>none</strong></p><p>布局时完全被忽略</p></blockquote><p>这里我们需要注意inline：</p><blockquote><p>width height不生效</p><p>padding border可以生效，垂直方向上会覆盖其他元素（意味着并不会挤开其他元素）</p><p>margin 可以生效，但是竖直上不会影响其他元素</p><p>如此种种，综上所述，<strong>inline里面不能嵌套block</strong></p></blockquote><h3 id="定位和布局"><a href="#定位和布局" class="headerlink" title="定位和布局"></a>定位和布局</h3><h4 id="布局基础"><a href="#布局基础" class="headerlink" title="布局基础"></a>布局基础</h4><p>曾经提到过，块级元素和行级（内联元素）元素</p><p>看一段代码</p><p><img src="https://img-blog.csdnimg.cn/9af8ceb51f7448e69aa5017e0e170cb9.png" alt="行级元素不能直接改宽高"></p><p>显然，width和height并没有生效，这就和行级元素的性质有关系了，</p><p>不过我们可以通过修改display属性来改变元素的默认类型</p><p>很明显，这就生效了</p><p>这是因为，我们将其类型<strong>改变为块级（block）</strong></p><p><img src="https://img-blog.csdnimg.cn/0c12a49af1b5425ba64453cc4a4d0e66.png" alt="修改为块级元素"></p><p>同样地，还有非常多的类型可以尝试，特别是</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>inline-block</td><td>行级（内联）块元素。综合了二者</td></tr><tr><td>flex</td><td>弹性元素。非常好的一维布局</td></tr><tr><td>grid</td><td>网格元素。非常好的二维布局</td></tr><tr><td>none</td><td>不显示，配合js做一些特效</td></tr></tbody></table><p>通过上述知识可以至少可以完成多种形式的两栏或者说n栏布局。</p><p>当然，也不是所有布局都是要靠display完成的，还可以使用流式布局、设置margin: auto;水平居中等等</p><h4 id="常规流"><a href="#常规流" class="headerlink" title="常规流"></a>常规流</h4><p>这是三套定位的规则</p><p><strong>常规流 Normal Flow</strong></p><blockquote><p>也叫<strong>文档流</strong>，包括了行级、块级、表格布局、flex布局、grid布局等等规则</p><p>根元素、浮动和绝对定位的元素会脱离常规流，其它元素都在常规流之内（in-flow）</p><p>常规流中的盒子，在某种排版<strong>上下文</strong>中参与布局——上下文可以理解为某个范围内</p></blockquote><p>我们细细地嗦一嗦：</p><p><strong>行级排版上下文 Inline Formatting Context</strong></p><blockquote><p>因翻译不同而可以叫做行级格式化上下文，行级格式化环境等等</p><p>只包含行级盒子的容器会创建一个IFC，其规则为</p><p>1.优先在一行内摆放，空间不够则换行</p><p>2.text-align 决定一行内盒子的水平对齐</p><p>3.vertical-align决定一个盒子在行内的垂直对齐</p><p>4.<strong>避开浮动元素</strong></p></blockquote><p><strong>块级排版上下文 Block Formatting  Context</strong></p><blockquote><p>有的翻译是<strong>块级格式化上下文</strong>，还有叫<strong>块级格式化环境</strong>的,<br>触发这个性质的元素将会变成<strong>一个独立的、不会干扰外界的区域</strong><br>可以把这个看做一个隐藏的属性，不能像其他属性那样直接开启，需要通过一些间接方式开启</p><p>反正就是老生常谈的BFC咯</p><p>满足以下条件之一的容器会创建一个BFC：</p><ol><li><p>根元素</p></li><li><p>浮动/绝对定位（absolute或者fixed）/</p></li><li><p>flex子项/grid子项</p></li><li><p>overflow不为visible</p></li><li><p>display设置为 inline-block 或 table系列 或 flow-root</p></li><li><p>….(方式很多，上述几个是常见的，其余可以参考zeal)</p></li></ol><p>排版规则是：</p><p>1.盒子从上到下摆放</p><p>2.BFC内依旧有兄弟间margin塌陷</p><p>3.父元素开启BFC后不会再发生父子间margin塌陷</p><p>4.BFC不会和浮动元素重叠，并且可以包裹浮动元素</p></blockquote><p><strong>弹性盒子 Flex Box</strong></p><blockquote><p>也是上下文，别被名字误导了</p><p>规则是：</p><p>1.自定义摆放的方向（上下左右）</p><p>2.自定义摆放顺序</p><p>3.可以设置盒子宽高、水平垂直对齐方式</p><p>4.自定义是否允许换行</p></blockquote><p><strong>网格盒子 Grid Box</strong></p><blockquote><p>可以粗糙地理解为是二维的Flex Box</p></blockquote><h4 id="浮动流（待补充）"><a href="#浮动流（待补充）" class="headerlink" title="浮动流（待补充）"></a>浮动流（待补充）</h4><p>一开始没有flex或者grid，就用float做图文环绕的效果</p><blockquote><p>而正是由于这个初衷，文字会自动环绕在浮动元素周围</p></blockquote><p>后来有了flex等操作之后浮动也就用的少了</p><p>浮动的产生不必多说，重点是浮动的性质以及浮动的问题以及解决方案</p><blockquote><p><strong>文档流元素能看见文档流元素，看不见浮动流元素，</strong></p><ol><li><p>这意味着浮动流元素的位置将被后面的文档流元素占据<br>(换种说法就是浮动流元素会覆盖后面的文档流元素)</p></li><li><p>也意味着文档流看不见自己内部的浮动流</p></li></ol><p><strong>浮动流元素能看见文档流元素、浮动流元素</strong></p><ol><li>这意味着浮动流会被文档流和其他浮动流元素阻挡</li><li>也意味着文档流内部的浮动流会被束缚</li></ol><p><strong>脱离文档流可以设置宽高等</strong></p><ol><li><p>这意味着行内元素浮动后会变得和块级元素类似，但是不完全一样（比如块级元素默认宽度100%，但是浮动流并不会这样）</p><p><strong>（这里说的是脱离文档流，浮动流只是脱离的一种形式，有的定位也会脱离）</strong></p><p>+</p></li></ol></blockquote><p><strong>清除浮动：其一</strong></p><p>如果不希望<strong>某个元素</strong>受到其他元素的浮动影响而改变位置，我们可以清除浮动</p><blockquote><p>注意，是清除某个元素因为浮动受到的影响，而不是清除浮动本身</p></blockquote><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.div1</span><span class="token punctuation">{</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> lightgray<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token selector">.div2</span><span class="token punctuation">{</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">clear</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>    <span class="token comment">/*清除div2左侧的div1的浮动对div2造成的影响*/</span>    <span class="token comment">/*注意，如果设置为both，是清除两侧中影响较大那一侧，而不是同时清除两侧，这个大小是如何界定的看下面原理部分的解释*/</span>     <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原理</strong></p><blockquote><p>据说是设置clear之后，浏览器会为元素添加一个自适应的margin，使其位置不受影响</p><p>（据说按下F12也看不到margin的变动，但是原理是如此）</p><p>（听上去感觉很荒诞的样子）</p><p>而这个所谓的需要添加的margin的值越大，那么就判定这个浮动的影响越大，clear:both则会清除较大那一个</p></blockquote><p><strong>清除浮动：其二</strong></p><p>如果不使用BFC，子级又存在浮动流，那么可以像下面这样做</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>浮动元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clearfix<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>浮动清除器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box</span> <span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> bisque<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.content</span> <span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.clearfix</span> <span class="token punctuation">{</span>    <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里是属于用HTML结构处理表现上的问题（这本来该是CSS做的），所以这么做还并不够好</p></blockquote><p>仔细一想，这个<strong>clearfix里面的文本内容好像没有存在的意义，所以可以删掉</strong>；</p><p>更进一步地，这个末尾的标签存在就仅仅是为了清除浮动，那么<strong>没有必要写这个标签</strong>，所以我们删除clearfix之后用<strong>伪元素</strong>做就好了（这样一来就是CSS亲自解决了）</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box</span> <span class="token punctuation">{</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> bisque<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token selector">.content</span> <span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token selector">.box::after</span> <span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span><span class="token comment">/*设置内容为空*/</span>    <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span> <span class="token comment">/*伪元素默认为行内元素*/</span>    <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span> <span class="token comment">/*利用类似margin的东西撑起整个box*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优化</strong></p><p>既然都做到这一步了，那么干脆再优化一点吧，顺便把父子间margin塌陷的问题也解决了吧，只需要做一点小小的改动：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box::before</span> <span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>     <span class="token comment">/*table独占一行，内容为空时没有大小，是此处最好的选择*/</span>    <span class="token comment">/*使用inline-block的话因为幽灵节点的关系会占据一个小小的行高从而把下面的元素挤下去*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原理</strong></p><blockquote><p>大概是父子间有这个伪元素间隔，可以作为第一个子元素margin-top的参照物</p></blockquote><blockquote><p>也可以理解为有了这个伪元素后，第一个子元素逻辑上变成了第二个子元素，所以就不满足父子间margin塌陷的条件了(只有第一个子元素可以触发)</p></blockquote><p><strong>整合</strong></p><p>了解到display:table的性质之后，那么就可以整合margin塌陷和高度塌陷的解决方案：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box::before,.box::after</span> <span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>    <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="静态定位static"><a href="#静态定位static" class="headerlink" title="静态定位static"></a>静态定位static</h4><p>position的默认属性<br><strong>从上到下，从左到右依次排列</strong><br>属于正常的文档流，可以用这个解除产生的其他定位方式</p><h4 id="相对定位relative"><a href="#相对定位relative" class="headerlink" title="相对定位relative"></a>相对定位relative</h4><p>相对<strong>自身的（文档流中）初始位置</strong>移动<br>但是元素<strong>所占有的空间还在原来的位置</strong><br><img src="https://img-blog.csdnimg.cn/80911748da134c009fd530608c1a450a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_14,color_FFFFFF,t_70,g_se,x_16" alt="CSS中relative定位后保留原来空间"><br>可以通过设置relative属性但是并不进行移动，以此来配合absolute进行定位</p><h4 id="绝对定位absolute"><a href="#绝对定位absolute" class="headerlink" title="绝对定位absolute"></a>绝对定位absolute</h4><p>会脱离文档流，不会挤占空间</p><blockquote><p>如果不设置偏移量，那么就其本身位置不会移动;<br>如果设置偏移量，那么才发生偏移</p></blockquote><p>如果其父级元素满足以下几个条件中<strong>至少一个条件</strong>：</p><blockquote><p>1.设置了非static的定位<br>2.具有transform属性<br>3.具有perspective属性</p></blockquote><p>那么，它相对满足上述条件的父级中<strong>距离自己最近的一个</strong>进行移动</p><blockquote><p> 如果不存在这样的父级，那么相对于谁进行移动？<br>有的资料说是html，有的说是body，有的说是<strong>初始包含块</strong></p><p>这个问题放到后面说</p></blockquote><p><strong>水平布局等式</strong></p><blockquote><p> <strong>left + margin + border  + padding + width (+ left + right ) = 定位参考元素的宽</strong></p><p>等式不成立时，则触发<strong>过度约束</strong>：</p><p>如果上述属性中没有值为auto，则浏览器自动调整right使等式成立；</p><p>如果上述属性中有值为auto，则浏览器调整值为auto的属性使等式满足；</p></blockquote><p>这个也解释了margin: 0 auto;为什么可以自动居中——浏览器自动调整水平方向的margin使水平布局使等式成立<br>同理，拆开设置margin-top:auto;和margin-bottom:auto;也可以达到同样的效果</p><p><strong>垂直布局等式</strong></p><blockquote><p>在文档流中并不是强制要求满足的，但是<strong>定位脱离文档流之后就必须满足</strong>：</p><p><strong>margin + border + padding + height (+ top + bottom)  = 定位参考元素的高</strong></p><p>再次强调，这个是在定位元素脱离文档流之后才必须满足的，才有类似水平布局等式的过度约束发生</p></blockquote><h4 id="固定定位fixed"><a href="#固定定位fixed" class="headerlink" title="固定定位fixed"></a>固定定位fixed</h4><p>类似于abosolute，也会脱离文档流，但是fixed相对窗口进行移动<br>会始终固定在窗口的某一位置</p><blockquote><p>根标签是fixed定位</p><p>html和body标签，如果二者都开启滚动条，那么body会出现滚动条；如果只有其中一个开启，那么仅有html出现滚动条</p></blockquote><p>比如C站的右下角这几个按钮的父级就是采用的固定定位，无论窗口怎么滑动，它都是在右下角同一位置<br><img src="https://img-blog.csdnimg.cn/cbef35b982344647a7289625a5061b99.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_17,color_FFFFFF,t_70,g_se,x_16" alt="CSDN使用CSS的fixed布局样例"></p><h4 id="黏性定位sticky"><a href="#黏性定位sticky" class="headerlink" title="黏性定位sticky"></a>黏性定位sticky</h4><p>（黏性布局是个人翻译…<br>这是C3的新属性，具体效果类似relative + fixed<br>即<strong>达到某个位置的时候就保持不动</strong></p><p>其中son具有sticky属性</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>son<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下<br><img src="https://img-blog.csdnimg.cn/8eec2b4db33f460aa700e7edd1277bb5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="CSS布局中的sticky布局效果1"></p><p>当我们向下滑动窗口，发现son<strong>开始保持在某个位置</strong>了<br>（这里的某个位置是指我设置的top:10px;）<br><img src="https://img-blog.csdnimg.cn/038997f38669432f9a9b873aa755eebf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="CSS布局中的sticky布局效果2"></p><p>继续，依旧保持不动</p><p><img src="https://img-blog.csdnimg.cn/b7eab9b4f94e438f8bbc524501d71e9b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="CSS布局中的sticky布局效果3"></p><blockquote><p>定位而脱离文档流的元素，渲染顺序越靠后，层级越高<br>层级可以通过z-index来手动设置</p></blockquote><h4 id="初始包含块"><a href="#初始包含块" class="headerlink" title="初始包含块"></a>初始包含块</h4><blockquote><p> 包含块（ containing block )</p><p><strong>-正常情况下</strong>:<br>包含块就是离当前元素最近的祖先块元素<br><strong>-绝对定位的包含块</strong>:<br>包含块就是离他最近的开启了定位的祖先元素<br>如果所有的祖先元素都没有开启定位则根元素就是它的包含块</p></blockquote><p>一开始我是不知道有这个概念的，但幸亏江宇是个好同志啊和我讨论这个事情，<br>几度怀疑之后我才发觉这个东西并不简单</p><p>探讨这个问题的根本在于，直接父级为body的元素开启绝对定位时，究竟是参照谁？body？html？</p><blockquote><p>答案是参照<strong>初始包含块</strong>，但是我们如何去理解这个概念，又该如何去验证呢？</p></blockquote><p>网页的结构由外至内是：</p><blockquote><p>浏览器窗口（视口） &gt; 初始包含块 &gt; html根标签 &gt; body &gt;…..</p><p><strong>所以初始包含块是包裹html的一层（有一种大象无形的感觉）</strong></p><p>但是我们依旧有办法看看它到底在哪</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842514eab6bb72b81feace203f9c74744b19e7c18e29135f25f/0.png" alt="初始包含块示意图"></p><p>图中可以看到，绝对定位是没有参照html，也没有参照body，而是这个平时从未注意过的初始包含块！</p><blockquote><p>太强了，这哪里是江宇老弟啊，这简直是江宇大帝啊！<br>竟然初学前端就注意到了这种问题，强至于此，实乃天人也！</p></blockquote><p>另外，还有一个有趣的现象就是，<strong>初始包含块的背景颜色</strong>是从html由上往下找的，如果html有颜色那么则采用html的颜色；没有则采用body的颜色——这是因为浏览器机制产生的现象</p><h3 id="字体（待补充）"><a href="#字体（待补充）" class="headerlink" title="字体（待补充）"></a>字体（待补充）</h3><h4 id="字体族"><a href="#字体族" class="headerlink" title="字体族"></a>字体族</h4><h4 id="图标字体"><a href="#图标字体" class="headerlink" title="图标字体"></a>图标字体</h4><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><h4 id="其他文本样式"><a href="#其他文本样式" class="headerlink" title="其他文本样式"></a>其他文本样式</h4><h3 id="CSS动画（待补充）"><a href="#CSS动画（待补充）" class="headerlink" title="CSS动画（待补充）"></a>CSS动画（待补充）</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><blockquote><p>前端实现小动画效果一般是三种形式：<br>gif  css js </p><p>（曾经也是前端三剑客之一的flash已经不在考虑范围之内）</p></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842d194cf4e14044856cc91de633456383c1ea6b920a6ef3913/0.png" alt="常用属性"></p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842d194cf4e14044856bb79fbddea37d6cf98f677e25989d972/0.png" alt="动画速度"></p><p>这个所谓的步长，实际上就是补帧，比如填个10，就是说10帧完成</p><p>而linear就是匀速，ease是慢速</p><h4 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h4><p><code>转换</code>实际上就是说的transform属性<br>关于transform记住以下几点就好了:</p><blockquote><ol><li>transform可以接多个属性值，而且一般把translate系列放前面</li><li>translateZ的参数一遍以px为单位，几乎不会像XY一样用百分比（因为大部分父级不能作为z轴上的参考</li><li>注意，translate没有第三个参数，应该使用translate3d来做三个方向上的偏移</li><li>而rotate3d则是四个参数，前三个是矢量法自定义转轴，第四个是旋转的角度</li><li>z轴的正方向是垂直向上</li></ol></blockquote><p>至于3D，具有  <strong>渊 博 美 术 知 识</strong>  的我还是很有话说的</p><blockquote><p>指学过一个月的素描…</p></blockquote><p>而要做3D效果就不能不知道<strong>透视（perspective，也可以理解为视距）</strong>，也可以理解为<strong>3D图形在2D平面的投影</strong></p><p>——这一点非常重要，不仅是满足远小近大这个特点，更是说图形虽然看上去是3D，但是实际上还是2D（可以旋转图形观察）</p><p>如果要做到真正的3D，则需要将<strong>父级的</strong>默认的transform-style:flat 改为 transform-style: perspective-3d开启立体空间</p><blockquote><p>配合translateZ属性就能明显地看到效果，注意，<strong>perspective属性要加在目标的父级上</strong></p><p>perspective和translatez可以看做——眼睛的位置和物体的位置</p></blockquote><h3 id="CSS预处理器（待补充）"><a href="#CSS预处理器（待补充）" class="headerlink" title="CSS预处理器（待补充）"></a>CSS预处理器（待补充）</h3><p>原生CSS也是支持变量的，语法用 “<strong>–变量名:变量值</strong>的形式声明,声明的位置可以是html标签选择器内（或者通配符内也行）,而使用变量时的语法则是<strong>var(变量名)</strong></p><blockquote><p>变量是CSS3的新特性，一是兼容性不好，二是功能不完善，所以还是需要有预处理器来辅助</p></blockquote><p>这个部分简单提一下，这已经超出CSS本身的范畴了<br>以后有空单独出一篇写预处理器</p><h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><blockquote><p>诞生于2007年，也叫SCSS，是对CSS的扩充<br>可以使用变量、常量、混入、函数等功能，最终会编译出合法的CSS给浏览器使用</p><p>严格来说，Sass和SCSS是有区别的，这个区别在于语法规则不一样:</p><p>SCSS和CSS一样采用了{}，而Sass采用缩进，不过Sass3之后的版本都支持SCSS这样的语法</p></blockquote><h4 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h4><blockquote><p>​    诞生于2009年，基于Sass的思想而使用CSS的语法</p></blockquote><p>别的预处理器怎么样不知道，但是Less支持父子级元素的CSS嵌套，这就很棒了</p><p><strong>创建和引入</strong></p><p>创建的文件扩展名是less，</p><p>在html内引入方式和CSS完全一致:</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx.css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就连扩展名也依旧用css而不是less</p><blockquote><p>因为在项目运行的时候，less文件会在同一目录下被编译为一个同名的css文件</p></blockquote><p>但是在less中引入less时，用的是如下语法:</p><pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token variable">@import</span> <span class="token string">"xxx.less"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注释</strong></p><p>Less新增单行注释，其内容不会被解析为CSS，但是CSS原有的多行注释会被解析</p><p><strong>变量</strong></p><p>语法如下，这里的变量依旧是弱类型的，所以值比较随意<br>至于在何处声明，推荐是在文件的开头直接写</p><pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token variable">@a<span class="token punctuation">:</span></span>100px<span class="token punctuation">;</span><span class="token variable">@b<span class="token punctuation">:</span></span>div233<span class="token punctuation">;</span> <span class="token comment">/* 这是一个class名称 */</span><span class="token selector">body</span> <span class="token punctuation">{</span>    <span class="token property">height</span><span class="token punctuation">:</span> 100px <span class="token operator">+</span> 100px<span class="token punctuation">;</span> <span class="token comment">// 没错，值可以直接运算，变量自然也可以</span><span class="token property">width</span><span class="token punctuation">:</span><span class="token variable">@a</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token comment">// 作为class名、属性名或者作为某个整体的部分（比如字符串拼接）使用时，需要用@{}的形式</span><span class="token selector">.@{b}</span> <span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token variable">@a</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">div</span> <span class="token punctuation">{</span>    <span class="token selector">div</span> <span class="token punctuation">{</span>        <span class="token comment">// 后代</span>    <span class="token punctuation">}</span>    <span class="token selector">&gt;span</span> <span class="token punctuation">{</span>        <span class="token comment">// 子代</span>    <span class="token punctuation">}</span>    <span class="token selector">&amp;:hover</span> <span class="token punctuation">{</span>        <span class="token comment">// &amp;表示父级的名称，也就是最外层这个div</span>        <span class="token comment">// 不能写成div:hover,这样会被视为子级div的hover</span>        <span class="token comment">// 但是要注意，&amp;实际上是代指一个字符串，也就是'div'</span>        <span class="token comment">// 它可以直接拼接拿来用，比如写成.&amp;233就可以表示.div233</span>          <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量重名时，优先使用较近者</p><p><strong>引用</strong></p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">body</span> <span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> $width<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样height就使用了width的值了</p><p><strong>继承</strong></p><p>也叫<strong>扩展</strong>….<br>两种写法：</p><pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token selector">.div1:extend(.p2)</span> <span class="token punctuation">{</span>    <span class="token comment">// 继承，懂的都懂吧？</span><span class="token punctuation">}</span><span class="token selector">.div1</span> <span class="token punctuation">{</span>    <span class="token comment">// 这个其实是一个简单的混合函数（mixin）</span>    .<span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两种写法在编译成CSS之后有差异：</p><blockquote><p>前者是变成了复合选择器中的并集选择器，后者则是直接把属性复制<br>（前者是类似并查集的思想，性能好；后者则是暴力copy，性能差）</p></blockquote><p>这种差异看完后面的混合函数相关的概念之后应该更好理解</p><p><strong>类选择器</strong></p><pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token selector">.p1()</span> <span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>类选择器本身不会生效，它的作用就是给别人使用，就像之前提到的继承中的第二个写法那样</p><p><strong>混合函数</strong></p><p>可以看作函数那样使用:</p><pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token selector">.mixin_fun(<span class="token variable">@a</span>， <span class="token variable">@b</span>:red)</span> <span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token variable">@a</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token variable">@b</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">div</span> <span class="token punctuation">{</span>    <span class="token mixin-usage function">.test</span><span class="token punctuation">(</span>200px<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其他内置函数</strong></p><blockquote><p>average()之类的，估计还有sum()等等，这些的就不多说了</p></blockquote><p>Less暂时就说这么多吧，再说就偏题了，以后花时间专门学一学更好</p><h4 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h4><blockquote><p>​    诞生于2010年，来自Node.JS社区,主要用来给Node项目进行CSS预处理，也支持缩进语法和CSS语法（但是好像人气并不如前两个诶）</p></blockquote><h4 id="其他预处理器"><a href="#其他预处理器" class="headerlink" title="其他预处理器"></a>其他预处理器</h4><blockquote><p>比如Turbine、Swithch CSS、CSS Cacheer、DT CSS等</p></blockquote><h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><h3 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h3><blockquote><p> 众所周知，物理像素和CSS像素（px）是两码事<br><code>物理像素</code>是真实存在且大小固定的一个物理发光单位，而<code>CSS像素</code>是与<code>物理像素</code>存在某种比例关系的值</p></blockquote><p>一般而言，PC端的1px就是1物理像素，而在移动端上则可能不符合这一比例，具体情况如下：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa0516842a14fd9b0c7299f45e7e40a711e6e730367f7450c667d072f/0.png" alt="移动端dpr表"></p><p>解释一下，比如这里的dpr==2.0就意味着pc端的1px在该移动端设备上将显示为2px的效果</p><p>我们可以通过如下代码获取当前设备的物理像素比dpr</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span>devicePixelRatio<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么，为什么移动端要做这样的设定呢？</p><h3 id="Retina显示技术"><a href="#Retina显示技术" class="headerlink" title="Retina显示技术"></a>Retina显示技术</h3><p>即 <strong>视网膜屏幕显示技术</strong>，可以把更多的物理像素点压缩到一块屏幕里面，<br><strong>从而达到更高的分辨率，并提高屏幕显示的细腻程度</strong></p><blockquote><p>据说这个技术是摩托罗拉公司开发的，没错就是诺基亚那个公司！<br>我的妈呀，想想诺基亚那个分辨率，里面可能有这个技术简直是惊为天人！</p></blockquote><p>另外，为了开发者调试，浏览器会做一些处理工作<br>比如模拟dpr==2的移动设备，参数上是说750 * 1800，<br>那么浏览器模拟时会自动将视口调整为375 * 900</p><h3 id="移动端开发选择"><a href="#移动端开发选择" class="headerlink" title="移动端开发选择"></a>移动端开发选择</h3><p>一般而言有两种，一种是原页面做兼容，另一种是单独写个页面</p><p><strong>响应式布局兼容原页面</strong></p><blockquote><p>% vw vh rem em 用起来，meta视口改一下，布局flex grid——<br>没有UI大佬的话，<br>差不多能用就行了，别要求太高 </p></blockquote><p><strong>单独写页面</strong></p><blockquote><p>这是国内市场的主流形式，配合navigator对象做一下设备判断选择性跳转页面</p></blockquote><p>另外，这里补充一下媒体查询（虽然感觉这个东西有点过时，但是还是说一下基本语法）</p><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> [mediatype] <span class="token keyword">and</span> | <span class="token keyword">not</span> | <span class="token keyword">only</span> <span class="token punctuation">(</span>media feature<span class="token punctuation">)</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">/*1. mediatype 是媒体类型2. and not only 是逻辑谓词，only是指定某个特定的媒体类型，可以省略3. media feature 媒体特性， 必须有小括号*/</span><span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 539px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>    <span class="token selector">body</span> <span class="token punctuation">{</span>        <span class="token property">background-color</span><span class="token punctuation">:</span>blue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/*上面这个就表示 小于540px的屏幕*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，如果全都挤到media里面看着挺臃肿的，所以这里再link引入css的也可以进行媒体查询</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 语法如下 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mediatype and | not | only (media feature)<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.../style.css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="移动端浏览器内核"><a href="#移动端浏览器内核" class="headerlink" title="移动端浏览器内核"></a>移动端浏览器内核</h3><p>一般来说是webkit，所以H5C3还是支持的，如果要考虑一些较新的特性的兼容性的话，<br>可以试着加上私有前缀webkit兼容</p><p>另外，浏览器也有一些特殊的内容，比如touch事件这些，不过此处不再赘述</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2021/12/06/mysql/"/>
      <url>/2021/12/06/mysql/</url>
      
        <content type="html"><![CDATA[<p>这是大一下暑假的时候写的，以前放在csdn上，现在搬迁到自己的博客了</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来学过的，结果太久没用就忘了<br>由于是做前端的，所这个就学个大概,笔记相对基础一点</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><img src="https://img-blog.csdnimg.cn/20210717142400480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>变量名别太离谱就行，<strong>变量值是mysql的bin文件的上级目录</strong><br><img src="https://img-blog.csdnimg.cn/20210717142609272.png" alt="在这里插入图片描述"><br>接下来找到这个，点击编辑<br><img src="https://img-blog.csdnimg.cn/20210717142807884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后点击新建<br><img src="https://img-blog.csdnimg.cn/20210717142905202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后输入bin文件路径<br><img src="https://img-blog.csdnimg.cn/20210717143204158.png" alt="在这里插入图片描述"></p><h2 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h2><p>win + r进入cmd窗口，进行如图所示操作<img src="https://img-blog.csdnimg.cn/20210717143808589.png" alt="在这里插入图片描述"><br>其中-u后紧跟的是用户名，-p紧跟的是密码，这些在mysql下载安装时有配置，我这里设置的是root和root<br><img src="https://img-blog.csdnimg.cn/20210717144018209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看到这一幕，说明MySQL的变量配置成功了，可以正常运行了</p><p><strong>另外，你可以这样输入密码</strong><br><img src="https://img-blog.csdnimg.cn/20210717144130558.png" alt="在这里插入图片描述"></p><p><strong>退出是exit指令</strong><br><img src="https://img-blog.csdnimg.cn/20210717144210447.png" alt="在这里插入图片描述"></p><h2 id="MySQL核心文件"><a href="#MySQL核心文件" class="headerlink" title="MySQL核心文件"></a>MySQL核心文件</h2><p>bin文件：存储命令文件<br>lib文件：存储库文件<br>include文件：存储头文件<br>Share文件：存储字符集、语言等信息<br>mysql.ini文件（隐藏文件）：mysql的配置文件</p><p><strong>了解即可，配置那些后面用可视化工具操作方便得多</strong></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>这一部分，可以暂时先跳过</p><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p><img src="https://img-blog.csdnimg.cn/20210718111810150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h4><p><img src="https://img-blog.csdnimg.cn/20210718111903906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p><img src="https://img-blog.csdnimg.cn/2021071811205639.png" alt="在这里插入图片描述"></p><h2 id="DDl-数据定义语言"><a href="#DDl-数据定义语言" class="headerlink" title="DDl:数据定义语言"></a>DDl:数据定义语言</h2><p>（当然这个标题并不是很严谨，只是大部分都是DDI的内容）</p><p>SQL是Structured Query Language结构化查询语言<br>而DDL是Data Definition Language，能对数据库进行操作</p><p>（<strong>注意:</strong><br>1.使用SQL语句时，记得结尾加；<br>2.使用SQL命令之前确保数据库已经开启<br><strong>3.mysql几乎不区分大小写，大部分内容最后都会统一转为小写</strong><br>）</p><h4 id="显示所有数据库SHOW-DATABASES"><a href="#显示所有数据库SHOW-DATABASES" class="headerlink" title="显示所有数据库SHOW DATABASES"></a>显示所有数据库<code>SHOW DATABASES</code></h4><p> 显示所有的数据库<br><img src="https://img-blog.csdnimg.cn/20210717145905852.png" alt="在这里插入图片描述"><br> 这几个是系统自带的数据库，具体情况由安装的版本决定，但无论如何，不要随便去动这几个</p><h4 id="创建数据库CREATE-DATABASE"><a href="#创建数据库CREATE-DATABASE" class="headerlink" title="创建数据库CREATE DATABASE"></a>创建数据库<code>CREATE DATABASE</code></h4><p>创建数据库，规范是这里要大写名字,但是实际上<strong>mysql会把名字统一转化为小写</strong><br>（毕竟命令都是大写，名称又都是大写实在是不方便阅读）<br><img src="https://img-blog.csdnimg.cn/20210717150832388.png" alt="在这里插入图片描述"><br>这里创建了一个名字叫myDataBase1的数据库，并且设置它的字符集是国标码 gbk<br><strong>（当然后面的CHARACTER SET gbk可以省略）</strong></p><p>再用SHOW DATABASES查询一下<br>（<em>这里我漏加了;不过会提示让你补上的</em>）<br><img src="https://img-blog.csdnimg.cn/20210717151215494.png" alt="在这里插入图片描述"><br>另外，如果你不确定某个数据库是否已经存在，可以这样写<br><img src="https://img-blog.csdnimg.cn/20210717152939962.png" alt="在这里插入图片描述"></p><h4 id="显示数据库的创建信息SHOW-CREATE-DATABASE"><a href="#显示数据库的创建信息SHOW-CREATE-DATABASE" class="headerlink" title="显示数据库的创建信息SHOW CREATE DATABASE"></a>显示数据库的创建信息<code>SHOW CREATE DATABASE</code></h4><p> 展示创建某个数据库时的相关信息<br> <img src="https://img-blog.csdnimg.cn/20210717152120378.png" alt="在这里插入图片描述"></p><h4 id="修改数据库ALTER-DATABASE"><a href="#修改数据库ALTER-DATABASE" class="headerlink" title="修改数据库ALTER DATABASE"></a>修改数据库<code>ALTER DATABASE</code></h4><p>修改某个数据库的某个信息<br><img src="https://img-blog.csdnimg.cn/20210717152455547.png" alt="在这里插入图片描述"><br>修改mydatabase1的字符集为utf8<br><strong>注意mysql中是utf8而不是utf-8</strong></p><h4 id="删除数据库DROP-DATABASE"><a href="#删除数据库DROP-DATABASE" class="headerlink" title="删除数据库DROP DATABASE"></a>删除数据库<code>DROP DATABASE</code></h4><p>删除某个数据库<br><img src="https://img-blog.csdnimg.cn/20210717153138676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="使用数据库USE"><a href="#使用数据库USE" class="headerlink" title="使用数据库USE"></a>使用数据库USE</h4><p>使用某个数据库<br>数据都在数据库里面，我们之前一直都在外面对众多数据库进行增删改查，还没有进去访问过<br><img src="https://img-blog.csdnimg.cn/20210717153436927.png" alt="在这里插入图片描述"></p><h4 id="查看当前数据库SELECT-DATABASE"><a href="#查看当前数据库SELECT-DATABASE" class="headerlink" title="查看当前数据库SELECT DATABASE()"></a>查看当前数据库SELECT DATABASE()</h4><p>假如你不知道你正在使用哪个数据库，你就可以这么写<br><img src="https://img-blog.csdnimg.cn/20210717153611248.png" alt="在这里插入图片描述"><br>正在使用mydatabase1<br><strong>如果没有使用任何数据库，那么结果是NULL</strong><br><img src="https://img-blog.csdnimg.cn/2021071715385160.png" alt="在这里插入图片描述"></p><p>那么这里我就突发奇想，数据库名字能叫NULL吗<br><img src="https://img-blog.csdnimg.cn/2021071715402028.png" alt="在这里插入图片描述"><br>果然不行。而且哪怕可以如此，数据库名字统一为小写，null仍能与NULL区分</p><p>==========================================================<br><strong>接下来的DDI语句内容可以先暂时跳过，后面看完了可视化数据库工具再折回来看</strong></p><h4 id="创建表CREATE-TABLE"><a href="#创建表CREATE-TABLE" class="headerlink" title="创建表CREATE TABLE"></a>创建表CREATE TABLE</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `subject`(</span><br><span class="line">subjectId <span class="type">INT</span>,</span><br><span class="line">`课序号` <span class="type">INT</span>,</span><br><span class="line">subjectName <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">subjectHours <span class="type">INT</span></span><br><span class="line">)CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></tbody></table></figure><p>以上代码运行的创建结果如图所示<br><img src="https://img-blog.csdnimg.cn/20210718200232542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="修改表ALERT-TABLE"><a href="#修改表ALERT-TABLE" class="headerlink" title="修改表ALERT TABLE"></a>修改表<code>ALERT TABLE</code></h4><h6 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a><code>ADD</code></h6><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `subject` <span class="keyword">ADD</span> gradeID <span class="type">INT</span>;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718200743443.png" alt="在这里插入图片描述"></p><h6 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a><code>DROP</code></h6><p>每次只能删除一列</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `subject` <span class="keyword">DROP</span>  gradeID;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718201530660.png" alt="在这里插入图片描述"></p><h6 id="MODIFY"><a href="#MODIFY" class="headerlink" title="MODIFY"></a><code>MODIFY</code></h6><p>修改该列的属性（不包括名称）</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `subject` MODIFY subjectName <span class="type">VARCHAR</span>(<span class="number">5</span>) ;</span><br></pre></td></tr></tbody></table></figure><p>修改前:<br><img src="https://img-blog.csdnimg.cn/20210718201917332.png" alt="在这里插入图片描述"><br>修改后：<br><img src="https://img-blog.csdnimg.cn/20210718202041410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="CHANGE"><a href="#CHANGE" class="headerlink" title="CHANGE"></a><code>CHANGE</code></h6><p>修改列的名称<br><img src="https://img-blog.csdnimg.cn/20210718203331714.png" alt="在这里插入图片描述"></p><h6 id="RENAME"><a href="#RENAME" class="headerlink" title="RENAME"></a><code>RENAME</code></h6><p>表重命名<br><img src="https://img-blog.csdnimg.cn/20210718205133463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="可视化数据库工具"><a href="#可视化数据库工具" class="headerlink" title="可视化数据库工具"></a>可视化数据库工具</h2><p>cmd <del>太丑了</del> 数据显示不是那么直观<br>所以诞生了许多可视化数据库工具</p><p>比如Navicate，SQLyog，SQL_Front，HeidiSQL，DBite for SQLite等等，根据自身情况随便选一个就行</p><p>我们这里采用SQL_yog<br>首先新建一个链接，名字随意取<br><img src="https://img-blog.csdnimg.cn/20210717155616692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后输入 用户名 和 密码 进入<br><img src="https://img-blog.csdnimg.cn/20210717160341399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>好耶，这可不比cmd香得多？<br><del>而且更棒的是还支持鼠标操作</del><br><img src="https://img-blog.csdnimg.cn/20210717160624108.png" alt="在这里插入图片描述"><br>有了大小写自动转化，而且还有了TAB补全！<br>甚至只执行单条语句都不用加分号</p><p>选中一条语句，然后按下F9，就可以在下方的区域看到执行结果<br><img src="https://img-blog.csdnimg.cn/20210717160811539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210717161006952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(注意创建新的库之后要刷新一下才能显示）</p><p>并且现在可以通过#创建注释了<br><img src="https://img-blog.csdnimg.cn/20210717161338216.png" alt="在这里插入图片描述"></p><h2 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL:数据查询语言"></a>DQL:数据查询语言</h2><p>hmmmmm查数据至少得先有数据吧….<br>那这里先用鼠标手动添加数据，或者也可以直接先去看后面的<strong>DML数据操作语言的内容</strong></p><h4 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h4><p>操作数据之前我们先做一点前置准备:<br><strong>鼠标创建一张表</strong><br>名字是t_persons<br><img src="https://img-blog.csdnimg.cn/20210717162852313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>然后打开表继续鼠标添加数据</strong><br><img src="https://img-blog.csdnimg.cn/20210717163449725.png" alt="在这里插入图片描述"></p><h4 id="查询SELECT-FROM"><a href="#查询SELECT-FROM" class="headerlink" title="查询SELECT FROM"></a>查询<code>SELECT FROM</code></h4><p>最简单的查询<br><img src="https://img-blog.csdnimg.cn/20210717164146419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">注意name是一个关键字，这里需要使用反引号（就是tab上面那个）屏蔽一下</p><p>另外，* 是所有的意思，这样写也可以<br>(不过这样写的话，底层还有一个展开的过程，所以执行速度会相对减慢)<br><img src="https://img-blog.csdnimg.cn/20210717164540901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><em>诶等等，之前不是录入了四组数据吗，某本伟怎么不见了！<br>看了看才发现我没保存….不过不影响…</em></p><p>另外，查询语句是可以进行运算的<br><img src="https://img-blog.csdnimg.cn/20210717165448925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里就要提到一个概念：<strong>虚拟表</strong><br>通过查询手段得到的新表是一个 <strong>处理过的</strong> <strong>节选的</strong> 原表 <strong>副本</strong>,即虚拟表<br>所以在查询的时候对数据进行操作并不会影响到原表</p><h4 id="重命名AS"><a href="#重命名AS" class="headerlink" title="重命名AS"></a>重命名<code>AS</code></h4><p>用来给出别称的</p><p><img src="https://img-blog.csdnimg.cn/20210717215129640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="有序查询ORDER-BY"><a href="#有序查询ORDER-BY" class="headerlink" title="有序查询ORDER BY"></a>有序查询<code>ORDER BY</code></h4><p>给查询结果排个序</p><p><strong>ASC</strong>（可省略，默认值）升序<br><img src="https://img-blog.csdnimg.cn/20210717221208990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>DESC</strong>降序<br><img src="https://img-blog.csdnimg.cn/20210717221306726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="条件查询WHERE"><a href="#条件查询WHERE" class="headerlink" title="条件查询WHERE"></a>条件查询<code>WHERE</code></h4><p>条件筛选<br><img src="https://img-blog.csdnimg.cn/20210717225828576.png" alt="在这里插入图片描述"></p><h4 id="逻辑AND和OR和NOT"><a href="#逻辑AND和OR和NOT" class="headerlink" title="逻辑AND和OR和NOT"></a>逻辑<code>AND和OR和NOT</code></h4><p>逻辑 且 或 非<br>(这里就演示一下OR，其他依葫芦画瓢)<br><img src="https://img-blog.csdnimg.cn/20210717230924632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="不等式"><a href="#不等式" class="headerlink" title="不等式"></a>不等式</h4><p>&lt;，&gt; ， &lt;，  &gt;=，  &lt;=，  !=， <strong>&lt;&gt;</strong></p><p> 最后一个&lt;&gt;<br> 也是不等于的意思，和!=一样<img src="https://img-blog.csdnimg.cn/20210717232133252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>另外还需要提一下的就只有<br>区间依旧需要分开写，然后用逻辑连接词链接<br><img src="https://img-blog.csdnimg.cn/20210717233048859.png" alt="在这里插入图片描述"></p><h4 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a><code>NULL</code></h4><p>空值<br>对于NULL值，判定不能用=或者！=以及&lt;&gt;<br>而需要用到</p><h4 id="IS"><a href="#IS" class="headerlink" title="IS"></a><code>IS</code></h4><p><img src="https://img-blog.csdnimg.cn/20210717234020106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="枚举IN"><a href="#枚举IN" class="headerlink" title="枚举IN"></a>枚举<code>IN</code></h4><p>枚举<br>选出id为1或2的<br><img src="https://img-blog.csdnimg.cn/20210717234721554.png" alt="在这里插入图片描述"></p><h4 id="模糊查询LIKE"><a href="#模糊查询LIKE" class="headerlink" title="模糊查询LIKE"></a>模糊查询<code>LIKE</code></h4><p>模糊查询<br>第一种是<strong>有限个数字符</strong>模糊，比如一个 张某<br><strong>每模糊一个字符，都要在相应的位置加上一个 _</strong><br><img src="https://img-blog.csdnimg.cn/20210717235948247.png" alt="在这里插入图片描述"></p><p>第二种是<strong>任意个数字符</strong>模糊<br><img src="https://img-blog.csdnimg.cn/20210718000234522.png" alt="在这里插入图片描述"></p><h4 id="CASE-END"><a href="#CASE-END" class="headerlink" title="CASE END"></a><code>CASE END</code></h4><p>就是一个分支结构，when这里翻译为   <strong>当…时</strong><br>注意别漏掉CASE前面的逗号<br><img src="https://img-blog.csdnimg.cn/20210718001904277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="时间类函数"><a href="#时间类函数" class="headerlink" title="时间类函数"></a>时间类函数</h2><p>这部分内容比较多，就不一一用代码演示了<br>以下几张图片都来自于视频截图<br><a href="https://www.bilibili.com/video/BV1BZ4y1H7LZ?p=13">图片来源</a><br><img src="https://img-blog.csdnimg.cn/2021071802393026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="字符类函数"><a href="#字符类函数" class="headerlink" title="字符类函数"></a>字符类函数</h2><p>同上<br><img src="https://img-blog.csdnimg.cn/20210718023945753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>同上<br><img src="https://img-blog.csdnimg.cn/20210718024005382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="分组查询GROUP-BY"><a href="#分组查询GROUP-BY" class="headerlink" title="分组查询GROUP BY"></a>分组查询<code>GROUP BY</code></h2><p>首先给表增加一点东西<br><img src="https://img-blog.csdnimg.cn/20210718025704334.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`,<span class="built_in">COUNT</span>(sex)</span><br><span class="line"><span class="keyword">FROM</span> t_persons </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sex</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>下表中的1，2代表1男2女<br><img src="https://img-blog.csdnimg.cn/20210718030404342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="限定查询LIMIT"><a href="#限定查询LIMIT" class="headerlink" title="限定查询LIMIT"></a>限定查询<code>LIMIT</code></h2><p>0,2代表是<strong>从0行开始   查询2行数据</strong>（下标从0开始）<br><img src="https://img-blog.csdnimg.cn/202107180316225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>其实也就是套娃<br>需要注意的就是注意 子查询结果 参与比较的时候 的数据类型<br>别用int和char比，不然只能稀里糊涂地改半天bug<br>1.子查询的结果是单行单列<br><img src="https://img-blog.csdnimg.cn/20210718032905509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.子查询的结果是单行多列<br>记得开枚举，不然你怎么用单个数据去和整个返回内容比较呢<br><img src="https://img-blog.csdnimg.cn/20210718034055805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.如果结果是多行单列</p><h2 id="任意与存在：ALL与ANY"><a href="#任意与存在：ALL与ANY" class="headerlink" title="任意与存在：ALL与ANY"></a>任意与存在：<code>ALL</code>与<code>ANY</code></h2><p>其实就是字面意思</p><p>另外，这里的sex用0,1表示的<br><img src="https://img-blog.csdnimg.cn/20210718034612437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.子查询的结果是多行多列（一张表）</p><p>注意as的作用是将整个临时的子查询结果（一张表里的数据）看做一个整体（一张表），不能少<br><img src="https://img-blog.csdnimg.cn/20210718035539294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="合并查询UNION-ALL"><a href="#合并查询UNION-ALL" class="headerlink" title="合并查询UNION (ALL)"></a>合并查询<code>UNION (ALL)</code></h2><p><strong>合并指的是把 查询结果 合并，并不合并原表</strong></p><p>再改一点数据<br><img src="https://img-blog.csdnimg.cn/20210718041237144.png" alt="在这里插入图片描述"><br><strong>合并的前提是，列数得相同</strong><br>说白了就是把后者硬塞进前者<br>这是UNION<br>完全重复的内容直接没了<br><img src="https://img-blog.csdnimg.cn/20210718041422957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这是UNION ALL<br>哪怕完全一样都还是保留<br><img src="https://img-blog.csdnimg.cn/20210718041444230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="表连接查询JOIN-ON"><a href="#表连接查询JOIN-ON" class="headerlink" title="表连接查询JOIN ON"></a>表连接查询<code>JOIN ON</code></h2><p>合并查询 是 合并 查询的结果，是个动宾短语<br>但是表连接查询中的“表连接”是一个定语后置的倒装，<br>作为一个偏正短语的定语修饰省略的中心词查询（结果）….啊吧啊吧<br>好吧扯远了….<br>表连接查询是指的，<strong>先把表（暂时）合并再查询</strong></p><p>先新建一个表叫做t_myfriends<br><del>叔叔我啊，最喜欢交朋友了</del><br><img src="https://img-blog.csdnimg.cn/20210718063425818.png" alt="在这里插入图片描述"></p><h3 id="1-内连接"><a href="#1-内连接" class="headerlink" title="1.内连接"></a>1.内连接</h3><p>我们先来观察一下</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_persons <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_myfriends;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718064413446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><code>SELECT * FROM t_myfriends INNER JOIN t_persons</code><br><img src="https://img-blog.csdnimg.cn/20210718064652326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>唔，在不加ON的情况下，表的行数变成了2 * 3 = 6（布尔积）行，我们可以发觉，两张表合并的时候的一些规律了，</p><p>那就是取二者行数的最小公倍数作为新的行数，并且均匀复制数据到新的表中</p><p>另外，INNER JOIN 语句左边的表，就是新合成的表的左部分，语句右边的便是新表的右部分。</p><p>我们再来观察一下</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_persons </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_myfriends </span><br><span class="line"><span class="keyword">ON</span> t_persons.`id` <span class="operator">=</span> t_myfriends.`id`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_myfriends </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_persons </span><br><span class="line"><span class="keyword">ON</span> t_persons.`id` <span class="operator">=</span> t_myfriends.`id`；</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718065402806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以ON其实就是加上了一个条件<br>只有两个表的id相等的数据才被放入新表，并且按照id相匹配<br>而且左右分布依旧遵循上文所述规则</p><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_persons</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_myfriends</span><br><span class="line"><span class="keyword">ON</span> t_persons.`id` <span class="operator">=</span> t_myfriends.`id`;</span><br></pre></td></tr></tbody></table></figure><p><strong>以左边的t_persons为主表，即t_persons的左外连接</strong><br><img src="https://img-blog.csdnimg.cn/20210718072515546.png" alt="在这里插入图片描述"><br>可以看出，右边的表会适应左边的表，</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_persons</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> t_myfriends</span><br><span class="line"><span class="keyword">ON</span> t_persons.`id` <span class="operator">=</span> t_myfriends.`id`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_myfriends</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> t_persons</span><br><span class="line"><span class="keyword">ON</span> t_persons.`id` <span class="operator">=</span> t_Myfriends.`id`;</span><br></pre></td></tr></tbody></table></figure><p>以右边的表为主表，即右外连接<br>（在左/右 还是由 在right join的左/右决定）<br><img src="https://img-blog.csdnimg.cn/20210718101559269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="DML-数据操纵语言"><a href="#DML-数据操纵语言" class="headerlink" title="DML:数据操纵语言"></a>DML:数据操纵语言</h2><p>鼠标操作虽好，但总不能只会鼠标操作吧</p><h4 id="增INSERT-INTO-VALUES"><a href="#增INSERT-INTO-VALUES" class="headerlink" title="增INSERT INTO VALUES"></a>增<code>INSERT INTO VALUES</code></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_persons(id,`名字`,`name`,`性别`,sex,age)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">'杨掉坑'</span>,<span class="string">'Yang Diodio'</span>,<span class="string">'男'</span>,<span class="number">1</span>,<span class="number">18</span>);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/2021071810301517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>也就是类似于形参实参的写法</p><h4 id="删DELETE"><a href="#删DELETE" class="headerlink" title="删DELETE"></a>删<code>DELETE</code></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t_myfriends</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'Cherry'</span>;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718105317910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="改UPDATE"><a href="#改UPDATE" class="headerlink" title="改UPDATE"></a>改<code>UPDATE</code></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t_persons </span><br><span class="line"><span class="keyword">SET</span> age <span class="operator">=</span> <span class="number">3</span> </span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'Yang Diodio'</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718105105733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="清空TRUNCATE"><a href="#清空TRUNCATE" class="headerlink" title="清空TRUNCATE"></a>清空<code>TRUNCATE</code></h4><p>清空整张表</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> t_myfriends;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210718105848317.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t_myfriends;</span><br></pre></td></tr></tbody></table></figure><p>也可以达到类似的效果，<br>不过truncate是销毁整张表之后重新创建一个同样格式的空表<br>DELETE是清空表的数据</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>这里只介绍三种常用的约束</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `全国人民身份信息`(</span><br><span class="line">`身份证号` <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">`名字` <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">`驾照证件号` <span class="type">INT</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">`年龄` <span class="type">INT</span></span><br><span class="line">)CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20210719200609953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="主键约束PRIMARY-KEY"><a href="#主键约束PRIMARY-KEY" class="headerlink" title="主键约束PRIMARY KEY"></a>主键约束PRIMARY KEY</h4><p>举个例子，当你要在全国范围内找到具体的某个人，用哪条信息找最准确呢？<br>如果是名字，那么重名的有很多，这样一来查询结果就不唯一。<br>如果用身份证号查找，那么就是唯一的。<br>这其实和一维数组类似，这里所说的<strong>主键类似于数组的下标。</strong><br><img src="https://img-blog.csdnimg.cn/20210719200859421.png" alt="在这里插入图片描述"><br>主键约束不能为空，也不能重复，<br>可以联想数组下标，不能重复也不能为空</p><h6 id="自增AUTO-INCREMENT"><a href="#自增AUTO-INCREMENT" class="headerlink" title="自增AUTO_INCREMENT"></a>自增AUTO_INCREMENT</h6><p>这个是<strong>主键约束的附属物</strong><br>只能用于主键约束<br><img src="https://img-blog.csdnimg.cn/20210719202418428.png" alt="在这里插入图片描述"><br>其实也是数组下标的模式，自动地依次递增</p><h4 id="唯一约束UNIQUE"><a href="#唯一约束UNIQUE" class="headerlink" title="唯一约束UNIQUE"></a>唯一约束UNIQUE</h4><p>就是不能重复<br>比如驾驶证号，这个重复了那还得了？<br><img src="https://img-blog.csdnimg.cn/20210719202906857.png" alt="在这里插入图片描述"><br>当然也不是每个人都有驾驶证，<strong>所以可以为NULL</strong></p><h4 id="非空约束NOT-NULL"><a href="#非空约束NOT-NULL" class="headerlink" title="非空约束NOT NULL"></a>非空约束NOT NULL</h4><p>一个人总有年龄和名字吧<br><img src="https://img-blog.csdnimg.cn/20210719203025790.png" alt="在这里插入图片描述"></p><h4 id="默认约束DEFAULT"><a href="#默认约束DEFAULT" class="headerlink" title="默认约束DEFAULT"></a>默认约束DEFAULT</h4><p>这里多加一条<br>…过亿这种毕竟是少数，如果给你十三亿的数据量，给个默认值肯定会减少工作量<br>（但是不知道为什么感觉有点悲伤….）<br><img src="https://img-blog.csdnimg.cn/2021071921004135.png" alt="在这里插入图片描述"></p><h4 id="引用约束CONSTRAINT-FOREIN-KEY-REFERENCES"><a href="#引用约束CONSTRAINT-FOREIN-KEY-REFERENCES" class="headerlink" title="引用约束CONSTRAINT FOREIN KEY REFERENCES"></a>引用约束CONSTRAINT FOREIN KEY REFERENCES</h4><p>直接用其他表里有的数据，不用手动重复地执行添加操作<br><img src="https://img-blog.csdnimg.cn/20210719215033790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlcmlvX2d1Z3VndQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> fk_t_persons_sex </span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(`性别`) </span><br><span class="line"><span class="keyword">REFERENCES</span> t_persons(sex)</span><br></pre></td></tr></tbody></table></figure><p>也就是当前表的里 <strong>性别 这个数据<br>是从t_persons这张表的sex里面引用来的</strong>，而这个<strong>引用关系我们命名为fk_t_persons_sex</strong></p><p>其余的约束相对来说不是特别常用，所以这里就不介绍了</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务就是“整体化”，就是如果其中有一条语句失败，事务内所有语句失效</p><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#开启事务</span><br><span class="line">#事务就是“整体化”，就是如果其中有一条语句失败，事务内所有语句失效</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line">#模拟借钱</span><br><span class="line"></span><br><span class="line">#(更新id <span class="operator">=</span> <span class="number">1</span>的用户的账户</span><br><span class="line">UPDATE account </span><br><span class="line"><span class="keyword">SET</span> money  <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#（更新id <span class="operator">=</span> <span class="number">2</span>的用户的账户</span><br><span class="line">UPDATE account <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">#全部成功就提交(<span class="keyword">COMMIT</span>)</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line">#出现失败就取消,</span><br><span class="line">#然后重置到执行前的状态，</span><br><span class="line">#这就叫回滚（<span class="keyword">ROLLBACK</span>）</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></tbody></table></figure><p>如果用户1借1000块钱给用户2<br>第一步：用户1的账户上先减少1000<br>第二步：用户2的账户上再增加1000</p><p>如果第一步成功，第二步失败，用户1就会凭空少1000块，这合理吗？？？</p><p>但好在我们开始了事务，这使得这个事件是一个整体，一步失败则回滚事件开始之前</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p><strong>原子性：</strong><br>即不可分割，是一个整体，要么全部成功，要么全部失败<br><strong>一致性：</strong><br>一旦失败，操作涉及到的所有数据回会回滚到与操作前一致<br><strong>隔离性：</strong><br>事务开始前的状态和完成后的状态相隔离，不存在中间状态<br><strong>持久性：</strong><br>持久性事务完成之后，它对整个系统的影响是永久的</p><h2 id="管理权限"><a href="#管理权限" class="headerlink" title="管理权限"></a>管理权限</h2><h4 id="相关命令-1"><a href="#相关命令-1" class="headerlink" title="相关命令"></a>相关命令</h4><p>就是谁能用这个数据库，并且能用哪些操作</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#创建用户</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> `Serio` </span><br><span class="line">IDENTIFIED <span class="keyword">BY</span> <span class="string">'123'</span>;</span><br><span class="line"></span><br><span class="line">#授权</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> companydb.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">TO</span> `Serio`;</span><br><span class="line"></span><br><span class="line">#撤销权限（和授权一样，在账户重新连接客户端后生效）</span><br><span class="line">REMOVE <span class="keyword">ALL</span> <span class="keyword">ON</span> companydb.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> `Serio`;</span><br><span class="line"></span><br><span class="line">#删除用户</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> `Serio`;</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是，撤销权限后，需要重启一次客户端才可以生效</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图就是一种可以保存下来的虚拟表，说白了就有点像你把某张节选某张表的数据形成一张新的表再打印下来，打印下来这个就是视图.</p><p>可以运用在保存查询结果等方面，<br>然后达到简化查询的目的</p><h4 id="创建视图CREATE-VIEW"><a href="#创建视图CREATE-VIEW" class="headerlink" title="创建视图CREATE VIEW"></a>创建视图CREATE VIEW</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> t_personsInfo</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> `name`, age <span class="keyword">FROM</span> t_persons;</span><br></pre></td></tr></tbody></table></figure><p>有了这个视图，当下次你要查询name和age的时候，就不需要select写那么多字了<br>直接一句</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_personsInfo;</span><br></pre></td></tr></tbody></table></figure><h4 id="修改视图CREATE-OR-REPLACE-VIEW"><a href="#修改视图CREATE-OR-REPLACE-VIEW" class="headerlink" title="修改视图CREATE OR REPLACE VIEW"></a>修改视图CREATE OR REPLACE VIEW</h4><p>顾名思义是创建或者修改视图，总结就是 覆盖</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> t_personsInfo</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> `名字` age <span class="keyword">FROM</span> t_persons;</span><br></pre></td></tr></tbody></table></figure><p>当然这也还有其他修改方式</p><h4 id="修改视图ALTER-VIEW"><a href="#修改视图ALTER-VIEW" class="headerlink" title="修改视图ALTER VIEW"></a>修改视图ALTER VIEW</h4><p>这个依旧是覆盖</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#修改视图<span class="number">2</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> t_personsInfo</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> `名字` age <span class="keyword">FROM</span> t_persons;</span><br></pre></td></tr></tbody></table></figure><h4 id="删除视图DROP-VIEW"><a href="#删除视图DROP-VIEW" class="headerlink" title="删除视图DROP VIEW"></a>删除视图DROP VIEW</h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> t_personsInfo;</span><br></pre></td></tr></tbody></table></figure><p>删除也没什么好说的</p><h4 id="视图的性质总结"><a href="#视图的性质总结" class="headerlink" title="视图的性质总结"></a>视图的性质总结</h4><p>形式上与表一样，主要区别在于 <strong>增 删 改</strong>，<br>表的增删改比较自由，<strong>但是视图只能通过整体覆盖的形式来进行增删改</strong><br>视图常作为表的节选内容的副本存在，方便用户<strong>查</strong>找数据<br>但是并不会从查询速率上优化，<strong>只是单纯地减少代码量</strong></p><p>另外，如果视图包含有 由 聚合函数、DISTINCT、GROUP BY、HAVIG UNION等语句处理过 的结果，那么视图不可更新</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Router</title>
      <link href="/2021/12/03/vue-router/"/>
      <url>/2021/12/03/vue-router/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><font color="fa3700">这是几个月前写的，当时放在CSDN上的，现在放到自己的博客上，广告气息很重就是了</font></p><p>学完了一堆后端的知识之后呢，又去学了下git…<br>嘛，现在又回到了前端的学习<br>前置内容：<br><a href="https://blog.csdn.net/Serio_gugugu/article/details/119416221">😍Vue全家桶学习笔记_零基础入门到入坑:Vue篇✨</a></p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/120253610">😘Git学习笔记:告别单机开发从此处开始😝</a></p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/118059067">🤑ES6学习笔记:使前端锦上添花的必看内容🧐</a></p><p>这个学过后端的servlet的话就再清楚不过了。<br>后端的内容可以参考：</p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/119833436">❤❤❤Java基础学习笔记：零基础快速入门❤❤❤</a></p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/118856246">😃😃😃Mysql学习笔记：两小时学完mysql数据库😃😃😃</a></p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/119874047">😜😏😳JDBC学习笔记：半小时学会Java操作数据库😜😏😳</a></p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/119976821">🍠🥩🥙JavaWeb学习笔记：后端极速入门教学🥪🌯🥟</a></p><p>另外，文章末尾还有更多学习资料献给大家~~</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><blockquote><p>路由就是通过网络，把网络信息从源地址传输到目标活动地址</p></blockquote><p>（大概就是URL和页面之间的映射吧）<br>路由本来是后端负责的，但是随着前端的不断发展，路由也进入了前端的范围。</p><h3 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h3><p>嘛，就是浏览器给后端发个请求，后端直接把整个页面（包括html css js等等）响应给浏览器<br>这个过程中，页面已经在后端形成，并且由后端决定URL和页面之间的映射关系。</p><h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><p>随着前后端分离的发展<br>后端变得只负责提供数据和资源<br>前端负责页面内部所有业务（那页面表面呢？html css很多直接丢给美术老师做了..）<br>一个网页的大部分内容都将由前端渲染，并且一个网站中会为了多个网页多次请求</p><p>前后端分离时工作流程如图所示<br>（图片来自网络）<br><img src="https://img-blog.csdnimg.cn/72bd089a5101432c835c156e49efea3e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>只能说是前端渲染，但是路由依旧是后端路由！</strong></p><p>这种技术条件下就有了：</p><h3 id="单页面应用程序（SPA）"><a href="#单页面应用程序（SPA）" class="headerlink" title="单页面应用程序（SPA）"></a>单页面应用程序（SPA）</h3><p><strong>SPA是建立在前后端分离的基础上的</strong><br><strong>整个站点只有一个网页（只有一个index.html）</strong>，请求时会一次性请求全部内容，然后根据前端路由的映射关系，对应的url展示对应的页面内容<br>这种情况下，改变url，不会发起服务端请求，页面也不进行整体刷新</p><p>工作流程如图所示<br>（图片来自网络）<br><img src="https://img-blog.csdnimg.cn/1d9a290aa62f44a18d50e0aa2392621b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="前端路由的基本使用"><a href="#前端路由的基本使用" class="headerlink" title="前端路由的基本使用"></a>前端路由的基本使用</h2><h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><p>有两种模式：第一种是hash模式，第二种是history模式<br><strong>hash模式</strong><br>hash模式是通过监听浏览器的onhashchange()事件变化，查找对应的路由。由<strong>createWebHashHistory（）</strong>创建<br><img src="https://img-blog.csdnimg.cn/3f2f9f20469e4a8cbc11e69e86261f4f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>并且，不会刷新页面，而是在页面上直接加载<br>上图使用了location.hash修改，但是由于b站这个页面本身没有使用hash模式，所以页面没有发生变化</p><p><strong>history模式</strong><br>利用了HTML5 History Interface中新增的**pushState()<strong>和</strong>ReplaceState()**方法<br><img src="https://img-blog.csdnimg.cn/59f7c89313ec44ff9e4fce4b4afc5dd5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>相当于是pushState()把url压栈，然后back()弹出</p><p>刷新一下可以尝试访问<br><img src="https://img-blog.csdnimg.cn/56c9cf83bbaa473393a39f1c9a172cd3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>进一步了解两种模式</strong><br><strong>兼容性</strong><br>hash模式兼容性比较好，history其实也不错（除了IE）<br><strong>是否会发起请求（是否影响后端）</strong><br>hash模式不会，直接在前端解析了#后面的内容<br>history模式则会发起http请求，在路由嵌套的时候会导致404<br>（因为现在路由配置是在前端，http请求时发给后端，后端没有相应配置，所以就会404）</p><h3 id="vue-router实例"><a href="#vue-router实例" class="headerlink" title="vue-router实例"></a>vue-router实例</h3><p>打开cmd，输入vue ui，然后跳转到可视化界面<br><img src="https://img-blog.csdnimg.cn/8d0e409b41044fb382a937910b550ce9.png" alt="在这里插入图片描述"><br>新建一个项目，记得插件要安装<strong>vue-router</strong></p><p>这里我们用idea打开<br>可以在App.vue中找到这个<br><img src="https://img-blog.csdnimg.cn/7d20dc3d3ca5489095d134c5db70f34a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>实际上呢，这个东西实际上就可以看作</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>（其实在vue较早的版本中，就是用的上述语法实现的路由跳转）</p><p>相应的页面会被挂载到图中的view-router标签上</p><p>我们运行一下，在页面中点击About，页面就会变化为<br><img src="https://img-blog.csdnimg.cn/0364fe9ec32444a9a1a85b42a52fdaf2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这其中的路由配置是在router文件下的index.js中配置的<br>routes是创建的路由对象<br><img src="https://img-blog.csdnimg.cn/1d8a18b2b35f421188b71ee2a27cbdbc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>path就是对应的相对url<br>component就对应的组件<br>name就是这个路由的名字罢了</p><p>至于下面的这一行</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'../views/About.vue'</span>)</span><br></pre></td></tr></tbody></table></figure><p>其实也可以在上面import然后再在下面写名称，<br>不过直接合在一起更方便一些不是吗</p><hr><p><strong>点击Home之后我们可以看url变化，就是#后面加了个/<br>/是Home对应的url<br>#说明这是hash模式</strong><br><img src="https://img-blog.csdnimg.cn/e420c559e82445f297463526a42b5e94.png" alt="在这里插入图片描述"><br><strong>可以在下面这里做更多配置（设置模式等等），</strong><br>但是这里就只是确定路由关系为routes，其他配置后面再提</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter({</span><br><span class="line">  routes</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>然后导出</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></tbody></table></figure><p>在main.js里面接收，一切都大工告成</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="简单使用vue-router"><a href="#简单使用vue-router" class="headerlink" title="简单使用vue-router"></a>简单使用vue-router</h3><p>大概看了长啥样，不写的话很快就会忘，这还不得写一下加深印象和理解？<br><strong>第一步：写一个router-link</strong><br>这个放到app.vue就好</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> |</span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span>|</span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/mine"</span>&gt;</span>来康康我写的东西<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#app</span> {</span></span><br><span class="line"><span class="css">  <span class="attribute">font-family</span>: Avenir, Helvetica, Arial, sans-serif;</span></span><br><span class="line"><span class="css">  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span><br><span class="line"><span class="css">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span><br><span class="line"><span class="css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#nav</span> {</span></span><br><span class="line"><span class="css">  <span class="attribute">padding</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#nav</span> <span class="selector-tag">a</span> {</span></span><br><span class="line"><span class="css">  <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#nav</span> <span class="selector-tag">a</span><span class="selector-class">.router-link-exact-active</span> {</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="number">#42b983</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>实际上就是多加了一行：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/mine"</span>&gt;</span>来康康我写的东西<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>第二步：配置路由</strong><br>它对应的url是/mine，所以我们要去router里面的index.js做相应的配置<br>增加这一段</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">path</span>: <span class="string">'/mine'</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'Mine'</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'../views/Mine.vue'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>第三步：配置对应的组件</strong><br>可以看到其对应的组件式import导入的，所以我们还得在对应的位置添加一个Mine.vue文件</p><p>随便写写就行</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>没错这就是我写的路由<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img0.baidu.com/it/u=2976614615,180926968&amp;fm=11&amp;fmt=auto&amp;gp=0.jpg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">'Mine'</span></span></span><br><span class="line"><span class="javascript">}</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>效果如下</strong><br><img src="https://img-blog.csdnimg.cn/391e9e75e57b4a62852090c8e4b45c81.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/230444f180604e2d9e85ef9e3a2d270a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="进一步学习路由"><a href="#进一步学习路由" class="headerlink" title="进一步学习路由"></a>进一步学习路由</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>就是跳转到URL1,然后URL1说：“别找我，你去找URL2”<br>比如这样</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">path</span>: <span class="string">'/'</span>,</span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">'/mine'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>访问‘/’时，被转到了’/mine’<br>所以，我们每次访问/，都会跳到这个页面<br><img src="https://img-blog.csdnimg.cn/97517af679514d0dbf4a43f621c08b43.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="修改模式"><a href="#修改模式" class="headerlink" title="修改模式"></a>修改模式</h3><p>上面提到过的两种模式：hash模式和history模式<br>默认情况下是hash模式，标志是url会带有#（哈希字符）</p><p>之后呢我们开始使用Vue3.x的写法了！</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Vue2.x的写法!</span></span><br><span class="line"><span class="comment">// const router = new VueRouter({</span></span><br><span class="line"><span class="comment">//   routes</span></span><br><span class="line"><span class="comment">// })</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue3.x的写法！</span></span><br><span class="line"><span class="keyword">const</span> router = createRouter({</span><br><span class="line">  <span class="comment">//路由</span></span><br><span class="line">  <span class="attr">routes</span>: routes,</span><br><span class="line">  <span class="comment">//模式（此处为hash模式；如果要改为history模式就写createWebHistory()）</span></span><br><span class="line">  <span class="attr">history</span>: createWebHashHistory(),</span><br><span class="line">  <span class="comment">//router-link在被选中时的css class</span></span><br><span class="line">  <span class="attr">linkActiveClass</span>: <span class="string">'zhe-shi-yi-ge-class'</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>导入对应的内容</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Vue2.x的写法</span></span><br><span class="line"><span class="comment">//import VueRouter from 'vue-router'</span></span><br><span class="line"><span class="comment">//Vue3.x的写法</span></span><br><span class="line"><span class="keyword">import</span> { createRouter, createWebHashHistory } <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br></pre></td></tr></tbody></table></figure><p>至于给它的class呢，就是在App.vue里面给一个对应的就行了</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.zhe-shi-yi-ge-class</span>{</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/b1886364c7e1491c8aeb62b083c5cc3d.png" alt="在这里插入图片描述"></p><h3 id="不可回退约束：replace"><a href="#不可回退约束：replace" class="headerlink" title="不可回退约束：replace"></a>不可回退约束：replace</h3><p>像下面这么写就行</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home"</span> <span class="attr">replace</span>=<span class="string">"replace"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> |</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span> <span class="attr">replace</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span>|</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/mine"</span> <span class="attr">replace</span>&gt;</span>来康康我写的东西<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>众所周知浏览器有前进和回退的功能：<br><img src="https://img-blog.csdnimg.cn/265ea84439c544bfbd6e068d08743d14.png" alt="在这里插入图片描述"><br>实现原理是压栈和出栈<br>但是有些东西我们不想让它入栈，这时候就可以使用replace来约束它<br>即 <strong>被replace约束则不会入栈，并且不可参与路由嵌套</strong></p><h3 id="触发事件进行路由跳转"><a href="#触发事件进行路由跳转" class="headerlink" title="触发事件进行路由跳转"></a>触发事件进行路由跳转</h3><p>这里将就用一下about.vue文件</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"about"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an about page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"toMine"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'../router'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">    <span class="attr">name</span>: <span class="string">'About'</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> toMine = <span class="function">() =&gt;</span> {</span></span><br><span class="line"><span class="javascript">      <span class="comment">//没错，replace是跳转，并且会用replace约束</span></span></span><br><span class="line"><span class="javascript">          router.replace(<span class="string">'/mine'</span>)</span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">        toMine</span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">  }</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>比如我们打开csdn首页，很明显是一个网页，但是打开多次，每次显示的内容却不一样<br>说明这里的路由是个变量！这就是动态路由！<br><img src="https://img-blog.csdnimg.cn/01ef0d407a1e4dcabd21f64c2f1bef3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>来写一个动态路由</strong><br><strong>第一步：写路由跳转</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"'/news/' + newsId"</span> <span class="attr">replace</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>其实就是v-bind绑定一下，所以script部分如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { ref } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">const</span> newsId = ref(<span class="string">'lc666'</span>)</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      newsId</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>第二步：写路由</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">path</span>: <span class="string">'/news/:id'</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'News'</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/News.vue'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>记住这里的id，它将作为后面的键值对的键<br><strong>第三步：写组件</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"news"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>大新闻<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>编号：{{ $route.params }}<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img2.baidu.com/it/u=4244264354,1813450227&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=GIF?w=300&amp;h=300"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>产品经理被打啦！！！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">"News"</span></span></span><br><span class="line"><span class="javascript">}</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-id">#news</span>{</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">#ddd</span> solid <span class="number">1px</span>;</span></span><br><span class="line"><span class="css">  }</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>效果图</strong><br><img src="https://img-blog.csdnimg.cn/4dd8af180d7a438ba7adc98d913074c7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如图所示，url部分是我们动态绑定的lc666，然后编号部分是一个键值对<br>如果我们修改编号部分的代码如下，就可以访问到其值：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>编号：{{ $route.params.id }}<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/d83cac08bfaf4f619a3d7f658ddd4570.png" alt="在这里插入图片描述"><br>当然，我们还可以用js获取id</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> {useRoute} <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"News"</span>,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">const</span> route = useRoute()</span><br><span class="line">    <span class="built_in">console</span>.log(route.params.id)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/83d2c67a91c2415d9b7ae3f91317d6df.png" alt="在这里插入图片描述"></p><hr><p><strong>扩展</strong><br>这里我们是本地写的内容<br>但是我们是动态绑定的url，所以我们能够从服务器请求到id、文章内容之类的话，就可以实现真正的动态加载内容了</p><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>就咱们写的这个页面来说，比如我首屏是Home界面，这个时候我又看不到About等其他三个界面。<br>那要是我一开始就把所有资源请求下来了，那加载岂不是慢得一批？<br>为什么不优化一下？<strong>只有在访问某个界面的时候才请求资源——这就是，懒加载</strong><br>实际上之前也看到过懒加载的方式了：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">   <span class="attr">path</span>: <span class="string">'/news/:id'</span>,</span><br><span class="line">   <span class="attr">name</span>: <span class="string">'News'</span>,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/News.vue'</span>)</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>比如上述的component的写法就是懒加载，是利用了函数的性质：只有被使用的时候才会执行</p><p><strong>懒加载的内容在打包的时候，会被被单独分为一个文件</strong>，而不是像原来一样所有内容都在一个文件里</p><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><p><img src="https://img-blog.csdnimg.cn/530914aa4f5742bfb9e3df40fe465062.png" alt="在这里插入图片描述"><br>比如http:localhost:8080/Mine/msg<br>新建一个组件命名规范如图所示<br>然后写一个新组件</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mine_msg"</span>&gt;</span>咕咕咕<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">'MineMsg'</span></span></span><br><span class="line"><span class="javascript">}</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-id">#mine_msg</span>{</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: aqua;</span></span><br><span class="line"><span class="css">    <span class="attribute">font-size</span>: <span class="number">32px</span>;</span></span><br><span class="line"><span class="css">  }</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>再到路由配置里面，找到Mine，增加一个children属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">   <span class="attr">path</span>: <span class="string">'/mine'</span>,</span><br><span class="line">   <span class="attr">name</span>: <span class="string">'Mine'</span>,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'../views/Mine.vue'</span>),</span><br><span class="line">   <span class="attr">children</span>: [</span><br><span class="line">     {</span><br><span class="line">       <span class="attr">path</span>: <span class="string">'msg'</span>,</span><br><span class="line">       <span class="attr">name</span>: <span class="string">'MineMsg'</span>,</span><br><span class="line">       <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/MineMsg.vue'</span>)</span><br><span class="line">     }</span><br><span class="line">   ]</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>在到Mine里面写，大概写成这样就行</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>没错这就是我写的路由<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img0.baidu.com/it/u=2976614615,180926968&amp;fm=11&amp;fmt=auto&amp;gp=0.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-nav"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/mine/msg"</span>&gt;</span>我的消息<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">'Mine'</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> {}</span></span><br><span class="line"><span class="javascript">}</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.content</span>{</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">    <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span></span><br><span class="line"><span class="css">  }</span></span><br><span class="line"><span class="css">  <span class="selector-class">.content-nav</span>{</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: gold;</span></span><br><span class="line"><span class="css">  }</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>效果大概是这样<br><img src="https://img-blog.csdnimg.cn/6433832382ac4c1cb6846a65e5d6c7dc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>点一下<br><img src="https://img-blog.csdnimg.cn/85741f6f9f2046d480ca27e61f46a439.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>大概就是这样啦</p><hr><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>参数传递有两种方式，一种是parmas类型，另一种是query类型</p><table><thead><tr><th>类型</th><th>传递方式</th><th>路由配置格式</th><th>传递后形成的路径格式</th></tr></thead><tbody><tr><td>parmas</td><td>在path后跟上传递的参数</td><td>/router/:params</td><td>/router/xxx</td></tr><tr><td>query</td><td>对象种使用query的key作为传递方式</td><td>/router</td><td>/router?id=xxx</td></tr></tbody></table><p><strong>query类型</strong><br>就是经典的?username=xxx&amp;pswd=xxx，比如<br><img src="https://img-blog.csdnimg.cn/51902b46592e4fbfb391950532f99e91.png" alt="在这里插入图片描述"></p><p>说白了也就是Cookie和Session嘛….<br>不过vue为我们提供了一手高效便捷的封装操作<br>再建一个<br><img src="https://img-blog.csdnimg.cn/d362765cc74e462d8f96ae99de7d775d.png" alt="在这里插入图片描述"><br>路由…</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">path</span>: <span class="string">'/circle'</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'Circle'</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Circle.vue'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>组件里面随便写点，反正也不重要</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>雀食蟀啊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后到App.vue里面加上这个</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"{path:'/circle', query:{name:'大帅逼',id:'666666'}}"</span>&gt;</span>朋友圈<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>点一下就来了<br><img src="https://img-blog.csdnimg.cn/4c0a0c02b1bf4811abcf321b22e72205.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>也可以拿到上面的数据</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>雀食蟀啊<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{$route.query}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{$route.query.name}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{$route.params}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>注意params拿的是vue组件里面传递的参数，query拿的才是URL里面的参数（Cookie）<br><img src="https://img-blog.csdnimg.cn/d10235c2f0d845db96d8112f6934da0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>parmas类型</strong><br>About里面这样写</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"about"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an about page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"toMine"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"toCircle"</span>&gt;</span>朋友圈<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'../router'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> { ref } <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">    <span class="attr">name</span>: <span class="string">'About'</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> circleId = ref(<span class="string">'2333'</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> toMine = <span class="function">() =&gt;</span> {</span></span><br><span class="line"><span class="javascript">          router.replace(<span class="string">'/mine'</span>)</span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> toCircle = <span class="function">() =&gt;</span> {</span></span><br><span class="line"><span class="javascript">          router.push(<span class="string">'/circle/'</span> + circleId.value)</span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">        toMine,</span></span><br><span class="line"><span class="javascript">        toCircle</span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">  }</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/c4f365c964eb437c88e28d55a0eff582.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/651842a39c9240dba54cbd70886a73c1.png" alt="在这里插入图片描述"><br>仔细观察一下，“点击跳转”按钮用的是router.replace，而“朋友圈”按钮是用的router.push，那么二者的区别是什么呢？<br><strong>replace是替换栈顶，push是压入一个新的</strong><br>那么参数传递大概也就是这样了</p><hr><h2 id="路由的高阶使用"><a href="#路由的高阶使用" class="headerlink" title="路由的高阶使用"></a>路由的高阶使用</h2><h3 id="Router和Route对象"><a href="#Router和Route对象" class="headerlink" title="Router和Route对象"></a>Router和Route对象</h3><p>如果要简单地概括router和route的关系的话，那么就是：<br>router是全局的，route是具体的某一个组件<br>| 名称   | 区别                                                         |<br>| —— | ———————————————————— |<br>| router | router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router实例对象 |<br>| route  | route是一个可跳转的路由对象，是一个局部对象，可以通过它获取相应的name，path，params，query等 |</p><p>另外，router3.x里面都还用的JS，到了4.x就都用TS了（完了没学过根本看不懂）</p><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p>大概就是你进入这个页面的时候，了解“你是谁”“你从哪里来”“你要到哪里去”<br>（大雾），并且决定是否“<strong>放行</strong>”<br><strong>全局路由前置守卫</strong><br>说白了就是全局的前门守卫</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter({</span><br><span class="line">  <span class="attr">history</span>: createWebHistory(process.env.BASE_URL),</span><br><span class="line">  <span class="attr">routes</span>: routes,</span><br><span class="line">  <span class="attr">linkActiveClass</span>: <span class="string">'zhe-shi-yi-ge-class'</span></span><br><span class="line">})</span><br><span class="line"><span class="comment">//全局路由的前置守卫，三个参数:去、来、是否放行的函数</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>)=&gt;</span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"贫僧来自"</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">from</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"欲前往"</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(to)</span><br><span class="line">  <span class="comment">//放行</span></span><br><span class="line">  next()</span><br><span class="line">})</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/c5d27ddb70114755870c8e1a54cc323b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>记得一定要有next()，不然无法成功跳转<br>既然有前置的那也有后置的，把beforeEach改成afterEach就行了，但是还是前置的常用一些</p><p>有全局那应该还有局部的，这就是<strong>路由元信息</strong><br>通过设置路由元信息可以把<strong>任意信息</strong>附加到路由上，比如过渡名称<br>谁可以访问这个路由等等，这些效果通过meta属性实现：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">path</span>: <span class="string">'/circle'</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'Circle'</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Circle.vue'</span>),</span><br><span class="line">  <span class="attr">meta</span>: {<span class="attr">title</span>: <span class="string">'呜呼呼是朋友圈诶'</span>}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后我们就能在路由守卫中的对象参数to中<code>在这里插入代码片</code>的属性中找到这个title</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>)=&gt;</span>{</span><br><span class="line">  <span class="built_in">document</span>.title = to.meta.title</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"贫僧来自"</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">from</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"欲前往"</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(to)</span><br><span class="line">  <span class="comment">//放行</span></span><br><span class="line">  next()</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/b87b254ec6b54a0f832d08e8141fc90e.png" alt="在这里插入图片描述"><br>当然，其他没有设置meta.title的自然是undefined了</p><p>当然，守卫的主要作用之一其实是<strong>判断用户登录状态并做出响应的跳转！</strong></p><p><strong>其他守卫的形式</strong><br>除了上述介绍的在路由中写守卫的方式，还有就是通过事件监听的方式来做</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> {onBeforeRouteLeave, onBeforeRouteUpdate} <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br></pre></td></tr></tbody></table></figure><p>引入之后自己写一下事件监听就好了(参数依旧是那三个</p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>组件A跳转到组件B时，创建组件B，销毁组件A。再由A返回B时，又创建A，销毁B…如果这样的过程多，那么开销就太大，不如让AB始终存在，就免去了创建销毁的成本</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  一般的写法--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  &lt;router-view/&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- vue2.x的写法 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  &lt;keep-alive&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;router-view&gt;&lt;/router-view&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  &lt;/keep-alive&gt;  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- vue3的写法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">"{ Component }"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"Component"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>用插槽的话能够动态匹配（虽然我也快忘完了）<br>那怎么体现它没有销毁重建呢，比如你可以加一个勾选框或者输入框之类的，输入一些东西然后跳转过去再回来，发现输入内容还在，这就说明还是原来那个没有销毁</p><p><strong>附带的生命周期钩子</strong><br>这两个钩子是<strong>专门服务于被keep-alive包裹的router-view</strong><br>分别是：<strong>onActived和onDeactived</strong>，也就是当访问某个页面和离开某个页面时</p><p><strong>常用的属性</strong><br>| 属性    | 数据类型                     |                                    |<br>| ——- | —————————- | ———————————- |<br>| include | String，RegExp（正则）,Array | 只有名称匹配的组件才会被渲染       |<br>| exclude | String, RegExp, Array        | 任何名称匹配的组件都<strong>不会</strong>被渲染 |<br>| max     | String                       | 最多可以渲染多少组件实例           |</p><p>比如：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">"{ Component }"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">name</span>=<span class="string">"fade"</span> <span class="attr">exclude</span>=<span class="string">"{'News', 'Home'}"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"Component"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样一来，它就不会保存News和Home，News和Home每次还是会销毁和重新创建</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>今天是2021.10.22<br>一晃就学了半年的前端了，半年收获还是挺多的…<br>唔，vue-router的大致内容就是这些了，由于本人才疏学浅，也难以将所有的知识全部概括，所以要完全掌握vue-router还需要各位自行学习了<br>这之后我还会继续更新 <strong>操作系统</strong> 和 <strong>VueX</strong>（估计至少也得十二月去了）的内容<br>以下是操作系统的内容，希望对大家有帮助<br><a href="https://blog.csdn.net/Serio_gugugu/article/details/120575984">本科操作系统学习笔记:从入门到精通🥰</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2021/12/03/os/"/>
      <url>/2021/12/03/os/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>操作系统因为翘课太多只能自学啊~~<br>而且计算机基础知识是很重要的，必须要认真对待才是（那为啥翘课？翘课学前端去了…）<br>不管怎么说，还是做个笔记方便日后复习</p><h2 id="计组和操作系统杂谈"><a href="#计组和操作系统杂谈" class="headerlink" title="计组和操作系统杂谈"></a>计组和操作系统杂谈</h2><p>随便写点（这个部分可以跳过）</p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p><strong>计算机系统</strong>：处理机+外围设备</p><p><strong>处理机</strong>：包括CPU，主存储器、输入输出设备</p><p><strong>CPU</strong>：中央处理器+控制核心<br>(<strong>下文有时会把处理机称为CPU，见谅</strong>)<br>(<strong>后面网上一查才发现，好多人都把处理机和处理器混淆了</strong>)</p><p><strong>中央处理器</strong>：运算单元+控制单元<br><strong>主存储器</strong><br><strong>外围设备</strong>：输出设备 输入设备 存储设备 网络通信设备（比如鼠标键盘等）<br><strong>总线</strong>：Bus,是CPU，内存，输入输出设备传输信息的共用通道；外围设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统</p><p>存储器的层次：<br><img src="https://img-blog.csdnimg.cn/cf49c35e358f4d20a82d616b4466ae36.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>外围设备及其控制：<br><img src="https://img-blog.csdnimg.cn/a0c3bf94ddf941af87fec900e3433fd7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>总线的类型：<br><img src="https://img-blog.csdnimg.cn/2471b066836144e8b159b58b9001887c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>上述内容是<strong>冯诺依曼提出的存储程序计算机模型</strong><br><img src="https://img-blog.csdnimg.cn/1ac6e9d9460e48b8aa877a0817fc23d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="指令执行的过程"><a href="#指令执行的过程" class="headerlink" title="指令执行的过程"></a>指令执行的过程</h3><p><strong>前置概念</strong><br>（引用自<a href="https://blog.csdn.net/qq_34801169/article/details/102782643">CSDN博主「快乐的一只小喵喵」的原创文章</a>）</p><blockquote><p><strong>程序计数器（PC，Program counter）</strong><br>用于存放指令的地址。为了保证程序(在操作系统中理解为进程)能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，此过程称，为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。<br><strong>指令寄存器（IR，Instruction Register）</strong><br>用来保存当前正在执行的一条指令。是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一条指令。当执行一条指令时，先把它从内存取到数据寄存器（DR，Data<br>Register）中，然后再传送至IR。指令划分为操作码和地址码字段，由二进制数字组成。为了执行任何给定的指令，必须对操作码进行测试，以便识别所要求的操作。指令译码器就是做这项工作的。指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号。<br><strong>&gt; 通用寄存器（GR，General register）</strong><br>通用寄存器可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。除此之外，它们还各自具有一些特殊功能。通用寄存器的长度取决于机器字长，汇编语言程序员必须熟悉每个寄存器的一般用途和特殊用途，只有这样，才能在程序中做到正确、合理地使用它们。</p></blockquote><p>————————————————</p><p>一种较为简单的指令执行步骤:<br><strong>1.取指</strong>：根据PC从存储器或高速缓冲存储器中取指令到IR<br><strong>2.解码</strong>：解译IR中的指令来决定其执行行为<br><strong>3.执行</strong>：连接到CPU部件，执行运算，产生结果并写回，同时在CC里设置运算结论标志；跳转指令操作PC，其他指令递增PC值</p><p><strong>指令执行的流水线</strong><br><img src="https://img-blog.csdnimg.cn/9352d87c2e9246558b6d9ddce89c5de5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>其中流水线的过程有点<strong>并发</strong>的意思</p><h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><p>用户的程序并不能够使用全部的计算机指令（比如app总是要你授权就是这个道理），<strong>计算机核心资源的特殊指令会被保护起来</strong>，它们只能被操作系统程序使用<br>至于特权指令是怎么被实现的，就要提到<strong>处理器模式</strong>：<br>计算机一般设置0 1 2 3四种模式<br>0是操作系统内核<br>1是系统调用<br>2是共享库程序<br>3是用户程序</p><p>数值越大权限越低<br>tip：现代操作系统很多都只是用了0和3两个模式，<strong>内核模式</strong>和<strong>用户模式</strong>（下图以红色的括号为准）<br><img src="https://img-blog.csdnimg.cn/b5fedf610b114ce3b33a21bc84b51d55.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>嘛。。。其实就是字面意思嘛。。。<br>就是程序执行过程中，遇到突发状况，就暂时终止处理机上当前程序的运行，转去处理突发事件，<strong>处理完成之后再回到刚才暂停的地方继续执行</strong> 这个过程，就是中断</p><p><strong>中断是并发的基础</strong></p><hr><p><strong>中断源</strong><br>那引起中断的事件就称为中断源<br>它可能是处理器执行机器指令引起的，比如除数为0，操作数溢出等算数异常或者其他异常</p><hr><p>对于简单的问题，处理器会简单处理然后报告用户；也可以由用户编写的中断续元程序处理</p><p>但是复杂的问题（比如I/O中断，来源于外围设备报告I/O状态的中断事件)（比如打印机打印一般了发现缺纸了）<br>就需要人工干预了</p><hr><h2 id="初步认识操作系统"><a href="#初步认识操作系统" class="headerlink" title="初步认识操作系统"></a>初步认识操作系统</h2><p>终于进入主题。由于学校的视频资源给的好像不是很系统，所以我决定自己找视频再结合教材作书摘一样地写<br><img src="https://img-blog.csdnimg.cn/00a410ed4e5940efaad2e96334c6f6b7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>定义</strong></p><p>Operating system，即OS，是配置在计算机硬件上的第一层<strong>软件</strong>,也就是说，<strong>操作系统是计算机硬件的第一次扩充</strong></p><hr><p><strong>目的</strong></p><p><strong>管理硬件，提高利用率和系统吞吐量</strong>，具体实现了以下四个方面</p><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>方便性</td><td>没有操作系统的话用户只能用机器语言操作了</td></tr><tr><td>有效性</td><td>合理组织计算机工作流程，提高效率</td></tr><tr><td>可扩充性</td><td>方便地增加新的功能和模块</td></tr><tr><td>开放性</td><td>很好地应用于网络环境</td></tr></tbody></table><p><strong>功能</strong></p><p>不同的场合下身份不同，一共可以充当三个角色</p><table><thead><tr><th>身份</th><th>功能</th></tr></thead><tbody><tr><td>资源的管理者</td><td>管理 处理机、 存储器、 文件、 设备</td></tr><tr><td>用户的服务者</td><td>向用户提供接口（定义见后续内容）</td></tr><tr><td>硬件的扩充者</td><td>扩充机器</td></tr></tbody></table><p>管理处理机、存储器、文件和设备</p><hr><p><strong>接口</strong></p><p>学过开发的大家应该清楚什么意思。<br>这里指的是用户和计算机硬件之间的接口，即用户操控计算机硬件资源的途径<br>以下是三种主要的接口</p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>命令接口</td><td>允许用户直接使用</td></tr><tr><td>程序接口</td><td>允许用户通过程序间接使用</td></tr><tr><td>GUI</td><td>现代操作中最流行的图形用户接口（比如windows，这里我们不讨论GUI）</td></tr></tbody></table><p>其中，<strong>命令接口</strong>又可以分为：<br>| 类型                       | 内容                   |<br>| ————————– | ———————- |<br>| 联机命令接口               | 用户说一句，系统做一句 |<br>| 脱机命令接口               | 用户说一堆，系统做一堆 |<br>| 然后，<strong>程序接口</strong>具体是： |                        |</p><blockquote><p>由一组系统调用组成（系统调用 就是 程序接口，有的地方也叫广义指令）</p></blockquote><h3 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h3><p>一共有四个特征：<strong>并发 共享 虚拟 异步</strong><br>其中 <strong>并发 和 共享 是最基本的特征</strong>， 二者互为存在条件</p><hr><p><strong>并发</strong></p><blockquote><p>并发是两个或多个事件在同一时间间隔内发生<br>这些事件在宏观上是同时发生，但是微观上是交替发生的</p></blockquote><p>这是书上的话，其实就是说<br><strong>并发是一个时间段里面多个事件先后发生</strong><br>（并且不是一贯到底的）<br>（如果时间段比较短的话，就像是同时完成了多个事件）</p><p><strong>另外，并发的基础是中断</strong></p><hr><p>这里有一个容易混淆的概念：<strong>并行</strong></p><blockquote><p>两个或多个事件在同一时刻同时发生</p></blockquote><p>这个才是真正的同时进行<br>如下图所示：<br><img src="https://img-blog.csdnimg.cn/dc310655319c4db7bacf383c78715bc9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><p><strong>那么问题来了——为什么是并发而不是并行</strong><br>对于计算机来说，并行不是明显更高效吗，为什么操作系统的特征是并发呢？<br>主要是硬件限制，以前单核的CPU，同一时刻只能执行一个程序，所以就需要并发；<br>现在呢，保底都是四核了，也就是同一时刻四个程序，但是现在用电脑同一时刻才几个程序？所以还是会有并发…</p><hr><p> <strong>共享</strong></p><blockquote><p>共享指的是资源共享，是指系统中的资源可供内存中多个并发执行的进程使用</p></blockquote><hr><p><strong>资源共享的方式</strong><br>| 方式     | 内容                           |<br>| ——– | —————————— |<br>| 互斥共享 | 一个时间段内只能给一个进程访问 |<br>| 同时共享 | 一个时间段内由多个进程轮流访问 |</p><p>同时共享 和 并发 类似，也只是宏观上的同时，微观上是几个程序轮流占用</p><p>（当然有些时候也真的是同时，比如一边打游戏一边听歌，扬声器可以同时播放两者的音乐）</p><hr><p><strong>并发和共享的关系</strong><br>单核CPU下，没有并行这种操作，那要是并发都没有，计算机隔很久才执行一个程序，那共享从何而来？<br>另外，要是没有共享性质，极短的事件内，一个资源不能被两个或者多个程序访问，那么并发也无法继续进行</p><p>所以二者是相互依存</p><hr><p> <strong>虚拟</strong></p><blockquote><p>把一个物理上的实体变为若干个逻辑上的对应物；实体是实际存在的，对应物是用户感受到的</p></blockquote><p><strong>举例1：空间的虚拟</strong><br><strong>一个程序需要放入内存并且给它分配cpu才能执行</strong><br>那么比如运行一个游戏要10G内存，但是我们的电脑只有4G的内存，但是我们就是可以让它运行，好像我们电脑的内存不止10G的样子</p><p>这个例子中，4G内存就是实体，10G是用户感受到的，也就是逻辑上的对应物体<br>这里涉及到的技术叫做 <strong>空分复用术</strong></p><p><strong>举例2：时间的虚拟</strong><br>单核CPU的计算机 看上去 似乎可以“同时”执行多个程序（体现为 并发），可是它的原理是什么呢？<br>这里涉及到的技术叫做<strong>时分复用术</strong><br>（这里也看出，如果没有并发，就不需要（时间上的）虚拟；如果没有虚拟，就难以并发）</p><hr><p><strong>异步</strong></p><blockquote><p>在多道程序环境下，允许多个程序并发执行，但是资源有限，每个进程的执行不是一贯到底（进程是并发的），而是走走停停（轮流使用一段时间资源），以不可预知的速度向前推进</p></blockquote><p>说到异步啊….最开始学前端学到async和ajax的时候接触到了异步，当时我以为的异步实际上是并行（因为当时学的时候，有人说异步是生活中的同步，同步才是生活中的异步）….所以我之前一直理解错了….</p><hr><p><strong>图示举例</strong><br><img src="https://img-blog.csdnimg.cn/d75d734e01634f84ad34e566cb267da7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><h3 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h3><p>我们学习的范围包括：</p><blockquote><p>1.手工操作系统<br>2.批处理操作系统（包括单道和多道）<br>3.分时操作系统<br>4.实时操作系统<br>5.网络操作系统<br>6.分布式操作系统<br>7.个人计算机操作系统</p></blockquote><p>发展顺序自上而下，每一个阶段都是为了解决上一代的主要缺点</p><p>其中重点掌握2 3 4，1 5 6 7了解即可</p><hr><p><strong>1.手工操作系统</strong><br>其实这个都算不上操作系统<br>当时的程序员用<strong>纸带打孔</strong>的方式 表示0和1 进行编程</p><p>流程大概是：</p><blockquote><p>纸带A（代码）–&gt;纸带机–&gt;计算机（计算）–&gt;纸带机–&gt;纸带B（运行结果）</p></blockquote><p><strong>计算机速度很快</strong>，但是啊<strong>纸带机很慢</strong>，整个流程中大部分时间都在等待纸带机读取数据</p><p>这种流程有两个主要缺点：</p><blockquote><p>计算机有很多时间在等待 ，<br>一次只能有一个用户占用资源（机器）<br>上述两点概括为 <strong>人机速度矛盾</strong></p></blockquote><hr><p><strong>2.1批处理操作系统：单道</strong></p><p>这个阶段引入了<strong>脱机输入/输出技术</strong>，并且引入<strong>监督程序</strong>（操作系统的雏形）负责控制作业的输入输出</p><p>流程大概是（对称的，看一半就行）</p><blockquote><p>纸带-&gt;纸带机-&gt;外围设备-&gt;磁带-&gt;计算机-&gt;磁带-&gt;外围设备-&gt;纸带机-&gt;纸袋</p></blockquote><p>其实就是<strong>引入了外围设备和磁带</strong>，外围设备可以把数据快速存到磁带里面，然后磁带内的数据可以被计算机快速处理，输出同理</p><p>这个过程中，<strong>监督程序负责调控 计算机读取磁带内数据</strong></p><p>图示<br><img src="https://img-blog.csdnimg.cn/0a3218f01fe94443b05c235a1bf2b629.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>缺点是</p><blockquote><p>只有一个程序能运行，CPU依旧有很多时间在等待I/O，资源利用率还是不高</p></blockquote><hr><p><strong>2.2批处理操作系统：多道</strong><br>流程同上，但是每次可以使用多个磁带向计算机输入数据了<br><strong>引入了中断技术，并发由此出现，操作系统正式诞生</strong><br>（再次强调，中断是并发的基础）</p><p>图示<br><img src="https://img-blog.csdnimg.cn/136015b304454cc7929165d0ce62b2cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>缺点</strong></p><blockquote><p>响应时间长，没有人机交互能力（用户提交之后就只能等，不能手动控制调度）</p></blockquote><hr><p><strong>3.分时操作系统</strong><br>引入了<strong>时间片</strong>的概念(就是一个较小的时间段，大概是一个定值)</p><blockquote><p>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可以通过终端与计算机进行交互</p></blockquote><p><strong>举例</strong><br>比如时间片是0.01s，那么每个任务轮流执行0.01s，在1s内可能会完成多个任务，给用户的感受就是多个“同时”完成</p><p><strong>缺点</strong></p><blockquote><p>没有优先级，完全公平地处理任务，不能分轻重缓急</p></blockquote><hr><p><strong>4.实时操作系统</strong><br>引入了优先级</p><blockquote><p>在分时操作系统的基础上，能够优先响应一些紧急任务（它们不需要时间片排队）</p></blockquote><p><strong>分类（了解即可）</strong></p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>硬实时系统</td><td>必须在绝对严格的固定时间内完成处理</td></tr><tr><td>软实时系统</td><td>能够接受偶尔违反时间规定</td></tr></tbody></table><hr><p><strong>5-7其他几种操作系统（了解即可）</strong><br><strong>网络操作系统</strong></p><blockquote><p>实现网络中各种资源的共享和各台计算机之间的通信</p></blockquote><p><strong>分布式操作系统</strong></p><blockquote><p>有分布性和并行性，由多台计算机分工，工作可以分布在这些计算机上并行、协同完成</p></blockquote><p><strong>个人计算机操作系统</strong></p><blockquote><p>比如windows，方便个人使用</p></blockquote><hr><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p> <strong>两种指令</strong><br>这里的指令是指机器语言指令（高级语言翻译过来的）</p><p>两种指令主要是：<strong>特权指令</strong>和<strong>非特权指令</strong></p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>特权指令</td><td>不允许用户随意使用</td></tr><tr><td>非特权指令</td><td>允许用户随意使用</td></tr></tbody></table><p>出现这种分类的原因正如其名——有的指令可能造成的影响较大（比如删库？），不允许用户随便使用，即“特权”</p><p>但是，计算机怎么识别当前是否可以执行特权指令呢？<br>这就是接下来将要提到的处理器状态了</p><hr><p> <strong>两种处理器状态</strong><br>处理器状态分为 <strong>用户态（目态）</strong> 和 <strong>核心态（管态）</strong></p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>用户态（目态）</td><td>此时处理器不可执行特权指令</td></tr><tr><td>核心态（管态）</td><td>此时处理器可以执行特权指令</td></tr></tbody></table><p>这是利用<strong>程序状态字寄存器PSW</strong>中的某标志位来标识当前处理器处于什么状态。（比如可以让用户态为0，核心态为1）</p><p>上述内容体现在处于不同状态的程序上</p><hr><p><strong>两种程序</strong><br>也就是<strong>内核程序</strong>和<strong>应用程序</strong>，正如其名，不再多言<br>(当然，如果提到“管态程序”、“核心态程序”这些等价的概念时，也要反应得过来才是)</p><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><blockquote><p>是计算结配置上的底层软件，是操作系统最基本、最核心的部分</p></blockquote><p>就是常常听到的什么四核八核十六核CPU那个核<br>大概是这么一个地位：<br><img src="https://img-blog.csdnimg.cn/7c5250cd7e24460887cd5f091490a10c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><p> <strong>时钟管理</strong></p><blockquote><p>实现计时的功能</p></blockquote><hr><p> <strong>中断</strong><br>前面说并发的时候提到过</p><blockquote><p>负责实现中断机制（并发的前提）</p></blockquote><p><strong>分类</strong><br>广义的中断的分类标准主要根据信号的来源——CPU的内部还是外部</p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>内中断（异常、例外、陷入/陷阱）</td><td>指令中断的则为<strong>自愿中断</strong>；硬件故障或者软件中断的则为<strong>强迫中断</strong></td></tr><tr><td>外中断(中断)</td><td>一般是人工干预或外围设备请求导致的</td></tr></tbody></table><p><strong>运作过程</strong><br>配合时钟管理的计时器，发出中断信号</p><p>中断处理是内核的一部分，<strong>所以中断发生时，CPU进入核心态</strong><br>（<strong>中断是 用户态 转为 核心态 的唯一途径</strong>）</p><p>（<strong>而核心态 转为 用户态 的途径是执行一个特权指令，将PSW设置为“用户态”</strong>）</p><p>中断发生后，当前运行的进程暂停，接下来操作系统内核将对其进行处理</p><p>那么具体一点就是：</p><blockquote><p>执行每个指令后，CPU都会检测是否有外部中断信号： 如果没有，那么执行下一个指令；<br>如果有，那么保存即将被中断的CPU环境（相当于游戏存档，方便下次继续），然后进行中断处理。</p></blockquote><hr><p><strong>原语</strong></p><blockquote><p>一种特殊的程序<br>处于操作系统最底层，最接近硬件<br>运行时间短、调用频繁<br>具有原子性（就是数据库事务提到的那个）</p></blockquote><hr><p> <strong>系统资源管理</strong></p><blockquote><p>包括进程管理、存储器管理和设备管理等</p></blockquote><hr><p> <strong>内核分类</strong><br>有不同的分类标准，比如：</p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>单内核</td><td>内核中各个部件混杂的形态</td></tr><tr><td>大内核</td><td>在微内核基础上，还包括进程、存储器、设备管理等</td></tr><tr><td>微内核</td><td>结构性部件与功能部件分离</td></tr><tr><td>混合内核</td><td>微内核和单内核的折中，较多组件再核心态中运行</td></tr><tr><td>外内核</td><td>尽可能减少内核的软件抽象化和传统微内核的消息传递机制</td></tr></tbody></table><hr><p>这里主要讨论 <strong>大内核 和 微内核</strong><br><strong>大内核</strong><br>把操作系统主要模块都作为系统内核，运行在核心态（管态）<br>优点：高性能（一直是核心态不用切换）<br>缺点：代码庞大，结构乱，难维护<br>（这个缺点是很多早期计算机技术的通病）</p><p><strong>微内核</strong><br>内核只保留基本功能<br>优点：内核功能少，结构清晰，方便维护<br>缺点：需要频繁地在核心态和用户态之间切换，低性能</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>就是程序接口（严格意义上说操作系统是由一组系统调用组成的），上面有提到过</p><blockquote><p>操作系统提供给应用程序（编程人员）使用的接口。可以理解为一种可供应用程序调用的特殊函数，应用程序可以请求系统调用来获得操作系统的服务。</p></blockquote><p><strong>系统调用背后的过程</strong><br><img src="https://img-blog.csdnimg.cn/d007fb671aff4eceba98feecac3295a5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="定义和组成"><a href="#定义和组成" class="headerlink" title="定义和组成"></a>定义和组成</h3><p>进程就是一个程序地执行过程<br>当一个程序被放到内存中，才能够被CPU处理，才能执行<br>(我们双击exe文件，就是把程序放入内存的操作)</p><p>其中，程序的定义是<strong>一个指令序列</strong><br>而进程可以从不同角度进行定义，比如这些：</p><blockquote><p>程序段，数据段，PCB（进程控制块）三部分组成了进程实体（也叫进程映像，简称为进程）</p></blockquote><blockquote><p>进程是程序的一次执行过程</p></blockquote><blockquote><p>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</p></blockquote><blockquote><p>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</p></blockquote><blockquote><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p></blockquote><p>程序段，数据段，PCB三者都在内存中：<br>程序段、数据段分别是CPU中存放程序代码和所需数据的地方，<br>PCB则存储了程序段和数据段在CPU中的地址等信息</p><p>严格地说，<strong>进程实体是静态的，进程是动态的</strong></p><p><strong>PCB的存在时进程存在的唯一标志</strong></p><hr><h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><p>一个系统中，会存在众多PCB。必须用适当的形式来组织管理他们。<br>主要有两种组织方式：<br>| 方式     | 内容                                                         |<br>| ——– | ———————————————————— |<br>| 链接方式 | 按照进程状态将PCB分为多个队列；操作系统持有指向各个队列的指针 |<br>| 索引方式 | 根据进程状态的不同，建立几张索引表；操作系统持有各个索引表的指针 |</p><p><strong>链接方式</strong><br>拥有<strong>执行指针</strong>，指向当前处于运行态（执行态）的进程的控制器PCB；<br>拥有<strong>就绪队列指针</strong>，指向当前处于就绪态的进程；<br>拥有<strong>阻塞队列指针</strong>，指向当前处于阻塞太的进程，很多操作系统会因为阻塞原因不同而划分多个阻塞队列；</p><p><strong>索引方式</strong><br>和链接方式类似，拥有<strong>执行指针</strong>和<strong>阻塞队列指针</strong><br>并且拥有<strong>就绪表指针</strong>，指向一张就绪索引表的地址</p><hr><h3 id="进程的五大特征与三大状态"><a href="#进程的五大特征与三大状态" class="headerlink" title="进程的五大特征与三大状态"></a>进程的五大特征与三大状态</h3><p><strong>五大特征</strong><br>| 特征   | 内容                                                         |<br>| —— | ———————————————————— |<br>| 动态性 | 进程是程序的一次执行过程，是动态地产生、变化和消亡           |<br>| 并发性 | 内存中存在多个进程实体，可以并发执行                         |<br>| 独立性 | 进程是<strong>能够独立地运行、获取资源、接受调度的基本单位</strong>       |<br>| 异步性 | 各个进程以独立的、不可预知的速度向前推进。操作系统需要提供“进程同步机制”来解决问题 |<br>| 结构性 | 每个进程都由PCB、结构段、数据段组成                          |</p><p>其中，<strong>动态性</strong>是进程的最基本特征</p><p><strong>三大状态</strong><br>| 状态                            | 内容                                                         |<br>| ——————————- | ———————————————————— |<br>| 运行态                          | 占有CPU并且在CPU上运行                                       |<br>| 就绪态                          | 已经具备运行条件，但是由于没有闲置CPU，暂时不能运行          |<br>| 阻塞态(等待态)                  | 因为等待某一件事暂时不能运行                                 |<br>| 以上是基本的状态                |                                                              |<br>| 进程还能被细分为更多的状态,比如 |                                                              |<br>| 其他状态                        | 内容                                                         |<br>| –                              | –                                                           |<br>| 创建态                          | 进程正在被创建，操作系统为进程分配资源、初始化PCB            |<br>| 终止态                          | 进程正在从系统中被撤销，操作系统将会回收资源、撤销PCB        |<br>| 挂起态                          | 还可以细分为<strong>就绪挂起态</strong>和<strong>阻塞挂起态</strong>，是在内存不够的时候，被<strong>调度</strong>（后面会说）到<strong>外存</strong>（硬盘;这是和阻塞的最大区别）暂时保存的状态 |</p><hr><p><strong>状态转换</strong><br>还是比较好懂，大概内容如图所示<br><strong>三态四转换模型</strong><br><img src="https://img-blog.csdnimg.cn/f124ce79f2cc4245a91b912267b4d629.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>五态六转换模型</strong></p><p><img src="https://img-blog.csdnimg.cn/f7eba01b479b4f3eb3dc7b9af053809a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>七态十二转换模型</strong><br><img src="https://img-blog.csdnimg.cn/2edc211422384c1aa41561d59ac76c4b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>内存不够可以理解为内存中的就绪/阻塞队列满了，只能先放到外存</p><hr><p>五态转换详细过程的如下<br><img src="https://img-blog.csdnimg.cn/c70fe6f5db5c4ae98a410f717bfd5bb7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>但是上图也看出了一个问题：<br>就绪态的任务在CPU修改PCB状态为执行之后，进入执行态，执行态开始请求，进入阻塞态，请求完成，阻塞态回归到就绪态——问题就出现了，这个时候，PCB的状态依旧是执行！<br>为了解决这个问题，利用了<strong>原语</strong></p><hr><h3 id="原语控制进程"><a href="#原语控制进程" class="headerlink" title="原语控制进程"></a>原语控制进程</h3><p><strong>原语的实现</strong><br>具有原子性的操作，不允许中断<br>原语是通过<strong>关中断指令</strong>和<strong>开中断指令</strong>实现的:</p><blockquote><p>在原语代码执行前，先执行关中断指令，之后代码执行不会引起中断；</p></blockquote><blockquote><p> 在原语代码执行后，再执行开中断指令，此后都将执行中断处理；</p></blockquote><hr><p><strong>进程的创建</strong></p><p>有两种常见的进程创建方式：</p><p><strong>发生引起创建进程的事件</strong></p><blockquote><p>用户登录、应用请求、作业调度和提供服务等</p></blockquote><p><strong>执行创建原语</strong></p><blockquote><p>1.申请空白PCB<br>2.为新进程分配所需资源<br>3.初始化PCB<br>4.将PCB插入就绪队列</p></blockquote><hr><p><strong>进程的终止</strong></p><p>也有两种常见的进程终止方式：</p><p><strong>发生引起进程终止的事件</strong></p><blockquote><p>任务正常结束、异常结束或被外界干预</p></blockquote><p><strong>执行撤销原语</strong></p><blockquote><p>1.从PCB集合中找到终止进程的PCB<br>2.如果进程正在执行，则将其占有的CPU剥夺然后分配给其他进程<br>3.终止其所有子进程<br>4.将该进程拥有的所有资源归还给父进程或操作系统<br>5.删除其PCB</p></blockquote><p><strong>注意，撤销原语可以直接让进程变为终止态——无论该进程正处于何种状态</strong></p><hr><p><strong>进程的阻塞</strong></p><p>还是两种方式：</p><p><strong>发生引起阻塞进程的事件</strong></p><blockquote><p>需要等待 系统分配资源 或 其他与之合作的进程完成工作</p></blockquote><p><strong>执行阻塞原语</strong></p><blockquote><p>1.找到阻塞进程对应的PCB<br>2.保护进程运行环境，将PCB信息修改为阻塞态，暂停该进程<br>3.将PCB插入相应事件的等待队列</p></blockquote><hr><p><strong>进程的唤醒</strong></p><p>依旧是两种方式：</p><p><strong>发生引起唤醒进程的事件</strong></p><blockquote><p>等待结束</p></blockquote><p><strong>执行唤醒原语</strong></p><blockquote><p>1.在事件等待队列中找到PCB<br>2.将PCB从等待队列中移除<br>3.将PCB插入就绪队列，等待被调度</p></blockquote><p>阻塞和唤醒其实就是等待和等待结束的意思<br>另外，阻塞和唤醒一定成双成对出现</p><hr><p><strong>进程的切换</strong><br>还是两种：<br><strong>发生引起切换进程的事件</strong></p><blockquote><p>1.当前时间片用完<br>2.有更高优先级的进程到达<br>3.当前进程主动阻塞<br>4.当前进程终止</p></blockquote><p><strong>执行切换原语</strong></p><blockquote><p>1.将运行环境存入当前进程的PCB<br>2.该PCB移入相应的队列<br>3.选择另一个进程执行，并更新其PCB<br>4.根据PCB中信息恢复进程需要的运行环境</p></blockquote><hr><p>其实无论哪种原语，其作用无非以下三点：<br><strong>1.更新PCB信息</strong><br>    1.1所有进程控制原语一定会修改进程状态标志<br>    1.2剥夺当前进程的CPU使用权必然要保存其运行环境<br>    1.3某进程回复运行前必然要恢复其运行环境<br><strong>2.将PCB插入合适的队列</strong><br><strong>3.分配/回收资源</strong></p><hr><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>由于进程是分配系统资源的基本单位，所以各个进程的内存地址相互独立<br>进程通信即进程之间的信息交换，但是为了保证安全性，一个进程不能直接访问其他进程的地址空间，所以进程通信会通过以下方式实现</p><p><strong>方式1：共享存储</strong></p><p>开辟一个共享空间，用来进程间传递信息<br><img src="https://img-blog.csdnimg.cn/37558959115b4394bae6ceaaa630f66b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>进程对这个空间的访问必须是互斥的，这由操作系统提供的工具实现（同步互斥工具，如P/V操作）</p><p><strong>实现原理</strong><br>两种…..<br>| 类型         | 内容                                                         |<br>| ———— | ———————————————————— |<br>| 基于数据结构 | 低级通信方式，速度慢，限制多，每次只能传格式固定的某种数据结构，如长度为10的串 |<br>| 基于存储区   | 高级通信方式，速度快，在内存中开辟共享存储区，<strong>存放的位置由进程决定</strong> |</p><p><strong>方式2：管道通信</strong></p><p><strong>实现原理</strong></p><blockquote><p>“管道”指的是用于连接读写进程的一个共享文件，又叫pipe文件，其实就是在内存中开辟的一个大小固定的缓冲区</p></blockquote><p>tips：<br>1.管道只能采用<strong>半双工通信</strong>（可以正向传输也可以逆向传输，但是同一时间只能朝一个方向传输；双向同时通信则需要两个管道）</p><p>2.各个进程对管道的访问是互斥的（哪怕是同向也一样）</p><p>3.其中，数据以字符流的形式传输，读写操作是用write()和read()程序接口（系统调用）实现的。</p><p>4.管道没写满，就不允许读；如果没读空，就不允许写（会被阻塞）</p><p>5.数据一旦被读出，就从管道中清除，无法再次使用（这意味着最多一个读进程，否则可能出现读取错误）</p><hr><p><strong>方式3：消息传递</strong></p><blockquote><p>进程之间的数据交互以格式化的信息为单位<br>通过操作系统提供的<strong>发送消息/接受消息</strong>两个原语进行数据交换</p></blockquote><p>上述的<strong>“格式化的信息”</strong>指的是消息头+消息体<br>（类似于请求/响应的头/体）<br>| 名称   | 内容                                                   |<br>| —— | —————————————————— |<br>| 消息头 | 发送进程ID，接受进程ID，消息类型，消息长度等格式化信息 |<br>| 消息体 | 消息的内容等等                                         |</p><p><strong>实现原理</strong></p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>直接通信</td><td>消息会被直接挂到接受进程的缓冲队列上</td></tr><tr><td>间接通信</td><td>消息先发送到中间实体“信箱”，所以间接通信也称“信箱通信”（可以通过消息头的信息确定收发对象）</td></tr></tbody></table><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>背景</strong><br>上古之世，未有进程之说，企鹅和企鹅音乐竟然无法同时运作!<br>先贤鬼斧神工以创进程，自此以后，企鹅和企鹅音乐才得以“同时”运作…<br>再后来，随着科技发展，企鹅作为一个进程却可以同时进行文字传输，视频播放，文件传输等等操作<br>单个进程是如何做到同时进行多项任务的？</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>众所周知，传统的进程只能串行（顺序）执行一系列程序（传统进程是程序执行流的最小单位），无法达到“同时”的效果</p><p>所以引入了线程的概念：</p><blockquote><p>一个进程会包含多个线程，各个线程独立的、并发的运行，CPU轮流为每个线程服务。<br>这样一来，<strong>线程是程序执行流的基本单位</strong>，可以看做<strong>轻量级的进程</strong><br>和进程类似，拥有TCB（线程控制块）等</p></blockquote><p><strong>和子进程的区别</strong><br>1.线程是进程的一部分，一个没有线程的进程可以看做单线程<br>2.引入线程的概念后，<strong>进程是（除了CPU以外的）资源分配的基本单位，而线程是程序执行（调度）的基本单位。线程几乎没有系统资源。</strong><br>3.进程有独立的地址空间，而多个线程总是共享地址空间和公共变量</p><hr><p><strong>影响和意义</strong><br>1.同一个进程内的线程切换不需要切换进程环境，系统开销减小<br>2.线程可以并发，提高了并发度</p><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><p><strong>方式1:用户级线程</strong><br>User-Level Thread(ULT)<br><img src="https://img-blog.csdnimg.cn/4d789aab865e4a928ac9d43f3b56a2b1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>用户可以感知到多个线程，但是操作系统内核只能感知到进程</p></blockquote><p>tips：<br>用户级线程是由 应用程序 通过 线程库 实现的<br>所有的<strong>线程管理都由应用程序负责</strong><br>用户级线程中，线程切换可以在用户态下完成，无需操作系统干预</p><hr><p><strong>方式2：内核级线程（内核支持线程）</strong><br>Kernel-Level Thread，KLT<br><img src="https://img-blog.csdnimg.cn/33f7f9aaa9a54209b3b975f04b42fd73.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>即操作系统内核可以感知到的线程，线程切换需要在核心态下进行</p></blockquote><hr><p><strong>方式3：组合线程</strong><br><img src="https://img-blog.csdnimg.cn/072a015c0c2d45d682e77558479d4638.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>将ULT和KLT混合使用（当然并不是每个操作系统都支持这么做)</p><blockquote><p>将n个用户级线程映射到m个内核级线程上（n &gt;= m)</p></blockquote><p>这里，分配CPU资源的单位是内核级线程（毕竟内核只看得见它们啊..）<br>如上图所示的情况，哪怕是4核CPU，也只能并行两个用户级线程</p><p><strong>混合线程的思路，引出了多线程模型</strong></p><hr><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p><strong>模型1：多对一模型</strong><br><img src="https://img-blog.csdnimg.cn/e64a39c14c03415483c0f89251f08117.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>概述</strong><br>多个用户级线程映射到一个内核级线程</p><p><strong>优点</strong><br>用户级线程的切换可以在用户态完成，无需切换核心态，开销小，效率高</p><p><strong>缺点</strong><br>当一个（内核级）线程被阻塞后，整个进程都会被阻塞，并发度低；<br>并且，多个线程不可以在多核CPU上并行。</p><hr><p><strong>模型2：一对一模型</strong><br><img src="https://img-blog.csdnimg.cn/fdeb388e1fd0482b91c05f1afb94ddf0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>概述</strong><br>一个用户级线程映射到一个内核级线程</p><p><strong>优点</strong><br>一个（内核级）线程阻塞，不影响线程，并发性强；<br>可以在多核CPU上并行。</p><p><strong>缺点</strong><br>一个用户进程会占用多个内核级线程，并且切换操作需要在核心态完成，<br>线程的管理成本高，开销大。</p><hr><p><strong>模型3：多对多模型</strong><br><img src="https://img-blog.csdnimg.cn/2de20aad87014cd29637bf096230edb4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>正是之前提到的组合模式的图示</p><p><strong>概述</strong><br>n个用户级线程映射到m个内核级线程（n&gt;=m)</p><p><strong>优/缺点</strong><br>是模型1和模型2的中和，并发度居中，开销和管理成本也居中</p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><blockquote><p>在多道程序系统中，进程的数量总是多于CPU个数，不可能并行所有进程。<br>所以需要CPU调度，从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行</p></blockquote><h3 id="三层调度"><a href="#三层调度" class="headerlink" title="三层调度"></a>三层调度</h3><p> <strong>高级调度（作业调度）</strong></p><blockquote><p>按照一定原则，从后备队列中的作业中筛选一个或多个作业，为之分配资源、建立PCB，使它们获得竞争处理机的权力</p></blockquote><p>后备队列是因为有时候用户提交的作业过大，无法一次性全部放入内存，所以先放到处于外存的后备队列，等操作系统调度安排</p><blockquote><p>高级调度是外存（辅存，硬盘）与内存之间的调度，每个作业只调入一次（此时为之建立PCB），调出一次（作业结束菜调出）<br>主要是解决调入的问题，由操作系统决定何时调入</p></blockquote><p>tips:<br><strong>作业</strong></p><blockquote><p>是一个比程序/进程更加宽泛的概念，不仅包含通常的程序和数据，还配有一份程序说明书，系统根据说明书对进程进行控制</p></blockquote><hr><p><strong>中级调度（内存调度）</strong></p><blockquote><p>把暂时不能运行的进程调度到外存等待，直到其重新具备了运行条件才再次调入内存</p></blockquote><p>与高级调度的区别是这个可以多次调入调出，把进程放到外存等待（此时状态变为<strong>挂起</strong>，PCB放到内存中的挂起队列），给其他进程空间</p><p>这样做<strong>提高了内存的利用率和系统吞吐量</strong></p><hr><p><strong>低级调度（进程调度）</strong></p><blockquote><p>按照某种方法和策略，从就绪队列中选取一个进程，将处理机分配给它<br><strong>进程调度是操作系统中最基本的一种调度</strong>，频率较高，几十毫秒便会执行一次</p></blockquote><hr><p><strong>总结：</strong><br><img src="https://img-blog.csdnimg.cn/973a2560c87c461e8a582b2b01e045ae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="进程调度时机、方式、切换与过程"><a href="#进程调度时机、方式、切换与过程" class="headerlink" title="进程调度时机、方式、切换与过程"></a>进程调度时机、方式、切换与过程</h3><p><strong>时机</strong></p><p>进程调度即低级调度<br><strong>什么时候需要进程调度</strong><br>1.当前运行的进程<strong>主动</strong>放弃处理机</p><blockquote><p>进程正常终止、运行过程中发生异常而终止、进程主动请求（阻塞）</p></blockquote><p>2.当前运行的进程被<strong>动放</strong>弃处理机</p><blockquote><p>该进程的时间片用完、由优先级更高的进程进入就绪队列、有更紧急事件需要处理</p></blockquote><hr><p><strong>什么时候不能进程进程调度</strong></p><p>（对于大部分操作系统而言）</p><blockquote><p>1.处理中断的过程中（据说是因为中断处理很复杂，与硬件关联大…阿巴阿巴）<br>2.进程处于操作<strong>系统内核程序临界区</strong>（但是在普通临界区是可以进行的）<br>3.在原子操作中（比如原语），不可中断</p></blockquote><hr><p><strong>方式</strong></p><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>非剥夺调度方式（非抢占方式）</td><td><strong>只允许进程主动放弃处理机</strong>。就算有优先级更高的任务到达，当前任务依旧会继续执行，知道该进程终止或者主动发出申请进入阻塞态</td></tr><tr><td>剥夺调度方式（抢占方式）</td><td>当一个进程在处理机上执行时，有优先级更高的进程到达，当前进程立刻暂停，处理机将被分配给更优先级更高的进程</td></tr></tbody></table><p><strong>优劣</strong><br><strong>非剥夺调度方式（非抢占方式）</strong>：<br>实现简单，系统开销小<br>但是无法实现紧急任务<br>适合早期的批处理系统</p><p><strong>剥夺调度方式（抢占方式）</strong>：<br>能优先处理紧急任务，也可以以时间片轮流执行<br>适合分时操作系统、实时操作系统</p><hr><p><strong>切换与过程</strong></p><p><strong>狭义的进程调度 与 进程切换 的区别</strong></p><blockquote><p>狭义的进程调度指的是，从就绪队列中选中一个要运行的进程这一行为。</p></blockquote><blockquote><p>进程切换是指，一个进程让出处理机，由另一个进程占用处理机的过程。</p><p>进程切换主要完成了<br>1.保存原来运行的进程中数据（保存到PCB）<br>2.恢复新的进程的数据（从PCB读取）</p></blockquote><p>而<strong>广义的进程调度</strong>包含 选择一个进程 和 进程切换 两个步骤（这也是我们通常所说的进程调度）</p><p>tips:<br>进程切换是有代价的，需要消耗时间，过于频繁必将拉低效率</p><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><p><strong>CPU利用率</strong></p><blockquote><p>即 忙碌时间/总时间</p></blockquote><p>如某个作业需要在CPU上运行5s，再用打印机输出5s，之后再执行5s，那么利用率就是10/15<br>（这里打印机的利用率是5/15）</p><hr><p><strong>系统吞吐量</strong></p><blockquote><p>即 完成的作业量/总时间</p></blockquote><p>比如完成10道作业，花费100秒，则系统吞吐量为<br>10/100 = 0.1 </p><hr><p><strong>周转时间</strong></p><blockquote><p>即 作业提交到作业完成的用时<br>（站在用户的视角看待）</p></blockquote><p>tip：<br>实际运行时间是指<strong>占用处理机的时间</strong>（<strong>不包括输入输出的时间</strong>）</p><p> <strong>带权周转时间</strong></p><blockquote><p>（作业完成时间  -  作业提交时间）/  作业实际运行时间<br>即 <strong>周转时间 / 作业实际运行时间</strong></p></blockquote><p>对于周转事假相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，<strong>带权周转时间更小，用户满意度更高</strong></p><p>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高</p><hr><p><strong>等待时间</strong></p><blockquote><p>进程/作业处于等待处理机状态时间之和。</p></blockquote><p>对于进程来说，等待时间是指进程建立之后等待被服务的时间之和，但是等待I/O的期间也算是被服务，所以不计入等待时间</p><p>对于作业来说，还要加上作业在外存后备队列的等待时间</p><hr><p><strong>响应时间</strong></p><blockquote><p>指从用户提交请求到<strong>首次</strong>产生响应所用的时间</p></blockquote><hr><p><strong>响应比</strong></p><blockquote><p>（等待时间+要求服务时间） /  要求服务时间</p></blockquote><p><strong>举个例子</strong></p><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>7</td></tr><tr><td>P2</td><td>2</td><td>4</td></tr><tr><td>0时刻：只有P1在就绪队列，P1占用处理机</td><td></td><td></td></tr><tr><td>7时刻：P1主动放弃处理机，就绪队列中有P2，其响应比是(5 + 4)/4=2.25</td><td></td><td></td></tr></tbody></table><hr><h3 id="几种调度算法"><a href="#几种调度算法" class="headerlink" title="几种调度算法"></a>几种调度算法</h3><p>前置概念：<strong>饥饿</strong></p><blockquote><p>作业/进程长期得不到服务（意思是可能一直被插队而无法得到处理，不是说需要等待的时间较长）</p></blockquote><p><strong>先来先服务FCFS</strong></p><blockquote><p>First Come First Serve，先来先服务</p></blockquote><table><thead><tr><th>属性</th><th>内容</th></tr></thead><tbody><tr><td>思想</td><td>公平（分先来后到）</td></tr><tr><td>规则</td><td>按照作业/进程的先后顺序进行服务</td></tr><tr><td>用于作业/进程调度</td><td>用于作业调度：考虑哪个作业先到达后备队列；用于进程调度：考虑哪个进程先到达就绪队列</td></tr><tr><td>是否为抢占</td><td>非抢占</td></tr><tr><td>优缺点</td><td>优点：公平、简单；缺点：不利于排在长作业/进程后的短作业/进程用户体验 和 长作业/进程的运行</td></tr><tr><td>是否会产生饥饿现象</td><td><strong>不会</strong></td></tr></tbody></table><hr><p><strong>短作业优先SJF</strong></p><blockquote><p>Shortest Job First，最先服务（服务时间）最短的<br>用于进程就是Shortest Process First</p></blockquote><table><thead><tr><th>属性</th><th>内容</th></tr></thead><tbody><tr><td>思想</td><td>追求最少的平均等待时间、平均周转时间、平均带权周转时间</td></tr><tr><td>规则</td><td><strong>从已经到达的作业/进程中，选择服务时间最短的优先服务</strong></td></tr><tr><td>用于作业/进程调度</td><td>用于作业调度：考虑哪个作业先到达后备队列；用于进程调度：考虑哪个进程先到达就绪队列</td></tr><tr><td>是否为抢占</td><td><strong>非抢占</strong></td></tr><tr><td>优缺点</td><td>优点：“最短的”（不严谨地说）平均等待/周转时间；缺点：不利于厂作业，可能导致饥饿，难以做到真正的短作业优先</td></tr><tr><td>是否会产生饥饿现象</td><td><strong>会</strong></td></tr></tbody></table><hr><p><strong>最短剩余时间优先SRTN</strong></p><blockquote><p>Shortest Remaining Time Next，是短作业优先算法SJF的抢占版本</p></blockquote><hr><p><strong>高响应比优先HRRN</strong></p><table><thead><tr><th>属性</th><th>内容</th></tr></thead><tbody><tr><td>思想</td><td>综合考量作业进程的等待时间和要求服务的时间</td></tr><tr><td>规则</td><td>每次调度优先考虑响应比最高的</td></tr><tr><td>用于作业/进程调度</td><td>同上</td></tr><tr><td>是否为抢占</td><td>非抢占</td></tr><tr><td>优缺点</td><td>优点：综合考量了….；缺点：（不明显）</td></tr><tr><td>是否会产生饥饿现象</td><td><strong>不会（随着等待时间变长，响应比也会越来越大，被调用的几率就越来越大）</strong></td></tr></tbody></table><hr><p><strong>时间片轮转RR</strong></p><blockquote><p>Round-Robin<br>需要注意，如果一个任务剩余的时间小于一个时间片，那么它会在完成时主动放弃处理机，然后发生调度，其他就绪态的任务开始执行<br>这种调度方式常用于分时系统</p></blockquote><table><thead><tr><th>属性</th><th>内容</th></tr></thead><tbody><tr><td>思想</td><td>公平</td></tr><tr><td>规则</td><td>轮流执行一个时间片</td></tr><tr><td>用于作业/进程调度</td><td>用于进程调度（只有作业放入内存建立相应的进程后才能被分配处理机时间片）</td></tr><tr><td>是否为抢占</td><td>抢占（原理是中断）</td></tr><tr><td>优缺点</td><td>优点：响应快、公平；缺点：高频的进程切换开销太大、公平</td></tr><tr><td>是否会产生饥饿现象</td><td><strong>不会</strong></td></tr></tbody></table><hr><p><strong>优先级调度</strong></p><blockquote><p>优先级越高越先执行（注意优先级和优先数不一样，优先数还得看题目的定义）</p></blockquote><p>tips:</p><blockquote><p>1.优先级也有静态和动态两种，顾名思义<br>2.系统进程&gt;用户进程，前台进程&gt;后台进程<br>3.操作系统更偏好（优先处理）I/O型进程（也叫I/O繁忙型进程，与I/O相对的是计算型进程，也叫CPU繁忙型进程)。这样设计是因为I/O操作可以和CPU并行工作，如果让I/O繁忙的进程优先运行的话，那么就能让I/O设备尽早投入工作，资源利用率，系统吞吐量都会得到提升<br>| 属性               | 内容                                                     |<br>| —————— | ——————————————————– |<br>| 思想               | 轻重缓急                                                 |<br>| 规则               | 先执行优先级高的                                         |<br>| 用于作业/进程调度  | 用于进程和作业调度，甚至还会用于之后会提到的I/O调度      |<br>| 是否为抢占         | 两种都有                                                 |<br>| 优缺点             | 优点：能分清轻重缓急；缺点：可能会有高频的切换和饥饿现象 |<br>| 是否会产生饥饿现象 | 会                                                       |</p></blockquote><hr><p><strong>那么问题来了</strong><br>这么多算法，各有千秋但是也各有缺点，所以，能不能有一个集大成者出现呢？<br><strong>多级反馈队列调度算法</strong><br>| 属性               | 内容                                                         |<br>| —————— | ———————————————————— |<br>| 思想               | 其他算法的综合                                               |<br>| 规则               | 1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大 <br>2.新进程到达时进入第一级队列，按照FCFS等待分配时间片；若时间片用完进程还未结束，那么进程进入下一级队列队尾（如果此时已经是最低一级的队列，那么重新放到本队列末尾)<br>3.只有第K级队列为空时，才会为K+1级队列的进程分配时间片 |<br>| 用于作业/进程调度  | 用于进程                                                     |<br>| 是否为抢占         | 抢占                                                         |<br>| 优缺点             | 优点：综合性强，适应多种情况 缺点：可能导致饥饿              |<br>| 是否会产生饥饿现象 | 会（短进程不断，并且在一个时间片内可以被处理完，那么已经被降级的进程就得不到处理） |</p><hr><h2 id="进程同步-与-进程互斥"><a href="#进程同步-与-进程互斥" class="headerlink" title="进程同步 与 进程互斥"></a>进程同步 与 进程互斥</h2><p><strong>进程同步</strong><br>众所周知，进程具有异步性。异步性是指，各并发执行的进程以自己独立的、不可预知的速度向前推进。</p><p>但是在读写进程的时候，写 一定要发生在 读 的前面，这种情况就需要<strong>解决异步性带来的问题</strong>——这便是<strong>进程同步</strong>要讨论的</p><blockquote><p>进程同步 也叫 <strong>直接制约关系</strong>，它是为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p></blockquote><p><strong>进程互斥</strong><br>一个资源在同一时间内只能被一个进程使用<br>对临界区的互斥访问，从逻辑上可以分为以下四个部分：</p><blockquote><p>do{<br>    entry section;            //进入区:负责检测<br>critical section;        //临界区<br>exit section;                //退出区<br>    remainder section;  //剩余区<br>}</p></blockquote><table><thead><tr><th>区域</th><th>内容</th></tr></thead><tbody><tr><td>entry section进入区</td><td>负责检查是否可以进入临界区，若可进入，则应设置正在访问临界资源的标指（可以看作<strong>上锁</strong>），阻止其他进程进入临界区</td></tr><tr><td>critical section临界区</td><td>也叫临界段。就是访问临界资源的那段代码</td></tr><tr><td>exit section退出区</td><td>“解锁”</td></tr><tr><td>remainder section剩余区</td><td>做一些其他处理</td></tr></tbody></table><p>tips:<br><strong>进入区</strong>和<strong>退出区</strong>是 <strong>负责实现互斥</strong> 的代码段</p><p>遵循了四个原则：<br>| 原则     | 内容                                                         |<br>| ——– | ———————————————————— |<br>| 空闲让进 | 临界区空闲时，允许 一个请求进入临界区的进程 立刻 进入临界区  |<br>| 忙则等待 | 当已经有进程进入临界区的时候，其他试图进入这里的进程必须等待 |<br>| 有限等待 | 等待时间不能是无限的（不能饥饿）                             |<br>| 让权等待 | 当进程不能进入临界区时，应该立即释放处理机，防止进程忙等待   |</p><hr><h3 id="软件实现方法"><a href="#软件实现方法" class="headerlink" title="软件实现方法"></a>软件实现方法</h3><p><strong>1.单标志法</strong></p><blockquote><p>两个进程在访问完临界区之后，把临界区的权限交给另一个进程。也就是<strong>每个进程进入临界区的权限只能被另一个进程授予</strong><br><strong>违背了空闲让进原则</strong><br><img src="https://img-blog.csdnimg.cn/e74855743ed94d5888de6c1a54b69c94.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></blockquote><hr><p><strong>2.双标志先检查法</strong></p><blockquote><p>设置一个布尔型数组（习惯性叫flag)，数组中每个元素用来标记进程想进入临界区的意愿。比如flag[0] = true表示0号元素想要进入，每个进程进入临界区之前都要检查当前有没有别的进程想要进入临界区。<br>如果没有，那么就把自身对应的表示设为true</p></blockquote><p><img src="https://img-blog.csdnimg.cn/08b8df5ca4a349d68037e0071d5908e4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>上图的问题是，两者同时进入了临界区</p><hr><p><strong>3.双标志后检查法</strong></p><blockquote><p>双标志先检查法的改版。前一个算法（先检查）的问题是，先“检查”后“上锁”，但是这两个操作无法一气呵成，因此导致了两个进程同时进入临界区。<br>所以机智的人类就提出了先上锁后检查的操作<br><img src="https://img-blog.csdnimg.cn/c86ea433dd7049619ab0e84fe5571cae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></blockquote><p>然后又发现，这不是会导致两个都进不去吗（注意<strong>这是饥饿，不是死锁</strong>）</p><hr><p><strong>4.peterson算法</strong></p><blockquote><p>在双标志检查法的基础上，如果出现了几个进程争着进入临界区的情况，那么让进程变得“谦让”<br>方法是，依旧设置一个flag数组表示自身的意愿，但是额外地增加一个turn值表示愿意谦让哪个进程(比如turn=1，就是在发生冲突时，愿意把机会让给1号进程)</p></blockquote><p><img src="https://img-blog.csdnimg.cn/75720710fb4d48998fcb1688e65970fc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果按①⑥②⑦⑧的顺序执行<br>P0谦让，然后P1不甘落后又谦让，并且执行⑧循环等待，所以最终P0先使用</p><hr><h3 id="硬件实现方法"><a href="#硬件实现方法" class="headerlink" title="硬件实现方法"></a>硬件实现方法</h3><p><strong>1.中断屏蔽法</strong></p><blockquote><p>利用 开/关中断指令 实现（和原语一样，在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个进程同时访问临界区的情况）</p></blockquote><p>优点：简单高效<br>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令，只能运行在内核态，这组指令如果能让用户随意使用会很危险)</p><hr><p><strong>2.TestAndSet指令</strong></p><blockquote><p>简称TS指令，也有叫做TestAndSetLock指令的，简称TSL指令<br>他们是通过硬件控制做到的，暂不细究</p></blockquote><p>优点：实现简单；适用于多处理机环境；<br>缺点：不满足“让权等待”</p><hr><p><strong>Swap指令</strong></p><blockquote><p>也叫Exchange简称XCHG指令，同上，暂不细究</p></blockquote><p>优点：实现简单；适用于多处理机环境；<br>缺点：不满足“让权等待”</p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><blockquote><p>分为两大类，整型信号量 和 记录型信号量<br>主要思想是，设置一个变量（即信号量），可以用这个量表示系统中某种资源的数量<br>常用到一对原语：wait(S)和signal(S)，分别简称为P、V（来自荷兰语），操作其中S是信号量</p></blockquote><p><strong>整形信号量</strong></p><blockquote><p>只支持三种操作：初始化、p、v</p></blockquote><p><img src="https://img-blog.csdnimg.cn/0c897e1d1a5b44529e10e61d1c55f455.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>注意这里的while只是为了方便理解，实际上当资源不够的时候，进程会被挂起而中断</strong></p><p>优点：检查和上锁一气呵成，避免了并发异步导致的问题<br>缺点：不满足让权等待原则，会发生忙等</p><hr><p><strong>记录型信号量</strong></p><blockquote><p>即在整型信号量的基础上，用记录型数据结构表示的信号量</p></blockquote><p><img src="https://img-blog.csdnimg.cn/1d5c5b1a820744778b95e5020311eb1b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>至于signal那里，<br>由于wait保证了，在没资源的情况下，进程会进入阻塞队列（block），<br>所以<br><strong>value为正数的时候表示空闲资源数量，<br>为负数的时候其绝对值表示阻塞队列中进程的数量</strong></p><hr><p><strong>使用信号量实现进程互斥</strong><br><img src="https://img-blog.csdnimg.cn/c222b06ad5564f0e8bd3d00b39f363f2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><p><strong>使用信号量实现进程同步</strong><br><img src="https://img-blog.csdnimg.cn/b7331da4c8ca4aaf868323600600d35c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><p><strong>信号量机制实现前驱关系</strong><br><img src="https://img-blog.csdnimg.cn/458be36075aa454c82418fa33726841f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><p>tip:缓冲区等临界资源为互斥访问，不为临界资源可以不用互斥</p><p><strong>生产者消费者问题</strong></p><blockquote><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一组数据放入缓冲区，消费者每次从缓冲区拿出一组数据使用。<br>生产者消费者共用一个初始为空、大小为n的缓冲区。</p></blockquote><p>只有当缓冲区不满的时候，生产者才能生产，否则进入阻塞直到收到缓冲区不满的信号才被唤醒，重新进入就绪队列；<br>消费者只有当缓冲区不为空的时候，才能拿出使用，否则阻塞知道收到缓冲区不为空的信号才被唤醒，重新进入就绪队列；</p><p>规则很简单，但是存在问题：<br>如果并发（或者并行）环境下，有多个生产者，它们几乎同时检测了缓冲区，都发现还没满，结果两个都试图写入，结果其中一个生产者写入之后就已经满了，其他的生产者就写入失败发生写入错误</p><p>解决这个问题之前，我们先要<strong>分析</strong></p><blockquote><p>1.缓冲区是临界资源，需要<strong>互斥</strong>访问<br>2.缓冲区满的时候，消费者先取，生产者后放，是一种<strong>同步</strong>关系；缓冲区为空的情况同理</p></blockquote><p><img src="https://img-blog.csdnimg.cn/8c64f235e3314b61b9c1cde460d920d3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>但是如果我们这么执行呢？<br><img src="https://img-blog.csdnimg.cn/08e99cca3c4a48db85b7312af2b94de3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这就会引发死锁</p><hr><p><strong>多生产者-多消费者问题</strong><br>是对上一个问题的拓展<br><img src="https://img-blog.csdnimg.cn/7b88b9a3118a452287d8810fe06be3d5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>我们再来分析一手：</p><blockquote><p>互斥（其实就是先V后P）：<br>1.盘子相当于缓冲区，是临界资源，需要互斥访问<br>同步：<br>2.父亲放苹果后，女儿才能取苹果，是同步关系。母亲和儿子同理。<br>3.只有盘子为空，父母才能放，也是同步关系。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/3166525c3a064162bfeedab2f3ace993.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果不设互斥信号量mutex会怎么样？</p><blockquote><p>不会怎么样。因为缓冲区大小为1，并且存在三个同步信号量，这三个同步信号量中同一时刻最多有一个为1。因此在任何时刻，最多只有一个进程的P操作<strong>不会</strong>被阻塞，从而顺利进入临界区<br>(但是还是设置一个吧，保险</p></blockquote><p><strong>分析技巧</strong><br><img src="https://img-blog.csdnimg.cn/f6a6915aa72842638bb172680c562eb1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>其实是站在缓冲区的角度看问题，而不是站在进程上看问题</p><hr><p><strong>吸烟者（单生产者-多消费者）问题</strong><br><img src="https://img-blog.csdnimg.cn/f132573e2d6149d3babb6bf3af8de72d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>再来分析一手：</p><blockquote><p>这里桌子是缓冲区，但是注意容量应该是1！桌上摆了两个东西但是不能看作是2，应该 把两个东西看做捆绑出现的一种组合！<br>所以有三种组合：纸+胶水、烟草+胶水、烟草+纸<br>互斥：<br>1.桌上只能摆放一种组合，需要互斥访问<br>同步：<br>1.桌上有组合一，那么第一个抽烟者取走<br>2.桌上有组合二，那么第二个抽烟者取走<br>3.桌上有组合三，那么第三个抽烟者取走<br>4.抽烟完毕，供应者提供下一组材料<br>另外，还需要设置一个变量来使得三个抽烟者轮流抽烟（如果是随机给材料的情况那么就不用了）<br><img src="https://img-blog.csdnimg.cn/419f972cd19f4e458d3ee9cae0f72562.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>伪代码如下（建议把P（finish）放到前面去，这样更符合表达）<br><img src="https://img-blog.csdnimg.cn/1567e0f45e6545f7a9758437d3b1ad86.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></blockquote><hr><p><strong>读写（带计数器的互斥）问题</strong><br><img src="https://img-blog.csdnimg.cn/37fb365530be4d979330926870c37547.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>这个问题我也深有体会，在CSDN写博客的时候，如果对同一个文字打开多个编辑窗口，分别写入不同的内容发布，最后以后者的内容为最终内容。</p><p>分析一手：</p><blockquote><p>由于这里出现了两种类型的进程，所以不能够再从缓冲区出发了<br>互斥：<br>1.写进程和写进程互斥<br>2.写进程和读进程互斥</p></blockquote><p><strong>初步设想</strong><br><img src="https://img-blog.csdnimg.cn/f0c564bdb77e4ac29c6db3407829c7c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"> 由于会出现无法<strong>一气呵成</strong>的情况，count还没自增就一起进去了，所以我们发现读进程之间还是得互斥的来</p><blockquote><p>（3.读进程也得先后读取，主要是先后上锁）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/c61c864004444faaad7d02e12ecc0772.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p> 但是我们还忽略了一个问题就是，写进程优先级比读进程高，那么从实际角度来说，应该是内容更新更为重要，而这种可能导致写进程<strong>饥饿（因为最后一个读进程负责解锁，所以读进程可以一直插队到写进程前)的算法</strong>不太好，所以我们进一步优化为：</p><hr><p><strong>哲学家进餐问题</strong><br><img src="https://img-blog.csdnimg.cn/f7de3e41beae4dd79345311ce27ba10f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>上述伪代码的问题是，由于异步和并发，可能出现，每个人依次拿起自己左边的筷子，然后就出现<strong>死锁</strong>，所有人都没法进行下一步于是全体尬住乐<br>所以我们还得先分析一手：</p><p><img src="https://img-blog.csdnimg.cn/ef20f104f1b2433dae0d89b50be4f980.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>互斥：<br>1.每只筷子都是临界资源，要互斥访问<br>同步：<br>1.需要组织一定的先后顺序，比如设置一个初值为4的同步信号量 或者 让每个人互斥地取筷子</p></blockquote><p><img src="https://img-blog.csdnimg.cn/4bc9cb9c203b4e5e8581d5603d85d8d9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><blockquote><p>在管程出现之前，使用信号量机制较为普遍，但是这样很容易出错<br>管程是一种特殊的软件模块，属于一种高级的同步机制，由<br>1.共享数据结构<br>2.初始化数据结构的语句<br>3.一组用来访问数据结构的过程（函数）</p></blockquote><p>如果感觉不容易理解，那么可以把管程看做是PV操作的封装，这样一来直接调用就不容易出错</p><p><strong>管程的基本特征</strong></p><blockquote><p>1.外部进程/线程只能通过管程提供的特定入口才能访问共享数据<br>2.每次仅允许一个进程在管程内执行某个内部过程</p></blockquote><p><strong>补充</strong></p><blockquote><p>各个进程必须互斥访问管程的特性，是由编译器实现的<br>可以在管程设计条件变量及等待/环形操作来解决同步问题</p></blockquote><hr><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><blockquote><p>并发环境下，各进程竞争资源而造成的一种互相等待其他进程占有的资源，导致各个进程都阻塞、都无法进一步推进的现象</p><p><strong>死锁、饥饿、死循环的区别</strong><br>先来看看各个名词的定义<br>| 名称   | 定义                                                         |<br>| —— | ———————————————————— |<br>| 死锁   | 各个进程互相等待对方手里的资源，导致各个进程阻塞、都无法推进 |<br>| 饥饿   | 由于长期得不到想要的资源，某个进程无法向前推进               |<br>| 死循环 | 某个进程一直执行，没有跳出某个循环（有时是bug，有时是有意为之） |</p></blockquote><p>再来分析一下区别<br>| 名称   | 区别（特点）                                                 |<br>| —— | ———————————————————— |<br>| 死锁   | 1.两个或者两个以上的进程<br>2.一定处于阻塞态                 |<br>| 饥饿   | 1.不限数目<br>2.可能是 阻塞态 或 就绪态                      |<br>| 死循环 | 1.不限数目<br>2.前两个是管理者（OS）的问题，死循环是被管理者的逻辑问题引发的（除非有意为之）<br>3.是运行态 |</p><hr><h3 id="死锁的发生"><a href="#死锁的发生" class="headerlink" title="死锁的发生"></a>死锁的发生</h3><p><strong>死锁的四个必要条件</strong><br>死锁发生必须<strong>同时满足</strong>四个条件：<br>| 条件       | 内容                                               |<br>| ———- | ————————————————– |<br>| 互斥条件   | 对必须互斥使用的资源的争抢会导致死锁               |<br>| 不剥夺条件 | 进程保持的资源只能主动释放，不能由其他进程强行夺走 |<br>| 请求和保持 | 保持某些资源不放的同时，请求别的资源               |<br>| 循环等待   | 存在进程资源的循环等待链                           |</p><p>这里需要注意</p><blockquote><p>死锁一定有循环等待，但是循环等待未必是死锁</p></blockquote><p>即 <strong>循环等待是死锁的必要不充分条件</strong><br>如果同类资源数大于1，即使循环等待，也未必死锁；<br>但是<strong>如果系统中每类资源都只有一个，那么循环等待就是死锁的充分必要条件了</strong></p><hr><p><strong>死锁发生的时候</strong></p><blockquote><p>概括就是<strong>资源分配不合理时就可能导致死锁</strong>，主要是以下三种情况：<br>1.对系统资源的竞争<br>2.进程推进顺序非法<br>3.信号量使用不当</p></blockquote><hr><h3 id="静态策略：死锁的预防"><a href="#静态策略：死锁的预防" class="headerlink" title="静态策略：死锁的预防"></a>静态策略：死锁的预防</h3><blockquote><p>核心思想是<strong>破坏</strong>死锁产生的四个必要<strong>条件</strong>中的一个或者几个</p></blockquote><p><strong>破坏互斥条件</strong></p><blockquote><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：<strong>SPOOLing技术</strong>。</p><p>SPOOLing技术可以把独占设备<strong>在逻辑上改造为共享设备</strong><br>这里由于涉及的硬件知识过多，所以我们不用深究该技术原理，只需要明白其过程：<br>比如进程1和进程2同时访问打印机，在使用SPOOLing之前会发生阻塞；使用该技术之后，宏观上看就不会阻塞，两个请求被“同时”接受了（或许是类似并发的技术吧）</p></blockquote><p><strong>缺点</strong></p><blockquote><p>1.并不是所有资源都能被改造为共享资源。<br>2.并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</p></blockquote><hr><p><strong>破坏不剥夺条件</strong></p><blockquote><p>我们有几种方案可供选择<br><strong>方案一</strong><br>当某个进程请求新的资源得不到满足，那<strong>使它立即释放保持的资源</strong>，待以后需要时再重新申请。<br><strong>方案二</strong><br>大概某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般要考虑各个进程的优先级。（比如剥夺调度方式，就是将处理及资源强行剥夺给优先级更高的进程使用）</p></blockquote><p><strong>缺点</strong></p><blockquote><p>1.实现起来比较复杂<br>2.释放已经获得的资源可能导致前一阶段的工作失效。因此这种方法一般只适用于容易保存和恢复的资源，比如CPU<br>3.反复地申请和释放资源会增加系统开销，降低系统吞吐量。<br>4.如果采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就需要放弃，以后再重新申请。如果一直发生这种情况，就会发生进程饥饿。</p></blockquote><p>嘶。看完第4点才意识到，原来饥饿中提到的“得不到处理”是指处理完毕！</p><hr><p><strong>破坏请求和保持</strong></p><blockquote><p>采用<strong>静态分配法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它资源未满足之前不开始运行。一旦请求完毕，这些资源一直归它所有，那么它就不会再请求资源，也就不会发生死锁。</p></blockquote><p>如果需要的资源都有，那它不争不抢（感觉也破坏了互斥条件），当然不会死锁呀~</p><p><strong>缺点</strong></p><blockquote><p>虽然简单，但是也有很明显的缺点呀：<br>1.如果整个运行期间都一直保持所有资源，就会造成严重的资源浪费而且利用率可能很低<br>2.可能导致其他进程饥饿<br>（比如有A类进程需要资源1，B类进程需要资源2，C类进程需要资源1和资源2。如果由源源不断的A或B进程，那么C就会饥饿）</p></blockquote><hr><p><strong>破坏循环等待</strong><br>说实话这个看上去很简单，但是我还是看得有点懵…</p><blockquote><p>采用<strong>顺序资源分配法</strong>，首先给系统资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完毕</p><p><strong>原理</strong><br>一个进程只有已经占有小编号的资源时，才有资格申请更大编号的资源。<br>按照这种规则，已经持有大编号的进程不可能逆向地申请小编号的资源，从而就不会产生循环等待现象。（懵逼，这说的啥看不懂啊(＃°Д°)）</p></blockquote><p><strong>缺点</strong></p><blockquote><p>1.不方便增加新的设备，因为可能需要重新分配所有编号<br>2.一个进程实际使用资源的顺序可能和编号递增顺序不一致，这样会导致资源浪费<br>3.必须按照规定次序申请资源，用户编程麻烦（(＠_＠;)这又是为啥啊）</p></blockquote><hr><h3 id="动态策略：死锁的避免"><a href="#动态策略：死锁的避免" class="headerlink" title="动态策略：死锁的避免"></a>动态策略：死锁的避免</h3><blockquote><p>用某种方法防止系统进入不安全的状态，比如<strong>银行家算法</strong></p></blockquote><p><strong>安全序列</strong><br>先看图<br><img src="https://img-blog.csdnimg.cn/38afac5b2919437f8e19e0caa96e9d75.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/21ad05f964e14c249e307ac02c5c1eab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>提炼一下：</p><blockquote><p><strong>安全序列</strong><br>如果按照这种序列分配资源，那么每个进程都能顺利完成。安全序列可能有多个<br><strong>不安全状态</strong><br>如果没有任何安全序列，那么就进入不安全状态。不安全状态可能会因为进程资源的提前归还，而重新进入安全状态<br>(死锁一定发生在不安全状态，但是不安全状态不一定死锁)<br><strong>安全状态</strong><br>在安全状态下<strong>一定不会发生死锁</strong></p></blockquote><p>上述内容可以得出<br><strong>银行家算法</strong><br>没错，这个算法又是DJ老哥提出的，一开始真的是为了解决银行贷款时避免资金不够的情况。</p><blockquote><p>在资源分配之前，预先判断这次分配是否会导致系统进入不安全状态，以此来决定是否分执行这次分配</p></blockquote><p><img src="https://img-blog.csdnimg.cn/d9858bc47b264ffca6e50bde12942367.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/6e712da2bdb24746bbd555e174ca98ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>此后继续检测（不检测已经加入安全序列的进程）<br>通俗地说就是，如果它我分配了之后它能够顺利完成，它就会归还——那就分配，然后把它加入安全序列，之后继续。<br>（类似贪心？)<br>考试中用笔算，注意技巧：如果现有资源可以分别满足几个进程，那么直接把它们全部扔进安全序列（反正可以先后完成）</p><p>至于计算机怎么实现…这个对于数学不好的人（比如我）简直劝退<br>这一部分有兴趣了解一下就行…<br><img src="https://img-blog.csdnimg.cn/cfd1bf0d37864a0f8df0133530918641.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><blockquote><p>允许死锁发生，不过操作系统会检测出死锁，然后采取某种措施解除死锁</p></blockquote><p>当然，这是 死锁预防措施 或 死锁避免措施 没有被系统启用（或者失效了)的情况下的处理方式</p><p><strong>两个算法</strong></p><p> <strong>1.死锁检测算法</strong></p><blockquote><p>用于检测系统状态，以确定系统中是否发生了死锁<br><strong>方式</strong><br>1.用某种数据结构(<strong>资源分配图</strong>)来保存资源的请求和分配信息<br>2.提供一种算法，利用上述信息来检测系统是否进入了死锁</p></blockquote><p><img src="https://img-blog.csdnimg.cn/6cc1da3f54714a16977d0674a5eda755.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>（注意，分配边表示<strong>已经</strong>分配了多少）<br>对于上图中P1 P2 R1 R2构成的资源分配图<br>首先看P1，因为P1的请求可以满足，那么和P1相连的边可以全部移除<br>然后看P2，也是同理，与之相连的边可以全部移除<br>这样一来所有的边都被移除了，这种资源分配图就是<strong>可完全简化的</strong>，这说明这是安全的，没有发生死锁；否则就是<strong>已经发生了死锁</strong>，而最终还有相连边的进程就是<strong>发生死锁的进程</strong></p><p>其实上述内容就是<br><strong>死锁定理</strong></p><blockquote><p>如果某时刻资源分配图是不可完全简化的，那么此时系统处于死锁</p></blockquote><p>(比如来看一个死锁的情况)<br><img src="https://img-blog.csdnimg.cn/e2ff05e67b6849d4a33baa8b3d3cc3c1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p> <strong>2.死锁解除算法</strong></p><blockquote><p>发生死锁时，解除死锁。有几种方法：<br><strong>1.资源剥夺法</strong><br>挂起某些死锁进程，抢占其资源，并且将其资源分配给其他资源。但是要防止被挂起的进程发生饥饿。<br><strong>2.撤销进程法</strong><br>也叫<strong>终止进程法</strong>。强制撤销部分甚至全部死锁进程，并剥夺这些进程的资源。（这种方式简单粗暴，但是代价可能巨大，比如一个进程运行很久已经快结束了结构又被撤销直接白干了）<br><strong>3.进程回退法</strong><br>让一个或多个死锁进程回退到足以避免死锁的地步<br>（这需要系统记录进程的历史信息，设置还原点）</p></blockquote><p>有了方法，现在还要讨论对哪个进程出手<br>我们一般从一下几个方面进行考虑：</p><blockquote><p>1.进程优先级（干掉优先级低的）<br>2.已经执行时间（干掉执行时间少的）<br>3.剩余执行时间（干掉剩余时间多的）（和上面那个有点矛盾）<br>4.已经使用多少资源（先干掉资源用的多的）<br>5.交互式进程还是批处理式进程（先干掉批处理进程，让用户感受好些）<br>…..</p></blockquote><h2 id="存储与查询"><a href="#存储与查询" class="headerlink" title="存储与查询"></a>存储与查询</h2><h3 id="内存基础知识"><a href="#内存基础知识" class="headerlink" title="内存基础知识"></a>内存基础知识</h3><blockquote><p>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</p></blockquote><p><strong>内存单元</strong><br>即每一个内存地址对应的存储空间，至于存储空间的大小，分两种情况：<br><strong>1.按字节编址</strong></p><blockquote><p>每个内存单元大小为1字节（byte，b）</p></blockquote><p><strong>2.按字长编址</strong></p><blockquote><p>每个内存单元大小为1字（每个字大小是2字节)</p></blockquote><p><strong>冷知识</strong><br>1K  = 2^10<br>1M = 2^20,<br>1G = 2^30 </p><p>所以4G内存表示，内存中可以存储4<em>2^30字节——如果是按字节编址，也就有4</em>20^30个地址，即2^32个地址</p><hr><p> <strong>逻辑地址 与 物理地址</strong><br>其实就相当于直接路径和相对路径这样的，很好理解<br>比如实际的地址（物理地址）是666，把666当成0，那么667就是1</p><hr><p><strong>编辑、编译、链接 和 装入</strong></p><blockquote><p>编辑：高级语言写代码<br>编译：高级语言编译为(机器语言)多个目标模块，分散在多个逻辑地址段中<br>链接：多个模块组装成一个<strong>装入模块</strong>，有一个完整的<strong>逻辑地址</strong>段<br>装入：把装入模块装入内存中，有完整的物理地址</p></blockquote><hr><h3 id="三种装入-与-三种链接"><a href="#三种装入-与-三种链接" class="headerlink" title="三种装入 与 三种链接"></a>三种装入 与 三种链接</h3><p>首先是三种装入：<br><strong>绝对装入</strong></p><blockquote><p><strong>在编译时</strong>，如果知道程序放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。<br><strong>概述为：编译时产生绝对地址</strong></p></blockquote><p>比如你知道大小为装入模块要从物理地址为100的地方开始存放，那就直接装入100</p><p>只适用于<strong>单道程序环境</strong>，且通常是编译或汇编环节给出绝对地址(其实也可以由程序给)</p><hr><p><strong>静态重定位</strong></p><blockquote><p>又称<strong>可重定位装入</strong>，装入模块中的地址是逻辑地址，直至真正装入时逻辑地址换为物理地址。程序运行期间无法移动。<br><strong>概述为：装入时将逻辑地址转为物理地址。</strong></p></blockquote><p><strong>这是早期多道批处理操作系统采用的</strong></p><hr><p><strong>动态重定位</strong></p><blockquote><p>又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的逻辑地址都是从0开始的。装入程序（负责把装入模块装入的程序)把装入模块装入内存之后，并不会把逻辑地址转为物理地址，而是把地址转换推迟到<strong>程序真正要执行时</strong>才进行。因此，装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持（进行的操作是物理地址+目标逻辑地址）。<br><strong>概述为：运行时将逻辑地址转为物理地址</strong></p></blockquote><p>通过重定位寄存器，可以将程序分配到不连续的内存中（意思是每段只有部分的程序代码，这也是<strong>虚拟</strong>的体现，这样使用户能够使用一个比存储空间大得多的地址空间）<br><strong>这也是现代操作系统普遍采用的</strong></p><hr><p>再来看看三种链接：</p><p><strong>静态链接</strong></p><blockquote><p>在程序运行之前，将各目标模块及它们所需要的库函数连接成一个完整的可执行文件(也就是装入模块)，之后不再拆分。</p></blockquote><hr><p><strong>装入时动态链接</strong></p><blockquote><p>将各目标模块装入内存时，边装入边链接。</p></blockquote><hr><p><strong>运行时动态链接</strong></p><blockquote><p>在程序执行中需要该目标模块时，才对他进行链接。其优点时便于修改和更新，便于实现对目标模块的共享。</p></blockquote><hr><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><blockquote><p>管理内容大概分为以下3个方面：<br>1.内存空间的分配与回收<br>2.从逻辑上对内存空间进行扩充<br>3.地址转换（逻辑地址和物理地址的转换)<br>4.内存保护</p></blockquote><hr><p>专门说一下</p><p><strong>内存保护</strong></p><blockquote><p>只允许各个进程访问自己拥有的内存，保证各个进程互不干扰</p></blockquote><p><strong>方式一</strong></p><blockquote><p>cpu中有上下限寄存器，存放进程的上下限地址，进程访问地址时，cpu据此检测是否越界</p></blockquote><p><strong>方式二</strong></p><blockquote><p>采用<strong>重定位寄存器（也叫基址寄存器）</strong> 和  <strong>界地址寄存器（也叫限长寄存器）</strong>，分别存放<strong>起始物理地址</strong>和<strong>最大逻辑地址</strong>，同样检测是否越界</p></blockquote><h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><blockquote><p>早期计算机额内存很小，比如IBM的第一台PC机器，最大就1MB内存。所以得想办法解决一下内存过小从而导致程序无法顺利运行的情况——<strong>覆盖技术</strong>因此诞生</p></blockquote><p><strong>覆盖</strong></p><blockquote><p>思想是<strong>将程序分为多个段（多个模块)</strong><br>常用的段常驻内存，不常用的段在需要时调入内存</p></blockquote><p>这样就使得1mb的内存可以运行2mb甚至更大程序！</p><p>这其中，内存被划分为两个区域<br>| 区域名称 | 数量   | 简介                                             |<br>| ——– | —— | ———————————————— |<br>| 固定区   | 1个    | 常驻内存的段就被放入这里，在运行结束之前不会调出 |<br>| 覆盖区   | 若干个 | 选取可能放入这个区域中最大的段的内存             |</p><p><img src="https://img-blog.csdnimg.cn/b4ec013df1844f488b5a7cdc4e8293e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>橙色是常驻区，BC是不会被同时调用的两个段，分别是D、EF的前驱</p><p>这种技术</p><blockquote><p>优点：由程序员声明覆盖结构，操作系统自动完成覆盖<br>缺点：对用户不透明，增加了编程负担</p></blockquote><hr><p><strong>交换技术</strong></p><blockquote><p>思想是内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某系已经具备运行条件的进程换入内存（进程在内存与外存间动态调度)</p></blockquote><p>没错，就是<strong>挂起与就绪之间的转换</strong>的<strong>中级调度（内存调度）</strong></p><p><strong>1.至于如何交换呢？</strong></p><blockquote><p>一般来说，具有交换功能的操作系统中，通常把磁盘空间分为 <strong>文件区</strong> 和 <strong>对换区</strong>两个部分。<br>文件区主要用于存放文件，追求存储空间的利用率，因此对文件区的空间管理采用<strong>离散匹配方式</strong>；<br>对换区只占很小的空间，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此通常对换区采用<strong>连续分配方式</strong>。<br>（总之，对换区的I/O速度比文件区要快）</p></blockquote><p><strong>2.那么什么时候发生交换？</strong></p><blockquote><p>交换通常在内存紧张时进行，在内存充裕时暂停。比如在许多进程运行时发生缺页，就说明内存紧张，此时可以换出一些进程。</p></blockquote><p><strong>3.换出哪些进程？</strong></p><blockquote><p>优先换出阻塞进程。可以换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。（注意PCB常驻内存）</p></blockquote><hr><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>由于时间紧迫，这里开始先水一点了，后面再细细地补上</p><p><strong>连续分配</strong></p><blockquote><p>指为用户进程分配一个连续的内存空间</p></blockquote><hr><p><strong>固定分区分配</strong></p><blockquote><p>把整个内存的用户区域（对换区）分为n个大小固定的分区</p></blockquote><hr><p><strong>动态分区分配</strong></p><blockquote><p>动态分区分配又称为可变分区分配，在进程装入内存时，根据进程动态地建立分区</p></blockquote><p><strong>动态分区分配算法</strong><br>这个算法是为了解决一个问题：在动态分配过程中，当很多歌空闲分区都能满足需求时，应该选择哪个分区进行分配？</p><p>这里举例四种动态分区分配算法：<br><strong>1.首次适应算法</strong></p><blockquote><p>每次从低地址开始查找，找到第一个满足的空闲分区<br>查找方式是通过空闲分区链或者空闲分区表来查找的(其实就是空闲的内存的首地址和大小等信息会以顺序或者链式存储，可以据此遍历）</p></blockquote><p><strong>2.最佳适应算法</strong></p><blockquote><p>和首次适应算法类似，不过存储空闲分区地址的数据结构将以<strong>递增</strong>的形式存储，所以空间越大的分区排在越后面</p></blockquote><p>这样一来每次都能找到大小最接近的，使得内存利用率很高<br>可是问题也很明显，每次使用，都可能会留下非常小的空间（比如10mb的程序占用了11mb内存，空闲的1mb难以利用），这种空间叫做<strong>内部碎片</strong><br>内部碎片多了之后，利用率又下来了</p><p><strong>3.最坏适应算法</strong></p><blockquote><p>和最佳适应算法相反，最坏适应算法存储是<strong>递减</strong>的</p></blockquote><p>主要是想着防止小碎片产生，那我就每次用最大的空间不就好了？（10mb程序占用100mb内存，还有90mb这不是很容易用出去吗）</p><p>但是问题是，可能导致后面来的大进程没有空间<br><strong>4.邻近适应算法</strong></p><blockquote><p>递增存储并且是环形结构，每次查找从上一次查找结束的位置开始继续查找</p></blockquote><h3 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h3><blockquote><p>上一节中提到的算法，虽然各有千秋，但是无一例外地都可能产生碎片<br>（虽然可以使用<strong>紧凑技术</strong>来解决碎片问题，但是其时间开销太大）</p></blockquote><p>所以出现了<strong>基本分页存储管理</strong></p><blockquote><p>就是把内存分为一个个大小相等的小分区，再按照分区大小把进程拆分为一个个小部分<br><strong>每一个分区就是一个“页框”</strong>，或者叫“页帧”、“内存块”、“物理块”，每个页框都有一个编号，即“页框号”（或者叫“内存块号”之类的），从0开始</p></blockquote><p>tips：内存可能不能整除页框大小，所以最后一个页面可能没有一个页框那么大，因此页框不能太大，否则可能产生较大的内部碎片</p><p><strong>装入</strong><br>类似于一个程序的链接装入过程<br><img src="https://img-blog.csdnimg.cn/3ffe3e28e17c4ceb91cdbc873529da8f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>其中涉及到一些关于 <strong>页号</strong> 和 <strong>页内偏移量</strong>的计算</p><blockquote><p>页号 = 逻辑地址 / 页面长度<br>页内偏移量 = 逻辑地址 % 页面长度</p></blockquote><p>另外，为了方便计算页号、页内偏移量，页面大小一般用2的整数幂</p><hr><p><strong>页表</strong><br>为了能够知道进程中每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表<br><img src="https://img-blog.csdnimg.cn/9017ebfe3cf34f45a928e5e96e46093b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>（完了卧槽啊，吃个饭回来发现电脑重启了，一下午的笔记就没了，7k字一个字一个字码上去的啊，淦哦，缺失的内容先简单写一下了，心态有点炸）</p><p><strong>基本概念</strong></p><blockquote><p>核心思想是把进程分成很多大小相等的段，内存也分为与进程等大的段，然后前者叫做页面，后者叫页框，它们之间的对应关系用页表来存，页表也放在页框中</p><p>1.页面：简称页，也就是进程的分段<br>2.页框：大小和页面相同，也叫内存块的（有一堆名字），是内存的分段<br>3.页表：记录了页面和页框的对应关系，其中每一项叫做页表项<br>4.页号：页表中某个页面的编号，其值为 <strong>逻辑地址 / 页面大小</strong><br>5.页面偏移量：即 <strong>逻辑地址位数 % 页面大小</strong>（页面长度）的值<br>6.<strong>逻辑地址构成 = 页号 + 页内偏移量</strong><br>（比如30位的逻辑地址 = 10位页号 + 20位页内偏移量;<br>如果有m位页号，那么说明一个进程中最多有m个页面；<br>如果有k位页内偏移量，那么一个页面的大小是2^k^个内存单元）<br>7.页面大小：就是一个页面的大小，是2的整数幂</p></blockquote><hr><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p><strong>基本地址变换机构</strong></p><blockquote><p>基本地址变换机构通过页表将逻辑地址转为物理地址<br>通常会在系统中设置一个<strong>页表寄存器（PTR）</strong>，存放在内存中的<strong>起始地址F</strong>和<strong>页表长度M</strong>。地址变换的过程如下：<br>1.进程未执行时，页表的  起始地址F 和  页表长度M 放在进程控制块PCB中，当进程被调度时候，操作系统内核将F和M放到寄存器中<br>2.根据页表中记录的逻辑地址计算出 <strong>页号</strong> 和 <strong>页内偏移量</strong><br>3.与PTR里面的数据进行比较，如果页号<strong>大于等于</strong>页表长度，那么发生越界，内中断；如果小于，那么判定合法，进入下一步。<br>4.根据页号查询页表，找到对应的页框号<br>5.用页框号和页内偏移量得到物理地址<br>6.访问目标单元</p></blockquote><p>这个过程中，<strong>访问了两次内存</strong><br>（访问内存开销比较大，所以减少访问内存的次数可能会得到优化）</p><hr><p><strong>带有快表的地址变换机构</strong></p><p><strong>局部性原理</strong><br>先看如下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">{</span>arr<span class="token punctuation">[</span>i <span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>时间局部性</strong><br>如果执行了程序中某条指令，那么不久后这条指令可能被再次执行；<br>如果某个数据被访问过，那么不久后该数据可能再次被访问；<br><strong>空间局部性</strong><br>如果某个存储单元被访问，那么不久之后其附近的存储单元也可能被访问。（比如很多具有连续存储这一性质的数据）<br><strong>至于为什么叫局部</strong><br>我个人的理解是，限制在某一个时间段，限制在某一个空间内，这就是局部。<br><strong>有什么意义</strong><br>其实上述内容暗示我们，一个较短的时间段内，进程只有一部分被访问了。这就说明我们每次只需要访问一部分就能运行一个进程，那么就没有必要一次性存储全部的内容。</p></blockquote><p>我们上面提到过，访问内存开销大，那么我们尽量减少访问内存的次数。<br>这样重复的访问内存，却只是找同样的东西，那么我们能不能把这个东西保存到内存外面，下次访问就不需要从内存里面找了？</p><p><strong>快表</strong></p><blockquote><p>又称<strong>联想寄存器（TLB） 或者 地址变换高速缓存</strong>，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问过（当前指的是当前运行的进程）的若干页表。<br>与之对应的<strong>慢表</strong>通常指的是内存中的页表</p></blockquote><p>在加入快表后，地址变换过程变为：<br><strong>（黑色斜体字表示新加入的步骤）</strong></p><blockquote><p>1.进程未执行时，页表的  起始地址F 和  页表长度M 放在进程控制块PCB中，当进程被调度时候，操作系统内核将F和M放到寄存器中<br>2.根据页表中记录的逻辑地址计算出 <strong>页号</strong> 和 <strong>页内偏移量</strong><br>3.与PTR里面的数据进行比较，如果页号<strong>大于等于</strong>页表长度，那么发生越界，内中断；如果小于，那么判定合法，进入下一步。<br><em><strong>3.查询快表，如果查询成功（命中），就进入第5步；失败则进入第4步</strong></em><br>4.根据页号查询页表，找到对应的页框号，<em><strong>并把该页表项中的页号和页框号放入快表中</strong></em><br>5.用页框号和页内偏移量得到物理地址<br>6.访问目标单元</p></blockquote><p>上述过程中，如果第3步命中，那么地址变换就只需要访问一次内存<br>可以根据以下例题感受效率的变化<br><img src="https://img-blog.csdnimg.cn/dbec1330a0bc457b860dd742beb9241e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>tips：<br>至于第3步为什么会有<strong>查询失败</strong>的情况，有两种可能：</p><blockquote><p>1.第一次访问某个页号，快表中没有存储（快表一开始是空的）<br>2.快表满了，装不下全部数据，所以就出现访问过也查找失败的情况（因为快表造价要贵点，空间比较小。不）（然要主存干啥，干脆全用快表了）</p></blockquote><hr><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>其实主要还是二级页表….多级同理…</p><p><strong>单级页表存在的问题</strong><br>首先看一个计算<br><img src="https://img-blog.csdnimg.cn/2532254450104700b1a82f52e115f05b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>首先是告诉我们这个系统支持32位逻辑地址，然后页面大小是4KB = 2^12^位，结合前面的知识（逻辑地址位数 = 页面大小位数 +<br>页号位数）,我们知道<strong>页号位数 = 32 - 12 = 20位</strong>，<br>然后页号就是页面的编号嘛，所以有2^20^个页面，一个页面在页表中都有一个对应的页表项，那么就有2^20^个页表项，题目告知一个页表项大小为4B，那么整个页表的大小就是2^22^B。<br>这时候，不要忘了页框和页面等大，所以一个页框也是4KB = 2^12^B，于是乎，页框个数就是 <strong>2^22^/ 2^12^ =<br>2^10^个</strong> ，也就意味着，要分配1024个连续的页框来存储页表，这将是不小的开销</p></blockquote><p>所以存在两个问题：<br>1.页表必须连续存放，当页表很大时，存放起来比较困难（最起码开销很大吧）<br>2.由于存在局部性原理，所以让整个页表常驻内存并不明智</p><p>为了解决问题1，大佬们提出<br><strong>二级页表</strong></p><blockquote><p>将页表分组，使得每一个内存块正好可以放入一个分组（比如页面大小4KB，页表项4B，每个页框可以存放1K个页表项，所以每1K个页表项分为一组，然后离散地存入各个页框）<br>此后，为了记录这些离散存储的页表组，我们再建一张页表，称为<strong>页目录表，或者外层页表、顶层页表</strong>等等</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2939689873d1496ea6f392f42572d470.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>需要注意的几个细节：<br><img src="https://img-blog.csdnimg.cn/a009ca69fdd146d193e6d5b65a6b7c6d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>让我鹦鹉学舌来一手（主要是为了巩固，加深印象）</p><blockquote><p>40位逻辑地址就是2^40^B，而一个页面是4KB = 2^12^B，那么可以容纳2^28^个页面，也就是有2^28^个页号，因为按字节编制，所以页号有28位。<br>页面和页框等大，都是2^12^B，一个页表项是4B，那么一个页面可以容纳2^10^个页表项，因此一个页表项对应的页号是10位。<br>由于<strong>各级页表的大小不能超过一个页面的容量</strong>，所以一级最大就是10位，那么对于28位的页号来说就是10 + 10 + 8三级页表才能完成存储</p></blockquote><p>但是n级页表的缺陷也很明显：<br>（不考虑快表）需要访问n+1次内存</p><hr><p>至于问题2，后面细说，这里先大概了解</p><blockquote><p>大佬们提出了虚拟存储技术，就是在内存只放一部分，然后访问的时候如果内存中没有那么就产生缺页中断（内中断），从外存中调进来就可以了</p></blockquote><h3 id="分段存储"><a href="#分段存储" class="headerlink" title="分段存储"></a>分段存储</h3><blockquote><p>与分页存储的最大区别就是离散分配时，所分配的地址空间的基本单位不同：<br>进程的地址空间指的是，按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址。<br><strong>段成为内存分配的单位</strong>，每个段在内存中占据连续的空间，但是<strong>各段之间可以不相邻</strong>。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/336dcb1cdd7346cdbad992866805e425.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>段名会在编译过程中被处理为段号</p><h3 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h3><p><strong>分页分段的优缺点</strong></p><table><thead><tr><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页管理</td><td>内存利用率高，没有外部碎片，几乎没有页内碎片（很少）</td><td>不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td>分段管理</td><td>很方便按照逻辑模块实现信息的共享和保护</td><td>如果段长过大，为其分配连续的内存空间不方便，另外也可能产生较多外部碎片</td></tr></tbody></table><p><strong>段页式的具体过程</strong></p><blockquote><p>段页式便是段和页的结合<br>是先分段，分成大大小小不同的段，然后再装进一样大小的页框中</p><p><img src="https://img-blog.csdnimg.cn/0db198d7e86c4c3fa5f286ac9c16823b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统段页式管理中分段分块"></p></blockquote><p>（仔细一想，这不应该是产生了更多没有利用的内存空间吗，不过考试迫在眉睫，暂时先背着吧）</p><p>之后的对应关系大概是<br><img src="https://img-blog.csdnimg.cn/be8a44faa43e40908d76887ff54a13c3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统段页式管理离散匹配"></p><blockquote><p>段页式管理中，一个进程可以对应<strong>一个段表</strong>，这个段表又对应了<strong>多个页表</strong>（即一个段表项对应了一个页表）<br>注意这里的段表，其每个段表项是等长的，短号是隐含的（不记录，默认从0开始升序），<br>记录了页表长度和页表存放的块号</p></blockquote><blockquote><p>至于进程分段后是怎么确定在内存中的位置这件事情：<br>0.先把<strong>段表始址F</strong>和<strong>段表长度M</strong>存放到段表寄存器中<br>1.根据逻辑地址得到<strong>段号S</strong>、<strong>页号P</strong>、页内<strong>偏移量W</strong><br>2.判断是否越界：如果段号S&gt;=偏移量M那么产生越界，中断；否则进行下一步<br>3.查询页表，找到对应的段表项，段表项的存放地址为F+S*段表项长度<br>4.判断是否越界，若页号&gt;=页表长度，中断；否则进行下一步<br>5.根据页表存放块号、页号查询页表，找到对应页表项<br>6.根据内存块号页内偏移量得到最终物理地址<br>7.访问目标内存单元</p></blockquote><p><img src="https://img-blog.csdnimg.cn/784b552e912e4e34885c43f2869ee095.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统段页式访问内存的过程"></p><p>上述过程会访问三次内存（访问段表、页表、最终目标内存）</p><p>当然如果引入<strong>快表</strong>，那么可能只需要一次访问</p><h2 id="虚拟内存及相关存储管理方式"><a href="#虚拟内存及相关存储管理方式" class="headerlink" title="虚拟内存及相关存储管理方式"></a>虚拟内存及相关存储管理方式</h2><h3 id="虚拟内存概述"><a href="#虚拟内存概述" class="headerlink" title="虚拟内存概述"></a>虚拟内存概述</h3><p><strong>传统内存</strong></p><blockquote><p>即之前提到的连续分配和非连续分配内存的方式。<br>很多暂时用不到的数据也会长期占用内存，导致内存利用率不高。<br>其特征如下：<br><strong>一次性</strong>：作业必须一次性全部装入内存后才能开始运行<br>这就造成了两个问题：<br>（<br>1.作业很大时，不能全部装入内存，大量作业无法运行；<br>2.大量作业运行时，由于内存无法容纳所有作业，只有少量作业能运行，导致多道程序并发度下降<br>）<br><strong>驻留性</strong>：一旦作业被装入内存，就会一直驻留在内存中，直到作业运行结束。<br>（事实上，在一个时间段内，只要访问作业的一小部分数据即可正常运行，导致了大量内存空间浪费）</p></blockquote><p><strong>虚拟内存的原理</strong></p><p>上一篇提到过<strong>局部性原理</strong>，还有<strong>时空局部性</strong><br>虚拟内存就是利用了（理论上的原理）空间的局部性原理实现的<strong>空分复用术</strong>，其技术上的原理是<strong>高速缓冲技术</strong></p><blockquote><p>高速缓冲技术的思想是将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放到更低速的存储器中<br>（存储器速度：寄存器&gt;cache(高速缓存)&gt;内存&gt;外存）</p></blockquote><p><strong>虚拟内存的具体体现</strong></p><blockquote><p>比如，程序执行过程中，访问的信息不在内存中时，由操作系统负责将所需要的信息从外存调入内存，然后继续执行程序<br>如果内存空间不够，那么就把暂时用不到的信息调到外存<br>在操作系统的管理下，在用户看来似乎有一个比实际内存大的多的内存，这就是<strong>虚拟内存</strong></p></blockquote><p><strong>虚拟内存三大特性</strong><br>（就是单纯想总结一下，不要求掌握）<br>| 名称   | 内容                                                         |<br>| —— | ———————————————————— |<br>| 多次性 | 无需作业运行时一次性全部装入内存，而是允许被分为多次调入内存 |<br>| 对换性 | 在作业运行时，无需一直常驻，而是在作业运行的过程中，将作业换入换出（请求调页 + 页面置换） |<br>| 虚拟性 | 从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量 |</p><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><p> <strong>与 基本分页管理 的主要区别：</strong></p><blockquote><p>在程序执行过程中，当所<strong>访问的信息不在内存时</strong>，由操作系统负责将<strong>所需要的信息从外存调入内存</strong>，然后继续执行程序<br>若内存空间不够，由操作系统将<strong>内存中暂时用不到的信息换出外存</strong></p></blockquote><p>为了更好的实现调入调出，请求分页存储管理的页表增加了四个字段：<br><img src="https://img-blog.csdnimg.cn/5f3b5dd82d1748eca44ca2cde6997bc7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_请求分页存储管理的页表"></p><table><thead><tr><th>新增字段</th><th>作用</th></tr></thead><tbody><tr><td>状态位</td><td>是否已经调入内存</td></tr><tr><td>访问字段</td><td>可记录最近被访问过几次，或者记录上次访问的时间，供置换算法选择换出页面时参考</td></tr><tr><td>修改位</td><td>页面调入内存后是否被修改过</td></tr><tr><td>外存地址</td><td>页面在外存中的存放位置</td></tr></tbody></table><p>和基本分页存储管理<strong>不同之处</strong><br><strong>请求调页</strong><br>如果访问页面不在内存中，那么就产生一个<strong>缺页中断</strong>（属于内中断），然后由操作系统的缺页中断处理程序处理中断，此时缺页的进程阻塞，被放入阻塞队列末尾，调页完成后再被唤醒加入就绪队列。</p><p><strong>页面置换</strong><br>如果内存不够，则会根据<strong>页面置换算法</strong>淘汰页面，若该页面在内存时期被修改过，那么还得将其在外存中的内容同步修改（写回外存）；未修改则不用写回；<br>具体过程是：<br>请求调页、页面置换、需要请求页表中新增的表项</p><p><strong>引入快表</strong><br>同样地，又是需要多次访问内存，所以我们就容易想到快表</p><p><img src="https://img-blog.csdnimg.cn/2ec9fb40089646ca9091459b2b41e08b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_具有快表的请求分页管理"></p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>这里时间有些紧迫，所以长话短说，暂时先不举出例子了<br><strong>OPT最佳置换算法</strong></p><blockquote><p>每次选择淘汰<strong>不再使用 或 以后最长时间不使用</strong>的页面</p></blockquote><p>这是最优的算法，但是<strong>无法实现</strong>，因为无法预知未来</p><hr><p><strong>FIFO先进先出置换算法</strong></p><blockquote><p>淘汰最先到达的页面</p></blockquote><hr><p><strong>LRU最近最久未使用置换算法</strong></p><blockquote><p>利用访问字段记录上次自上次使用后经历的时间，据此淘汰目前最长时间未使用的页面。需要硬件支持才能实现。<br>该算法是最性能最接近OPT的</p></blockquote><p>乍一想好像和FIFO一样，我对此只能说，<br><em>想的好，下次不许想了</em><br>验证过了，有些时候结果不一样，所以别想了，先背着要考了<br><strong>手写做题的时候，可以倒过来找，当前的几个页面里最后出现的就是淘汰的</strong></p><hr><p><strong>CLOCK时钟置换算法</strong></p><blockquote><p>也叫<strong>NRU最近未使用算法</strong>，或者<strong>第二次机会算法</strong><br>页面访问字段为1表示最近访问过，0反之；<br>循环扫描当前几个页面，修改访问字段，如果是1就改为0，如果是0那就淘汰当前页面，循环结束</p></blockquote><p>也就是最多循环两次</p><p>这个算法性能是很好的，虽然次于OPT和LRU，但是实现难度相对小，均衡</p><hr><p><strong>改进的CLOCK时钟置换算法</strong></p><blockquote><p>简单的CLOCK时钟置换只考虑页面最近是否被访问，但是没考虑最近是否被修改（因为只有被修改过的页面才有必要调出内存、写回外存）<br>改进就是，其他条件相同的时候，优先淘汰没有被修改的页面（利用修改位判断是否被修改过）</p></blockquote><p>这个至多访问四轮：</p><blockquote><p>第一轮是找<strong>最近没使用的、且 没有 修改过的</strong>，这一轮不会修改访问位，如果没找到：<br>第二轮就查找<strong>最近没使用的、且修改过的</strong>，这一轮要是再失败，就把所有扫描到的访问位置为0——表示没使用过<br>第三轮就重复第一轮的过程，如果还失败，（就再来一轮） 第四轮就重复第二轮的过程，由于第二轮的修改，那这次一定会找到</p></blockquote><hr><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><p><strong>驻留集</strong></p><blockquote><p>指请求分页存储管理中给进程分配的物理块（内存块）的集合，在虚拟存储技术中，驻留集一般小于进程的总大小</p></blockquote><p>驻留集大小过大，并发度下降，资源利用率低下<br>驻留集过小，系统大量时间用于处理缺页，进程推进的实际时间太小</p><hr><p><strong>页面分配、置换策略</strong><br>分配</p><blockquote><p><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不在改变。即，驻留集大小不变。<br><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可以根据情况做适当的增加或减少。即，驻留集大小改变。</p><p>置换</p></blockquote><blockquote><p><strong>局部置换</strong>：发生缺页时，只能选进程自己的物理块进行置换<br><strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存</p></blockquote><p>组合起来：</p><p><strong>可变分配全局置换</strong>：刚开始会为每个进程分配一定数量的物理块，当某天进程发生缺页的时候<br><strong>可变分配局部置换</strong>：根据发生缺页的频率来动态地增加或减少进程的物理块</p><hr><p><strong>调入页面的时机 及 从何处调入</strong></p><p><strong>调入时机</strong></p><blockquote><p>1.<strong>预调页策略</strong>：根据局部性原理，一次性调入若干个相邻的页面比一次性调入一个页面更高效，但是如果提前调入的页面中有大多数都不被访问，则又是低效的。<br>这种策略需要程序员指出应该先调入哪些部分。<br>2.<strong>请求调页策略</strong>：进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都因I/O操作而有较大的开销</p></blockquote><p><strong>从外存的何处调入内存</strong><br><strong>外存</strong>有对换区和文件区，<br>对换区I/O操作速度快，采用连续分配方式；<br>文件区I/O操作速度慢，采用离散分配方式；</p><blockquote><p>1.系统对换存空间足够： 页面调入调出都是在<strong>内存和对换区</strong>之间进行的（进程运行前，将进程相关数据复制到对换区）</p></blockquote><blockquote><p>2.系统对换区空间不足： 凡是不会被修改的数据都会直接从文件区调入内存，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。</p></blockquote><hr><p><strong>抖动现象</strong></p><blockquote><p>页面在内外间过于频繁的切换。（一般是发生在进程频繁访问的<strong>页面数目高于可用的内存块数</strong>）</p></blockquote><p><strong>工作集</strong></p><blockquote><p>指在某段时间间隔里，<strong>进程实际访问页面</strong>的集合</p></blockquote><p><img src="https://img-blog.csdnimg.cn/656565ffeaca46b19c568871db11bebd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统工作集示例"></p><p>一般来说，驻留集大小不能小于工作集大小，否则容易<strong>抖动</strong></p><h2 id="文件管理（待补充）"><a href="#文件管理（待补充）" class="headerlink" title="文件管理（待补充）"></a>文件管理（待补充）</h2><p>这部分咱学校考试考得稍微少点，所以这部分先水过，后面有空再回来补上</p><h3 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h3><blockquote><p>类似数据结构，逻辑结构指的从用户的视角看的结果<br>分为两大类：无结构文件 和 有结构文件</p></blockquote><hr><p><strong>无结构文件</strong><br>文件内部的数据就是一系列二进制流或字符流组成。又称“<strong>流式文件</strong>”。如：windows操作系统中的txt文件。</p><hr><p><strong>有结构文件</strong><br>由一组相似的记录组成，又称“<strong>记录式文件</strong>”。每条记录又由若干个数据项组成，又可以分为“<strong>可变长记录</strong>”和“<strong>定长记录</strong>”。如：数据库表文件。一般来说，每条记录有一个数据项可作为关键字（主码/主键）</p><p>我们重点讨论的就是有结构文件，它又有三种：<br><strong>顺序文件</strong>、<strong>索引文件</strong>、<strong>索引顺序文件</strong></p><p><strong>顺序文件</strong></p><blockquote><p>（逻辑上的顺序）类似线性表，（物理上的存储结构）即链表和数组；(考试通常是数组)</p></blockquote><p>其结构可以分为<br>串结构：记录之间的顺序与关键字无关；<br>顺序结构：记录之间的顺序按关键字顺序排列；</p><hr><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><strong>文件控制块</strong></p><blockquote><p>FCB，类似进程控制块，这是实现文件目录的关键数据结构<br>FCB中包含了文件的<br>基本信息（文件名、物理地址、逻辑结构、物理结构）<br>存取控制信息（是否可读/可写、禁止访问的用户名单）<br>使用信息（如文件的建立时间、修改时间）</p></blockquote><p>由于目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该目录下的文件，这些记录项也正是FCB。<br><strong>FCB实现了文件名和文件之间的映射，使用户可以实现“按名存取”</strong><br>以及以下四种操作：<br>| 操作     | 具体内容                                                   |<br>| ——– | ———————————————————- |<br>| 搜索     | 当用户使用一个文件时，系统要根据文件名搜索目录             |<br>| 创建文件 | 创建一个文件时，需要在其所属的目录中增加一个目录项         |<br>| 删除文件 | 当删除一个文件时，需要在目录中删除相应的目录项             |<br>| 显示目录 | 用户可以请求显示目录的内容，如显示该目录中的所有文件及属性 |</p><hr><p><strong>单级目录结构</strong></p><blockquote><p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项</p></blockquote><p>单级目录实现了“按名存取”，但是不允许文件重名<br>所以建立一个新的文件时，要先优先查看有无重名文件。</p><hr><p><strong>两级目录结构</strong></p><blockquote><p>早期的多用户操作系统，采用两级目录结构。分为<strong>主文件目录</strong>（MFD）和<strong>用户文件目录</strong>（UFD）</p></blockquote><p>其实就是允许建文件夹了（但是不能在文件夹建文件夹）</p><hr><p><strong>多级目录结构</strong></p><blockquote><p>也叫<strong>树型目录结构</strong></p></blockquote><p>也就是现在大家常见的这种，文件夹可以进行套娃<br>每访问一层，都要进行一次读磁盘的I/O操作</p><p>从这里开始引入<strong>绝对路径</strong>和<strong>相对路劲</strong>的概念，这个大家dddd，不再赘述</p><hr><p><strong>无环图目录结构</strong></p><blockquote><p>在树形目录结构的基础上，增加了一些指向同一节点的有向边，方便多个文件夹之间共享文件</p></blockquote><p>其实就是，文件夹A里面的文件，在文件夹B里面创建了个快捷方式，所以B可以访问到A的文件</p><hr><h3 id="非空闲磁盘块管理（文件的物理结构）"><a href="#非空闲磁盘块管理（文件的物理结构）" class="headerlink" title="非空闲磁盘块管理（文件的物理结构）"></a>非空闲磁盘块管理（文件的物理结构）</h3><p>讨论这点的目的是为了更好地对磁盘块进行管理，具体内容和内存分页很像</p><p>这里有一个前置概念是<strong>磁盘块</strong>，也就是类似内存分页，即<strong>外存的内存分配单元，其大小与一个页面等大</strong></p><p><strong>文件的物理结构 ，也叫文件的分配方式，即文件数据应该怎样存放在外存中</strong>，这里讨论三种方式：<br>1.连续分配<br>2.链接分配：又有隐式链接和显式链接两种形式<br>3.索引分配</p><hr><p><strong>1.连续分配</strong></p><blockquote><p>连续分配方式要求每个文件在磁盘上占有一组连续的块</p></blockquote><p>这里提前介绍一下，读取磁盘块的时候，要移动磁头。<strong>访问的两个磁盘块相隔越远，移动磁头所需时间就越长</strong></p><table><thead><tr><th>优缺点</th><th>具体内容</th></tr></thead><tbody><tr><td>优点</td><td>连续分配的文件在<strong>顺序读写</strong>时速度是最快的</td></tr><tr><td>缺点</td><td>1.在对文件进行拓展时，可能因为当前位置连续的空间不足而发生整体的迁移，最坏的情况是没有足够的连续空间从而无法进行拓展<br> 2.容易产生难以利用的磁盘碎片</td></tr></tbody></table><hr><p><strong>链接分配</strong></p><blockquote><p>采用离散匹配的方式，可以为文件分配离散的磁盘块（FCB增加两个字段：起始块号和结束块号，然后串起来）<br>分为<strong>隐式链接</strong>和<strong>显示链接</strong>两种形式<br>隐式指的是（静态链表），使用指针链接<br>显示指的是（邻接表），建立一张文件分配表（FAT）记录所有前驱后继关系</p></blockquote><p>隐式链接<br>| 优缺点 | 具体内容                                 |<br>| —— | —————————————- |<br>| 优点   | 空间利用率高                             |<br>| 缺点   | 1.只能顺序访问<br>2.指针会占用一定的空间 |</p><p>显式链接<br>| 优缺点 | 具体内容                                                     |<br>| —— | ———————————————————— |<br>| 优点   | 1.空间利用率高<br>2.文件拓展方便<br>3.支持随机访问，并且.地址转换时不需要访问磁盘，速度会快很多<br> |<br>| 缺点   | 1.文件分配表需要占用一定的空间                               |</p><hr><p><strong>3.索引分配</strong></p><blockquote><p>类似页表地，文件离散分配在各个磁盘块中，系统会为每个文件建立一张索引表，其中记录了文件的各个逻辑块对应的物理块。<br>索引表存放的磁盘块称为索引块，文件数据存放的磁盘块称为数据块。</p></blockquote><p><strong>和显示链接的区别在哪？</strong><br>显示链接是把所有链接关系都放到了一起集中存储（只有一张FAT）<br>索引分配中，每个文件的索引表也是离散存储在各个磁盘块中的（有多张表）<br>这样带来的优势就是，更灵活，也就引申出了以下三种索引分配方案：<br>1.链接方案<br>2.多层索引<br>3.混合索引<br>（暂不细究）</p><hr><h3 id="空闲磁盘块管理（文件存储空间）"><a href="#空闲磁盘块管理（文件存储空间）" class="headerlink" title="空闲磁盘块管理（文件存储空间）"></a>空闲磁盘块管理（文件存储空间）</h3><p><strong>文件卷、存储空间的划分与初始化</strong></p><blockquote><p>安装windows操作系统的时候，一定经历过磁盘分区（C、D、E盘等等），这些盘就是文件卷<br>（有的系统支持超大型文件，可以由多个物理磁盘合并为一个文件卷）<br><strong>初始化</strong>是将各个文件卷划分为<strong>目录区</strong>和<strong>文件区</strong></p></blockquote><blockquote><p>目录区主要存放文件目录信息（FCB）和用于磁盘管理的信息<br>文件区用于存储各种普通文件</p></blockquote><hr><p><strong>空闲空间分配方式</strong><br><strong>1.空闲表法</strong></p><blockquote><p>建议一张表，包含首个空闲盘块号 和 空闲盘块数 两个信息<br>同样可以采用首次适应、最佳适应、最坏适应等算法来解决这个问题</p></blockquote><p><strong>2.空闲链表法</strong></p><blockquote><p>分为两种：<br>1.空闲盘块链<br><img src="https://img-blog.csdnimg.cn/046c1b20f42d4ec0907cfb429c2c50bc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_文件_空闲盘块链"><br>2.空闲盘区链<br><img src="https://img-blog.csdnimg.cn/5906fd2cf9904e589ef5c7716cf37f9c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_文件_空闲盘区链"></p></blockquote><p><strong>3.成组链接法</strong></p><blockquote><p>空闲表法和空闲链表法可能不适用于大型文件系统，因为空闲表和空闲链表可能过大<br>而成组链接法实在目录区中专门用一个磁盘块作为“<strong>超级块</strong>”，系统启动时，将超级块读入内存并保证内外存中超级块数据一致<br><img src="https://img-blog.csdnimg.cn/453d304e67474a6c840a5de424308206.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_文件_成组链接法"></p></blockquote><h3 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h3><table><thead><tr><th>操作</th><th>系统调用（接口）</th></tr></thead><tbody><tr><td>创建文件</td><td>create</td></tr><tr><td>删除文件</td><td>delete</td></tr><tr><td>读文件</td><td>read</td></tr><tr><td>写文件</td><td>write</td></tr><tr><td>打开文件</td><td>open</td></tr><tr><td>关闭文件</td><td>close</td></tr></tbody></table><h3 id="文件共享和保护（暂不细究）"><a href="#文件共享和保护（暂不细究）" class="headerlink" title="文件共享和保护（暂不细究）"></a>文件共享和保护（暂不细究）</h3><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h3><p><img src="https://img-blog.csdnimg.cn/a4ca03a865444899ae941c48eaf1b85b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_磁盘结构"><br><img src="https://img-blog.csdnimg.cn/9bf7417d2f2049e1973d8518336a0c57.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_磁盘的磁道"><br><img src="https://img-blog.csdnimg.cn/2848f22bf8f847138125958d9bfebf1f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_磁盘的扇区"><br><img src="https://img-blog.csdnimg.cn/1f83c409f0f64834aaca3e908e477924.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统_磁盘_磁臂_盘面_柱面"></p><table><thead><tr><th>结构名称</th><th>介绍</th></tr></thead><tbody><tr><td>磁盘</td><td>磁盘表面由一些磁性物质组成，可以记录二进制数据</td></tr><tr><td>磁道</td><td>磁盘的盘面被划分为多圈，每一个圈都是一个磁道</td></tr><tr><td>扇区</td><td>磁盘被划分为多个扇形区域，这些区域就是扇区，<strong>每个扇区都是一个磁盘块</strong>，<strong>各个扇区存放的数据量相同</strong>，所以每个扇区最内的磁道数据密度最大</td></tr><tr><td>盘面</td><td>盘片<strong>记录了数据的表面</strong>，有的可能是两面都能记录</td></tr><tr><td>柱面</td><td>所有盘面中相对位置相同的磁道组成柱面</td></tr><tr><td>磁头</td><td>用于读取数据的结构，磁头可以移动的磁盘是<strong>活动头磁盘</strong>，不可移动的是<strong>固定头磁盘</strong>（固定头磁盘是为每个磁道设置一个磁头，贵）</td></tr><tr><td>磁臂</td><td>固定磁头的结构，一般有多个磁头</td></tr></tbody></table><p><strong>磁盘中读写数据</strong><br>读写数据首先要把<strong>磁头移动</strong>到指定扇区的指定磁道，之后磁盘转动起来，让目标扇区从磁头下面划过，才能进行数据的读写</p><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>由于固定头磁盘很贵，通常还是采用活动头磁盘，所以如何高效地移动、读写数据就成了问题，这就需要我们使用算法去解决这个问题</p><p>先分析问题所在：</p><blockquote><p>消耗时间 = 寻找时间 + 延迟时间 + 传输时间<br><strong>寻找时间（寻道时间）</strong><br>启动磁臂 和 移动磁头到指定磁道的时间<br><strong>延迟时间</strong><br>由硬件决定，无法通过算法优化<br>旋转磁盘，使磁头进入目标扇区所要的时间<br><strong>传输时间</strong><br>由硬件决定，无法通过算法优化<br>读写数据所用的时间</p></blockquote><p>所以我们通过算法能够优化的就是<strong>寻道时间</strong></p><p><strong>调度算法</strong><br><strong>1.先来先服务算法FCFS</strong></p><blockquote><p>按照请求的顺序先后执行</p></blockquote><p><img src="https://img-blog.csdnimg.cn/1f5a736d9ee9470c8358831a8eaed6f3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="先来先服务算法"></p><p><strong>2.最短寻找时间优先算法SSTF</strong></p><blockquote><p>相当于是优先找最近的<br><img src="https://img-blog.csdnimg.cn/b576d35133f44f59bf3029a911cba694.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="最短寻找时间优先算法"><br><strong>可能产生饥饿</strong></p></blockquote><p><strong>3.扫描算法SCAN</strong></p><blockquote><p>也叫<strong>电梯算法</strong>,只有磁头移动到最外侧磁道的时候才能往内侧移动，反之同理<br><img src="https://img-blog.csdnimg.cn/7a0ef86e0252452a86b316aa4abe94ed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这就<strong>避免了死锁</strong>，<br>但是每次都要移动到头，这是没有必要的，<br>而且它对各个位置磁道的响应频率不平均</p></blockquote><p>所以对于SCAN算法来说，还存在以下几种改进版本</p><p><strong>4.LOOK调度算法</strong></p><blockquote><p>是改进的扫描算法，<br>即如果在磁头移动的方向上已经没有新的请求了，那么就允许立刻改变方向<br><img src="https://img-blog.csdnimg.cn/90a0ed9e464741fda7364ffca065334f.png" alt="LOOK调度算法"></p></blockquote><p><strong>5.循环扫描算法C-SCAN</strong></p><blockquote><p>再次改进，规定磁头移动到头之后立刻返回初始位置而不处理之间的任何任务<br><img src="https://img-blog.csdnimg.cn/8a8ef6cdcdce4654a3b8afb476e30bb7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="循环扫描算法"><br><strong>6.C-LOOK调度算法</strong><br>再次改进，就是C-SCAN依旧没有必要移动到头，如果移动方向上已经没有任务要处理，那么就立刻返回初始位置<br><img src="https://img-blog.csdnimg.cn/1e73acb19e684e83a064cc03029985cb.png" alt="C-LOOK调度算法"></p></blockquote><p>需要注意一个事情，大部分时候，题目如果没有特别说明，那么其所指的SCAN就是LOOK，C-SCAN就是C-LOOK</p><h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h3><p><strong>磁盘初始化</strong></p><blockquote><p>磁盘刚被制造出来的时候，只有磁道：<br>1.需要进行<strong>低级格式化（物理格式化）</strong>，即划分扇区，而一个扇区又可以分为头、数据区域、尾三个部分（计组阿巴阿巴）<br>2.<strong>磁盘分区</strong>，每个分区由若干柱面组成（即C、D、E盘）<br>3.进行<strong>逻辑格式化</strong>，创建文件系统的根目录、初始化存储空间管理所用的数据结构</p></blockquote><p><strong>引导块</strong></p><blockquote><p>计算机刚开机的时候，需要初始化一系列东西，而这初始化是通过执行<strong>初始化程序（自举程序）</strong> 完成的<br>ROM中存在一个自举装入程序，完整的自举程序会放在磁盘的引导块（启动块）内，引导块又位于磁盘的固定位置<br>拥有引导块的磁盘被称为<strong>系统磁盘（引导磁盘）</strong> （比如C盘）</p></blockquote><p><strong>坏块及其管理</strong></p><blockquote><p>坏块就是坏掉的部分，可以在逻辑格式化的时候检查出来，<br>并且会通过一系列操作来<strong>忽略或者启用备用扇区来替换</strong>它，这些操作对于操作系统是透明的</p></blockquote><h2 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h2><p><del>这部分算是计组的内容，暂时不写了，很多科目要考试了，得预习了~~~<br> （几天后）<br> ~~做了套真题回来发现考的还不少，回来补上…..</del> </p><p>其实这部分内容相对于前面的内容来说已经算是简单的了<br> <strong>基本概念</strong></p><blockquote><p><strong>什么是I/O设备</strong><br>input/output设备，输入输出设备，能讲数据输入计算机的设备，比如鼠标键盘等是输入设备，显示屏等是输出设备，而U盘、触摸屏等则是可以是输入设备也可以是输出设备<br><strong>系统管理I/O设备</strong><br>一些系统会将接入计算机的输入输出设备抽象为一种特殊的文件，用户可以通过相关的文件操作来对实现对输入输出设备进行操作<br> 比如我们这个数位板，就可以通过其相关的软件来管理<br> （为了避免打广告嫌疑，这里图只放一半）<img src="https://img-blog.csdnimg.cn/72a4dc3a19ef41baa8e078f47e7a61f4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="操作系统管理输入设备的体现"></p></blockquote><h3 id="I-O设备的几种分类"><a href="#I-O设备的几种分类" class="headerlink" title="I/O设备的几种分类"></a>I/O设备的几种分类</h3><p><strong>按使用特性分类</strong><br>虽然都是输入输出设备，但是也会有不同的特性<br>| 分类           | 特点                           | 举例                 |<br>| ————– | —————————— | ——————– |<br>| 人机交互类外设 | 数据传输速度慢，用于人机交互   | 鼠标、键盘、数位板等 |<br>| 存储设备       | 数据传输速度快，用于存储数据   | 移动硬盘、光盘等     |<br>| 网络通信设备   | 数据传输速度介中，用于网络通信 | “猫”，路由器等       |</p><p><strong>按传输设备分类</strong><br>| 分类     | 大致速度范围         | 举例         |<br>| ——– | ——————– | ———— |<br>| 低速设备 | 每秒几个到几百个字节 | 鼠标、键盘等 |<br>| 中速设备 | 每秒几千上万个字节   | 激光打印机等 |<br>| 高速设备 | 每秒几千只几千兆字节 | 磁盘等       |</p><p><strong>按信息交换的单位分类</strong><br>| 分类     | 单位                                                         | 举例       |<br>| ——– | ———————————————————— | ———- |<br>| 块设备   | “块”，即之前的学习中常常提到的那个概念，传输速率高。可以寻址，即可以对块设备进行随机读写 | 磁盘等     |<br>| 字符设备 | “字符”，较慢。不可寻址，输入输出时常采用<strong>中断驱动</strong>的方式   | 鼠标键盘等 |</p><h3 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I/O控制器"></a>I/O控制器</h3><p><strong>概念</strong></p><blockquote><p>I/O设备由机械部件和<strong>电子部件</strong>（I/O控制器，也称设备控制器）组成，<br>机械部件是鼠标、键盘、硬盘、显示器等我们看见的结构<br>电子部件一般是一块<strong>电路板</strong>，它的存在相当于操作系统 和 机械部件 间建立联系的桥梁</p></blockquote><p><strong>结构组成</strong><br>涉及部分计组知识，此处大概了解即可<br><img src="https://img-blog.csdnimg.cn/7155bf1b276c4588b93d6b7415fd1c3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="I/O控制器组成结构"></p><p><strong>功能</strong></p><blockquote><p>四个主要功能：<br><strong>1.接受和识别CPU发出的命令</strong><br>I/O控制器内包含<strong>控制寄存器</strong>，存放CPU发来的命令和参数<br>2.<strong>向CPU报告设备的状态</strong><br>I/O控制器内包含<strong>状态寄存器</strong>，记录I/O设备的状态，比如1代表空闲，0代表忙碌<br>3.<strong>数据交换</strong><br>I/O控制器内包含<strong>数据寄存器</strong>，用于暂存CPU发来的数据<br>4.<strong>地址识别</strong><br>类似于内存地址，为了区分各个寄存器，I/O控制器也给各个寄存器设置了一个“地址”<br>tips：地址编码方式有两种，一种是<strong>内存映射I/O</strong>，另一种是<strong>寄存器独立编址</strong>：<br>前者是，寄存器地址是接着内存地址递增；<br>后者是，各个寄存器采用独立的地址。<br><img src="https://img-blog.csdnimg.cn/b2f8274bb7154ab0b00d569a9aa81159.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="I/O控制器的两种编址方式"></p></blockquote><h3 id="四种I-O控制方式"><a href="#四种I-O控制方式" class="headerlink" title="四种I/O控制方式"></a>四种I/O控制方式</h3><p>究竟用什么样的方式来控制I/O设备的数据读写</p><p> <strong>1程序直接控制方式</strong><img src="https://img-blog.csdnimg.cn/f553e513a899475a90facefc2b76a2b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="程序直接控制方式"></p><table><thead><tr><th>行为</th><th>内容</th></tr></thead><tbody><tr><td>完成一次读写操作的流程</td><td>轮询</td></tr><tr><td>CPU干预频率</td><td>I/O操作之前、之后需要CPU介入，并且等待I/O完成的过程中CPU会不断轮询状态寄存器</td></tr><tr><td>数据传输</td><td>低速，每次传输一个字符，读操作是从I/O设备-&gt;CPU-&gt;内存；写操作是则是读操作反过来</td></tr><tr><td>优点</td><td>实现简单，在读写指令之后加上一些循环检测指令即可（因此才叫程序直接控制）</td></tr><tr><td>缺点</td><td>CPU和I/O只能串行工作，CPU一直轮询长期忙等，利用率低</td></tr></tbody></table><p> <strong>2.中断驱动方式</strong><br> <img src="https://img-blog.csdnimg.cn/f2ee849ac24445e5ac3d9037bd20091b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_15,color_FFFFFF,t_70,g_se,x_16" alt="中断驱动方式"><br>| 行为                   | 内容                                                         |<br>| ———————- | ———————————————————— |<br>| 完成一次读写操作的流程 | 中断                                                         |<br>| CPU干预频率            | I/O操作之前、之后需要CPU介入，但是且等待I/O完成的过程中<strong>CPU可以处理别的进程</strong> |<br>| 数据传输               | 低速，每次传输一个字符，读操作是从I/O设备-&gt;CPU-&gt;内存；写操作是则是读操作反过来 |<br>| 优点                   | 通过<strong>中断信号</strong>主动报告进程完成，而不用CPU不停轮询，此时CPU则可以和I/O设备并行工作，CPU利用率明显提升 |<br>| 缺点                   | 每个字在设备与内存之间的传输，都要经过CPU，频繁的中断会消耗CPU较多时间 |</p><p> <strong>3.DMA方式</strong></p><blockquote><p>即直接存储器存储，主要用于块设备<br>主要做了以下几个改进：<br>1.用“块”作为数据传送的单位，而不再是字，可以读写连续的多个块<br>2.数据的流向是从设备直接放入内存，或者从内存直接到设备。而不再需要CPU作为中介。<br>3.仅在传送一个或多个数据块的开始和结束时，才需要CPU干预 </p></blockquote><p>硬件结构大概如下，了解即可</p><p><img src="https://img-blog.csdnimg.cn/7de7e500971146dc99a6f37f78736ecb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="DMA方式"><br><img src="https://img-blog.csdnimg.cn/33ebc6915c6f4499ab803a190aa95c43.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="DMA方式"></p><table><thead><tr><th>行为</th><th>内容</th></tr></thead><tbody><tr><td>CPU干预频率</td><td>I/O操作之前、之后需要CPU介入</td></tr><tr><td>数据传输</td><td>高速，每次传输<strong>一个或连续的多个块</strong>，读操作是从I/O设备-&gt;内存；写操作是则是读操作反过来</td></tr><tr><td>优点</td><td>CPU介入频率降低，数据传输不再需要先经过CPU</td></tr><tr><td>缺点</td><td>读取离散的数据时，开销较大</td></tr></tbody></table><p> <strong>4.通道控制方式</strong></p><blockquote><p>通道是一种硬件，可以理解为低配版CPU<br><img src="https://img-blog.csdnimg.cn/8a113ddd950344fa834f54ad490e25c9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="通道控制方式"></p></blockquote><p><img src="https://img-blog.csdnimg.cn/b53e7cbeae9d47bf9578654d65519c5f.png" alt="通道控制方式的执行过程"></p><table><thead><tr><th>行为</th><th>内容</th></tr></thead><tbody><tr><td>CPU干预频率</td><td>极低，通道根据CPU的指令执行响应的通道程序，只有完成一组数据块的读写后才需要发出中断信号，请求CPU干预</td></tr><tr><td>数据传输</td><td>高速，每次传输<strong>一个或连续的多个块</strong>，读操作是从I/O设备-&gt;内存；写操作是则是读操作反过来</td></tr><tr><td>优点</td><td>CPU介入频率相当低，CPU、通道、I/O设备可以并行工作</td></tr><tr><td>缺点</td><td>实现复杂，需要专门的硬件设备支持</td></tr></tbody></table><p><strong>总结</strong><br><img src="https://img-blog.csdnimg.cn/3e134741fb1e4a8e97cfbe107329d08e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="四种控制方式的比较"></p><h3 id="I-O软件的结构层次"><a href="#I-O软件的结构层次" class="headerlink" title="I/O软件的结构层次"></a>I/O软件的结构层次</h3><p>如图所示<br><img src="https://img-blog.csdnimg.cn/7a6cc78b61104a8eb4c953ee356e7e50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="I/O软件的结构层次"></p><p><img src="https://img-blog.csdnimg.cn/ad2d8a3a2ad249bd8b939763ccb6cd6b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="库函数与系统调用"></p><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p><strong>什么是缓冲区</strong><br>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可用内存作为缓冲区<br>其中，硬件成本较高，容量也较小，适用于对速度要求较高的场合（比如快表作为缓冲区）<br><strong>有什么作用</strong><br><strong>1.减少了CPU的中断频率</strong><br>CPU可以把要输出的数据快速放入缓冲区，之后就可以去做别的事情，慢速的I/O设备就可以从缓冲区里拿数据。<br>就比如两个人交换物品，没有缓冲区的话，就得一个人等另一个人来了之后才完成交接。<br>有缓冲区的话，先到的人把东西放到缓冲区里面就可以走了，后到的人自己拿就行<br>（如下图就是一个单缓冲）<img src="https://img-blog.csdnimg.cn/7a72283e0dd5472197dd7092659b96bf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="缓冲区"><br><strong>2.解决数据粒度不匹配（人机速度不匹配）</strong><br>输出进程每次只能生成一块数据，但是I/O设备每次只能输出一个字符<br><strong>3.提高了CPU和I/O设备之间的并行度</strong></p></blockquote><h3 id="几种类型的缓冲区"><a href="#几种类型的缓冲区" class="headerlink" title="几种类型的缓冲区"></a>几种类型的缓冲区</h3><p>其实在上篇的进程同步互斥章节的内容中我们已经提到过一些了<br><strong>1.单缓冲</strong></p><blockquote><p>只有一个缓冲区，如果没有特殊说明，默认其是一个内存块。</p></blockquote><table><thead><tr><th>状态</th><th>写（冲入数据）</th><th>读（传出数据）</th></tr></thead><tbody><tr><td>空</td><td>可</td><td>不可</td></tr><tr><td>非空</td><td>不可</td><td>可</td></tr></tbody></table><p><strong>2.双缓冲</strong></p><blockquote><p>也就是两个缓冲区，这里我们将其称为A和B<br>设置两个缓冲区的目的是，在遇到如A非空B空的情况时，读写操作可以并行执行<br>另外，在遇道两机通信时：<br><img src="https://img-blog.csdnimg.cn/7aa3106d85b3468295df4a393d8ae658.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="缓冲区在两机通信中的应用"><br>上图中的两台机器都只有单缓冲区，这意味着它们同一时间只能单向通信<br>而双缓冲就是：<br><img src="https://img-blog.csdnimg.cn/e9520ba9ad9244bb9620f32831134e0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="双缓冲区在两机通信时的优势"><br>其实，上篇提到过的<strong>管道通信</strong>中的<strong>管道就是缓冲区</strong><br>而上述两机通信的情形，就是管道通信</p></blockquote><p><strong>循环缓冲</strong></p><blockquote><p>将多个大小相等的缓冲区链接成一个循环队列<br><img src="https://img-blog.csdnimg.cn/f236aaf7b4804a5e8d8ece7b0411d26d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="循环缓冲"></p></blockquote><p><strong>缓冲池</strong><br><img src="https://img-blog.csdnimg.cn/4d35c1577c334b75972dca8484e95296.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA56Kz6Iuv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="缓冲池"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex学习笔记</title>
      <link href="/2021/11/01/vuex/"/>
      <url>/2021/11/01/vuex/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h3><p>看到身边的大佬一个二个的秀到飞起，我也要加把劲才是</p><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><blockquote><p><strong>2021/11/01</strong><br>写下这篇博文，因为难以解决的bug被劝退到自闭<br><strong>2022/02/13</strong><br>遇到了一个好的机会，所以又重新拾起这部分内容，更棒的是有仙人指路一下子豁然开朗起来</p></blockquote><h3 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h3><p>感谢19级软件工程<strong>朱珂江</strong>学长凌晨的技术指导，我这才得以顺利入门</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="什么是Vuex"><a href="#什么是Vuex" class="headerlink" title="什么是Vuex"></a>什么是Vuex</h3><blockquote><p>Vuex是一个专为Vue.js应用开发的<strong>状态管理模式 和 库</strong>（与Vue 3.x对应的是Vuex 4），</p><p>采用集中式存储管理应用的所有组件的状态，并且已响应的规则来保证状态以一种可以预测的方式发生变化。</p><p>Vuex集成到Vue的官方调试工具devtools extension，提供了诸如零件配置的time-travel调试、状态快照导入导出等高级调试功能</p></blockquote><h3 id="单向数据流的弊端"><a href="#单向数据流的弊端" class="headerlink" title="单向数据流的弊端"></a><strong>单向数据流的弊端</strong></h3><p>由于vue提倡的是<strong>单向数据流</strong>，如果组件与组件层层嵌套，那么利用父子间通信的方式进行数据传递就相当麻烦（其实也可以通过 发布和订阅 来解决这种问题）</p><p>在制定出解决这个问题的方案之前，我们先了解一下单向数据流中的几个部分：</p><blockquote><p><strong>状态</strong><br>驱动应用的数据源<br><strong>视图</strong><br>以声明的方式将状态映射到视图<br><strong>操作</strong><br>响应在视图上的用户输入导致的状态变化</p></blockquote><p>它们之间的关系像是这样<br><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684251544e25e0feaa5a3f4283f4f21787a76f439f47fc8f6e61/0.png" alt="image.png"></p><h3 id="Vuex状态管理模式"><a href="#Vuex状态管理模式" class="headerlink" title="Vuex状态管理模式"></a>Vuex状态管理模式</h3><p>vuex就相当于给所有需要数据通信的组件<strong>创建一个公共的父级</strong>，这样进行数据传递的话就快多了</p><p>（但是使用Vuex的成本比较高，所以只有中大型项目才使用）</p><blockquote><p>“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：</p><ol><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li></ol></blockquote><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684251544e25e0feaa5ad9eb7ab105f3e74d6d3930d2e8bcf481/0.png" alt="Vuex中store原理示意图"></p><h3 id="什么时候使用Vuex"><a href="#什么时候使用Vuex" class="headerlink" title="什么时候使用Vuex"></a>什么时候使用Vuex</h3><blockquote><p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 <a href="https://v3.cn.vuejs.org/guide/state-management.html#%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86">store 模式</a>就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</p></blockquote><p>上面的是官方文档中的介绍，下面的是某大佬的个人理解：</p><blockquote><p>管你小中大型应用，我就想用就用呗，一个长期构建的小型应用项目，谁能知道项目需求以后会是什么样子，毕竟在这浮躁的时代，需求就跟川剧变脸一样快，对不对？毕竟学习了 Vuex 不立马用到项目实战中，你永远不可能揭开 Vuex 的面纱。项目中使用多了，自然而然就会知道什么时候该用上状态管理，什么时候不需要。老话说的好熟能生巧，你认为呢？<br> （括弧 – 先了解好Vuex 一些基本概念，然后在<strong>自己的项目</strong>中使用过后，再用到你公司项目上，你别这么虎一上来就给用上去了～）</p></blockquote><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="安装版本问题"><a href="#安装版本问题" class="headerlink" title="安装版本问题"></a>安装版本问题</h3><p>如果你仔细阅读了本博客的更新日志，你会发现第一次更新和第二次更新之间相差了近3个月，而这是因为一个当时未得到解决的bug劝退了我，所以停止了学习的步伐</p><p>但是最近由于一个项目特别适合用vuex，我便觉得这该是一个非常好的机会啊，就重新拾起了学习vuex的热情</p><p>使用如下npm命令安装：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install vuex --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是在我代码没有问题的前提下，这个bug依旧出现：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168428dd01ac0de8120a0c0fad8fe93ef7f92702ac593b7e22a35/0.png" alt="Uncaught TypeError: Object(...) is not a function"></p><p>我也因此在这里又卡顿了两三天，后来经过朱老师的点拨，才终于豁然开朗了<br><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168428dd01ac0de8120a06c45a3910e1ed165cf6ec2c29769a88e/0.png" alt="太卷了"></p><p>原来这是因为Vue和VueX的版本的关系，我们这里用的是Vue2和VueX4.x，版本不匹配所以导致了报错<br>所以此时正确的操作应该是：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 直接npm install vuex而不指定版本的话就是安装最新版(4.x)，# 版本指定第一位即可npm install vue@3 --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>正确的版本对应关系如下：</p><table><thead><tr><th>Vue版本</th><th>VueX版本</th></tr></thead><tbody><tr><td>Vue2.x</td><td>VueX3.x</td></tr><tr><td>Vue3.x</td><td>VueX4.x</td></tr><tr><td>Vue3.x(猜测，暂未查证)</td><td>Pinia(可以看做VueX5.x)</td></tr></tbody></table><p>这里个人习惯使用Vue2.x，所以下文如未特殊说明，皆为Vue2.x</p><h3 id="基本文件结构"><a href="#基本文件结构" class="headerlink" title="基本文件结构"></a>基本文件结构</h3><blockquote><p>|—— index.html<br>|—— main.js<br>|—— api<br>|        |____ …<br>|—— components<br>|        |____ App.vue<br>|        |____ …<br>|—— <strong>store</strong>            # 核心文件夹<br>         |____ index.js          # 组装导出模块<br>         |____ action.js         # 根级action<br>         |____ mutations.js    # 根级mutation<br>         |____ modules          # 各种模块<br>                   |____ ….</p></blockquote><p>上述文件结构是针对于大型应用的标准文件结构，这里我们只是入门，所以并不严格遵循，而是将所有js文件<strong>糅合成一个store.js</strong>，并且暂时先不做模块化</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684251544e25e0feaa5ac0a1b96fec01aa848e8216113f4bcad3/0.png" alt="image.png"></p><p>然后在store.js和main.js中分别写入:</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684251544e25e0feaa5a302b275164e0a8fbf037e8e5765908fe/0.png" alt="store.js和main.js代码示例"></p><p>Vuex 通过 <code>store</code> 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 <code>Vue.use(Vuex)</code>）</p><p>通过在根实例中注册 <code>store</code> 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 <code>this.$store</code> 访问到</p><h3 id="基本数据使用"><a href="#基本数据使用" class="headerlink" title="基本数据使用"></a>基本数据使用</h3><p>在进行了上述操作之后，如果想要<strong>使用数据</strong>msg我们只需要使用如下语句：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>msg <span class="token comment">// 这里的this在template部分中可以省略</span><span class="token comment">// 但是在JS部分中是不可以省略的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用数据并不困难，我们需要注意的是如何修改数据，我们虽然可以通过对上述语句赋值的形式</p><p>来修改，但是我们并不推荐这样做，因为这些数据应该被视为private，但是我们又希望所有组件都可以访问并修改它们，这时候就该想到getter和setter</p><p>getter我们会在后面提到</p><p>这里的setter被放到mutations里面，而要访问到这些setter则需要用this.$store.commit，例如：</p><h3 id="基本数据修改"><a href="#基本数据修改" class="headerlink" title="基本数据修改"></a>基本数据修改</h3><p>不建议直接使用<code>this.$store.state</code>直接修改，一是因为这样修改后没有任何提示，若出错则可能难以追溯问题来源；二是因为这样修改则形成了双向绑定结构，对于数据不安全；</p><p>所以推荐像下面这样：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168428975fe52584230d5d22a08d765df7674eb49a9135cd94ca3/0.png" alt="image.png"></p><p>这里我们可以发现，<code>mutation</code>中的函数的第一个参数是state，这个是固定的，而如果需要更多的参数则在后面依次添加，传参只需要像这样：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'change'</span><span class="token punctuation">,</span> <span class="token string">'我是参数'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意这里如果要追加参数，<strong>不能用逗号隔开来继续添加</strong>，而是将参数打包成一个对象传入——当然，函数声明也要遵循这一点</p><p>另外，还要注意，<strong>mutation只能是同步任务</strong><br>如何异步后面会提到</p><h3 id="基本数据增删"><a href="#基本数据增删" class="headerlink" title="基本数据增删"></a>基本数据增删</h3><p>并不需要使用额外的语法，只需要我们像下面这样就能完成</p><p>由于新添加的属性如果要规范使用的话还得添加额外的<code>mapState</code>语句，所以我们会再包装一层：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token keyword">new</span><span class="token operator">:</span> <span class="token number">233</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者这样写也行：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span> state<span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token string">'new'</span><span class="token punctuation">,</span> <span class="token number">123</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168428975fe52584230d5e9447247f922a2708ca8127760791174/0.png" alt="mutation的两种添加方式"></p><p>归根结底<code>commit</code>是触发<code>mutation</code>中函数的方式之一，我们还能通过<code>mapMutations</code>来触发，不过这里暂时不讨论这个</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在学会基础使用之后，再来稍微深入一点，接下来这部分内容省略了已经提及过的部分</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><h4 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h4><p>用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (<a href="https://en.wikipedia.org/wiki/Single_source_of_truth">SSOT (opens new window)</a>)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段</p><h4 id="组件中获取-Vuex-状态"><a href="#组件中获取-Vuex-状态" class="headerlink" title="组件中获取 Vuex 状态"></a>组件中获取 Vuex 状态</h4><p>那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在<a href="https://cn.vuejs.org/guide/computed.html">计算属性 (opens new window)</a>中返回某个状态：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 创建一个 Counter 组件</span><span class="token keyword">const</span> Counter <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;{{ count }}&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>  computed<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token function">count</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每当 <code>store.state.count</code> 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM<br>相较于直接使用store.state.count访问，更推荐使用</p><h4 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h4><p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余<br>为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性</p><p>当映射的<strong>计算属性的名称与 state 的子节点名称相同时</strong>，我们也可以给 <code>mapState</code> 传一个字符串数组</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> mapState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token comment">// ...</span>   computed<span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'msg'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这样操作之后，你就能直接使用<code>msg</code>来访问变量，而不是<code>$store.state.msg</code><br>mapState的原理就是字符串映射，将msg映射成为一个与之相关的函数，并放入一个对象返回</p><p>请看下面的例子：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168425eac5d9b41dfa3a4dfbc973cbfb260b26f64c2570caea6d8/0.png"></p><h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><h4 id="同步原则"><a href="#同步原则" class="headerlink" title="同步原则"></a>同步原则</h4><p><code>mutation</code>必须是同步函数，<br>举个例子：</p><blockquote><p>devtool在debug过程中，需要记录mutation的前一状态和后一状态，<br>但是在mutation执行的时候，异步操作还未执行，这就使得状态无法跟踪，<br>但是这种操作在视图层渲染上却是没有问题的——可正是这样，又导致了数据发生了不同步</p></blockquote><p>那么异步的操作要到哪里执行呢？我们后面再提</p><h4 id="mapMutations辅助函数"><a href="#mapMutations辅助函数" class="headerlink" title="mapMutations辅助函数"></a>mapMutations辅助函数</h4><p>和mapState类似，<code>mupMutation</code>作为触发<code>mutation</code>内的函数的第二种方式</p><p>有两种使用方式，具体语法如下：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168428975fe52584230d5b567a20aef623c8587475dd95b0529c4/0.png" alt="mapMutations的两种使用方式"></p><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><h4 id="处理异步"><a href="#处理异步" class="headerlink" title="处理异步"></a>处理异步</h4><p>Action是专门用于处理任务的</p><p>如果通过异步操作更改数据，必须通过<code>action</code>，而不能使用<code>mutation</code>，但是在<code>action</code>中还是要通过触发<code>mutation</code>的方式间接变更数据——只有<code>mutation</code>才能修改<code>state</code></p><p>也就是：</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa05168428f9883e692954e777e3b7f7196aceca114332ca09039c1bd/0.png" alt="image.png"></p><p>其中的context可以理解为new Vuex.Store实例对象</p><p>这里要注意，actions中的函数不是用commit触发了，而是用dispatch</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'plusAsync'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果需要传参，那么也是和<code>commit</code>一个道理</p><p>如果是同步的内容，那么可以用dispatch或commit，异步只能dispatch</p><p><img src="https://p.qlogo.cn/hy_personal/3e28f14aa051684251544e25e0feaa5a24bc949ce2f33777624f2e745776c63f/0.png" alt="Vuex模式示意"></p><h4 id="mapActions辅助函数"><a href="#mapActions辅助函数" class="headerlink" title="mapActions辅助函数"></a>mapActions辅助函数</h4><p>dispatch是第一种方式，而第二种方式是mapActions</p><p>方法跟之前的辅助函数如出一辙，此处不再赘述</p><h3 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h3><p>Getter是用于对Store中的数据进行加工处理，然后形成新的数据（深拷贝）,并不修改原本的数据</p><blockquote><p>可以认为是 store 的计算属性，就像计算属性一样，getter 的返回值会根据它的依赖<strong>被缓存起来</strong>，且只有当它的依赖值<strong>发生了改变才会被重新计算</strong></p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">computed<span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token function">doneTodosCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">todo</span> <span class="token operator">=&gt;</span> todo<span class="token punctuation">.</span>done<span class="token punctuation">)</span><span class="token punctuation">.</span>length  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  state<span class="token operator">:</span> <span class="token punctuation">{</span>    todos<span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token string">'...'</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token string">'...'</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  getters<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token function-variable function">doneTodos</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> state<span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">todo</span> <span class="token operator">=&gt;</span> todo<span class="token punctuation">.</span>done<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="通过属性访问"><a href="#通过属性访问" class="headerlink" title="通过属性访问"></a>通过属性访问</h4><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>doneTodos <span class="token comment">// -&gt; [{ id: 1, text: '...', done: true }]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，getter 在<strong>通过属性访问时</strong>是作为 Vue 的响应式系统的一部分<strong>缓存</strong>其中的。</p><h4 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h4><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p><p>（这个方法真的是震撼我一年）</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">getters<span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token comment">// ...</span>  <span class="token function-variable function">getTodoById</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> state<span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">todo</span> <span class="token operator">=&gt;</span> todo<span class="token punctuation">.</span>id <span class="token operator">===</span> id<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span><span class="token function">getTodoById</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// -&gt; { id: 2, text: '...', done: false }</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</strong></p><h4 id="mapGetters辅助函数"><a href="#mapGetters辅助函数" class="headerlink" title="mapGetters辅助函数"></a>mapGetters辅助函数</h4><p>依然是那么回事，只不过说<code>mapGetters</code>一般只能放到computed中</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> mapGetters <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token comment">// ...</span>  computed<span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      <span class="token string">'doneTodosCount'</span><span class="token punctuation">,</span>      <span class="token string">'anotherGetter'</span><span class="token punctuation">,</span>      <span class="token comment">// ...</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>由于是Vuex是单一状态树，所以当状态过多的时候，store对象就会相当臃肿，为了解决这种问题，就提出了将store分割成多个模块的思想</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  mutations<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  getters<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> moduleB <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  mutations<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  modules<span class="token operator">:</span> <span class="token punctuation">{</span>    a<span class="token operator">:</span> moduleA<span class="token punctuation">,</span>    b<span class="token operator">:</span> moduleB  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>a <span class="token comment">// -&gt; moduleA 的状态</span>store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>b <span class="token comment">// -&gt; moduleB 的状态</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本使用就是向上面这样，更多深入的地方以后再进行学习</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>Junting的博文：<a href="https://www.jianshu.com/p/c6356958ca52">https://www.jianshu.com/p/c6356958ca52</a><br>Vuex官方文档：<a href="https://vuex.vuejs.org/zh/guide/mutations.htm">https://vuex.vuejs.org/zh/guide/mutations.htm</a><br>Vuex从入门到实战：<a href="https://www.bilibili.com/video/BV1h7411N7bg">https://www.bilibili.com/video/BV1h7411N7bg</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios学习笔记</title>
      <link href="/2021/10/26/axios/"/>
      <url>/2021/10/26/axios/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>axios是对ajax的高度封装，也是vue推荐的通信方式，有大量的请求方式，所以很重要</p><p>（更完这篇我就去更新操作系统的内容了，有兴趣的同学可以点击下方链接查看）</p><p><a href="https://blog.csdn.net/Serio_gugugu/article/details/120575984">😘<font color="#ff6700">本科操作系统笔记（持续更新)：万字长文一篇搞定</font></a></p><p>另外，以后我的文章会优先发布到我的个人博客上，之后再挑选一部分发布C站。欢迎大家访问:</p><p><a href="https://serio.gitee.io/">😘<font color="#ff3377">本科操作系统笔记（持续更新)：万字长文一篇搞定</font></a></p><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>axios什么意思</strong></p><blockquote><p>axios 是 ajax i/o system的缩写，即”**异步 JavaScript 和 XML 输入输出 系统”</p><p>是一个基于promise网络请求库，作用域node.js和浏览器中。</p></blockquote><p><strong>前置准备</strong></p><p>首先得建立一个vue项目，然后安装相关依赖</p><p>如果不清楚vue基础知识的话可以阅读我的博客：<a href="https://blog.csdn.net/Serio_gugugu/article/details/119416221"><font color="#faee00">Vue全家桶学习笔记_零基础入门到入坑:Vue篇</font></a></p><p>这里我们采用的是vue-cli，语法是vue3.x</p><p>此处建议使用vue的GUI项目管理器进行创建，顺便把axios的相关依赖安装上（当然，使用npm或者yarn安装都行)</p><p>打开vue的GUI项目管理器只需要用cmd打开命令控制符然后输入下方的指令即可</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></tbody></table></figure><p>GUI的话就把<strong>依赖和插件</strong>都装上就行了</p><p><img src="C:\Users\MSI-pc\AppData\Roaming\Typora\typora-user-images\image-20211023160417870.png" alt="image-20211023160417870"></p><hr><h2 id="原生ajax示例"><a href="#原生ajax示例" class="headerlink" title="原生ajax示例"></a>原生ajax示例</h2><p>下面段代码就是原生js写的ajax请求，请求的内容是本地的json文件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">httpRequest = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">           </span><br><span class="line"><span class="keyword">if</span> (!httpRequest) {  </span><br><span class="line">    alert(<span class="string">"创建请求失败"</span>);      </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">httpRequest.open(<span class="string">"GET"</span>, <span class="string">"./JSONtest.json"</span>);</span><br><span class="line">           </span><br><span class="line">httpRequest.send();</span><br><span class="line"></span><br><span class="line">httpRequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{       </span><br><span class="line">    <span class="keyword">if</span> (httpRequest.readyState === <span class="number">4</span>) {         </span><br><span class="line">        <span class="keyword">if</span> (httpRequest.status === <span class="number">200</span>) {  </span><br><span class="line">            <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(httpRequest.responseText);              </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'AJAX'</span> + data[<span class="string">'key'</span>]);</span><br><span class="line">                        <span class="comment">//别忘了和data.key的区别             </span></span><br><span class="line">        }          </span><br><span class="line">        <span class="keyword">else</span> {              </span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">'请求失败'</span>);            </span><br><span class="line">        }          </span><br><span class="line">    }          </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="使用axios"><a href="#使用axios" class="headerlink" title="使用axios"></a>使用axios</h2><p>axios封装了很多通信方式</p><table><thead><tr><th>名称</th></tr></thead><tbody><tr><td>request</td></tr><tr><td><strong>get</strong></td></tr><tr><td><strong>post</strong></td></tr><tr><td>delete</td></tr><tr><td>head</td></tr><tr><td>options</td></tr><tr><td>put</td></tr><tr><td>patch</td></tr></tbody></table><h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><p>以下两种写法都是可以的</p><p>(url随便给的，赋值粘贴之后记得换成后端的接口，或者本地的文件路径之类的)</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axiosGetTest = <span class="function">() =&gt;</span> {</span><br><span class="line">        axios.get(<span class="string">'http://rap2api.taobao.org/xxx'</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">          <span class="built_in">console</span>.log(res.data)</span><br><span class="line">        }).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">          <span class="built_in">console</span>.log(error)</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> axiosGetTest2 = <span class="function">() =&gt;</span> {</span><br><span class="line">      axios({</span><br><span class="line">        <span class="attr">method</span>: <span class="string">'get'</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">'http://rap2api.taobao.org/xxx'</span>,</span><br><span class="line">      }).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(res.data)</span><br><span class="line">      }).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">      })</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>get方法还可以写第二个参数，那就时配置信息</p><p>可以按住ctrl+鼠标左键点击get方法看源码，再如此操作第二个参数，就可以查看能够填写哪些内容作为第二个参数</p><p>这里我们加一个params，就可以实现传参了</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axiosGetTest = <span class="function">() =&gt;</span> {</span><br><span class="line">        axios.get(<span class="string">'http://rap2api.taobao.org/app/mock/292586/user/list'</span>,{</span><br><span class="line">          <span class="attr">params</span>: {</span><br><span class="line">            <span class="attr">username</span>: <span class="string">'千尊'</span>,</span><br><span class="line">            <span class="attr">id</span>: <span class="number">666</span></span><br><span class="line">          }</span><br><span class="line">        }).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">          <span class="built_in">console</span>.log(res.data)</span><br><span class="line">        }).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">          <span class="built_in">console</span>.log(error)</span><br><span class="line">        })</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>这里似乎没有用utf-8所以中文部分乱码了</p><p><img src="C:\Users\MSI-pc\AppData\Roaming\Typora\typora-user-images\image-20211023192211496.png" alt="image-20211023192211496"></p><p>get请求就是以这种拼接的形式传递数据</p><h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><p>依旧是两种，post和get相比就多了中间一个参数data</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axiosPostTest = <span class="function">() =&gt;</span> {</span><br><span class="line">      axios({</span><br><span class="line">          <span class="attr">method</span>: <span class="string">'post'</span>,</span><br><span class="line">          <span class="attr">url</span>:<span class="string">'http://rap2api.taobao.org/yyy'</span>,</span><br><span class="line">          <span class="attr">data</span>: {</span><br><span class="line">            <span class="string">"isOk"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"errMsg"</span>: <span class="string">"失败了诶1"</span></span><br><span class="line">          }</span><br><span class="line">      }).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(res.data)</span><br><span class="line">      }).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">      })</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> axiosPostTest2 = <span class="function">() =&gt;</span> {</span><br><span class="line">      axios.post(</span><br><span class="line">          <span class="string">'http://rap2api.taobao.org/yyy'</span>,</span><br><span class="line">          {</span><br><span class="line">            <span class="string">"isOk"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"errMsg"</span>: <span class="string">"失败了诶2"</span></span><br><span class="line">          },</span><br><span class="line">          {}).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(res.data)</span><br><span class="line">      }).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">      })</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><img src="C:\Users\MSI-pc\AppData\Roaming\Typora\typora-user-images\image-20211023194416353.png" alt="image-20211023194416353"></p><p>信息是以请求头+请求体的形式发送的</p><p>当然还有其他通信方式，它们的专长不一样，但是使用方式类似，这里就不再赘述了</p><h2 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h2><p>什么是并发？</p><p>如果不清楚的话可以参考我放在文章开头的<strong>操作系统笔记</strong>，系统地学习并发并行异步等专业术语</p><p>如果知道什么是并发的话，那么请接着往下看</p><p>并发请求要用到axios.all方法，其返回结果是一个数组，可以用axios.spread将数组的值展开</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axiosAll =  <span class="function">() =&gt;</span> {</span><br><span class="line">  axios.all([</span><br><span class="line">      axios.get(<span class="string">'http://rap2api.taobao.org/app/mock/292586/user/list'</span>),</span><br><span class="line">      axios.post(<span class="string">'http://rap2api.taobao.org/app/mock/292586/user/login'</span>)</span><br><span class="line">  ]).then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> res){</span><br><span class="line">      <span class="built_in">console</span>.log(i.data);</span><br><span class="line">    }</span><br><span class="line">  }).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>至于axios.spread方法，感觉很多时候没什么用，还不如for循环，所以这里就不再演示了</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
